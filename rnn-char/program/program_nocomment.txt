
#if !defined(NBACKMAIN_H_INCLUDED)
#define NBACKMAIN_H_INCLUDED
















#include "ustring.h"
#include "direlem.h"
#include "runstage.h"

class utar_flags_info;
class context;
class backstate;
class ustring;
class DIRELEM;
class dirstats;

class nbackmain {
private:
    utar_flags_info& flags;
    utar_flags_info& dstflags;  
    context*         ctxt;
    ustring          buildVersion;
    ustring          root;

public:
    nbackmain(context *main_, utar_flags_info& flags_, utar_flags_info& dstflags_);
    ~nbackmain();
    
    void setBuildVersion(ustring version) { buildVersion = version; }
    exitcodes_t doBackup();

    
    static exitcodes_t cache_setup(bool loadhashcache, context *ctxt, utar_flags_info& flags, backstate &state);
    static void cache_write(context *ctxt, utar_flags_info& flags, backstate &state, ubigint64 explicit_backupid, int explicit_ddr_index);

private:
    int processSystemstate(ustring sysstate);
    int backupSystemstate();
    bool stats_data_only(DIRELEM rootdirelem, context* main);

    exitcodes_t initBackup(DIRELEM& rootdirelem);
    exitcodes_t runBackup(backstate &state, DIRELEM& rootdirelem);

    bool raw_format_supported_for_backup(const utar_flags_info& flags, bool only_if_by_default) const;

#if SYSTEM_UNIX
    bool wakeup_automounts(backstate& state);
    bool enter_default_mount_rules(backstate& state, ustring root, dirstats& dstats);
#endif

    xml_messagep most_recent_sessionprogress; 

    
    void send_secondary_session_ticket(context* main);

}; 

#endif  
















#include "common.h"
#include "debug.h"

#include <algorithm>

#include "runstage.h"
#include "dirrec_pack.h"
#include "dumpstreamutils.h"
#include "utar_flags_info.h"
#include "hostinfo.h"  


#define msg1 ((xflag[2]&2048)!=0)   
#define msg2 ((xflag[2]&4096)!=0)   
#define inode_msg ((xflag[30] & 256) !=0)   

#define do_dir_map     ((xflag[22] & 128) == 0) 
#define do_acl_ref_map ((xflag[22] & 2048)!= 0) 

#define do_sparse_file_size ((xflag[29] & 67108864) == 0)  

#define dbg_xp ((xflag[30] & 4096) != 0) 

namespace dumpstream
{

typemap::inodetype typemap::get(int32_t inum) const
{
    assert(inum > 0);
    inum--; 
    const int32_t iindex = (inum >> 3) << 1; 
    const int32_t ibit = 1 << (inum & 7);
    assert(iindex < size());
    const char *t = start() + iindex;
    return inodetype((t[0] & ibit ? 1 : 0) | (t[1] & ibit ? 2 : 0));
}


void typemap::set(int32_t inum, inodetype itype)
{
    assert(inum > 0);
    inum--; 
    const int32_t iindex = (inum >> 3) << 1; 
    const int32_t ibit = 1 << (inum & 7);
    assert(iindex < size());
    char *t = start() + iindex;
    t[0] = itype & 1 ? t[0] | ibit : t[0] & ~ibit;
    t[1] = itype & 2 ? t[1] | ibit : t[1] & ~ibit;
}


upath typemap::format(int32_t inum, inodetype itype, bool oldstyle )
{
    
    
    
    assert(itype != unused);
    return itype == dir && inum == 2 ? upath(TS_DIR_FILENAME "/2") :
           itype == acl && inum == 3 ? upath(TS_ACL3_FILENAME "/3") :
           upath(ustring::sprintf("%s/%02x/%03x/%03x",
                                  itype == file ? TS_FILE_FILENAME :
                                  itype == dir  ? TS_DIR_FILENAME  :
                                  oldstyle      ? TS_ACL_FILENAME
                                                : TS_ACL3_FILENAME,
                                  inum>>24 & 0xff, inum>>12 & 0xfff, inum & 0xfff));
}


int32_t typemap::parse(const upath &path, inodetype &itype)
{
    
    ustring top = path.get(0);
    if (top == TS_DIR_FILENAME)       itype = dir;
    else if (top == TS_FILE_FILENAME) itype = file;
    else if (top == TS_ACL_FILENAME)  itype = acl;
    else if (top == TS_ACL3_FILENAME) itype = acl; 
    else                              itype = unused;
    
    
    ustring inodestr = path.slice(1, path.numelems()).image("");
    
    
    
    
    if (inodestr != "2" && inodestr != "3") inodestr += "00000000";
    return inodestr.substr(0,8).toint(16);
}


int32_t inodemap_err_cnt = 0; 
int32_t inodemap_maxerr = 5;  

bool inodemap::get(int32_t inum) const
{
    
    
    
    
    

    assert(inum > 0);
    inum--; 
    const int32_t iindex = (inum >> 3);  
    const int32_t ibit = 1 << (inum & 7);  

    
    
    
    
    
    
    
    
    
    
    
    if (iindex >= size()) {
        
        if (inodemap_err_cnt < inodemap_maxerr) {
            
            assert(iindex < size());  
            inodemap_err_cnt++;  
            if (inodemap_err_cnt == inodemap_maxerr) {
                
                Out->msg(INFO, LOCTXT("Maximum number of \"assert (iindex < size())\" errors reached.  No more will be written to the log file"));
            }
        }
        return FALSE;
    }
    const char *t = start() + iindex;
    return (*t & ibit) != 0;
}


void inodemap::set(int32_t inum, bool present )
{
    assert(inum > 0);
    inum--; 
    const int32_t iindex = (inum >> 3);
    const int32_t ibit = 1 << (inum & 7);
    assert(iindex < size());
    char *t = start() + iindex;
    *t = present ? *t | ibit : *t & ~ibit;
}

int32_t inodemap::count() const {
    int32_t  sum = 0;
    for (int i = 1; i < max_inode(); i++) {
        sum += get(i);
    }
    return sum;
}

void inodemap::print() const {
    int32_t  sum = 0;
    for (int i = 1; i < max_inode(); i++) {
        if (get(i)) {
           sum ++;
           DB->msg("inodemap::print:  count=%d\tinode=%d", sum, i);
        }
    }
    DB->msg("inodemap::print:  Total inodes set = %d", sum);
}


dirmap::dirmap()
    
    
    
  : tassoc<intobj, fileref>(4099, false) 
{
    setversion();
}


void dirmap::setversion()
{
    
    fileref data;
    data.initmem(sizeof(dirinfo));
    dirinfo *d = reinterpret_cast<dirinfo*>(data.start());
    d->dir_inode   = 0;
    d->dir_mtime   = DIRMAP_VERSION;
    d->child_count = 2;
    d->child[0] = d->child[1] = 0; 
    enter(+d->dir_inode, data);
}


void dirmap::init(fileref flattened)
{
    clear();
    struct dirinfo versioncheck, di;

    
    flattened.getslice64(0, sizeof(versioncheck), &versioncheck);

    fileoffset off = 0;
    while (off < flattened.size64()) {
        
        flattened.getslice64(off, sizeof(di.dir_inode), &di.dir_inode);
        off += sizeof(di.dir_inode);

        flattened.getslice64(off, sizeof(di.dir_mtime), &di.dir_mtime);
        off += sizeof(di.dir_mtime);

        
        
        if (+versioncheck.dir_mtime >= 2) {
            flattened.getslice64(off, sizeof(di.dir_acl_inode), &di.dir_acl_inode);
            off += sizeof(di.dir_acl_inode);
        } else {
            di.dir_acl_inode = 0;
        }

        flattened.getslice64(off, sizeof(di.child_count), &di.child_count);
        off += sizeof(di.child_count);
        assert(+di.child_count >= 2);

        flattened.getslice64(off, sizeof(di.child), &di.child);
        off += sizeof(di.child);
        fileoffset childlistsize = ((di.child_count - 2) * sizeof(swapint));
        assert(off + childlistsize <= flattened.size64());

        
        fileref dirmapblockref;
        fileoffset dirmapsize = childlistsize + sizeof(di);
        
        
        dirmapblockref.initmem(static_cast<size_t>(dirmapsize.value()));
        dirmapblockref.setslice64(0, sizeof(di), &di);

        
        dirmapblockref.setslice64(sizeof(di), flattened.makeslice64(off, childlistsize));

        enter(+di.dir_inode, dirmapblockref);
        off += childlistsize;
    }
}


int dirmap::version() const
{
    
    fileref data = lookup(0);
    if (data == fileref()) return 0;
    const dirinfo *d = reinterpret_cast<const dirinfo *>(data.start());
    return +d->dir_mtime; 
}


bool dirmap::has(int32_t inum) const
{
    return defined(inum);
}


bool dirmap::get(int32_t inum, epoch_t &mtime, undoo::vector<intobj> &chld) const
{
    assert(inum > 0);
    fileref data = lookup(inum);
    if (data == fileref()) return false;
    const dirinfo *d = reinterpret_cast<const dirinfo *>(data.start());
    assert(+d->dir_inode == inum);
    mtime = +d->dir_mtime;
    chld.resize(+d->child_count);
    for (size_t i = 0; i < +d->child_count; i++) {
        chld[i] = +d->child[i];
    }
    return true;
}



bool dirmap::get(int32_t inum, epoch_t &mtime, int32_t &acl_inode, undoo::vector<intobj> &chld) const
{
    assert(inum > 0);
    fileref data = lookup(inum);
    if (data == fileref()) return false;
    const dirinfo *d = reinterpret_cast<const dirinfo *>(data.start());
    assert(+d->dir_inode == inum);
    mtime = +d->dir_mtime;
    acl_inode = +d->dir_acl_inode;
    chld.resize(+d->child_count);
    for (size_t i = 0; i < +d->child_count; i++) {
        chld[i] = +d->child[i];
    }
    return true;
}


void dirmap::set(int32_t inum, epoch_t mtime, const undoo::vector<intobj> &chld)
{
    assert(inum > 0);
    assert(chld.size() >= 2); 
    fileref data;
    
    data.initmem(sizeof(dirinfo) + (chld.size()-2) * sizeof(swapint));
    dirinfo *d = reinterpret_cast<dirinfo*>(data.start());
    d->dir_inode   = inum;
    d->dir_mtime   = mtime;
    d->child_count = static_cast<uint32_t> (chld.size());
    for (size_t i = 0; i < chld.size(); i++) {
        d->child[i] = chld[i];
    }
    enter(+d->dir_inode, data);
}



void dirmap::set(int32_t inum, epoch_t mtime, int32_t acl_inode, const undoo::vector<intobj> &chld)
{
    assert(inum > 0);
    assert(chld.size() >= 2); 
    fileref data;
    
    data.initmem(sizeof(dirinfo) + (chld.size()-2) * sizeof(swapint));
    dirinfo *d = reinterpret_cast<dirinfo*>(data.start());
    d->dir_inode   = inum;
    d->dir_mtime   = mtime;
    d->dir_acl_inode = acl_inode;
    d->child_count = static_cast<uint32_t> (chld.size());
    for (size_t i = 0; i < chld.size(); i++) {
        d->child[i] = chld[i];
    }
    enter(+d->dir_inode, data);
}


bool dirmap::add(fileref dumpdata)
{
    epoch_t mtime;
    undoo::vector<intobj> chld;
    undoo::vector<ustring> dummy;
    int32_t nt_ads_dummy;
    int32_t acl_inode;
    int32_t inum = parsedumpdir(dumpdata, mtime, nt_ads_dummy, chld, dummy, acl_inode);
    
    if (inum) set(inum, mtime, acl_inode, chld);
    return inum != 0;
}


bool dirmap::del(int32_t inum)
{
    assert(inum > 0);
    return remove(inum);
}


fileref dirmap::flatten() const
{
    undoo::vector<intobj> inodes = keys();
    std::sort(inodes.begin(), inodes.end());
    fileref data;
    const size_t vector_size(inodes.size());
    data.initcat((int)vector_size);

    
    size_t loop_count(0);
    uint32_t total_child_count(0);
    const size_t message_interval(vector_size / 10);  

    DB->msg("  dirmap::flatten: Entering loop. (Memory usage: %dMB, Number of inodes: %s)",
            axion_procinfo().vmsize_mb, *(::tostr(vector_size)));
    for (size_t i = 0; i < vector_size; i++) {
        
        
        
        
        
        
        
        
        
        
        
        fileref dirinfodata = lookup(inodes[i]);
        dirinfo *dinfo = reinterpret_cast<dirinfo*>(dirinfodata.start());
        fileref dirmapslice;

        
        
        
        
        const int entry_size(sizeof(dinfo->dir_inode) +
                             sizeof(dinfo->dir_mtime) +
                             sizeof(dinfo->child_count) +
                             (dinfo->child_count * sizeof(dinfo->child[0])) +
                             (version() >= 2 ? sizeof(dinfo->dir_acl_inode) : 0));
        dirmapslice.initlist(entry_size);
        dirmapslice.append(&dinfo->dir_inode, sizeof(dinfo->dir_inode));
        dirmapslice.append(&dinfo->dir_mtime, sizeof(dinfo->dir_mtime));
        if (version() >= 2)
            dirmapslice.append(&dinfo->dir_acl_inode, sizeof(dinfo->dir_acl_inode));
        dirmapslice.append(&dinfo->child_count, sizeof(dinfo->child_count));
        for (size_t j = 0; j < dinfo->child_count; j++)
            dirmapslice.append(&dinfo->child[j], sizeof(dinfo->child[j]));
        data.append(dirmapslice);

       
       total_child_count += dinfo->child_count;
       loop_count++;
       if (((message_interval > 0) && (loop_count % message_interval == 0)) || loop_count == vector_size) {
           DB->msg("    dirmap::flatten: Loop progress: Processed %s map entries (Memory usage: %dMB, Total children: %s)",
                   *(::tostr(loop_count)), axion_procinfo().vmsize_mb, *(::tostr(total_child_count)));
       }
    }
    DB->msg("  dirmap::flatten: Exited loop. Calling makecontiguous(). (Memory usage: %dMB)", axion_procinfo().vmsize_mb);
    data.makecontiguous();
    DB->msg("  dirmap::flatten: Returning. (Memory usage: %dMB)", axion_procinfo().vmsize_mb);
    return data;
}

void dirmap::print() const
{
    undoo::vector<intobj> inodes = keys();
    std::sort(inodes.begin(), inodes.end());
    DB->msg("dirmap::print: Begin listing inodes:");
    for (unsigned int ii = 0; ii < inodes.size(); ii++) {
        fileref data = lookup (inodes[ii]);
        dirinfo *d = reinterpret_cast<dirinfo*>(data.start());
        int32_t my_inode = inodes[ii];
        DB->msg("dirmap::print: inode %d child_count=%d", my_inode, d->child_count);
        for (unsigned int jj = 0; jj < d->child_count; jj++) {
            DB->msg("dirmap::print:       child[%d] = %d", jj, d->child[jj]);
        }
    }
}


int32_t parsedumpdir(fileref dumpdata, epoch_t &mtime, int32_t &nt_ads, undoo::vector<intobj> &childinode,
                     undoo::vector<ustring> &childname, int32_t &acl_inode)
{
    if (!dumpdata.contiguous()) {
        Out->msg(ERR, "<8480>Parsing directory: Fileref must be contiguous");
        return 0;
    }
    if (dumpdata.size64() < TP_BSIZE) {
        Out->msg(ERR, "<8481>Parsing directory: Possibly truncated directory record (size=%d, expected > %d", dumpdata.size(), TP_BSIZE);
        return 0;
    }
    dump_header *hdr = reinterpret_cast<dump_header*>(dumpdata.start());
    if (!validate_magic(*hdr)) { 
        Out->msg(ERR, "<8482>Parsing directory: Invalid magic number, possibly corrupt stream");
        return 0;
    }
    int32_t inum = +hdr->c_inumber;
    assert(inum > 0);
    mtime = +hdr->c_dinode.di_mtime;
    nt_ads    = +hdr->c_spare[NETAPP_NTADSINX];
    acl_inode = +hdr->c_spare[NETAPP_ACLINX];
    int16_t	nlinks = +hdr->c_dinode.di_nlink;
    fileoffset bufpos = 0;
    do {
        bufpos += TP_BSIZE;
        
        
        fileoffset nexthdr = bufpos+hdr->c_count*TP_BSIZE;
        hdr = reinterpret_cast<dump_header*>(dumpdata.start()+nexthdr.value());
        while (bufpos < nexthdr) {
            ndmp_direct *dir = reinterpret_cast<ndmp_direct*>(dumpdata.start()+bufpos.value());
            
            if (dir->d_reclen == 0) {
                bufpos = dumpdata.size64(); 
                break;
            }
            if (dir->d_ino != 0) { 
                childinode.push_back(+dir->d_ino);
                childname.push_back(ustring(dir->d_name, dir->d_namlen));
                if (inode_msg) Out->msg(INFO,"INODES_3: Parent: %d\tChild: %d\tlinks: %d\tmtime: %d\tName: %s", inum, +dir->d_ino,
                    nlinks, mtime, *ustring(dir->d_name, dir->d_namlen));
            }
            bufpos += +dir->d_reclen;
        }
        if (bufpos != nexthdr)
            break; 
    } while (bufpos < dumpdata.size64());
    if (bufpos != dumpdata.size64()) {
        Out->msg(ERR, "<8483>Parsing directory: Parse error, bufpos=%s", *bufpos.image());
        return 0;
    }
    return inum;
}


bool aclmap::get(int32_t acl, undoo::vector<intobj> &refs) const
{
    epoch_t dummy;
    if (!dirmap::get(acl, dummy, refs)) return false;
    refs.erase(refs.begin(), refs.begin()+2);
    return true;
}


void aclmap::add(int32_t acl, int32_t ref)
{
    
    
    
    undoo::vector<intobj> refs;
    epoch_t dummy = 0;
    if (!dirmap::get(acl, dummy, refs)) {
        refs.push_back(acl);
        refs.push_back(0);  
    }
    if (!refs.contains(ref)) refs.push_back(ref);
    set(acl, dummy, refs);
}


bool aclmap::del(int32_t acl, int32_t ref)
{
    undoo::vector<intobj> refs;
    epoch_t dummy = 0;
    if (!dirmap::get(acl, dummy, refs)) return false; 
    int index;
    if (!refs.contains(ref, index) || index < 2) return false; 
    if (refs.size() > 3) { 
        refs.erase(refs.begin()+index);
        set(acl, dummy, refs);
    } else { 
        dirmap::del(acl);
    }
    return true;
}


int32_t decodeNTstreamsdirinode(ustring dirname)
{
    int off = dirname.contains("_ntstreams_");
    if (off < 0) return 0;
    int32_t ref = 0, power=1;
    static const char *digit = "0123456789ABCDEFGIJKLMNOPQRSTUVW";
    for (off += static_cast<int> (strlen("_ntstreams_")); off < dirname.bytelength(); off++, power *= 32) {
        const char *p = strchr(digit, dirname.byteindex(off));
        
        
        if (p == NULL) {
            if (dirname.byteindex(off) == 'H')
                 p = digit+16;
           else {
                Out->msg(WARN, "Found unexpected character '%c' in decoding ADS directory '%s'. Alternate datastream info may not be restored properly.",
                    dirname.byteindex(off), *dirname);
                return 0;
            }
        }
        ref += static_cast<int32_t> ((p - digit)) * power;
        if (ref < 0) return 0;
    }
    return ref;
}


bigint64 file_count(const dirmap &dmap, const typemap &tmap, const inodemap &imap)
{
    Out->msg(INFO, "<8484>Counting files in the backup...");
    bigint64 n = 0;
    if (dmap.size() > 0) {
        undoo::vector<intobj> dir = dmap.keys();
        undoo::vector<intobj> child;
        epoch_t dummy;
        
        
        for (size_t i = 0; i < dir.size(); i++) {
            
            if (dir[i] == 0) continue;
            
            (void) dmap.get(dir[i], dummy, child);
            
            if (tmap.get(child[1]) != typemap::file) {
                for (size_t c = 2; c < child.size(); c++) { 
                    if (tmap.get(child[c]) == typemap::file && (imap.size() == 0 || imap.get(child[c]))) n++;
                }
            }
        }
    } else {
        Out->msg(WARN, "<8485>Dir map disabled: file count may include NTFS alternate datastreams");
        for (int32_t i = 1; i < tmap.max_inode(); i++) {
            if (i == 3) continue; 
            if (tmap.get(i) == typemap::file && (imap.size() == 0 || imap.get(i))) n++;
        }
    }
    Out->msg(INFO, "<8486>Counting files in the backup...done");
    return n;
}


parser::parser(const utar_flags_info &flgs, const ustring& streamdesc, const int stream_timeoutsecs)
    : parsestream      (streamdesc, 0, TP_BSIZE, stream_timeoutsecs, parsestream::flags_none, "") 
    , flags            (flgs)
    , ddate            (0)
    , eom_seen         (false)
    , last_type        (typemap::unused)
    , last_inode       (0)
    , object_size      (0)
    , object_bytes_read(0)
    , acl_bytes_left   (0)
{
    memset(&cur_header, 0, sizeof cur_header);
    buffer.initlist(0);
    prev_type_map.initlist(0);
}


parser::~parser()
{
    
    DIRELEMp dummy;
    fileref dummy2;
    while (getentry(dummy, dummy2, dummy2)) {}
}







parser::path_action parser::next_modified_path(const upath &dir, ustring &name)
{
    
    
    DIRELEMp de;
    fileref dummy;
    if (!getentry(de, dummy, dummy))
        return no_more_items;
    upath path = de->fullpath();
    push_entry(de, dummy, dummy); 
    typemap::inodetype itype;
    int32_t inum = type_map.parse(path, itype); 
    if (msg2) DB->msg(DBTXT("dumpstream::parser::next_modified_path next item in stream is path:%s inum:%d itype:%d"),
                      *path.image(), inum, itype);

    if (prev_type_map.size() < type_map.size()) {
        
        prev_type_map.append(type_map.start()+prev_type_map.size(), type_map.size()-prev_type_map.size());
    }
    assert(prev_type_map.max_inode() == type_map.max_inode());
    assert(itype == typemap::unused || inum < prev_type_map.max_inode());

    
    
    
    
    
    bool deleted = false;
    while ((last_inode != inum || last_type != itype) && !deleted) {
        if (msg2) DB->msg(DBTXT("dumpstream::parser::next_modified_path inode:%d type:%d scanning for deletions"), last_inode, last_type);
        if (last_type != typemap::unused) {
            if (last_inode == 0) last_inode = 1; 
            for (int32_t upto = last_type == itype ? inum : prev_type_map.max_inode(); last_inode < upto && !deleted; last_inode++) {
                if (prev_type_map.get(last_inode) == last_type) {
                    if (last_type != typemap::acl) {
                        
                        deleted = (last_inode != 3 && !use_map.get(last_inode)) || 
                                   stream_map.get(last_inode);                     
                        
                    } else {
                        
                        
                        
                        
                        deleted = use_map.get(last_inode);
                    }
                    if (msg2) DB->msg(DBTXT("dumpstream::parser::next_modified_path inode:%d type:%d used:%s stream:%s delete:%s"),
                                      last_inode, last_type, use_map.get(last_inode) ? "yes" : "no",
                                      stream_map.get(last_inode) ? "yes" : "no", deleted ? "yes" : "no");
                }
            }
            if (deleted) {
                last_inode--; 
            } else if (last_inode == prev_type_map.max_inode()) {
                last_inode = 0; 
            }
        }
        if (last_inode == 0) {
            
            
            
            
            if (last_type == typemap::acl && acl_bytes_left > 0) {
                
                
                
                Out->msg(WARN, "<8652>Inode number rolling over in ACLs section.");
            } else {
                switch (last_type) {
                    case typemap::unused: last_type = !eom_seen          ? typemap::dir  : typemap::acl;    break;
                    case typemap::dir:    last_type = acl_bytes_left > 0 ? typemap::acl  : typemap::file;   break;
                    case typemap::acl:    last_type = !eom_seen          ? typemap::file : typemap::unused; break;
                    case typemap::file:   last_type = typemap::unused;                                      break;
                }
            }
            if (last_type != typemap::unused)
                Out->msg(INFO, last_type == typemap::dir  ? "<8487>Reading directories..." :
                               last_type == typemap::file ? LOCTXT("Reading files...")
                                                          : LOCTXT("Reading acls..."));
        }
    }
    if (deleted) {
        
        path = prev_type_map.format(last_inode, last_type, acl_bytes_left == 0);
    }

    
    int cnt = 0;
    do {
        name = path.stripdir();
        path.pop_back();
        cnt++;
    } while (path.numelems() > dir.numelems());
    if (path != dir)
        return no_more_items;      
    if (cnt > 1)
        return subdir_item;    
    
    if (deleted) {
        
        
        if (type_map.get(last_inode) == last_type) {
            if (do_dir_map && dir_map.has(last_inode)) dir_map.remove(last_inode);
            type_map.set(last_inode, typemap::unused);
            if (msg2) DB->msg(DBTXT("dumpstream::parser::next_modified_path setting inode %d to type %d"),
                              last_inode, typemap::unused);
        }
        
        last_inode++;
        return delete_item;
    }
    if (inum > 0) {
        
        if (msg2) DB->msg(DBTXT("dumpstream::parser::next_modified_path setting inode %d to type %d"), inum, itype);
        type_map.set(inum, itype);
        
        
        last_inode++;
    }
    return save_item;
}







bool parser::getentry(DIRELEMp &de, fileref &dummy1, fileref &dummy2)
{
    int32_t oldaclref = 0;
    if (!de.isnull()) {
        dirrec_pack::acl_ref acl(de.getimpl());
        acl.get(oldaclref);
        
        if (inode_msg && (de->inode_number() != 0)) Out->msg(INFO,"INODES_1: inode: %d\tdirrec: %d", de->inode_number(), oldaclref);
    }

    
    if (parsestream_base::getentry(de, dummy1, dummy2)) {
        update_acl_ref(oldaclref, de);
        return true;
    }

    if (!uapp::staging().canRun()) 
        return false; 

    
    char buf[TP_BSIZE];
    while (readdata(buf, sizeof buf) > 0) {}
    if (object_size == 0)
        return false; 

    const dinode &inode = cur_header.c_dinode;

    upath path;
    int32_t inum = +cur_header.c_inumber;
    typemap::inodetype itype = typemap::unused;
    switch (cur_header.c_type) {
        case TS_TAPE:
            path = upath(TS_TAPE_FILENAME);
            break;
        case TS_CLRI:
            path = upath(TS_CLRI_FILENAME);
            break;
        case TS_BITS:
            path = upath(TS_BITS_FILENAME);
            break;
        case TS_EOM:
            path = upath(TS_EOM_FILENAME);
            break;
        case TS_END:
            path = upath(eom_seen ? TS_END_FILENAME ".2" : TS_END_FILENAME ".1");
            break;
        case TS_INODE:
            itype = eom_seen                              ? typemap::acl :
                    acl_bytes_left > 0                    ? typemap::acl : 
                    (inode.di_mode & FT_IFMT) == FT_IFDIR ? typemap::dir
                                                          : typemap::file;
            path = type_map.format(inum, itype, acl_bytes_left == 0);
            if (inode_msg) Out->msg(INFO,"INODES_2: Inode: %d\tType: %d\tACL: %d\tADS: %d\tlinks: %d\tmtime: %d",
                inum, (int)itype, +cur_header.c_spare[NETAPP_ACLINX],  +cur_header.c_spare[NETAPP_NTADSINX],
                +cur_header.c_dinode.di_nlink, +cur_header.c_dinode.di_mtime);
            break;
        default:
            if (uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid header type"))
                Out->msg(FATAL, "<8488>Invalid header type %d", +cur_header.c_type);
            object_size = 0;
            object_bytes_read = -1;
            return false;
    }

    
    de = new DIRELEM;
    if (cur_header.c_type == TS_INODE) {
        de->initialize(epoch_t(inode.di_ctime), epoch_t(inode.di_atime), epoch_t(inode.di_mtime), fileoffset(+inode.di_size),
                       ATTR_EXTENDED, path.stripdir());
        de->set_unix_special(0, 0, inum, inode.di_nlink);
        de->set_unix_attributes(unsigned(inode.di_mode), univuns(inode.oldids[0] ),
                                                         univuns(inode.oldids[1] ));

        
	
        max_mtime = std::max(max_mtime, (unsigned long)inode.di_mtime);
	
        max_ctime = std::max(max_ctime, (unsigned long)inode.di_ctime);

        
    
        dirrec_pack::acl_ref acl(de.getimpl());
        acl.set(cur_header.c_spare[NETAPP_ACLINX]);
        update_acl_ref(oldaclref, de);

        dirrec_pack::data_origin org(de.getimpl());
        dirrec_pack::data_origin::origin_type origin
            (itype == typemap::acl ? dirrec_pack::data_origin::netapp_acl :
             itype == typemap::dir ? dirrec_pack::data_origin::netapp_dir
                                   : dirrec_pack::data_origin::netapp_file);
        
        org.set(origin, fileoffset(TP_BSIZE), fileoffset(+cur_header.c_dinode.di_size));

    } else {
        de->initialize(0, 0, 0, object_size, 0, path.stripdir());
    }
    de->set_fullpath(path);
    de->set_stdin(); 

    object_bytes_read = 0; 

    if (msg2) DB->msg(DBTXT("dumpstream::parser::getentry next item in stream is %s"), *path.image());
    return true;
}


void parser::update_acl_ref(int32_t oldaclref, DIRELEMp de)
{
    if (!do_acl_ref_map) return;

    int32_t aclref = 0;
    dirrec_pack::acl_ref acl(de.getimpl());
    acl.get(aclref);

    if (oldaclref == aclref) return;

    int32_t inum = de->inode_number();
    if (oldaclref != 0 && acl_ref_map.has(oldaclref)) acl_ref_map.del(oldaclref, inum);
    if (aclref != 0) acl_ref_map.add(aclref, inum);
}











bigint64 parser::readdata(void *bufp, size_t n)
{
    if (!uapp::staging().canRun())
        return -1;

    
    

    if (object_bytes_read < 0)
        return 0; 

    
    if (object_bytes_read == object_size) {
        
        object_size = 0;
        object_bytes_read = -1;

        
        if (cur_header.c_type == TS_END && eom_seen)
            return 0;

        
        fileoffset curpos = bytepos;
        fileref header;
        int32_t len = (int32_t) parsestream::getdata(sizeof cur_header, header, "header");
        if (len == 0)
            return 0; 
        if (len != TP_BSIZE) {
            
            if (uapp::staging().startTermination(EXIT_DUMPSTREAM, "incomplete header in stream")) {
                if (len > 0) Out->msg(FATAL, "<8489>Incomplete header in parser::readdata at stream offset %s",
                                      *curpos.image());
            }
            return -1;
        }
        memcpy(&cur_header, header.start(), sizeof cur_header);

        
        bool is_header = true;
        if (!validate_magic(cur_header)) {
            if (acl_bytes_left == 0 && uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid magic number in stream")) {
                Out->msg(FATAL, "<8490>Invalid stream format: magic number %08x (stream offset = %s)",
                         +cur_header.c_magic, *bytepos.image());
            }
            is_header = false;
        }
        if (!validate_checksum(cur_header)) {
            if (acl_bytes_left == 0 && uapp::staging().startTermination(EXIT_DUMPSTREAM, "incorrect checksum in stream")) {
                Out->msg(FATAL, "<8491>Incorrect checksum: %d (stream offset = %s)",
                         +cur_header.c_checksum, *bytepos.image());
            }
            is_header = false;
        }

        if (msg2 && is_header) DB->msg(DBTXT("dumpstream::parser::readdata next header in stream at offset %s"),
                                       *curpos.image());

        
        if (acl_bytes_left > 0) {
            acl_bytes_left -= sizeof cur_header; 
            object_size     = sizeof cur_header; 
            if (acl_bytes_left > 0) {
                
                if (!is_header || cur_header.c_type != TS_INODE) { 
                    object_bytes_read = 0;
                }
                if (is_header && cur_header.c_magic == ACL_MAGIC) {
                    
                    cur_header.c_shadow.c_level = 0;
                    cur_header.c_ddate = 0;
                    
                    update_checksum(cur_header);
                }
            } else if (acl_bytes_left == 0) {
                
                if (!is_header) {
                    Out->msg(FATAL, "<8653>Expected a header (stream offset = %s)", *bytepos.image());
                    uapp::staging().startTermination(EXIT_DUMPSTREAM, "expected a header in stream");
                } else if (cur_header.c_type == TS_ADDR) {
                    
                    
                    assert(cur_header.c_inumber == 3);
                    acl_bytes_left = (cur_header.c_count+1) * TP_BSIZE;
                    object_bytes_read = object_size;
                    if (msg2) DB->msg(DBTXT("header info at stream pos %s: type=TS_ADDR inode=3 size=%d"),
                                      *curpos.image(), acl_bytes_left);
                    return readdata(bufp, n); 
                }
                
            } else {
                
                assert(acl_bytes_left >= 0);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid TS_INODE data size in stream");
            }
        }

        if (!uapp::staging().canRun()) return -1;

        if (buffer.size64() != 0 && cur_header.c_type != TS_ADDR) {
            
            
            if (msg1) {
                int32_t inum = +reinterpret_cast<dump_header*>(buffer.start())->c_inumber;
                fileoffset pos = curpos - buffer.size64(); 
                DB->msg(DBTXT("Parsing inode %d directory contents, offset=%s, size=%ld"),
                        inum, *pos.image(), buffer.size64().value());
            }
            dir_map.add(buffer);
            buffer.initlist(0);
        }

        if (acl_bytes_left == 0) {
            
            
            object_size = (cur_header.c_count+1) * TP_BSIZE; 

            switch (cur_header.c_type) {
                case TS_TAPE:
                    ddate = epoch_t(+cur_header.c_ddate);
                    break;
                case TS_EOM:
                    
                    eom_seen = true;
                    
                case TS_BITS:
                case TS_CLRI:
                    
                    if (type_map.size64() < (object_size-TP_BSIZE)*2) { 
                        fileref zeroes;
                        zeroes.initzero((int)((object_size-TP_BSIZE)*2 - type_map.size()));
                        type_map.append(zeroes);
                        prev_type_map.append(zeroes);
                    }
                    break;
                case TS_ADDR:
                    
                    object_bytes_read = 0;
                    
                case TS_INODE:
                    
                    for (int i = 0; i < cur_header.c_count; i++) {
                        if (cur_header.c_data.s_addrs[i] == 0) object_size -= TP_BSIZE;
                    }
                    if (msg2) DB->msg(DBTXT("header info at stream pos %s: type=%s inode=%d size=%ld"),
                                      *curpos.image(), cur_header.c_type == TS_INODE ? "TS_INODE" : "TS_ADDR",
                                      +cur_header.c_inumber, object_size);
                    if (buffer.size64() != 0 || (do_dir_map && (cur_header.c_dinode.di_mode & FT_IFMT) == FT_IFDIR)) {
                        
                        buffer.append(&cur_header, sizeof cur_header);
                    } else if (flags.ontap73acls && !eom_seen && cur_header.c_inumber == 3) {
                        assert(cur_header.c_type == TS_INODE); 
                        
                        acl_bytes_left = (int32_t)object_size;
                        object_size = sizeof cur_header;
                    }
                    break;
                case TS_END:
                    
                    
                    object_size = TP_BSIZE;
                    break;
            }

            
            cur_header.c_shadow.c_level = 0;
            cur_header.c_ddate = 0;

            
            update_checksum(cur_header);
        }

        if (object_bytes_read < 0)
            return 0; 
    }

    
    if (object_bytes_read < TP_BSIZE) {
        n = std::min(TP_BSIZE - size_t(object_bytes_read), n);
        memcpy(bufp, (char*)&cur_header + object_bytes_read, n);
        object_bytes_read += n;
        return n;
    }

    
    
    
    int32_t len = (int32_t)parsestream::readdata(bufp, (size_t)std::min(object_size - object_bytes_read, bigint64(n)));
    if (len <= 0) {
        if (len < 0) {
            Out->msg(FATAL, "<8493>Problem reading stream (errno = %d: %s, stream offset = %s)", errno, strerror(errno), *bytepos.image());
        } else  {
            Out->msg(FATAL, "<8494>Unexpected end of stream (stream offset = %s)", *bytepos.image());
        }
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "unexpected end of stream");
        object_size = 0;
        return object_bytes_read = -1;
    }

    bigint64 bufp_data_offset = object_bytes_read - TP_BSIZE; 
    object_bytes_read += len;

    if (do_dir_map && buffer.size64() > 0) buffer.append(bufp, len); 

    
    
    switch (cur_header.c_type) {
        case TS_CLRI:
            use_map.append(bufp, len);
            break;
        case TS_BITS: {
            stream_map.append(bufp, len);
            assert(use_map.size() >= bufp_data_offset+len);
            
            
            
            
            
            
            
            
            
            
            char *b = (char*)bufp;
            char *c = use_map.start()  + bufp_data_offset;
            char *t = type_map.start() + bufp_data_offset*2;
            for (int32_t i = 0; i < len; i++, b++, c++, t += 2) *b |= (t[0] ^ t[1]) & *c;
            break;
        }
        case TS_EOM: {
            acl_map.append(bufp, len); 
            assert(use_map.size() >= bufp_data_offset+len);
            
            
            
            char *b = (char*)bufp;
            char *c = use_map.start()  + bufp_data_offset;
            char *t = type_map.start() + bufp_data_offset*2;
            for (int32_t i = 0; i < len; i++, b++, c++, t += 2) *b |= (t[0] & t[1]) & ~*c;
            break;
        }
    }

    return len;
}


void parser::validatebitmaps(bool incremental)
{
    Out->msg(INFO, "<8495>Validating dumpstream bitmap integrity...");

    assert(type_map.max_inode() == use_map.max_inode());
    assert(type_map.max_inode() == stream_map.max_inode());
    assert(type_map.max_inode() == acl_map.max_inode());

    
    
    
    
    const int32_t maxerrs = (xflag[22] & 2097152) ? type_map.max_inode() : 500;
    int32_t errs = 0;

    for (int32_t inum = 1; inum < type_map.max_inode() && errs < maxerrs; inum++) {
        switch (type_map.get(inum)) {
            case typemap::unused:
                if (use_map.get(inum))
                    Out->msg(ERR, "<8496>Inode %d found in TS_CLRI but not in backup", inum), errs++;
                if (stream_map.get(inum))
                    Out->msg(ERR, "<8497>Inode %d found in TS_BITS but not in backup", inum), errs++;
                if (acl_map.get(inum)) {
                    Out->msg(ERR, "<8498>Inode %d found in TS_EOM but not in backup", inum), errs++;
                    
                    
                    
                    if (incremental) {
                        Out->msg(INFO, "<8654>Setting inode %d type to ACL", inum);
                        type_map.set(inum, typemap::acl);
                    }
                }
                break;
            case typemap::file:
                if (inum == 3) {
                    
                    if (use_map.get(inum))
                        Out->msg(ERR, "<8499>Inode %d found in TS_CLRI but should not be", inum), errs++;
                    if (stream_map.get(inum))
                        Out->msg(ERR, "<8500>Inode %d found in TS_BITS but should not be", inum), errs++;
                    if (acl_map.get(inum))
                        Out->msg(ERR, "<8501>Inode %d found in TS_EOM but should not be", inum), errs++;
                    break;
                }
                
            case typemap::dir:
                if (!use_map.get(inum))
                    Out->msg(ERR, "<8502>Inode %d not found in TS_CLRI but present in backup", inum), errs++;
                if (!incremental && !stream_map.get(inum)) 
                    Out->msg(ERR, "<8503>Inode %d not found in TS_BITS but present in backup", inum), errs++;
                if (acl_map.get(inum))
                    Out->msg(ERR, "<8504>Inode %d found in TS_EOM but is not an ACL", inum), errs++;
                break;
            case typemap::acl:
                if (use_map.get(inum))
                    Out->msg(ERR, "<8505>Inode %d found in TS_CLRI but is an ACL", inum), errs++;
                if (stream_map.get(inum))
                    Out->msg(ERR, "<8506>Inode %d found in TS_BITS but is an ACL", inum), errs++;
                if (do_acl_ref_map && !incremental && acl_ref_map.has(inum) && !acl_map.get(inum))
                    
                    
                    Out->msg(ERR, "<8507>Inode %d not found in TS_EOM but present in backup", inum), errs++;
                break;
        }
    }
    if (errs >= maxerrs)
        Out->msg(INFO, "<9933>Validating dumpstream bitmap integrity...too many errors, aborting");
    else
        Out->msg(INFO, "<8508>Validating dumpstream bitmap integrity...done");
}


pipectrl::pipectrl(fileref output)
    : pipe_control(output, TP_BSIZE)
{
}


bool pipectrl::addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                      const fileoffset datasize, fileref& dataslice)
{
    dataslice.initslice6464(data, curroffset, datasize);
    add_to_curroffset(datasize, "data");
    return true;
}


bool pipectrl::fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                          const DIRELEM& elem,  const ustring& path,
                          const filetype ftype, const ustring& linkname,
                          const fileoffset startoff)
{
    return false;
}


}







dumpformat_directory::dumpformat_directory()
  : haveheader(false), header_type(0), direct_bytes(0)
{
    data.initcat(10);
}

dumpformat_directory::~dumpformat_directory()
{
}

bool dumpformat_directory::append_chunk(const fileref& curr_chunk, bool& keepgoing) {
    

    data.append(curr_chunk);  

    if(!haveheader) haveheader = check_header();

    if(msg1)DB->msg("dumpformat_directory::append_chunk 2 curr_chunk:%s data:%s haveheader:%d", *curr_chunk.size64().image(), *data.size64().image(), haveheader);

    
    if(haveheader && (data.size64() >= direct_bytes)) {
        if (!parse_directs(keepgoing)) { DB->msg("dumpformat_directory::append_chunk return false"); return false; }
        if (!keepgoing) { data.initcat(10); return true; }

        
        if(data.size64() > direct_bytes) {
            int leftover_size(data.size() - direct_bytes);
            DB->msg("dumpformat_directory::append_chunk saving leftovers %d", leftover_size);
            assert(leftover_size > 0);
            fileref leftovers;
            leftovers.initmem(leftover_size);
            data.getslice(direct_bytes, leftover_size, leftovers.start());
            data.initcat(10);
            data.append(leftovers);

        } else {
            data.initcat(10);
        }
        haveheader = false;
    }
    return true;
}

bool dumpformat_directory::finished() {
    DB->msg("dumpformat_directory::finished data:%s", *data.size64().image());

    if(data.size64() == 0) return true;

    if(!haveheader) haveheader = check_header();

    
    if(haveheader && (data.size64() >= direct_bytes)) {
        bool keepgoing;
        parse_directs(keepgoing);
        
        
        
        
        
        
        
        int offset = direct_bytes;
        while (keepgoing) {
            haveheader = check_header(offset);
            
            
            
            if (!haveheader) break;
            parse_directs(keepgoing, offset);
            offset += direct_bytes;
        }
        if (haveheader) return true;
    }

    assert(false);
    return false;
}


bool dumpformat_directory::parse_directs(bool& keepgoing, int offset) {
    DB->msg("dumpformat_directory::parse_directs data:%s direct_bytes:%d", *data.size64().image(), direct_bytes);

    

    if(direct_bytes > data.size()) { assert(false); return false; }

    data.makecontiguous();  

    char * loc  = data.start() + TP_BSIZE + offset; 
    char * last = data.start() + direct_bytes + offset;

    int totalsize = TP_BSIZE;
    while (loc < last) {
        struct ndmp_direct& entry = *(struct ndmp_direct *)loc;
        if (entry.d_namlen == 0 && entry.d_type != 0) {
            entry.d_namlen= entry.d_type;
        }
        entry.d_type = DT_UNKNOWN;

        loc += entry.d_reclen;
        if (entry.d_reclen == 0) { DB->msg("dumpformst::parse_directs zero reclen "); break; }

        int ino_num(entry.d_ino);
        ustring name(entry.d_name, entry.d_namlen);
        totalsize += entry.d_reclen;
        assert(totalsize<=direct_bytes);
        if(msg2)DB->msg("dumpformat_directory::parse_directs data:%s direct_bytes:%d totalsize:%d entry len:%d ino_num:%d name:%s",
                        *data.size64().image(), direct_bytes, totalsize, +entry.d_reclen, ino_num, *name);
        if(name.bytelength() != entry.d_namlen) {
            DB->msg("name.bytelength():%d != entry.d_namlen:%d '%s'", name.bytelength(), entry.d_namlen, *name);
        }
        if (!process_entry(ino_num, name, keepgoing)) {
            DB->msg("dumpformst::parse_directs error in process_entry");
            return false;
        }
        if (!keepgoing) { 
            DB->msg("dumpformst::parse_directs keepgoing = false");
            return true;
        }
    }
    return true;

}




bool dumpformat_directory::check_header(int offset) {
    DB->msg("dumpformat_directory::check_header data:%s", *data.size64().image());

    if(data.size64() < TP_BSIZE) return false;

    
    fileref headerdata;
    headerdata.initmem(TP_BSIZE);
    data.getslice(offset, TP_BSIZE, headerdata.start());
    dump_header *header = reinterpret_cast<dump_header*>(headerdata.start());

    if(header==NULL) return false;

    if (!check_magic(header->c_magic)) {
        Out->msg(FATAL, "<5757>Cannot decode stream, magic number invalid %d", +header->c_magic);
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid magic number in stream");
        return false;
    }

    header_type = +header->c_type;
    if (header_type != TS_INODE && header_type != TS_ADDR) {
        Out->msg(FATAL, "<8509>Unknown header type for directory %d", header_type);
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "unknown header type");
        return false;
    }

    direct_bytes = (header->c_count * TP_BSIZE) + TP_BSIZE; 
    DB->msg("dumpformat_directory::check_header found %d count:(%d * 1024)+1024 = %d size for directory", +header->c_type, +header->c_count, direct_bytes);
    return true;
}

bool dumpformat_directory::check_magic(swapint magic) {
    if (magic == NFS_MAGIC) { return true; }
    if (magic == OFS_MAGIC) { Out->msg(WARN, "<5753>Using OFS MAGIC???"); return true; }

    swap_use_little_endian = false;
    if (magic == NFS_MAGIC) { Out->msg(INFO, "<5765>Swapping bytes");  return true; }
    if (magic == OFS_MAGIC) { Out->msg(WARN, "<5755>Swapping bytes - Using OFS MAGIC???"); return true; }

    Out->msg(FATAL, "<5756>Bad magic number (%d) in dump stream.", +magic);
    return false;
}




crossplatform_ctl::crossplatform_ctl (ustring &filename)
    : m_backup_size(0)
    , m_backup_loc(0)
    , m_outfile_size(0)
    , m_outfile_loc(0)
    , m_hdr_loc(0)
    , m_count(0)
    , m_filename(filename)
{
    memset (m_data, 0, TP_NINDIR);
}


void crossplatform_ctl::set_backup_size(fileoffset::value_type size_in_backup) {
    m_backup_size = size_in_backup;
}



bool crossplatform_ctl::parsefileheader (fileref& buffer, int32_t inode, int64_t& actual_filesize) {
    if (buffer.size() < TP_BSIZE) return false;

    if (!buffer.contiguous()) {
        Out->msg(ERR, "Parsing file header: Fileref must be contiguous");
        return false;
    }
    if (buffer.size64() < TP_BSIZE) {
        Out->msg(ERR, "Parsing file header: Possibly truncated file record (size=%d, expected > %d)", buffer.size(), TP_BSIZE);
        return false;
    }
    dump_header *hdr = reinterpret_cast<dump_header*>(buffer.start());
    if (!validate_magic(*hdr)) { 
        Out->msg(ERR, "Parsing file header: Invalid magic number, possibly corrupt stream");
        return false;
    }
    const int32_t inum = +hdr->c_inumber;
    if (inum != inode) {
        Out->msg(ERR, "Parsing file header: Invalid inode number (is %d, expected %d)", inum, inode);
        return false;
    }
    
    
    
    
    
    actual_filesize = +hdr->c_dinode.di_size;

    for (int i=0; i < TP_NINDIR; i++) {
        m_data[i]     = +hdr->c_data.s_addrs[i];
    }

    if (dbg_xp) {
        DB->msg("crossplatform_ctl::parsefileheader: file='%s' block count = %d", *m_filename, +hdr->c_count);
        DB->msg("crossplatform_ctl::parsefileheader: blocks are: ");
        int current = 0;
        for (int line=0; line < 4; line++) {  
            unsigned  char value[16];
            for (int bunch=0; bunch < 16; bunch++) {
                value[bunch] = 0;
                for (int digit=0; digit < 8; digit++) {
                    value[bunch] = (value[bunch] << 1) + (+hdr->c_data.s_addrs[current]);
                    current++;
                }
            }
            ustring outline = ustring::sprintf("%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
                value[0], value[1], value[2],  value[3],  value[4],  value[5],  value[6],  value[7],
                value[8], value[9], value[10], value[11], value[12], value[13], value[14], value[15]);
            DB->msg("    %s", *outline);
        }
    }

    if (+hdr->c_type == TS_INODE) { 
        m_outfile_size = actual_filesize;
    }
    m_count = +hdr->c_count;
    m_hdr_loc = 0;
    m_backup_loc += TP_BSIZE;
    return true;
}


void crossplatform_ctl::dump() {
    DB->msg("crossplatform_ctl::dump: m_backup_size =%ld  m_backup_loc =%ld", m_backup_size, m_backup_loc);
    DB->msg("                                     : m_outfile_size=%ld  m_outfile_loc=%ld", m_outfile_size, m_outfile_loc);
    DB->msg("                                     : m_count=%d m_hdr_loc=%d", m_count, m_hdr_loc);
}



crossplatform_ctl::XP_action  crossplatform_ctl::get_next_action(fileoffset::value_type& backup_loc,
                                                                 fileoffset::value_type& outfile_loc, int& nbytes) {
    if (m_hdr_loc >= TP_NINDIR) {  
        if (m_outfile_loc == m_outfile_size) {
            return xp_file_done;  
        }
        else {  
            backup_loc  = m_backup_loc;
            outfile_loc = 0;
            nbytes = TP_BSIZE;
            return xp_get_tsaddr;  
        }
    }
    
    int blocks = 1;   
    char run_char = m_data[m_hdr_loc];
    for (int i=m_hdr_loc+1; i< TP_NINDIR; i++) {
        if (m_data[i] == run_char) blocks++;
        else break;
    }

    
    if (m_outfile_loc + (blocks*TP_BSIZE) < m_outfile_size){
        backup_loc   = m_backup_loc;
        outfile_loc  = m_outfile_loc;
        nbytes       = (blocks * TP_BSIZE);
        
        m_outfile_loc += nbytes;
        m_backup_loc  += nbytes;
        m_hdr_loc     += blocks;
    }
    else {  
        
        
        
        fileoffset::value_type remainder = (m_outfile_size % TP_BSIZE);
        fileoffset::value_type used =  m_outfile_loc + ((blocks-1)*TP_BSIZE) + (remainder > 0 ? remainder : TP_BSIZE);
        if (dbg_xp) DB->msg("crossplatform_ctl::get_next_action: file='%s' remainder=%ld  blocks=%d  used=%ld",
                            *m_filename, remainder, blocks, used);
        if (used  < m_outfile_size) {
            Out->msg(ERR, "Error: mismatch size on file '%s' used=%ld expected=%ld", *m_filename, used, m_outfile_size);
           
        }
        nbytes       = static_cast<int> (m_outfile_size - m_outfile_loc);
        backup_loc   = m_backup_loc;
        outfile_loc  = m_outfile_loc;
        
        m_backup_loc  = m_backup_size;
        m_outfile_loc = m_outfile_size;

        if (nbytes == 0) {
            return xp_file_done;  
        }
        m_hdr_loc = TP_NINDIR;    
    }

    XP_action action = (run_char != 0) ? xp_write_next : xp_sparse_next;
    if (dbg_xp) {
        DB->msg("crossplatform_ctl::get_next_action: AT END file='%s' RETURNING action=%d backup_loc=%ld outfile_loc=%ld nbytes=%d",
            *m_filename, (int)action, backup_loc, outfile_loc, nbytes);
        dump();   
    }
    return (action);
}





















#include "common.h"
#include "debug.h"
#include "axionfsdirelem.h"
#include "backaxionfs.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"

#include "backappend.h"
#include "backaxionfsdir.h"
#include "utar_flags_info.h"
#include "runstage.h"

#include "dpnobject.h"

#define debug_axionfs      ((xflag[2]&(1<<22))!=0)

#define use_metadata       ((xflag[29] & 1) != 0 && (xflag[13] & 512) == 0)

using namespace nsDpnobj;

backaxionfs::backaxionfs(context *main_) : cycle(NULL, main_), main(main_), overrideacntpath("")
{
    if (debug_axionfs) 
        DB->bt_msg("backaxionfs::backaxionfs constructor (parent:%p) (this:%p)", parent, this);
    rootdirelem = new axionfsDIRELEM(main);
    
    assert(rootdirelem != NULL);
    rootdirelem->set_fullpath("/");
    
    rootdirelem->set_is_root_directory();
    
}


backaxionfs::~backaxionfs() {
    delete rootdirelem;
    rootdirelem = NULL;
}


void backaxionfs::init() {
    
}

void backaxionfs::response(message& outargs) {
  if(debug_axionfs)DB->msg("backaxionfs::response (parent:%p) (this:%p)", parent, this);
  assert(false);
}

void backaxionfs::childdone(cycle *child) {
    if(debug_axionfs) DB->msg("backaxionfs::childdone (parent:%p) (this:%p) (child:%p)", parent, this, child);
    this->size = child->size;
    cycle::childdone(this);
}

void backaxionfs::notifyparent() {
    if(debug_axionfs) DB->msg("backaxionfs::notifyparent (parent:%p) (this:%p)", parent, this);















    cycle::notifyparent();
    
}



axionfsDIRELEM *backaxionfs::lookup (const upath &p_in, bool &ismetadata)
{
    upath p(p_in);

    
    if(debug_axionfs) DB->msg ("backaxionfs::lookup '%s'", *p.image());

    if (p.isroot())
        return rootdirelem;

    
    
    if (use_metadata && (p.stripdir() == dpnobj::metadatadirname)) {
        ismetadata = true;
        p.pop_back();
        if(debug_axionfs) DB->msg ("backaxionfs::lookup '%s' is a metadata directory, actually look up '%s'",
                                   *p_in.image(), *p.image());
    }

    
    
    if (p.numelems() > 1) {
        int last = p.numelems() - 1;
        upath::elemcat mddircat, filecat;
        ustring mddirelem, fileelem;
        p.get(last, fileelem, filecat);
        p.get(last-1, mddirelem, mddircat);
        if (use_metadata && (mddirelem == dpnobj::metadatadirname)) {
            ismetadata = true;
            p.pop_back();
            p.pop_back();
            p = p / upath(fileelem);
            if(debug_axionfs) DB->msg ("backaxionfs::lookup '%s' is a metadata file, for '%s'", *p_in.image(), *p.image());
        }
    }

    
    axionfsDIRELEM *direlemp = rootdirelem;
    int inx = p.get_start(upath::elem_entry);
    assert(inx >= 0); 

    for (; inx < p.numelems(); inx++) {
        if (direlemp == NULL) 
            return NULL;

        ustring pathelem;
        upath::elemcat elemcategory;
        
        p.get(inx, pathelem, elemcategory);
        
        
        if(debug_axionfs) DB->msg("backaxionfs::lookup... processing %s at inx %d (elemcategory %d, while elem_entry is %d)", 
                                  *pathelem, inx, elemcategory, upath::elem_entry);
        direlemp = direlemp->lookup(pathelem);
    }

    return direlemp;
}


void backaxionfs::set_account_path(const ustring &p)
{
    overrideacntpath = p;
}

ustring backaxionfs::get_account_path() const
{
    return overrideacntpath;
}


void backaxionfs::purge()
{
    
    if (rootdirelem) {
        delete rootdirelem;
        rootdirelem = NULL;
    }

    DB->msg("backaxionfs::purge constructor (parent:%p) (this:%p)", parent, this);
    rootdirelem = new axionfsDIRELEM(main);
    
    assert(rootdirelem != NULL);
    rootdirelem->set_fullpath("/");
    
    rootdirelem->set_is_root_directory();
    
}
























#include "common.h"
#include "debug.h"
#include "output.h"
#include "workelem.h"
#include "backupdir2backroot.h"
#include "backavpaxstream.h"
#include "parsestream_ucontainer.h"
#include "ddr_interface.h"
#include "utar_flags_info.h"
#include "runstage.h"
#include "filenames.h"
#include "utar_commands.h"





#define backupdir2backroot_msg      ((xflag[2]&8192)!=0)
#define backupdir2backroot_msg_only ((xflag[2]&16384)!=0)










backupdir2backroot::backupdir2backroot(BackCycle* parent_, context *main, workelem *info_, const mediadesc& mediaind_, exportstream_xmlp& infop, const location::tbackupid prev_backupid_) :
    BackCycle(parent_, info_),
    mediaindp(new mediadesc(mediaind_)),
    phase(fatalerror), 
    exportstream_infop(infop),
    prev_backupid(prev_backupid_),
    m_delist_sp(undoo::make_shared<direlemp_list_type>()),
    backup_already_exists(false)
{
    if(backupdir2backroot_msg) DB->msg("backupdir2backroot::backupdir2backroot constructor parent:%p, this:%p, stream:%s", parent, this, *mediaindp->to_xmlp()->simage());
    assert(parent != NULL);
    assert(mediaindp && mediaindp->valid());

    
    assert(m_delist_sp);

    
    if(exportstream_infop.isnull()) {
        
        const ustring filepath(mediaindp->getdirpath() / EXPORTSTREAM_METADATA_FILENAME);

        fileref datafile;
        if(initmediafileref(datafile, filepath)) {
            exportstream_infop = new exportstream_xml(datafile);
        }
    }

    
    
    if(exportstream_infop.isnull() || !exportstream_infop->valid()) {
        Out->msg(FATAL, "Specified backup directory media '%s' does not contain a valid backup", *mediaindp->to_xmlp()->simage());
    } else {
        bool fatal_error_during_ctor(true);

        
        
        if(info->use_container || flags.ddrenabled) {
            roothashflags original_backup_roothashflags;
            if(exportstream_infop->get_roothashflags(original_backup_roothashflags)) {
                const pidtype   original_backup_pid(pidtype(original_backup_roothashflags.plugin_num));
                const tddrindex original_backup_ddrindex(original_backup_roothashflags.ddrindex);

                if(original_backup_pid.kind() != pidtype::vcbimage) {
                    Out->msg(FATAL, "Specified backup is not a vmimage plugin created backup, can't perform replication restore to DD");
                } else if(original_backup_ddrindex <= 0) {
                    Out->msg(FATAL, "Specified backup was not originally on DD, can't perform replication restore to DD");
                } else {
                    fatal_error_during_ctor = false;
                }

                
                if(fatal_error_during_ctor) {
                    ubigint64 timestamp;
                    if(!exportstream_infop->get_snapup_timestamp(timestamp)) {
                        timestamp = 0;
                    }
                    const tbackupid backupid(timestamp);

                    DB->msg("backupdir2backroot::backupdir2backroot original backup info id:%s pid:%s ddr-index:%d",
                            *backupid.image(), *original_backup_pid.imagex(), original_backup_ddrindex);
                }
            }
        } else {
            fatal_error_during_ctor = false;
        }

        if(!fatal_error_during_ctor) {
            
            const ustring filepath(mediaindp->getdirpath() / CONTAINERSFILES_FILENAME);

            fileref datafile;
            if(initmediafileref(datafile, filepath) && containers.loadXmlBackupFileList(datafile)) {
                flags.dtoexportstream = true;
                
                phase = initial;
            } else {
                Out->msg(FATAL, "Specified backup directory media '%s' does not contain a valid containers list", *mediaindp->to_xmlp()->simage());
                
            }
        }
    }

    
    
    
    

    todoEnqueue(TODO_DIR, this);
}

backupdir2backroot::~backupdir2backroot()
{
    if(backupdir2backroot_msg)DB->msg("backupdir2backroot::~backupdir2backroot (parent:%p) (this:%p)", parent, this);
    
    
    mediaindp->teardown(false);
}

namespace {
    parsestream_ucontainer::container_map_type content_only_containers_map(const ddrfiles_xml& containers,
                                                                           const DIRELEMp dep,
                                                                           const emd_elementp container,
                                                                           const mediadesc& mediad)
    {
        parsestream_ucontainer::container_map_type ret;

        const ddrfiles_xml::emd_elementv emds(containers.queryFilesizeSortedEmds());
        for(ddrfiles_xml::emd_elementv::const_iterator it = emds.begin(); it != emds.end(); ++it) {
            if((*it)->content_only) {
                bool whole_container(false);
                const emd_elementp parentemd(containers.queryEmd(upath((*it)->gsanFullPath.get_dotdot()),
                                                                 dep->ignorecase(),
                                                                 whole_container));
                if(!parentemd.isnull() && parentemd->streamIndex == container->streamIndex) {
                    
                    mediadesc tmpmediad(mediad);

                    
                    tmpmediad.setpath(mediad.getdirpath() / (*it)->DDRFileName);

                    const ustring gsanfullpath((*it)->gsanFullPath);

                    
                    ret.insert(std::pair<ustring, mediadesc>(gsanfullpath, tmpmediad));
                }
            }
        }

        return ret;
    }
};

void backupdir2backroot::init()
{
    if(backupdir2backroot_msg) DB->msg("backupdir2backroot::init (parent:%p) (this:%p)", parent, this);

    if (phase == initial) {
        if(flags.restore_backup_createtime) {
            
            
            ubigint64 original_backup_create_time;
            if(exportstream_infop->get_snapup_timestamp(original_backup_create_time)) {
                
                utar_flags_info localflags;
                localflags.restore_after = localflags.restore_before = ustring();
                localflags.snapuptime    = original_backup_create_time;
                localflags.incpartials   = false;
                localflags.count         = 1;

                
                utar_flags_info dstflags;
                utar_commands utarcmds(localflags, getAdeMgr()->getHfsInfo(dpn0), dstflags);

                const exitcodes_t do_archives_ret(utarcmds.do_archives(true, true));

                if(do_archives_ret == EXIT_OK) {
                    
                    backup_already_exists = true;

                    Out->msg(INFO, "Backup already exists in account, nothing to do");

                    
                    notifyparent();

                    
                    
                    return;
                } else if(do_archives_ret == EXIT_NO_ARCHIVES) {
                    Out->msg(INFO, "Backup doesn't exists in account, performing restore replication to create backup");
                } else {
                    Out->msg(WARN, "Failed to determine if backup already exists in account, attempting backup creation");
                }
            } else {
                Out->msg(WARN, "Unable to check if replicated backup already exists, attempting backup creation");
            }
        }

        const ddrfiles_xml::emd_elementv emds(containers.queryFilesizeSortedEmds());
        for(ddrfiles_xml::emd_elementv::const_iterator it = emds.begin(); it != emds.end(); ++it) {
            
            
            if(!(*it)->content_only) {
                
                const ustring container1filepath(mediaindp->getdirpath() / (*it)->DDRFileName);

                fileref transport;
                if(initmediafileref(transport, container1filepath)) {
                    
                    const parsestream_ucontainer::container_map_type containers_map(content_only_containers_map(containers,
                                                                                                                info->direlemp,
                                                                                                                *it,
                                                                                                                *mediaindp));

                    parsestream_base *parser = new parsestream_ucontainer(transport,
                                                                          (*it)->streamType,
                                                                          containers_map);

                    
                    workelem *we = new workelem(info, info->direlemp->fullpath(), info->direlemp);

                    
                    if((*it)->gsanFullPath == UNDOO_DIRECTORY_NAME) {
                        we->use_container = false;
                        we->container     = 0;
                    }

                    const unsigned flags(backavpaxstream::flag_delete_parser | backavpaxstream::flag_use_cycles_location);
                    backavpaxstream *ucstream = new backavpaxstream(this, main, we, parser, 0, exportstream_infop, m_delist_sp, flags);

                    
                    todoEnqueueInsert(TODO_DIR, ucstream, 1);

                    nforked++;
                }
            }
        }

        
        
        phase = stream;
    } else if (phase == fatalerror) {
        
        notifyparent();
    } else {
        childdone(0);
    }
}

void backupdir2backroot::childdone(cycle *child)
{
    if(child) ncollected++;

    if(backupdir2backroot_msg) DB->msg("backupdir2backroot::childdone parent:%p this:%p child:%p nforked:%d ncollected:%d phase:%d", parent, this, child, nforked, ncollected, phase);

    switch (phase) {
    case initial:
    case listing:
        notifyparent();
        break;
    case stream:
        if(nforked == ncollected) {
            
            for(direlemp_list_type::iterator it = m_delist_sp->begin(); it != m_delist_sp->end(); ++it) {
                if((*it)->is_directory() && (*it)->name() == UNDOO_DIRECTORY_NAME) {
                    if(it != m_delist_sp->begin()) {
                        const DIRELEMp dep(*it);

                        m_delist_sp->erase(it);

                        m_delist_sp->insert(m_delist_sp->begin(), dep);
                    }
                    break;
                }
            }

            
            workelem *we = new workelem(info, info->direlemp->fullpath(), info->direlemp);
            backavpaxstream *ucstream = new backavpaxstream(this, main, we, 0, 0, exportstream_infop, m_delist_sp, backavpaxstream::flag_should_output_listing | backavpaxstream::flag_use_cycles_location);

            
            todoEnqueueInsert(TODO_DIR, ucstream, 1);

            nforked++;

            phase = listing;
        }
        break;
    default:
        assert(false); 
    }
}



bool backupdir2backroot::initmediafileref(fileref& fr, const ustring& filepath) const
{
    
    mediadesc tmpmediad(*mediaindp);

    
    tmpmediad.setpath(filepath);

    
    const bool ret(tmpmediad.init_fileref(fr, false));
    if(!ret) {
        Out->msg(ERR, "Error initializing input container for %s", *filepath);
    }

    return ret;
}
















#include "common.h"
#include "debug.h"
#include "tarpipe.h"
#include "output.h"
#include "avpx_ext.h"
#include "filenames.h"
#include "utar_flags_enums.h"
#include "utar_flags_info.h" 

#include <sys/types.h>

#define MINBLOCKSIZE 512

#define MAXPREFIX 155
#define MAXNAME 100


#define deb   ((xflag[11]&2048)!=0)

tarpipe::tarpipe(fileref data_,
                 const userid *uidmap_, const groupid *gidmap_, const ustring pathprefix_,
                 const int streamformat_, const int blocksize_,
                 const ustring changeblockmap_filepath )
  : pipe_control(data_, blocksize_ > MINBLOCKSIZE ? blocksize_ : MINBLOCKSIZE, streamformat_),
    extents(),
    uidmap(uidmap_),
    gidmap(gidmap_),
    pathprefix(pathprefix_),
    blocksize(blocksize_ > MINBLOCKSIZE ? blocksize_ : MINBLOCKSIZE),
    changemap(upath(changeblockmap_filepath)),
    filepath_for_extents(), nextextent(0),
    dont_output_pax_extended_header(false)
{
    if(blocksize < MINBLOCKSIZE) {
        Out->msg(ERR, "<7237>Invalid blocksize specified (%d), changed to %d", blocksize_, blocksize);
    }
    
    if(streamformat_ != utar_flags_enums::streamformat_avpax &&
       streamformat_ != utar_flags_enums::streamformat_none &&
       !pathprefix.isempty()) {
        Out->msg(INFO, "<7252>Generating %s stream blocksize %d to path \"%s\"", *utar_flags_info::streamformat_image(streamformat_).upper(), blocksize, *pathprefix);
    }
}



bool tarpipe::addfile(const DIRELEM& elem,
                      const ustring& path,
                      fileref& dataslice,
                      fileref& altdataslice,   
                      fileref& stubdataslice,  
                      fileref& gsanextentsdata,
                      const filetype ftype ,
                      const ustring& linkname ,
                      const fileoffset startoff 
                      )
{
    if (deb) DB->msg("tarpipe::addfile with gsanpath='%s'", *path);
    
    filepath_for_extents = ustring();
    extents.clear();
    nextextent = 0;
    

    
    bool is_xml;
    const upath extentsfilepath(changemap.find_mapping(upath(path), is_xml));

    const bool has_extents = (!gsanextentsdata.isnull() || !extentsfilepath.isempty());
    if (has_extents)
        Out->msg(INFO, "<12561>Processing extents for \"%s\"", *path);

    if (!gsanextentsdata.isnull()) {
        
        DB->msg("tarpipe::addfile parsing gsan extents data");
        extents = dataextents(gsanextentsdata, false);
        DB->msg("tarpipe::addfile: gsan extents.size()=%s", *::tostr(extents.size()));
    }

    
    if(!extentsfilepath.isempty()) {
        
        fileref data;

        
        const int waitsecs = 5;
        DB->msg("tarpipe::addfile opening extents file at '%s'", *extentsfilepath.image());
        for(int i=0; i<1440; i++) {
            data.initdisk(extentsfilepath.image());     
            if(!data.iserror() || !uapp::staging().canRun()) break;
            DB->msg(DBTXT("  could not open %s (attempt#%d), sleeping %d sec and trying again"), extentsfilepath.image().tostr(), i, waitsecs);
            threadbase::threadsleep(waitsecs * 1000);
        }

        if (data.iserror()) {
            Out->msg(ERR, "<10794>Unable to read extents file \"%s\"", *extentsfilepath.image());
        } else {
            dataextents userextents;
            DB->msg("tarpipe::addfile '%s' opened", *extentsfilepath.image());
            if (deb) data.hexdump(false, "userextents");
            if(userextents.parse("tarpipe::addfile", path, data, is_xml)) {
                
                
                
                if (userextents.size() > 0 && userextents.totalextentsize() > 0) {
                    Out->msg(INFO, 2, "<12562>Read extents file \"%s\" (%"Z"d entries)", *extentsfilepath.image(), userextents.size());
                    
                    combine_extents_intersection(userextents, upath(path));
                }
            } else {
                Out->msg(ERR, "<10795>Unable to parse extents file '%s'", *extentsfilepath.image());
            }
        }
    }

    
    if(has_extents)
        Out->msg(INFO, 2, "<12563>Final extents for \"%s\" (entries=%"Z"d, totalextentsize=%"LL"d, totalfilesize=%"LL"d)", 
                *path, extents.size(), extents.totalextentsize().value(), extents.totalfilesize().value());

    
    return pipe_control::addfile(elem, path, dataslice,
                                 altdataslice, stubdataslice,
                                 gsanextentsdata,
                                 ftype, linkname, startoff);
}







bool tarpipe::getnextextent(extent& e, fileoffset& off, const ustring path)
{


        if(nextextent < extents.size()) {
            
            off = 0;
            if(nextextent > 0) {
                for(size_t i = 0; i < nextextent; i++) {
                    off += extents[i].len;
                }
            }

            
            e = extents[nextextent++];
            return true;
        }




    return false;
}

bool tarpipe::combine_extents_intersection(const dataextents& newextents, const upath path) {
    DB->msg("tarpipe::combine_extents_intersection %s", *path.image());
    if(nextextent!=0) { assert(!"tarpipe::combine_extents_intersection called after nextextent already nonzero"); return false; }
    if (extents.size() > 0) {
        DB->msg("tarpipe::combine_extents_intersection: extents(%"Z"d entries) AND newextents(%"Z"d entries)", extents.size(), newextents.size());
        extents &= newextents;  
    } else {
        DB->msg("tarpipe::combine_extents_intersection: Setting extents to newextents(%"Z"d entries)", newextents.size());
        extents = newextents;
    }
    if (deb) {
        xml_messagep p = extents.xmlimage();
        Out->msg(INFO, "<12564>tarpipe::combine_extents_intersection extents list: %s", *p->simage());
    }
    return true;
}


void tarpipe::addstring(fileref& header, const ustring& s, int max) {
    const int count(std::min(s.bytelength(), max));

    for(int i = 0; i < count; i++) {
        header.appendbyte(s.byteindex(i));
    }

    int extra = max - count;
    assert(extra >= 0);
    if(extra > 0) {
        fileref zero = makezeros(extra);
        header.append(zero);
    }
}

void tarpipe::addxrec(fileref& header,
                      const ustring& keyword, const ustring& value) {
    const ustring keyword_value(ustring::sprintf(" %s=%s\n",
                                                 *keyword, *value));
    
    
    
    
    const ustring len1(ustring::sprintf("%d", keyword_value.bytelength() + 1));
    const ustring len2(ustring::sprintf("%d", keyword_value.bytelength() +
                                        len1.bytelength()));
    const ustring len3(ustring::sprintf("%d", keyword_value.bytelength() +
                                        len2.bytelength()));
    header.append(len3);
    header.append(keyword_value);
}

void tarpipe::addxrec(fileref& header,
                      const ustring& keyword, const ubigint64 value) {
    addxrec(header, keyword, tostr(value));
}

void tarpipe::addxrec(fileref& header,
                      const ustring& keyword, const fileref& value) {
    
    const size_t record_length(1 + keyword.bytelength() + 1 + value.size() + 1);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    const ustring len1(tostr(record_length + 1));
    const ustring len2(tostr(record_length + len1.bytelength()));
    const ustring len3(tostr(record_length + len2.bytelength()));
    header.append(len3);
    header.append(ustring(" ") + keyword + ustring("="));
    header.append(value);
    header.append(ustring("\n"));
}

bool tarpipe::addoctal(fileref& header, const ustring& path, const char *fieldname,
                       ubigint64 n, int max, const char appendvalue ) {

    
    
    const ubigint64 maxval = (ubigint64)1<<((max-1)*3);  
    if(n >= maxval)
       n = maxval-1;

    ustring format = ustring::sprintf("%%0%dllo", max-1);
    ustring field = ustring::sprintf(*format, n);
    if(field.bytelength() > max-1) {
        Out->msg(WARN, "<7696>%s=%"LL"d, overflows %d byte tar field, file not included in tar stream: %s", 
                 fieldname, n, max, *path);
        return false;
    }
    header.append(field);
    header.appendbyte(appendvalue);
    return true;
}

bool tarpipe::splitpath(const ustring& path, ustring& prefix, ustring& name) {
    if(path.bytelength() < MAXNAME) {
        prefix = "";
        name = path;
        return true;
    }
    int pos = 1;
    while(1) {
        int i = path.find(pos, '/');
        if(i == -1)
            break;
        if(i < MAXPREFIX && path.bytelength() - i < MAXNAME) {
            prefix = path.substr(0, i);
            name = path.substr(i+1);
            assert(prefix.bytelength() < MAXPREFIX);
            assert(name.bytelength() < MAXNAME);
            DB->msg("splitpath [%s] [%s]", *prefix, *name);
            return true;
        }
        pos = i + 1;
    }
    return false;
}



void tarpipe::pax_extended_header(const filetype ftype,
                                  const DIRELEM& elem,
                                  const ustring& path,
                                  const fileoffset& filesize,
                                  const ustring& uname, const ustring& gname,
                                  const ustring& linkpath,
                                  fileref& data) {
    
    fileref xdata;
    xdata.initlist(blocksize);

    addxrec(xdata, PAXKEY_CHARSET, "ISO-IR 10646 1993 UTF8");
    addxrec(xdata, PAXKEY_PATH, path);

    
    {
        fileref flatten;

        flatten.initlist(20 * DIRELEM_DOLAYOUT_AVERAGE_SIZE);
        elem.flatten(flatten, DIRELEM::flatten_nul);

        if(flatten.size() > 0) {
            addxrec(xdata, PAXKEY_FLATTENED_DIRELEM, flatten);
        }
    }

    
    if(extents.size() > 0) {
        fileref extents_image;

        extents_image.initlist();
        extents.image(extents_image);
        addxrec(xdata, PAXKEY_RESTOREDEXTENTS, extents_image);
    }

    
    if(ftype == NOFILTERREGTYPE &&
       (elem.supportsADS() || elem.is_macosx_file())) {
        addxrec(xdata, PAXKEY_UNFILTERED, 1);
    }

    
    
    {
        
        
        const upath pathobj(path, upath::kind_unix);
        const int nelems(pathobj.numelems());
        if(nelems > 0) {
            
            const ustring elemname(pathobj.get(nelems - 1));

            
            if(!elemname.isempty()) {
                addxrec(xdata, PAXKEY_OBJECTNAME, elemname);
            }
        }
    }

    if(!linkpath.isempty()) {
        addxrec(xdata, PAXKEY_LINKPATH, linkpath);
    }
    addxrec(xdata, PAXKEY_SIZE, filesize.value());
    if(!uname.isempty()) {
        addxrec(xdata, PAXKEY_UNAME, uname);
    }
    if(!gname.isempty()) {
        addxrec(xdata, PAXKEY_GNAME, gname);
    }

    
    if(elem.is_internal()) {
        const upath pathobj(path);

        if(!pathobj.isempty()) {
            const ustring firstelem(pathobj.get(0));
            
            
            const ubigint64 headflags((firstelem == UNDOO_DIRECTORY_NAME) ?
                                      PAX_HEADFLAGS_SYSINFO_OBJECT :
                                      PAX_HEADFLAGS_INTERNAL_OBJECT);
            addxrec(xdata, PAXKEY_HEADFLAGS, headflags);
        }
    }

    
    fileref xheader;
    xheader.initlist(blocksize);

    addstring(xheader, "././@PaxHeader", MAXNAME);           
    (void)addoctal(xheader, path, "mode", 0600, 8, ' ');     
    (void)addoctal(xheader, path, "uid", 0, 8, ' ');         
    (void)addoctal(xheader, path, "gid", 0, 8, ' ');         
    (void)addoctal(xheader, path, "size", xdata.size(), 12, ' '); 
    (void)addoctal(xheader, path, "mtime", 0, 12, ' ');      

    const int chksumoff = xheader.size();

    addstring(xheader, "        ", 8);               
    addstring(xheader, "x", 1);                      
    addstring(xheader, "", MAXNAME);                 
    addstring(xheader, "ustar", 6);                  
    addstring(xheader, "00", 2);                     
    addstring(xheader, uname, 32);                   
    addstring(xheader, gname, 32);                   
    (void)addoctal(xheader, path, "devmajor", 0, 8, ' '); 
    (void)addoctal(xheader, path, "devminor", 0, 8, ' '); 
    addstring(xheader, "", MAXPREFIX);               
    addstring(xheader, "", 12);                      
    if(xheader.size() != blocksize)
        DB->error("xheader size = %d", xheader.size());
    assert(xheader.size() == blocksize);

    
    
    unsigned short chksum = 0;
    char *p = xheader.start();
    for(int i = 0; i < blocksize; i++)
        chksum += (p[i]&0377);
    ustring chkstr = ustring::sprintf("%07o", chksum);
    fileref chkfile;
    chkfile.initlist(7);
    chkfile.append(chkstr);
    chkfile.appendbyte(' ');
    xheader.setslice(chksumoff, chkfile.size(), chkfile.start());

    
    data.setslice64(0, xheader, false);
    fillmyblock(data);

    
    data.setslice64(blocksize, xdata, false);
    fillmyblock(data);
}

void tarpipe::fillmyblock(fileref &fref)
{
    if(blocksize > 0) {
        const int cursize(fref.size());

        
        int extra = blocksize - (cursize % blocksize);
        if(extra == blocksize) {
            extra = 0;
        }
        if(extra > 0) {
            fileref zero = makezeros(extra);
            fref.setslice64(cursize, zero, false);
        }
        if(deb) DB->msg("tarpipe::fillmyblock curroffset:%d (extra:%d)", cursize, extra);
    }
}




bool tarpipe::lowfillheader(fileref& header,
                            const DIRELEM& elem, const ustring& path, const filetype ftype,
                            const fileoffset filesize, const ustring& linkname )
{
    
    
    if(deb) DB->msg("tarpipe::fillheader path [%s] length: %d",*path, path.bytelength());
    ustring realpath(upath(pathprefix/path).image("/"));  
    if (realpath.bytelength() > 100)
       DB->msg("realpath length: %d [%s]",realpath.bytelength(),realpath.tostr());
    
    const filetype ftype_to_output(ftype == NOFILTERREGTYPE ? REGTYPE : ftype);
    const ustring stype(ftype_to_output < 10 ? ustring::sprintf("%1d", ftype_to_output) : ustring::sprintf("%c", ftype_to_output));

    
    ustring pathprefix;
    ustring pathname;

    
    const ustring usrname(uidmap ? uidmap->lookup(elem.unix_uid()) : "");
    const ustring grpname(gidmap ? gidmap->lookup(elem.unix_gid()) : "");

    
    header.initlist(blocksize  + 2  + 1 );

    
    
    if(!dont_output_pax_extended_header &&
       (streamformat == utar_flags_enums::streamformat_pax ||
        streamformat == utar_flags_enums::streamformat_avpax)) {
        
        

        pax_extended_header(ftype, elem, realpath, filesize,
                            usrname, grpname, linkname,
                            header);
    }
    if(! splitpath(realpath, pathprefix, pathname)) {
        if(streamformat != utar_flags_enums::streamformat_pax &&
           streamformat != utar_flags_enums::streamformat_avpax) {
            Out->msg(WARN, "<5172>Path too long, file not included in tar stream: %s", *realpath);
            return false;
        } else {
            
            pathname = realpath;
            pathprefix = "";
        }
    }
    if(linkname.bytelength() >= MAXNAME) {
        if(streamformat != utar_flags_enums::streamformat_pax &&
           streamformat != utar_flags_enums::streamformat_avpax) {
            Out->msg(WARN, "<5173>Link path too long, file not included in tar stream: %s => %s", *realpath, *linkname);
            return false;
        }
    }

    fileref tarheader;
    
    
    tarheader.initlist(blocksize);

    addstring(tarheader, pathname, MAXNAME);           
    if(!addoctal(tarheader, realpath, "mode", elem.unix_mode(), 8))
        return false;
    int uid = elem.unix_uid();
    if(uid < 0) {
        Out->msg(WARN, "<5256>Invalid user id %d changed to 99: %s", uid, *realpath);
        uid = 99;
    }
    if(!addoctal(tarheader, realpath, "uid", uid, 8))
        return false;
    int gid = elem.unix_gid();
    if(gid < 0) {
        Out->msg(WARN, "<5257>Invalid group id %d changed to 99: %s", gid, *realpath);
        gid = 99;
    }
    if(!addoctal(tarheader, realpath, "gid", gid, 8))
        return false;
    if(!addoctal(tarheader, realpath, "size", filesize.value(), 12))
        return false;
    if(deb) DB->msg("Item size: %"LL"d", filesize.value());
    if(!addoctal(tarheader, realpath, "mtime", elem.mtime(), 12))
        return false;
    const int chksumoff = tarheader.size();
    addstring(tarheader, "        ", 8);               
    addstring(tarheader, stype, 1);                    
    addstring(tarheader, linkname, MAXNAME);           
    addstring(tarheader, "ustar", 6);                  
    addstring(tarheader, "00", 2);                     
    addstring(tarheader, usrname, 32);                 
    addstring(tarheader, grpname, 32);                 
    addstring(tarheader, "", 8);                       
    addstring(tarheader, "", 8);                       
    addstring(tarheader, pathprefix, MAXPREFIX);       
    addstring(tarheader, "", 12);                      
    if(tarheader.size() != blocksize)
        DB->error("tar header size = %d", header.size());
    assert(tarheader.size() == blocksize);

    unsigned short chksum = 0;
    char *p = tarheader.start();
    for(int i = 0; i < blocksize; i++)
        chksum += (p[i]&0377);
    ustring chkstr = ustring::sprintf("%06o", chksum);
    if(deb) DB->msg("chksum %d",chksum);
    fileref chkfile;
    chkfile.initlist(7);
    chkfile.append(chkstr);
    chkfile.appendbyte(0);
    tarheader.setslice(chksumoff, chkfile.size(), chkfile.start());

    header.setslice64(header.size(), tarheader, false);

    
    fillmyblock(header);
    return true;
}





bool tarpipe::fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                         const DIRELEM& elem,
                         const ustring& path,
                         const filetype ftype,
                         const ustring& linkname,
                         const fileoffset startoff
) {
    
    filesize = elem.file_size();
    if(ftype != REGTYPE && ftype != NOFILTERREGTYPE)
        filesize = fileoffset(0);

    if(extents.totalextentsize() > 0) {
      filesize = extents.totalextentsize();
      DB->msg("tarpipe::fillheader setting filesize to %s for %s", *filesize.image(), *path);
    }

    
    return lowfillheader(header, elem, path, ftype, filesize, linkname);
}








bool tarpipe::addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                     const fileoffset datasize, fileref& dataslice)
{
    bool ret(false);

    
    
    if(!dont_output_pax_extended_header) {
        dont_output_pax_extended_header = true;
    }

    if(deb) DB->msg(DBTXT("tarpipe::addobj() type: %d, path:'%s' size %"LL"d"),
                    otype, *path, datasize.value());

    fillblock_normal();   

    
    fileref header;
    if (lowfillheader(header, elem, path, otype, datasize)) {
        
        data.setslice64(curroffset, header, false);
        add_to_curroffset(header.size(), "header");

        
        
        dataslice.initslice6464(data, curroffset, datasize);
        add_to_curroffset(datasize, "data");

        
        dataslice.signalNtfsSourceToNonNtfsTarget(archive_unfiltered_data ? false : elem.supportsADS());

        
        dataslice.signalMacOSXSourceToNonMacOSXTarget(archive_unfiltered_data ? false : elem.is_macosx_file());

        ret = true;
    } else {
        DB->msg(DBTXT("tarpipe::addobj(%s) error making header"), *path);
    }

    if(deb) DB->msg("tarpipe::addobj(%s) curroffset:%s dataslice(off:%s size:%s) ret %d done",
                    *path, *curroffset.image(),
                    *dataslice.absoffset().image(), *tostr(dataslice.size64().value()),
                    ret);

    return ret;
}

#if !defined(BACKDUMPDIR_H_INCLUDED)
#define BACKDUMPDIR_H_INCLUDED












#include "cycle.h"
#include "dump_layout.h"
#include "dumpdirelem.h"

class DIRELEM;
class context;
class dumpDIRELEM;
class fileref;
class workelem;

class backdumpdir : public BackCycle

{
public:
    backdumpdir(BackCycle *parent, context *main, workelem *info,
                dumpDIRELEM* direlemp, direlem_assoc_type& inodeinfo,

                int traverse_depth = 0
    );

    virtual void init();

    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();

    virtual ~backdumpdir();

    SAFEPOOLALLOC(backdumpdir);
private:
    undoo::vector<DIRELEMp> de_listing;

    dumpDIRELEM* direlemp;
    direlem_assoc_type& inodeinfo;
    int          traverse_depth; 

    cycle *  datachild;
    ustring  path;



    ustring spaces;

  
  
    fileref build_dirblock(fileoffset& dirsize);

};

#endif

#if !defined(NBACKDATA_H_INCLUDED)
#define NBACKDATA_H_INCLUDED















#include <memory>
#include "cycle.h"

class dircontext;
class fileref;
class workelem;
class parsestream_base;

enum nbackdata_depkind { none, 
                         emctar_altdata, 
                         emctar_stubdata,
                         emctar_dedup,
                         do_not_set_hash }; 

class nbackdata : public BackCycle  {
public:
    friend class dircontext;

    
    nbackdata(BackCycle *parent,
              workelem *info,
              fileoffset offset,
              bool isdir,
              parsestream_base *parser = 0,
              const bool use_container = false);
    nbackdata(BackCycle *parent,
              workelem *info,
              nbackdata_depkind depkind,
              parsestream_base *parser,
              const bool use_container = false);
    
    virtual void init();

    virtual void notifyparent();   

    virtual void childdone(cycle *child);

    virtual ~nbackdata();

    nbackdata_depkind get_depkind() const { return depkind; }

    SAFEPOOLALLOC(nbackdata);
private:
    parsestream_base *parser;
    bool inlookup;
    fileref data;
    const nbackdata_depkind depkind;
    const bool isdir;
    const bool use_container;
};

#endif

#if !defined(BACKAXIONFSDIR_H_INCLUDED)
#define BACKAXIONFSDIR_H_INCLUDED












#include "cycle.h"

#include "axionfsdirelem.h"


class context;
class axionfsDIRELEM;
class fileref;
class workelem;

class backaxionfsdir : public BackCycle
{
public:
    backaxionfsdir(BackCycle *parent, context *main, workelem *info,
                   axionfsDIRELEM* direlemp, 
                   fileoffset   offset,
                   int traverse_depth = 0);
    
    virtual void init();
    
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();
    
    virtual ~backaxionfsdir();
    
    SAFEPOOLALLOC(backaxionfsdir);
 private:
    axionfsDIRELEM *direlemp;
    
    int            traverse_depth; 
    
    fileref  listing;
    cycle    *datachild;
    ustring  path;
    
    fileoffset sizeofchildren;  
    
    ustring spaces;
};

#endif



#if !defined(backndmptardir_base_H_INCLUDED)
#define backndmptardir_base_H_INCLUDED












#include "fileref.h"
#include "scalar.h"
#include "cycle.h"
#include "direlem.h"
#include "fileoffset.h"
#include "histmap.h"
#include "dataextents.h"
#include "ade_backup.h"
#include "backdataconsumer.h"
#include "inode_table.h"
#include "composite_to_direlemp.h"
#include "MetadataStore.h"

class cycle;
class workelem;
class utar_flags_info;
class upath;
class filemem;
class parsestream_base;
class inode_table;
class emctar_history;


class backndmptardir_base : public BackCycle,
                            public nsAdeLib::ADEBackup,   
                            public backdataconsumer::producer
{

public:
  SAFEALLOC(backndmptardir_base);

  
  
  
  
  backndmptardir_base(BackCycle* parent_,
                      workelem *info_,
                      parsestream_base *parser,
                      int traverse_depth,
                      inode_table &inodetab_,
                      int mount_point_numelems = 0,
                      MetadataIntf_sp parent_metadataIntfp_ = MetadataIntf_sp());

  virtual ~backndmptardir_base();

  virtual void init() = 0;
  virtual void response(message& outargs) = 0;  
  virtual void childdone(cycle *child) = 0;

  
  fileref nextdatablock(bool &suppress_requeue);  

private:
  backndmptardir_base(); 

public:
  
  
  virtual void determine_volume_offset();  
  virtual void add_directory_to_container();  

  
  virtual bool open_metastore_directory_entry();  
  virtual bool add_directory_to_metastore(DIRELEMp obj_direlem);  
  virtual bool add_item_to_metastore(DIRELEMp obj_direlem);  
  virtual bool add_children_to_metastore();  

  virtual void notifyparent();  

  virtual void set_phase(int phasenum, bool force_history_request = false);
  virtual void check_delta_size(const DIRELEMp cur, const fileref& listing, fileoffset &prev_size);  

  
  virtual void send_max_changed_date();  
  virtual bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata) = 0;  
  virtual void process_direlem(DIRELEMp  obj_direlem, fileref  altdata, fileref  stubdata) = 0;  
  virtual void insert_self(DIRELEMp obj_direlem);  

  
  virtual bool set_new_direlem_path(DIRELEMp &obj_direlem, bool pushed_entry);  

  
#if CELERRA_CMR10
  virtual bool isstubemctardedup(const fileref& stubdata);  
#endif

  virtual void process_dir_data(DIRELEMp obj_direlem);  

  
  virtual void process_wait_phases(const int hist_count);  
  virtual void process_forksdone_phase_part1(inode_table::synth_list_cur *cur_listp,
                                             inode_table::synth_list_prev *prev_listp);  
  virtual void process_forksdone_phase_part2(cycle *child_cycle,
                                             inode_table::synth_list_cur *cur_listp,
                                             inode_table::synth_list_prev *prev_listp);  
  virtual void process_do_hidden_phase();  
  virtual void final_childdone();

  
  virtual void update_stats_counts(const DIRELEMp &de) const;  

  
  virtual void add_to_direlem_commitment(int count)
      { total_direlem_commitment += count; cycle_direlem_commitment += count; }
  virtual void subtract_from_direlem_commitment(int count)
      { total_direlem_commitment -= count; cycle_direlem_commitment -= count; }
  
  
  virtual bool throttle_prevlist_requests();
  
  
  virtual bool throttle_child_spawning();

  virtual void request_prevlist() = 0;  
  virtual void request_history() = 0;   
  virtual void removesnapviewvolumes(const ustring ndmp_prefix); 
  virtual bool merge_lists() = 0;       

  
  
  
  virtual void add_to_prev_synth_list(const DIRELEMp &prevDE,
                                      inode_table::synth_list_prev* prev_synthlistp,
                                      inode_table::child_dir_list* childlistp);

  
  
  
  
  
  
  virtual void synth_block(const ubigint64 &block_begin,
                           const bigint64 &block_size,
                           const tchecksum::tchecksumval &block_checksum,
                           const ubigint64 &inode_number,
                           const ubigint64 &dir_header_size,
                           const bool base_container);

  
  
  
  virtual void merge_synth_lists(const inode_table::synth_list_cur* cur_listp,
                                 const inode_table::synth_list_prev* prev_listp,
                                 const bool footer_present,
                                 const ubigint64 inode_being_processed,
                                 const ubigint64 top_level_inode);

  
  virtual void copy_previous_backup(inode_table::synth_list_prev *prev_synthlistp,
                                    inode_table::child_dir_list *childlistp);
  virtual void debug_print_direlemp_list(composite_to_direlemp_table &list, const ustring &msg, bool shoulddump);

  
  
  virtual void add_dir_header_to_synth_list(inode_table::synth_list_cur* cur_synthlistp);
  virtual void add_files_to_synth_list(inode_table::synth_list_cur* cur_synthlistp);

  
  
  
  
  
  virtual void synth_volume_data(cycle *childconst,
                                 const inode_table::synth_list_cur* cur_synthlistp,
                                 const inode_table::synth_list_prev* prev_synthlistp);

  
  
  
  virtual void dump_synth_lists(const inode_table::synth_list_cur* cur_synthlistp,
                                 const inode_table::synth_list_prev* prev_synthlistp);

  
  
  
  
  
  
  virtual void save_location_template(const location &prev_loc, const bool base_container);

  virtual fileoffset emctar_file_hash_size(const DIRELEM &de);  

  virtual void finish_top_level_directory(cycle *child) = 0;
  virtual void commit_directory_metadata() = 0;

  enum phases { phase_init              = 0,  
                phase_read_data         = 1,  
                phase_wait_for_history  = 2,  
                                              
                phase_wait_for_children = 3,  
                                              
                                              
                phase_forksdone         = 4,  
                phase_do_hidden         = 5,  
                phase_done              = 6   
              };

  virtual ustring phase_image()
  {
      switch(phase) {
      case phase_init:              return "phase_init"; break;
      case phase_read_data:         return "phase_read_data"; break;
      case phase_wait_for_history:  return "phase_wait_for_history"; break;
      case phase_wait_for_children: return "phase_wait_for_children"; break;
      case phase_forksdone:         return "phase_forkdone"; break;
      case phase_do_hidden:         return "phase_do_hidden"; break;
      case phase_done:              return "phase_done"; break;
      default:                      return "unknown"; break;
      };
  }

  parsestream_base *parser;        
  int traverse_depth;              
  bool reserved_hiddendir;         
  int mount_point_numelems;        
  int phase;                       
  bool forked_prev_restore;        
  composite_to_direlemp_table curlist;   
  size_t dirlistcount;             
  composite_to_direlemp_table prevlist;  

  bool foundhistory;

  fileoffset emctarstreamoffset;   
  int historyrequests;             

  
  
  
  inode_table &inodetab;

  cycle *data_hasher_child;
  DataHasher dataHasher;

  DIRELEMp save_obj_direlem;  
  fileref save_altdata;
  fileref save_stubdata;

  inode_table::child_dir_list childlist;  
                                          

  
  
  bool inode_is_64_bits;

  
  static bool max_changed_date_msg_sent;

  
  
  
  
  
  
  
  
  static bool ddr_checksums_enabled;

  
  bool catalog_enabled;
  MetadataStore *metadatastorep;         
  MetadataIntf_sp parent_metadataIntfp;  
  MetadataIntf_sp my_metadataIntfp;      

  
  
  
  
  
  
  
  
  
  
  
  typedef DEFINE_STL_MAP_TYPE( DIRELEMp, MetadataIntf_sp ) DIRELEMp2metadataIntfp;
  typedef DIRELEMp2metadataIntfp::iterator direlemp2metadatap_iterator;

  
  DIRELEMp2metadataIntfp direlemp2metadatap;

  
  
  direlemp2metadatap_iterator direlemp2metadatap_entry;

  
  
  
  
  
  
  static int total_direlem_commitment;
  
  
  
  int cycle_direlem_commitment;
  
  
  int child_dir_count;
  
  bool child_spawning_paused;
  
  #define bytes_per_direlem 700

  
  
  
  
  
  
  
  
  fileoffset cur_synthlist_offset;
  fileoffset cur_synthlist_coversize;
  tchecksum::tchecksumval cur_synthlist_checksum;

  
  
  inode_table::data_block top_level_footer;

  
  
  inode_table::synth_list_cur cur_synthlist;

  
  
  inode_table::synth_list_prev prev_synthlist;

  
  
  
  bool dir_header_added;

  
  DIRELEMp prev_sysinfo;

  
  
  
  bool copy_entire_previous_backup;

  
  
  
  fileoffset merged_coverage_size;

  
  
  
  
  tchecksum::tchecksumval merged_checksum;

  
  ustring path_to_temp_container;

  
  
  
  
  
  
  
  
  
  
  
  std::vector<DIRELEMp> ordered_curlist;
  unsigned int ordered_curlist_index;
  std::vector<DIRELEMp> ordered_prevlist;
  unsigned int ordered_prevlist_index;
};

#endif

#if !defined(REPLDATA_H_INCLUDED)
#define REPLDATA_H_INCLUDED












#include "cycle.h"
#include "hashcode.h"
#include "fileref.h"
#include "chunktype.h"
#include "replroot.h"


class repldata : public replcycle {
public:
    repldata(replcycle *parent, const hashcode& hash, const int sliceoff,
             const bool can_cancel, const double rsize, const ustring& name,
             chunktype ctype, const epoch_t filetime, const int traverse_depth,
             workelem* info, cycle* starter, const bool destroy_workelem=false,
             bool search_sysinfo=false, replroot* rootcycle=NULL);
    static void report();
    virtual void init();
    void response(message& outargs);
    void childdone(cycle *child);
    virtual ~repldata();
    SAFEPOOLALLOC(repldata);
private:
    hashcode rhash;
    const hashcode oldhash;
    const bool can_cancel;
    const double rsize;
    const ustring name;
    chunktype ctype;
    const epoch_t filetime;
    const int traverse_depth;

    int phase;
    fileref data;
    double starttime;
    int redocount;
    const bool destroy_workelem;  
    int composit_size;

    void show_data(fileref &data, const ustring &msg, hashcode &computed_hash);
    void send_get_data(hashcode &hash);
    bool search_sysinfo;
    replroot* rootcycle;
    const int sysinfo_comp_off;
};



class replreportdata : public replcycle {
public:
    replreportdata(replcycle *parent, const hashcode& hash, const int sliceoff,
                   const bool can_cancel, const double rsize, const ustring& name,
                   chunktype ctype, const epoch_t filetime, const int traverse_depth,
                   workelem* info, bool destroy_workelem=false);
    static void report();
    virtual void init();
    void response(message& outargs);
    void childdone(cycle *child);

    virtual ~replreportdata();
    SAFEPOOLALLOC(replreportdata);
private:
    hashcode rhash;
    const bool can_cancel;
    const double rsize;
    const ustring name;
    chunktype ctype;
    const epoch_t filetime;
    const int traverse_depth;

    int phase;
    fileref data;
    double starttime;
    int redocount;
    int childcount;
    bool ghi_available;
    const bool destroy_workelem;  

    void show_data(fileref &data, const ustring &msg, hashcode &computed_hash);
    void send_get_data(hashcode &hash);
};
#endif

#if !defined(RESTDEPHASH_H_INCLUDED)
#define RESTDEPHASH_H_INCLUDED












#include "restnofilter.h"
#include "restelem.h"
#include "chunktype.h"
#include "fileoffset.h"

class direlem;

class restdephash : public restnofilter {
public:
    
    restdephash(bicycle         *parent,
                const hashcode&  hash,
                DIRELEM&         direlem,
                cycle           *starter = 0
                );

    
    virtual void childdone(cycle *child);

    
    virtual ~restdephash();

    SAFEPOOLALLOC(restdephash);
private:
};

#endif


#if !defined(BACKAXIONFS_H_INCLUDED)
#define BACKAXIONFS_H_INCLUDED












#include "common.h"
#include "axionfsdirelem.h"
#include "fileref.h"
#include "scalar.h"
#include "cycle.h"
#include "fileoffset.h"


class context;
class cycle;


 
class backaxionfs : public cycle
{

 public:
    SAFEALLOC(backaxionfs);

    backaxionfs(context *main_);
    virtual ~backaxionfs();

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();

    
    
    axionfsDIRELEM *lookup(const upath &p, bool &ismetadata);

    
    
    void set_account_path(const ustring &p);
    ustring get_account_path() const;

    
    
    
    void purge();

 private:
    context *main;

    axionfsDIRELEM *rootdirelem; 
    ustring overrideacntpath;
};


#endif












































































































































#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backemctardir6.h"
#include "backavpaxobj.h"
#include "parsestream_base.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "dirrec_pack.h"
#include "filenames.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "restdata.h"     

#include "streambuffer.h"            
#include "streamtransformemctardedup.h" 

#include "ndmp_volume_entification.h"

#include "emctarstream.h"
#include "backdirstreamslice.h"
#include "hash_cache.h"
#include "backstate.h"
#include "data_regions.h"
#include "utar_ctl_sup.h"

#include <algorithm>




#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define verbosealternative ((xflag[1]&16384)!=0) 

#define doaddhardlinkstoinodetabearly ((xflag[15]&4194304)!=0) 

tassoc<backemctardir6::uintobj, ustring> backemctardir6::needhardlinkvalues; 









backemctardir6::backemctardir6(BackCycle* parent_,
                               workelem *info_,
                               parsestream_base *parser_,
                               int traverse_depth_,
                               inode_table &inodetab_,
                               int mount_point_numelems_,
                               ndmp_history *hist ,
                               MetadataIntf_sp parent_metadataIntfp_ )
    : backndmptardir_base(parent_, info_, parser_, traverse_depth_,
                          inodetab_, mount_point_numelems_, parent_metadataIntfp_),
                          parent_backemctardir6p(NULL),
                          my_childlistp(NULL),
                          my_cur_synthlistp(NULL),
                          my_prev_synthlistp(NULL),
                          cur_synthlist_tag_index(0),
                          parentinode(0),
                          histsrv(hist),
                          nhistchildren(0),
                          merge_success(false)
{
    if(msg1) DB->msg("backemctardir6::backemctardir6 constructor (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    prevlist_iter.init_cycle_pointer(this);

    
    inode_is_64_bits = false;
    fake_offset = -2;
    undefined_offset = -1;

    
    if (traverse_depth == 0) {
        if (!flags.ndmp_history_pipe_name.isempty()) {
            
            assert(histsrv == NULL);
            histsrv = new ndmp_history(main, upath(flags.ndmp_history_pipe_name), upath(flags.save_ndmp_history));
            DB->msg("backemctardir6::backemctardir6() started ndmp_history");
        }

        if (info->use_container) {
            
            determine_volume_offset();
        }
    }

    
    if (info->use_container) {
        if (info->direlemp->is_directory()) {
            

            
            
            
            add_directory_to_container();

            
            
            
            
            
            
            
            
            
            
            
            
            beginning_dir_offset = info->direlemp->get_location().get_abs_offset_in_container();

            
            
            parent_backemctardir6p = dynamic_cast<backemctardir6 *>(parent);
            if (parent_backemctardir6p != NULL) {
                
                
                if (msg2) DB->msg("backemctardir6::backemctardir6: dynamic cast of parent succeeded; parent is a backemctardir6 cycle");

                
                parent_backemctardir6p->offset2lists.insert(std::make_pair(beginning_dir_offset, offset2lists_entry()));
                if (msg2) DB->msg("backemctardir6::backemctardir6: Created entry in offset-to-lists map for subdir. Offset=%"LL"d, Map size=%d",
                                  beginning_dir_offset.value(), (int)parent_backemctardir6p->offset2lists.size());

                
                
                my_offset2lists_entry = parent_backemctardir6p->offset2lists.find(beginning_dir_offset);
            } else {
                if (msg2) DB->msg("backemctardir6::backemctardir6: dynamic cast of parent failed; parent is not a backemctardir6 cycle");
            }

        } else {
            parent_backemctardir6p = NULL;

            
            
            
            
            
            
            
            

            
            fileoffset fake_offset(-1);
            offset2lists.insert(std::make_pair(fake_offset, offset2lists_entry()));
            if (msg2) DB->msg("backemctardir6::backemctardir6: Created entry in offset-to-lists map for top-level backemctardir6. Offset=%"LL"d, Map size=%d",
                              fake_offset.value(), (int)offset2lists.size());

            
            my_offset2lists_entry = offset2lists.find(fake_offset);
        }
        
        my_childlistp = &(my_offset2lists_entry->second.childlist);
        my_cur_synthlistp = &(my_offset2lists_entry->second.cur_synthlist);
        my_prev_synthlistp = &(my_offset2lists_entry->second.prev_synthlist);
    }

    
    
    
    
    if (catalog_enabled && info->direlemp->is_directory()) {
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'", *info->direlemp->fullpath().image());
            return;
        }
    }

    if (info->direlemp->is_directory()) {
        process_dir_data(info->direlemp);
    }

    
    
    
    insert_self(save_obj_direlem);
}


backemctardir6::~backemctardir6()
{
    if(msg1) DB->msg("backemctardir6::~backemctardir6 destructor (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    subtract_from_direlem_commitment(cycle_direlem_commitment);

    if (traverse_depth == 0 && histsrv != NULL) {
        
        delete histsrv;
    }
}








void backemctardir6::init()
{
    assert(info!=NULL);
    static int count;
    ++count;
    if(msg1 || (count%1000) == 0)
        DB->msg("backemctardir6::init cnt=%d (parent:%p) (this:%p), depth=%d info->direlemp:%s",
                count, parent, this, traverse_depth, *info->direlemp->fullpath().image());

    if (phase != phase_init) {
        
        

        if (info->use_container && !save_obj_direlem->is_directory()) {
            ucontainer::errortype errcode;
            if ((errcode = info->container->endfile(save_obj_direlem.getimpl(),0)) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->Abort("Problem creating container endfile for %s (%s)",
                        *save_obj_direlem->fullpath().image(), *errdesc);
                return;
            } else if (flags.incremental) {
                location loc(save_obj_direlem->get_location());

                
                
                
                
                
                
                if (cur_synthlist_coversize == 0) {
                    cur_synthlist_offset = loc.get_abs_offset_in_container();
                    if (msg2) DB->msg("backemctardir6::init: Reset cur_synthlist_offset to abs_offset_in_container (offset:%"LL"d)",
                                      cur_synthlist_offset.value());
                }

                
                
                
                
                
                cur_synthlist_coversize += loc.get_coverage_size();
                cur_synthlist_checksum ^= loc.get_checksum().value;  
                if (msg2) DB->msg("backemctardir6::init: cur_synthlist (offset:%"LL"d coversize:%"LL"d checksum:%u)",
                                  cur_synthlist_offset.value(), cur_synthlist_coversize.value(), cur_synthlist_checksum);
                
                offset2checksum[(ubigint64)loc.get_abs_offset_in_container().value()] = loc.get_checksum().value;
                if (msg2) DB->msg("backemctardir6::init: offset2checksum entry (offset:%"LL"d  checksum:%u  table size:%d",
                                  loc.get_abs_offset_in_container().value(), loc.get_checksum().value, (int)offset2checksum.size());
            }
        }
    }

    
    
    if(!get_next_header(save_obj_direlem, save_altdata, save_stubdata)) {
        
        
        

        
        
        
        
        if (info->use_container && (inodetab.current_container_location.get_containerid() == 0)) {
            save_location_template(info->direlemp->get_location(), false );
        }

        if (info->use_container && info->direlemp->is_directory() && !reserved_hiddendir) {
            
            
            

            if (flags.incremental) {
                
                add_files_to_synth_list(my_cur_synthlistp);
                if (msg2) DB->msg("backemctardir6::init: cur_synthlist (offset:%"LL"d coversize:%"LL"d)",
                                  cur_synthlist_offset.value(), cur_synthlist_coversize.value());
            }

            
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->Abort("Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *errdesc);
                return;
            }

            if (msg2) DB->msg("DDR: backemctardir6::init DIR LOCATION %s is %s",
                           *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());

            if (flags.incremental) {
                
                
                
                
                
                
                
                
                
                
                if (!dir_header_added) {
                    
                    add_dir_header_to_synth_list(my_cur_synthlistp);
                    
                    
                }

                
                inode_table::data_block synth_item;
                
                location loc(info->direlemp->get_location());
                
                
                synth_item.block_begin = (ubigint64)(loc.get_abs_offset_in_container() + loc.get_coverage_size() - loc.get_footer_size()).value();
                synth_item.block_size = (bigint64)loc.get_footer_size().value();
                synth_item.block_checksum = loc.get_checksum().footer_value;
                my_cur_synthlistp->add_item(synth_item);
                if (msg2) DB->msg("backemctardir6::init Added entry (footer for '%s') to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                                  *info->direlemp->name(), synth_item.block_begin, synth_item.block_size, (ubigint64)my_cur_synthlistp->list_size());
            }
        }  

        return;
    }
    

    assert(phase==phase_init || phase==phase_read_data);
    set_phase(phase_read_data);

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *save_obj_direlem->name(), save_obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *save_obj_direlem->name(), save_obj_direlem->file_size().dvalue());

    process_direlem(save_obj_direlem, save_altdata, save_stubdata);

    
    insert_self(save_obj_direlem);
}





bool backemctardir6::get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata) {
    
    
    
    
    
    
    
    

    
    altdata = fileref::empty;
    stubdata = fileref::empty;

    
    
    bool pushed_entry, have_entry;
    pushed_entry = have_entry = parser->pop_entry(obj_direlem, altdata, stubdata);

    
    if (!have_entry) {
        have_entry = parser->getentry(obj_direlem, altdata, stubdata);

        
        
        if (!have_entry && !max_changed_date_msg_sent) {
            send_max_changed_date();
        }
    }

    
    if (!have_entry || obj_direlem.isnull()) {
        
        

        
        
        if (flags.incremental && (phase == phase_init) && parser->is_empty_stream()) {
            const upath parent_path("");
            DB->msg("backemctardir6::get_next_header empty stream reading previous backup path for parent '%s'", *parent_path.image());
            
            location prev_loc(inodetab.base_container_location);
            prev_loc.set_abs_offset_in_container(0);

            
            
            
            
            
            
            
            prev_loc.set_containerid(0);
            prev_loc.set_enclosing_container(NULL);  

            cycle *child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, prev_loc, prevlist);
            child->noop();
            nforked++;
            forked_prev_restore = true;
        }

        set_phase(phase_wait_for_history, true ); 
        childdone(NULL);

        
        
        if ((NULL != histsrv) && (traverse_depth == 0))
            histsrv->data_stream_done(); 

        return false;
    }

    if (!set_new_direlem_path(obj_direlem, pushed_entry)) return false;

    
    
    if (obj_direlem->name().isempty()) {   
        Out->msg(ERR, "<7397>Illegal tar record found, name field is empty at streamoffset:%s.", *parser->get_headeroffset().image());
        
        
        insert_self(obj_direlem);
        return false;
    }

    const upath curpath(info->direlemp->fullpath());
    const int   cur_path_elems(curpath.numelems()); 
    const upath newpath(obj_direlem->fullpath());
    const int   new_path_elems(newpath.numelems());    

    if(msg2)
        DB->msg("backemctardir6::get_next_header cur_path_elems:%d(%s)[0]='%s' new_path_elems:%d(%s)[0]='%s' curroffset:%s",
                cur_path_elems, *curpath.image(), *curpath.get(0),
                new_path_elems, *newpath.image(), *newpath.get(0),
                *parser->get_headeroffset().image());

    
    
    
    
    if (new_path_elems > cur_path_elems+1) {
        assert(stubdata.isnull());
        if (msg1) DB->msg("backemctardir6::get_next_header big step '%s' vs '%s' new_path_elems:%d cur_path_elems+1:%d",
                          *curpath.image(), *newpath.image(), new_path_elems, cur_path_elems+1);

        
        
        
        
        
        
        
        

        assert(obj_direlem->is_directory()); 

        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        

        
        altdata = fileref::empty;
        
        obj_direlem->set_security(fileref::empty);

        
        obj_direlem->set_fullpath(newpath.slice(0, cur_path_elems));
        obj_direlem->set_name(obj_direlem->fullpath().stripdir());
        obj_direlem->set_is_root();  
        if (msg1) DB->msg("backemctardir6::get_next_header big step new path '%s' name '%s'", *obj_direlem->fullpath().image(), *obj_direlem->name());
    }

    
    
    if (new_path_elems <= cur_path_elems) {
        if(msg2)DB->msg("backemctardir6::get_next_header exiting2 because path is in parent (%d <= %d) '%s'",
                        new_path_elems, cur_path_elems, *obj_direlem->fullpath().image());
        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_wait_for_history, true ); 
        childdone(NULL);
        return false;
    }

    if (msg2) DB->msg("backemctardir6::get_next_header returns obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                      *obj_direlem->fullpath().image(), *obj_direlem->file_size().image(), *altdata.size64().image(), *stubdata.size64().image());
    return true;
}


void backemctardir6::process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata) {

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *obj_direlem->name(), obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *obj_direlem->name(), obj_direlem->file_size().dvalue());

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)DB->msg("backemctardir6::process_direlem obj_direlem1:%s dir:%d file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), obj_direlem->is_directory(), *datasize.image(), *altdata.size64().image(), *stubdata.size64().image());

    fileoffset patchoffset = 1;  

    
    
    if (info->use_container && !dir_header_added && flags.incremental && info->direlemp->is_directory()) {
        
        
        
        add_dir_header_to_synth_list(my_cur_synthlistp);
        
        
    }

    if (info->use_container && !obj_direlem->is_directory()) {
        
        ucontainer::errortype errcode;
        if ((errcode = info->container->beginfile(obj_direlem.getimpl(), datasize, 1 )) != ucontainer::pce__success) {
            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
            Out->Abort("Problem creating container beginfile for %s (%s)",
                    *obj_direlem->fullpath().image(), *errdesc);
            return;
        } else {
            if (msg2) DB->msg("DDR: beginfile (abs_offset_in_container: %"LL"d, file: %s)",
                              obj_direlem->get_location().get_abs_offset_in_container().value(),
                              *obj_direlem->fullpath().image());
        }
    }

    
    
    
    if (!obj_direlem->is_tar_hardlink()) {
        
        bool added = curlist.split_enter_if_undef(parser->get_headeroffset().value(), "", obj_direlem);
        if (!added) {
            Out->msg(ERR, "<9979>While processing %s (inode %d) found a second entry with name '%s'",
                     *info->direlemp->fullpath().image(), info->direlemp->inode_number(), *parser->get_headeroffset().image());
        } else {
            
            ordered_curlist.push_back(obj_direlem);
        }
        if(msg2)
            DB->msg("backemctardir6::process_direlem curlist.enter_if_undef('%s', '%s')",
                    *parser->get_headeroffset().image(), *obj_direlem->fullpath().image());

    } else {
        
        
        
        hardlinknames.push_back(obj_direlem->name());
        
        bool added = curlist.split_enter_if_undef(undefined_offset, obj_direlem->name(), obj_direlem);
        if (!added) {
            Out->msg(ERR, "<9979>While processing %s (inode %d) found a second entry with name '%s'",
                     *info->direlemp->fullpath().image(), info->direlemp->inode_number(), *obj_direlem->name());
        } else {
            
            ordered_curlist.push_back(obj_direlem);
        }
        if (msg2) DB->msg("backemctardir6::process_direlem curlist.enter_if_undef('%s', '%s') for hardlink",
                                *obj_direlem->name(), *obj_direlem->fullpath().image());
    }

    
    
    nhistchildren++;
    if (msg2)
        DB->msg("backemctardir6::process_direlem %p %s nhistchildren %d",
                this, *obj_direlem->name(), nhistchildren);

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    
    if (obj_direlem->is_directory()) {
        
        child_dir_count++;
        
        

        
        
        unsigned int dir_tag_index(0);
        if (info->use_container && flags.incremental) {
            
            add_files_to_synth_list(my_cur_synthlistp);
            
            

            
            
            
            
            
            
            
            
            
            
            dir_tag_index = (unsigned int)my_cur_synthlistp->list_size();
            inode_table::data_block synth_item;
            synth_item.block_begin = dir_tag_index;
            synth_item.block_size = inode_table::dir_placeholder_tag;
            synth_item.block_checksum = 0;  
            my_cur_synthlistp->add_item(synth_item);
            if (msg2) DB->msg("backemctardir6::process_direlem Added directory '%s' to cur_synthlist within '%s' (block_begin:%"LL"d block_size:%"LL"d)",
                              *obj_direlem->name(), *info->direlemp->name(), synth_item.block_begin, synth_item.block_size);
        }

        
        
        if (msg2) DB->msg("backemctardir6::process_direlem subdir for %s", *obj_direlem->fullpath().image());

        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        backemctardir6 *subdir = new backemctardir6(this, w, parser, traverse_depth+1,
                                                    inodetab, mount_point_numelems, histsrv,
                                                    my_metadataIntfp);

        if (info->use_container && flags.incremental) {
            
            
            
            
            
            
            
            
            

            
            subdir->cur_synthlist_tag_index = dir_tag_index;
        }

        subdir->noop();
        nforked++;

    
    } else if (obj_direlem->is_symlink() && datasize == 0) {
        
        
        fileref link = parser->get_symlink_data();
        assert(!link.isnull());
        datasize = link.size();
        obj_direlem->set_file_size(datasize);

        if(msg2)DB->msg("Handling inline symlink, size=%d", datasize.ivalue());
        workelem *w = new workelem( info, link );
        cycle *linkchild = new nbackdata(this, w, patchoffset, false , 0, info->use_container );
        linkchild->noop();
        nforked++;

    } else {
        
        if (msg2) DB->msg("Streamslice mode file, size=%"LL"d truncate?%d", datasize.value(), false); 

       
        
        
        
        

        
        obj_direlem->set_stdin();       

        
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);

        if (obj_direlem->is_tar_hardlink()) {
            if (msg2)
                DB->msg("backemctardir6::process_direlem this:%p obj_direlem:%s is_tar_hardlink:1", this, *obj_direlem->fullpath().image());
            
            
            
            
            
            w->hold_data = true;
        }

#if CELERRA_CMR10
        bool emctardedup = false;
        if (!stubdata.isnull() || stubdata.size() > 0) {
            emctardedup = isstubemctardedup(stubdata);
        }

        if (emctardedup && !disable_cmr10_inflation) {
            if (msg2)
                DB->msg("backemctardir6::process_direlem obj_direlem:%s is cmr10 dedup compressed, setting StreamtransformEmctarDedup in workelem", *obj_direlem->fullpath().image());
            w->st = new StreamtransformEmctarDedup();
            w->sb = new Streambuffer();
        }
#endif

        nbackdata *cycle_chunk = new nbackdata( this, w, patchoffset, false, parser, info->use_container );
        cycle_chunk->noop();

        nforked++;

        
        size += datasize;
    }
    if(msg2)DB->msg("backemctardir6::process_direlem DONE obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(), *stubdata.size64().image());
}


void backemctardir6::childdone(cycle *child)
{
    if (msg1) DB->msg("backemctardir6::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d", parent, this, child, nforked, ncollected);

    if (child) {
        ncollected++;

        switch (phase) {

        case phase_init:
            return;

        case phase_read_data:
        case phase_wait_for_history:
            
            
        case phase_wait_for_children:
            
            
        case phase_forksdone:
            
            
        case phase_do_hidden: {
            
            
            
            
            
            
            
            backemctardir6 *dir_dc = dynamic_cast<backemctardir6 *>(child);
            if (dir_dc != NULL) {
                
                

                
                child_dir_count--;
                
                

                DIRELEMp de(dir_dc->getInfo()->direlemp);

                
                ubigint64 child_inode(de->inode_number64());
                if (info->use_container) {
                    
                    

                    
                    
                    if (parent_backemctardir6p != NULL) {
                        
                        
                        if (msg2) DB->msg("backemctardir6::childdone-phase_do_hidden: dynamic cast of parent succeeded; parent is a backemctardir6 cycle");
                        

                        
                        my_childlistp->add_child(child_inode);
                        if (msg2) DB->msg("backemctardir6::childdone: Added inode %"LL"d to child_dir_list for %s. List size=%d",
                                          child_inode, *info->direlemp->name(), (int)my_childlistp->list_size());

                        if (flags.incremental) {
                            
                            
                            assert(dir_dc->cur_synthlist_tag_index < my_cur_synthlistp->list_size());

                            
                            
                            
                            
                            
                            
                            
                            
                            
                            unsigned int search_index(dir_dc->cur_synthlist_tag_index);
                            unsigned int list_index(search_index); 
                            bool index_found(0);
                            while (!index_found && list_index < my_cur_synthlistp->list_size()) {
                                
                                
                                if ((my_offset2lists_entry->second.cur_synthlist[list_index].block_size == inode_table::dir_placeholder_tag) &&
                                    (my_offset2lists_entry->second.cur_synthlist[list_index].block_begin == search_index)) {
                                    
                                    index_found = 1;
                                } else {
                                    list_index++;
                                }
                            }

                            if (!index_found) {
                                Out->msg(ERR, "During processing of directory '%s', failed to find synth list entry for inode '%"LL"d'",
                                         *ndmp_unentify_volume_plus_path(info->direlemp->fullpath().image()), child_inode);
                            } else {
                                
                                if (msg2) DB->msg("backemctardir6::childdone: Updating inode number for %s in cur_synthlist (old:%"LL"d new:%"LL"d)",
                                                  *de->name(), my_offset2lists_entry->second.cur_synthlist[list_index].block_begin, child_inode);
                                my_offset2lists_entry->second.cur_synthlist[list_index].block_begin = child_inode;
                                my_offset2lists_entry->second.cur_synthlist[list_index].block_size = inode_table::directory_tag;
                            }
                        }
                    }

                    if (flags.incremental) {
                        
                        
                        merged_coverage_size += dir_dc->merged_coverage_size;
                        if (msg2) DB->msg("backemctardir6::childdone  Updated merged_coverage_size for %s to:%"LL"d (added %"LL"d from child dir)",
                                          *info->direlemp->name(), (bigint64)merged_coverage_size.value(), (bigint64)dir_dc->merged_coverage_size.value());

                        
                        
                        merged_checksum ^= dir_dc->merged_checksum;
                        if (msg2) DB->msg("backemctardir6::childdone  Updated merged_checksum for %s to:%u (included %u from previous backup)",
                                          *info->direlemp->name(), merged_checksum, dir_dc->merged_checksum);
                    }
                }

                
                
                if (catalog_enabled) {
                    MetadataIntf_sp metadatap = dir_dc->my_metadataIntfp;
                    direlemp2metadatap.insert(std::make_pair(de.getimpl(), metadatap));
                    if (msg2) DB->msg("backemctardir6::childdone: Added child dir '%s' to metadata map (de.getimpl=%p, metadatap=%p, map_size=%d)",
                                      *de->name(), de.getimpl(), metadatap.get(), (int)direlemp2metadatap.size());

                    
                    
                    
                    
                    
                    
                    
                    if (child_inode == 2) {
                        
                        
                        
                        
                        const MetadataId metadataid(de->file_hash());
                        if (inodetab.use_inode_tree) {
                            
                            
                            
                            location loc(de->get_location());
                            fileoffset dir_abs_offset(loc.get_abs_offset_in_container());  
                            offset2lists_iterator list_entry = offset2lists.find(dir_abs_offset);  
                            
                            if (msg2) DB->msg("backemctardir6::childdone Adding inode table entry for directory '%s' with extra info for DDR. inode=%d offset=%"LL"d",
                                              *de->name(), de->inode_number(), (dir_abs_offset + loc.get_header_size()).value());
                            inodetab.add_entry(de->inode_number(), metadataid, de->file_size(), true, true ,
                                               (dir_abs_offset + loc.get_header_size()).value(), &(list_entry->second.childlist),
                                               &(list_entry->second.cur_synthlist), &(list_entry->second.prev_synthlist));
                        } else {
                            
                            
                            inodetab.add_entry(de->inode_number(), metadataid, de->file_size(), true, true );
                        }
                    }
                }
            }

            
            
            BackCycle *dc = dynamic_cast<BackCycle *>(child);
            
            if (dc && dc->getInfo()->direlemp->is_tar_hardlink() && dc->getInfo()->hold_data) {
                
                ustring linkvalue;

                if (dc->getInfo()->direlemp->is_stream_slice()) {
                    dirrec_pack::regions dr(dc->getInfo()->direlemp.getimpl());
                    data_regions::endoffsets_t endoffsets;
                    fileoffset startbyte, endbyte;
                    dr.get(endoffsets);
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    data_regions::findrange(endoffsets, primarydata, true , startbyte, endbyte);

                    fileoffset range(endbyte - startbyte);
                    const char* start = dc->getInfo()->data.start() + startbyte.lopart();

                    if (startbyte.hipart() != 0 || endbyte.hipart() != 0 || startbyte > endbyte ||
                        (int)(range.lopart()) > dc->getInfo()->data.size()) {
                        Out->msg(ERR, LOCTXT("Failure processing hardlink '%s', bad start/end values in dirrec (%s/%s), or data.size value (%d)"),
                                 *dc->getInfo()->direlemp->fullpath().image(),*startbyte.image(),*endbyte.image(),
                                 dc->getInfo()->data.size());
                    }

                    linkvalue = ustring(start, range.lopart());

                } else {
                    linkvalue = ustring(dc->getInfo()->data.start(), dc->getInfo()->data.size());
                }

                if (msg2)
                    DB->msg("backemctardir6::childdone %s is_tar_hardlink:1 with file_hash:%s data:'%s'",
                            *dc->getInfo()->direlemp->fullpath().image(),
                            *child->hash.partialimage(),
                            *linkvalue);
                name2link.enter(dc->getInfo()->direlemp->name(), linkvalue);
            }
            
            break;
        }
        case phase_done: {
            commit_directory_metadata();
            
            notifyparent();
            
            
            return;
        }
        default:
            assert(false);

        } 
    }

    if (msg1) DB->msg("backemctardir6::childdone this:%p phase:%d forked_prev_restore:%d nforked=%d ncollected=%d",
                      this, phase, forked_prev_restore, nforked, ncollected);

    if ((phase == phase_wait_for_history) || (phase == phase_wait_for_children)) {
        process_wait_phases(static_cast<int> (historytable.size()));
    } 

    if ((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)) {
        if (flags.incremental) {
            
            
            
            process_forksdone_phase_part1(my_cur_synthlistp, my_prev_synthlistp);
        } else {
            
            copy_inodes_from_history();
        }

        
        
        
        
        
        if (reserved_hiddendir && !flags.noinodetable) {
            fix_inodetab_entries();
        }

        
        
        
        
        if (catalog_enabled) {
            
            
            
            if (!add_children_to_metastore()) {
                Out->Abort("Problem adding children to the Metadata store for directory '%s'", *info->direlemp->fullpath().image());
                return;
            }
        }

        
        
        
        
        
        process_forksdone_phase_part2(child, my_cur_synthlistp, my_prev_synthlistp);
    } 

    
    if ((phase == phase_do_hidden) && (ncollected == nforked)) {
        process_do_hidden_phase();

        if (histsrv) {
            int inum = info->direlemp->inode_number();
            if (inum >= 0) histsrv->directory_complete(inum);
            else DB->msg("backemctardir6::childdone not calling directory_complete for inode:%d for info->direlemp->fullpath:%s",
                         inum, *info->direlemp->fullpath().image());
        }
    }
}




void backemctardir6::request_prevlist() {
    if (!flags.incremental) return;

    
    
    
    upath parent_path(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), true);  

    MetadataId metadataid(main->prev_backup.getRootLocation().getMetadataId());
    fileoffset abs_offset_in_container(0);

    if (msg1) DB->msg("backemctardir6::request_prevlist \"%s\"", *parent_path.image());

    if (!flags.noinodetable) {
        
        ubigint64 de_inode(info->direlemp->inode_number());
        
        
        
        
        
        
        
        
        
        if(parentinode>0) de_inode=parentinode;
        fileoffset dummy_size;
        bool wasdir = false;
        ubigint64 dir_offset;
        
        if (inodetab.find_entry(de_inode, metadataid, dummy_size, wasdir, dir_offset)) {
            if (!wasdir) {
                if (msg1)
                    DB->msg("backemctardir6::request_prevlist directory:%s found entry in inodetab (%"LL"d -> %s:file_size %s:wasdir %d) so not forking restore",
                            *info->direlemp->fullpath().image(), de_inode, *metadataid.partialimage(), *dummy_size.image(), wasdir);
                forked_prev_restore = true; 
                return;
            }
            abs_offset_in_container = dir_offset;
            parent_path = upath("");
        } else {
            
            
            
            
            
            if (de_inode > 2) {
                if (msg1)
                    DB->msg("backemctardir6::request_prevlist \"%s\" did not find de_inode:%"LL"d in inodetab for prev backup, so prevlist is empty",
                            *info->direlemp->fullpath().image(), de_inode);
                forked_prev_restore = true;
                return;
            }
        }
    }

    
    
    if (msg1 || (parent_path.numelems() > 0))
        DB->msg("backemctardir6::request_prevlist reading previous backup path:'%s' nforked:%d ncollected:%d phase:%d forked_prev_restore:%d",
                *parent_path.image(), nforked, ncollected, phase, forked_prev_restore);
    
    location prev_loc(inodetab.base_container_location);
    prev_loc.set_abs_offset_in_container(abs_offset_in_container);

    
    
    
    
    
    
    
    if (reserved_hiddendir) {
        prev_loc.set_containerid(0);
        prev_loc.set_enclosing_container(NULL);  
    }

    const location dirloc(main->prev_backup.getMedialoc(), metadataid);
    cycle *child = new restdirlist(this, dirloc, parent_path, prev_loc, prevlist);
    child->noop();
    nforked++;
    forked_prev_restore = true;
}




void backemctardir6::response(message& outargs)
{
    if(msg1)
        DB->msg("backemctardir6::response (parent:%p) (this:%p)", parent, this);
    ncollected++;
    
    msgpack_c::getndmphistlist thl(outargs);
    ustring streamoffset;
    ubigint64 tablea=0;
    ubigint64 hltablea=0;
    bool existed;
    unsigned int msg_parentinode;

    thl.res(UNPACK, streamoffset, tablea, existed, msg_parentinode, hltablea);
    if (msg1) DB->msg("backemctardir6::response unpacked result: streamoff:%s tablea:%p existed:%d parentinode:%u",
                      *streamoffset, (void*)tablea, existed, msg_parentinode);

    
    
    if (existed) {
        unsigned int cc = (int)(historytable.size() + hlhistorytable.size());
        bool undersizedhistory = ((unsigned int)nhistchildren > cc);
        if (undersizedhistory)
            DB->error("backemctardir6::response received a GETNDMPHISTLIST response with only %u children when we expected %d",
                      cc, nhistchildren);
        if ((undersizedhistory || msg2) && DB->messages_on) {
            DB->msg("backemctardir6::response received history response for backemctardir6 with(emctarstreamoffset:%s nhistchildren:%d) for parentinode:%d streamoffset '%s' %"Z"d entries, %d hardlink entries",
                    *emctarstreamoffset.image(), nhistchildren, msg_parentinode, *streamoffset, historytable.size(), hlhistorytable.size());
            for (histmap::const_iterator i=historytable.begin(); i != historytable.end(); i++) {
                DB->msg("        key:%s off:%s", *(i->first.image()), *(i->second));
            }
            undoo::vector<csustring> hlnames(hlhistorytable.keys());
            for (unsigned int j=0; j<hlnames.size(); j++) {
                DB->msg("        name:%s inode:%u", *hlnames[j], hlhistorytable.lookup(hlnames[j]));
            }
        }
        foundhistory=true;
        if (msg_parentinode > 0)
            update_direlem_unix_special(info->direlemp, -1, -1, msg_parentinode, -1);
    } else {
        foundhistory = false;
        DB->msg("backemctardir6::response unable to find history for streamoffset '%s'", *streamoffset);
    }
    parentinode = ubigint64(msg_parentinode);
    childdone(NULL);  
}

class curlist_rekeyer : public composite_to_direlemp_table::iterator {
public:
    curlist_rekeyer(csname_to_direlemp_t &topleveldirelems_) : topleveldirelems(topleveldirelems_) {}
    virtual ~curlist_rekeyer() {}
    virtual void callback(const composite_key& key, const DIRELEMp& val) {
        
        topleveldirelems[val->name()] = val;
    }
protected:
    csname_to_direlemp_t &topleveldirelems;
};

















bool
backemctardir6::find_hardlinkpath(const ubigint64 inode, const ustring linktext,
                                  const upath &volpath,
                                  hfs_info_struct &hfsinfo, 
                                  const csname_to_direlemp_t &topleveldirelems,
                                  DIRELEM &de,
                                  ubigint64 &parent_inode) const
{
    if (linktext.bytelength() < 2) { 
        Out->msg(ERR, "<10677>Hardlink target '%s' is not a valid path.",
                 *linktext);
        return false;
    }

    upath fullpath(linktext);
    upath nonvolpath    = fullpath.slice(volpath.numelems(), fullpath.numelems());
    ustring topname     = nonvolpath.get(0);
    upath remainingpath = nonvolpath.slice(1, nonvolpath.numelems()).to_relative();
    upath target; 
    if (msg2) DB->msg("backemctardir6::find_hardlinkpath for '%s' we have nonvolpath '%s', topname '%s', and remainingpath '%s'",
                      *linktext, *nonvolpath.image(), *topname, *remainingpath.image());

    
    
    csname_to_direlemp_t::const_iterator top_name_iter = topleveldirelems.find(topname);
    if (top_name_iter == topleveldirelems.end()) {
        Out->msg(ERR, "<10678>Unable to find '%s' in '%s' while looking up hardlink target path '%s' in partial backup.",
                 *topname, *volpath.image(), *linktext);
        return false;
    }
    DIRELEMp temp_DEp = top_name_iter->second;
    if (!temp_DEp->name().equal(topname)) {
        Out->msg(ERR, "<12119>Looked up '%s' in our top level listing and found an element with name '%s' which doesn't match.",
                 *topname, *temp_DEp->name());
        return false;
    }

    de = *temp_DEp;
    if (!remainingpath.isempty()) {
        
        
        
        
        const context::prep_for_no_ddr_container ddr_loc_ignored(*main);

        
        
        
        if (info->use_container) {
            
            
            
            
            
            
            if (remainingpath.numelems() > 1) {
                
                upath parent_path = remainingpath.slice(0, remainingpath.numelems()-2);
                remainingpath = remainingpath.slice(remainingpath.numelems()-1, remainingpath.numelems()).to_relative();
                
                

                
                ustring errdesc;
                
                

                
                
                
                location temp_loc(de.get_location());
                temp_loc.set_containerid(0);
                de.set_location(temp_loc);
                const location theloc(location::media::gsan, de.file_hash());
                bool res = utar_commands::get_direlem(hfsinfo, main->get_flags(),
                                                      theloc, parent_path,
                                                      de, errdesc, target);
                
                if (!res) {
                    Out->msg(ERR, "<12120>Unable to find '%s' in '%s' while looking up hardlink target path '%s' in partial backup: get_direlem error \"%s\"",
                             *parent_path.image(), *(volpath/topname).image(), *linktext, *errdesc);
                    return false;
                }
            }

            
            
            parent_inode = de.inode_number64();
        }

        
        ustring errdesc;
        
        

        
        
        
        location temp_loc(de.get_location());
        temp_loc.set_containerid(0);
        de.set_location(temp_loc);
        const location theloc(location::media::gsan, de.file_hash());
        bool res = utar_commands::get_direlem(hfsinfo, main->get_flags(),
                                              theloc, remainingpath,
                                              de, errdesc, target);
        
        if (!res) {
            Out->msg(ERR, "<12120>Unable to find '%s' in '%s' while looking up hardlink target path '%s' in partial backup: get_direlem error \"%s\"",
                     *remainingpath.image(), *(volpath/topname).image(), *linktext, *errdesc);
            return false;
        }
        if (inode != (ndmp_inode_t)de.inode_number()) {
            Out->msg(ERR, "<12121>Looked up path '%s' within '%s' and found direlem with name '%s' but inode %u when we're looking for inode %u",
                     *remainingpath.image(), *temp_DEp->fullpath().image(), *de.name(), (ndmp_inode_t)de.inode_number(), (ndmp_inode_t)inode);
            return false;
        }

    } else {
        
        
        
        parent_inode = 0;
    }

    return true;
}

void
backemctardir6::fix_inodetab_entries()
{
    Out->msg(INFO, "<10694>Updating inode2hash with hardlink data for %d hardlinks using %d top level elements",
             needhardlinkvalues.size(), curlist.size());

    
    
    
    
    
    if (!cycle::main->restorecache_enabled()) {
        cycle::main->restorecache_enable(flags.restorecachesize, false);
    }

    
    
    
    double lastprogresstime = timer::now();
    double starttime = lastprogresstime;
    double progressinterval = 60.0 * 5; 

    
    
    
    
    
    
    
    
    csname_to_direlemp_t topleveldirelems;
    curlist_rekeyer iter(topleveldirelems);
    curlist.iterate(&iter);

    if (!cycle::main->getAdeMgr()) {
        Out->msg(ERR, "<12122>Unable to retrieve hfs_info_struct to look up hardlink paths in backup.");
        return;
    }
    hfs_info_struct& hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);

    upath volpath(ndmp_unentify_volume(flags.ndmp_prefix));
    uintobj inode;
    ustring linktext;
    int progresscount = 0;
    while (needhardlinkvalues.pop(inode, linktext)) {
        double curtime = timer::now();
        if ((curtime - lastprogresstime) > progressinterval) {
            Out->msg(INFO, "<12535>Updated %d inode2hash hardlink entries in %lf seconds, %d remaining",
                     progresscount, curtime - starttime, needhardlinkvalues.size());
            lastprogresstime = curtime;
        }
        if (msg2) DB->msg("backemctardir6::fix_inodetab_entries (%u, %s)",
                          int(inode), *linktext);
        progresscount++;

        DIRELEM de;
        ubigint64 parent_inode(0);
        if (!find_hardlinkpath(inode, linktext, volpath, hfsinfo, topleveldirelems, de, parent_inode)) {
            continue; 
        }

        if (msg2) DB->msg("backemctardir6::fix_inodetab_entries: hardlinkpath found inode:%u path:%s file_size:%s abs_offset:%"LL"d parent_inode:%"LL"d",
                          int(inode), *de.fullpath().image(), *de.file_size().image(), de.get_location().get_abs_offset_in_container().value(), parent_inode);

        
        
        MetadataId metadataid;

        
        
        
        MetadataId de_metadataid(de.file_hash());
        

        fileoffset sz;
        bool wasdir;
        ubigint64 dir_offset(0);
        
        bool de_is_dir(de.is_directory());
        ubigint64 de_offset(de.get_location().get_abs_offset_in_container().value());

        
        if (inodetab.find_entry(inode, metadataid, sz, wasdir, dir_offset)) {
            if (msg2) DB->msg("backemctardir6::fix_inodetab_entries found entry for inode %u with offset %"LL"d", int(inode), dir_offset);
            if ((metadataid != de_metadataid) || (sz != de.file_size()) || (wasdir != de_is_dir) || (dir_offset != de_offset)) {
                DB->msg("backemctardir6::fix_inodetab_entries already have '%s:%s:%d:%"LL"d' for inode %u, replacing with '%s:%s:%d:%"LL"d'",
                        *metadataid.partialimage(), *sz.image(), wasdir, dir_offset,
                        int(inode),
                        *de_metadataid.partialimage(), *de.file_size().image(), de_is_dir, de_offset);
            }
        }

        
        
        inodetab.add_entry(inode, de_metadataid, emctar_file_hash_size(de), true, de_is_dir, de_offset);

        
        
        
        if (info->use_container && (parent_inode != 0)) {
            
            inodetab.add_to_child_list(parent_inode, inode);
        }
    }
}



bool backemctardir6::merge_lists()
{
    removesnapviewvolumes(flags.ndmp_prefix);

    if(msg1) {
        DB->msg("backemctardir6::merge_lists parent:%s with inode:%d prevlist:%d curlist:%d, foundhistory:%d historytable:%"Z"d",
                *info->direlemp->fullpath().image(), info->direlemp->inode_number(), prevlist.size(), curlist.size(), foundhistory, historytable.size());
    }

    if (parser->is_empty_stream()) {
        copy_previous_backup(my_prev_synthlistp, my_childlistp);
        return true;
    }

    if (!foundhistory) return false;  

    
    if (msg2) {
        DB->msg("backemctardir6::merge_lists for directory %s inode:%d",
                *info->direlemp->fullpath().image(), info->direlemp->inode_number());
        debug_print_direlemp_list(curlist, "curlist", msg2);
        debug_print_direlemp_list(prevlist, "prevlist", msg2);
    }

    
    
    
    
    
    
    
    
    
    prevlist.iterate(&prevlist_iter);

    
    
    
    
    
    
    
    
    composite_key hkey;
    ustring offset_link;
    while (!historytable.empty()) {
        histmap::iterator i = historytable.begin();
        hkey = i->first;
        offset_link = i->second;
        historytable.erase(i);

        if (msg2) DB->msg("backemctardir6::merge_lists popped historytable %s -> %s",
                          *hkey.image(), *offset_link);

        
        
        
        if ((hkey.key_number == 2) && offset_link.safe_substr(0, 2) == "0,") {
            DB->msg ("    skipping");
            continue;
        }

        ustring inode(ustring::sprintf("%d", hkey.key_number32()));
        ustring name(hkey.key_string);
        if (!name.isempty()) {
            
            

            assert(offset_link.isempty()); 
            
            
            
            
            
            
            
            dropped_multimap_rng rng = dropped.equal_range(inode.toint());
            if (rng.first == rng.second) {
                Out->msg(ERR, "<7829>Processing '%s': Unable to find a matching entry in prevlist for historytable ('%s' -> '%s')",
                         *info->direlemp->fullpath().image(), *hkey.image(), *offset_link);
                continue;
            }
            dropped_multimap::const_iterator tmp = rng.first; tmp++;
            if (tmp != rng.second) {
                Out->msg(ERR, "<7830>Processing '%s': Multiple potential prevlist items matched by historytable ('%s' -> '%s')",
                         *info->direlemp->fullpath().image(), *hkey.image(), *offset_link);
                continue;
            }

            
            
            
            
            if (traverse_depth == 1) {
                
                bool added = curlist.split_enter_if_undef(fake_offset--, "", rng.first->second);
                if (!added) {
                    Out->msg(ERR, "<9979>While processing %s (inode %d) found a second entry with name '%"LL"d'",
                             *info->direlemp->fullpath().image(), info->direlemp->inode_number(), fake_offset+1);
                }
            }

            
            ordered_prevlist.push_back(rng.first->second);

            
            
            if (info->use_container) {
                
                
                
                add_to_prev_synth_list(rng.first->second, my_prev_synthlistp, my_childlistp);
            }

            
            update_stats_counts(rng.first->second);
            continue;
        }

        
        
        
        ustring offset, link;
        offset_link.split(offset, link, false, ',');
        DIRELEMp curDE;
        
        
        curlist.split_lookup(offset.touint64(), "", curDE);
        if (msg2) DB->msg("    offset:'%s' link:'%s' found curDE:%p", *offset, *link, curDE.getimpl());
        if (curDE.isnull()) {
            Out->msg(FATAL, "<8014>historytable has entry with streamoffset:%s but curDE looked up with that value is null",
                     *offset);
            merge_success = false;
            uapp::staging().startTermination(EXIT_MISC, "error in historytable");
            set_phase(phase_forksdone);
            continue;
        }

        
        
        update_current_direlem(curDE, hkey.key_number32(), link);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    undoo::vector<csustring> hlk(hlhistorytable.keys());
    if(msg2) DB->msg("backemctardir6::merge_lists about to process %"Z"u hlhistorytable entries",
                     hlk.size());
    for (unsigned int j=0; j<hlk.size(); j++) {
        if (msg2) DB->msg("backemctardir6::merge_lists hlhistorytable entry %s -> %d",
                          *(hlk[j]), hlhistorytable.lookup(hlk[j]));
        DIRELEMp curDE;
        
        
        if (curlist.split_lookup(undefined_offset, hlk[j], curDE)) {
            unsigned int inode = hlhistorytable.lookup(hlk[j]);
            update_direlem_unix_special(curDE, -1, -1, inode, -1);
            ustring linktext = name2link.lookup(curDE->name());
            assert(!linktext.isempty());
            needhardlinkvalues.enter(inode, linktext);
            if (msg2) DB->msg("    after update curDE:(name:%s inode:%d)", *curDE->name(), curDE->inode_number());
        } else {
            if (msg2) DB->msg("    unable to find curDE element for hlhistorytable entry");
        }
    }

    
    
    undoo::vector<composite_key> clk;
    curlist.keys(clk);
    for (undoo::vector<composite_key>::const_iterator i=clk.begin(); i!=clk.end(); i++) {
        DIRELEMp curDE;
        curlist.lookup((*i), curDE);
        if ((curDE->inode_number() == 0) && !curDE->name().equal(UNDOO_DIRECTORY_NAME)) {
            DB->warn("backemctardir6::merge_lists curlist has '%s' -> curDE:(%s inode:0) at end of call",
                     *((*i).image()), *curDE->fullpath().image());
        }
    }

    if (msg2) DB->msg("backemctardir6::merge_lists--");

    return merge_success;
}




void backemctardir6::process_prevlist_item(const composite_key& pkey, const DIRELEMp& prevDE)
{
    
    ustring inode_name(pkey.image());  
    if (msg2) DB->msg("backemctardir6::process_prevlist_item prevlist.pop() %s -> prevDE:(%s, inode:%d)",
                      *inode_name, *prevDE->fullpath().image(), prevDE->inode_number());
    assert(composite_key(prevDE->inode_number(), prevDE->name()) == pkey);

    
    
    ustring offset_link;
    ustring offset, link;

    
    
    
    
    histmap::iterator i = historytable.find(pkey);
    if (i != historytable.end()) {
        
        

        if (msg2) DB->msg ("    found %s key in historytable, moving to current backup", *inode_name);
        assert((i->second).isempty()); 

        
        
        
        
        if (traverse_depth == 1) {
            
            if (msg2) DB->msg ("    adding %s to curlist", *inode_name);
            bool added = curlist.split_enter_if_undef(fake_offset--, "", prevDE);
            if (!added) {
                Out->msg(ERR, "<9979>While processing %s (inode %d) found a second entry with name '%"LL"d'",
                         *info->direlemp->fullpath().image(), info->direlemp->inode_number(), fake_offset+1);
            }
        }

        
        ordered_prevlist.push_back(prevDE);

        
        
        if (info->use_container) {
            
            
            
            add_to_prev_synth_list(prevDE, my_prev_synthlistp, my_childlistp);
        }

        main->getstatsobj(context::backupstats)->mergeprogress(prevDE);
        historytable.erase(i);
        return;
    }

    
    
    
    
    uint32_t uint_inode(pkey.key_number32());
    ustring inode(ustring::sprintf("%d", uint_inode));
    ustring name(pkey.key_string);
    unsigned int hlinode;
    i = historytable.find(composite_key(uint_inode, ""));
    if (i == historytable.end()) {
        
        
        
        

        if (msg2) DB->msg ("    failed to find %s in historytable (pkey %s, prevDE->inode_number() %d), dropping prevDE",
                           *inode, *inode_name, prevDE->inode_number());
        dropped.insert(std::make_pair((int)uint_inode, prevDE));

        
        
        
        
        if (msg2) DB->msg("    deleting entry for inode %u from inodetab", prevDE->inode_number());

        
        
        
        inodetab.mark_for_removal(prevDE->inode_number());

        return;

    
    
    
    
    } else if (hlhistorytable.remove(name, hlinode)) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        if (msg2) DB->msg("    found hlhistorytable entry %s -> %u with matching name from prevlist key %s",
                          *name, hlinode, *inode_name);
        if (hlinode != (unsigned int) prevDE->inode_number()) {
            
            
            
            
            
            
            if (msg2) DB->msg("    but prevDE->inode_number():%d != hlinode:%d",
                              prevDE->inode_number(), hlinode);
        }

        DIRELEMp curDE;
        
        
        if (curlist.split_lookup(undefined_offset, name, curDE)) {
            update_direlem_unix_special(curDE, -1, -1, hlinode, -1);
            
            
            update_stats_counts(curDE);
        } else {
            
            
            
            
            
            DB->msg("backemctardir6::process_prevlist_item  Found entry in hlhistorytable for '%s', but no entry in curlist", *name);
            assert(curDE.isnull());
            
            
            bool added = curlist.split_enter_if_undef(fake_offset--, "", prevDE);
            if (!added) {
                Out->msg(ERR, "<9979>While processing %s (inode %d) found a second entry with name '%"LL"d'",
                         *info->direlemp->fullpath().image(), info->direlemp->inode_number(), fake_offset+1);
            } else {
                
                ordered_prevlist.push_back(prevDE);
            }

            
            
            if (info->use_container) {
                
                
                
                add_to_prev_synth_list(prevDE, my_prev_synthlistp, my_childlistp);
            }

            main->getstatsobj(context::backupstats)->mergeprogress(prevDE);
        }
        return;

    } else { 
        
        
        
        
        
        
        

        
        offset_link = i->second;

        
        
        assert(!offset_link.isempty());
        offset_link.split(offset, link, false, ',');
        assert(!offset.isempty());

        DIRELEMp curDE;
        
        
        if (!curlist.split_lookup(offset.touint64(), "", curDE)) {
            Out->msg(FATAL, "<8013>Found ndmp history stream entries indicating inode:%s should have data at streamoffset:%s but curlist has no direlem at that offset",
                     *inode, *offset);
            merge_success = false;
            uapp::staging().startTermination(EXIT_MISC, "invalid inode data in ndmp history");
            set_phase(backndmptardir_base::phase_forksdone);
            return;
        }

        
        
        
        
        
        
        
        

        
        
        update_current_direlem(curDE, prevDE->inode_number(), link);

        
        
        
        if (curDE->get_security_size() <= 0) {
          fileref prev_security;
          prevDE->get_security(prev_security);
          if(msg2)DB->msg("backemctardir6::process_prevlist_item in curlist prev_security.size()=%d cur_security.size()=%d",
                          prev_security.size(), curDE->get_security_size());
          curDE->set_security(prev_security);
        }

        historytable.erase(i);
    }
}






void backemctardir6::update_current_direlem(DIRELEMp curDE,       
                                            const uint32_t inode, 
                                            const ustring link)   
{
    unsigned int nlink = curDE->hard_links();
    if (!link.isempty() && (link.toint() > 1)) {
        nlink = link.toint();
        if (!curDE->is_directory()) {
            

            
            
            
            
            const MetadataId metadataid(curDE->file_hash());
            if (inodetab.use_inode_tree) {
                
                
                
                
                location loc(curDE->get_location());

                if (msg2) DB->msg("backemctardir6::update_current_direlem Adding inode table entry for hardlink '%s' with extra info for DDR. inode=%d offset=%"LL"d",
                                  *curDE->name(), inode, loc.get_abs_offset_in_container().value());
                inodetab.add_entry(inode, metadataid, emctar_file_hash_size(*curDE), true, false ,
                                   loc.get_abs_offset_in_container().value());

                
                
                
                
                
                
                
                
                my_childlistp->add_child(inode);
                if (msg2) DB->msg("backemctardir6::update_current_direlem Added inode %"LL"d to child_dir_list for %s. List size=%d",
                                  (ubigint64)inode, *info->direlemp->name(), (int)my_childlistp->list_size());

                
                
                insert_hardlink_tag((ubigint64)inode,
                                    (ubigint64)loc.get_abs_offset_in_container().value(),
                                    (bigint64)loc.get_coverage_size().value());
            } else {
                
                
                inodetab.add_entry(inode, metadataid, emctar_file_hash_size(*curDE), true, false );
            }
        }
    }

    
    update_direlem_unix_special(curDE, -1, -1, inode, nlink);
    if (msg2) DB->msg("    updated curDE:%s inode to %d, nlink to %u",
                      *curDE->name(), curDE->inode_number(), nlink);

    if (curDE->is_directory()) {
        

        
        
        
        
        const MetadataId metadataid(curDE->file_hash());
        if (inodetab.use_inode_tree) {
            

            
            
            location loc(curDE->get_location());
            fileoffset dir_abs_offset(loc.get_abs_offset_in_container());  
            offset2lists_iterator list_entry = offset2lists.find(dir_abs_offset);  
            

            if (msg2) DB->msg("backemctardir6::update_current_direlem Adding inode table entry for directory '%s' with extra info for DDR. inode=%d offset=%"LL"d",
                              *curDE->name(), curDE->inode_number(), (dir_abs_offset + loc.get_header_size()).value());
            inodetab.add_entry(curDE->inode_number(), metadataid, curDE->file_size(), true, true ,
                               (dir_abs_offset + loc.get_header_size()).value(), &(list_entry->second.childlist),
                               &(list_entry->second.cur_synthlist), &(list_entry->second.prev_synthlist));
        } else {
            
            
            inodetab.add_entry(curDE->inode_number(), metadataid, curDE->file_size(), true, true );
        }
    }

    
    update_stats_counts(curDE);
}











void backemctardir6::insert_hardlink_tag(const ubigint64 inode,    
                                         const ubigint64 hl_begin, 
                                         const bigint64 hl_size)   
{
#if POINTER64
    if (msg2) DB->msg("backemctardir6::insert_hardlink_tag  inode:%"LL"d block_begin:%"LL"d block_size:%"LL"d list_size:%"LL"d",
                      inode, hl_begin, hl_size, my_cur_synthlistp->list_size());
#endif

    
    assert(info->use_container);

    ubigint64 hl_end(hl_begin + hl_size);
    bool entry_added(0);
    
    
    for(inode_table::synth_list_cur::cur_list_iterator citer(my_cur_synthlistp->list_begin());
                                                 !entry_added && (citer != my_cur_synthlistp->list_end());
                                                 citer++) {
        
        if (citer->block_size <= 0) {
            continue;
        }

        
        
        inode_table::data_block list_item(*citer);
        if ((hl_begin >= list_item.block_begin) && (hl_end <= (list_item.block_begin + list_item.block_size))) {
            if (msg2) DB->msg("backemctardir6::insert_hardlink_tag  Found block containing hardlink (block_begin:%"LL"d block_size:%"LL"d)",
                              list_item.block_begin, list_item.block_size);

            
            
            
            
            
            
            
            inode_table::synth_list_cur::cur_list_iterator temp_iter(citer);
            if (hl_begin != list_item.block_begin) {
                
                bigint64 offset_into_block(hl_begin - list_item.block_begin);
                inode_table::data_block new_item(list_item);

                
                
                
                
                offset2checksum_iterator o2c_iter = offset2checksum.find(new_item.block_begin);
                new_item.block_checksum = 0;
                while ((o2c_iter != offset2checksum.end()) && (o2c_iter->first < hl_begin)) {
                    new_item.block_checksum ^= o2c_iter->second;  
                    
                    
                    o2c_iter++;
                }
                if (o2c_iter == offset2checksum.end()) {
                    
                    
                    Out->msg(WARN,"Unable to accurately calculate DDR checksums.  Disabling checksum verification for this backup.");
                    
                    ddr_checksums_enabled = 0;
                }

                
                
                
                
                
                
                
                new_item.block_size = offset_into_block;
                list_item.block_begin = hl_begin;
                list_item.block_size = (list_item.block_size - offset_into_block);
                list_item.block_checksum ^= new_item.block_checksum;
                if (msg2) DB->msg("backemctardir6::insert_hardlink_tag  Splitting block into two pieces...(offset, size, checksum)");
                if (msg2) DB->msg("                                       Part One => (%"LL"d, %"LL"d, %u)",
                                  new_item.block_begin, new_item.block_size, new_item.block_checksum);
                if (msg2) DB->msg("                                       Part Two => (%"LL"d, %"LL"d, %u)",
                                  list_item.block_begin, list_item.block_size, list_item.block_checksum);

                
                my_cur_synthlistp->replace_item(citer, &list_item);
                temp_iter = my_cur_synthlistp->insert_item(citer, &new_item);

                
                
                temp_iter++;
            }

            
            inode_table::data_block tag_item;
            tag_item.block_begin = inode;
            tag_item.block_size = inode_table::hardlink_data_tag;
            temp_iter = my_cur_synthlistp->insert_item(temp_iter, &tag_item);

            
            entry_added = 1;
        }
    } 

    if (!entry_added) {
        
        Out->msg(ERR, "During processing of directory '%s', failed to find synth list entry for hardlink inode '%"LL"d'",
                 *ndmp_unentify_volume_plus_path(info->direlemp->fullpath().image()), inode);
    } else {
        
#if POINTER64
        if (msg2) DB->msg("backemctardir6::insert_hardlink_tag  Added hardlink tag for inode '%"LL"d' in cur_synthlist for dir '%s'. list_size:%"LL"d",
                          inode, *info->direlemp->name(), my_cur_synthlistp->list_size());
#endif
    }
}


void backemctardir6::request_history() {
    
    
    if(!histsrv)  return;

    assert(phase == phase_wait_for_history);

    
    if (historyrequests++) {
        DB->warn("backemctardir6::request_history %p request count %d, not requesting again!", this, historyrequests);
        return;
    }

    
    if (emctarstreamoffset == 0)
        nhistchildren++;

    message m;
    msgpack_c::getndmphistlist thl(m);
    ustring pp(emctarstreamoffset.image());
    ubigint64 tablep = (ubigint64)((ptrint)&historytable);
    ubigint64 hltablep = (ubigint64)((ptrint)&hlhistorytable);
    ubigint64 hardlinknamesp = (ubigint64) ((ptrint)&hardlinknames);
    thl.arg(PACK, pp, nhistchildren, tablep, hltablep, hardlinknamesp);
    m.setresponsecode(MSG_ERR_NONE);
    m.clearflag(MSGFLAG_NOACK);
    nforked++;
    if(msg1)
        DB->msg("backemctardir6::request_history requesting history (GETNDMPHISTLIST) for streamoffset:'%s'(%s) nforked:%d ncollected:%d nhistchildren:%d phase:%d forked_prev_restore:%d",
                *pp, *info->direlemp->fullpath().image(), nforked, ncollected, nhistchildren, phase, forked_prev_restore);
    histsrv->send(this, m);
    
    
}


void backemctardir6::copy_inodes_from_history() {  
        DB->msg("backemctardir6::copy_inodes_from_history dir:%s historytable.size():%"Z"d curlist.size():%d",
                *info->direlemp->fullpath().image(), historytable.size(), curlist.size());
    size_t count = 1;
    
    for (histmap::const_iterator i=historytable.begin(); i != historytable.end(); i++) {
        uint32_t histino(i->first.key_number32());  
        ustring histoff(i->second); 
        if(msg2 || (++count % 20000 == 1))
            DB->msg("backemctardir6::copy_inodes_from_history dir:%s handling %"Z"d'th item ino:%u streamoff:%s",
                     *info->direlemp->fullpath().image(), (count-2), histino, *histoff);

        ustring offset_part, link_count_part;
        histoff.split(offset_part, link_count_part, false, ',');

        if (histoff.isempty()) {
            Out->msg(ERR, "<8463>Processing '%s': Unable to find offset for (inode:name) (%s). File was deleted during backup time. Do backup with snapsure instead of production file system.",
                     *info->direlemp->fullpath().image(), *(i->first.image()));
            
            continue;
        }
        if (offset_part.isempty()) {
            Out->msg(ERR, "<7402>Processing '%s': No stream offset for inode %u was found in the history stream, unable to look up direlem by offset",
                     *info->direlemp->fullpath().image(), histino);
            
            continue;
        }

        if ((histino == 2) && offset_part.equal("0")) {
            
            continue;
        }

        DIRELEMp curDE;
        
        
        if (!curlist.split_lookup(offset_part.touint64(), "", curDE)) {
            Out->msg(ERR, "<7403>Processing '%s': Unable to find direlem for stream offset \"%s\" (filehistory inode:%u offset:%s)",
                     *info->direlemp->fullpath().image(), *offset_part, histino, *histoff);
            
            continue;
        }

        unsigned int nlink              = curDE->hard_links();
        unsigned int nlink_from_history = ( link_count_part.isempty() ? 1 : link_count_part.toint() );

        if (nlink_from_history < nlink) {
            Out->msg(WARN, "<15108>NDMP file history processing thread found nlink:%u for (inode %u, streamoffset %s), but the direlem direlem associated with that offset (path %s) has nlink %u",
                     nlink_from_history, histino, *offset_part, *curDE->fullpath().image(), nlink);
        } else {
            nlink = nlink_from_history;
        }

        
        
        
        
        const MetadataId metadataid(curDE->file_hash());

        if (nlink_from_history > 1) {
            
            
            
            
            
            
            
            
            nlink = nlink_from_history;
            if (doaddhardlinkstoinodetabearly) {
                
                
                
                
                DB->msg("backemctardir6::copy_inodes_from_history (x[15]&4194304)==1 so doing inodetab.add_entry_if_iszero(%u,%s,%s,%d,%d) for '%s'",
                        histino, *curDE->file_hash().partialimage(), *curDE->file_size().image(), true, curDE->is_directory(), *curDE->fullpath().image());
                (void)inodetab.add_entry_if_iszero(histino, metadataid, emctar_file_hash_size(*curDE), true, curDE->is_directory());
            } else {
                if (msg2) DB->msg("backemctardir6::copy_inodes_from_history skipping inodetab.add_entry_if_iszero(%u, %s, %s, true, %d) for nlink %d during backup of %s",
                                  histino, *curDE->file_hash().partialimage(), *curDE->file_size().image(), curDE->is_directory(),
                                  nlink, *curDE->fullpath().image());
            }
        }

        update_direlem_unix_special(curDE, -1, -1, histino, nlink); 
        if(msg2)DB->msg("backemctardir6::copy_inodes_from_history update_direlem_unix_special(-1, -1, %u, %d)",
                        histino, nlink);

        
        
        if(curDE->is_directory() || (catalog_enabled && nlink > 1)) {
            

            bool is_dir(curDE->is_directory());
            fileoffset file_size(fileoffset::unknown);

            if (is_dir) {
                
                file_size = curDE->file_size();
            } else {
                
                file_size = emctar_file_hash_size(*curDE);
            }

            if (inodetab.use_inode_tree) {
                
                
                
                

                
                
                fileoffset abs_offset(curDE->get_location().get_abs_offset_in_container());  
                offset2lists_iterator list_entry = offset2lists.find(abs_offset);  
                
                
                

                
                if (is_dir) {
                    abs_offset += curDE->get_location().get_header_size();
                }

                
                
                inodetab.add_entry(histino, metadataid, file_size, true, is_dir, abs_offset.value(),
                                   is_dir ? &(list_entry->second.childlist) : NULL);
            } else {
                
                
                inodetab.add_entry(histino, metadataid, file_size, true, is_dir);
            }
        }
        if(msg2)DB->msg("backemctardir6::copy_inodes_from_history adding name:%s ino:%u to elem:%s", *curDE->fullpath().image(), histino, *histoff);
    }

    
    
    
    
    undoo::vector<csustring> hlk(hlhistorytable.keys());
    for (unsigned int j=0; j<hlk.size(); j++) {
        DIRELEMp curDE;
        
        
        if (curlist.split_lookup(undefined_offset, hlk[j], curDE)) {
            unsigned int inode = hlhistorytable.lookup(hlk[j]);
            update_direlem_unix_special(curDE, -1, -1, inode, -1);
            ustring linktext = name2link.lookup(curDE->name());
            assert(!linktext.isempty());
            if (msg2) DB->msg("backemctardir6::copy_inodes_from_history needhardlinkvalues.enter(%d, %s)", inode, *linktext);
            needhardlinkvalues.enter(inode, linktext);
        } else {
            Out->msg(ERR, "<7404>Processing '%s': Unable to locate direlem in curlist with history stream name '%s'",
                     *info->direlemp->fullpath().image(), *hlk[j]);
        }
    }

    
    
    
    

    if(msg2) DB->msg("backemctardir6::copy_inodes_from_history done");
    return;
}


void
backemctardir6::update_direlem_unix_special(DIRELEMp de, bigint64 devno_, bigint64 rdev_, bigint64 inode_, bigint64 links_)
{
    assert(devno_ <= 0xFFFFFFFF);
    assert(rdev_ <= 0xFFFFFFFF);
    assert(inode_ <= 0xFFFFFFFF);
    assert(links_ <= 0xFFFFFFFF);

    unsigned int devno, rdev, inode, links;
    devno = rdev = inode = links = 0;

    if (de->get_kind() == KIND_UNIX_SP) {
        devno = de->device_number();
        rdev = de->unix_rdev();
        inode = de->inode_number();
        links = de->hard_links();
    }

    devno = ((devno_ >= 0) ? (unsigned int)devno_ : devno);
    rdev =  ((rdev_  >= 0) ? (unsigned int)rdev_ : rdev);
    inode = ((inode_ >= 0) ? (unsigned int)inode_ : inode);
    links = ((links_ >= 0) ? (unsigned int)links_ : links);

    
    
    
    de->set_unix_special(devno, rdev, inode, links);
}

void backemctardir6::finish_top_level_directory(cycle *child)
{
    
    
    
    
    if (info->use_container && info->direlemp->is_directory() && reserved_hiddendir) {
       if (!flags.incremental) {
           
           
           
           ucontainer::errortype errcode;
           if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
               ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
               Out->Abort("Problem creating container enddir for %s (%s)",
                       *info->direlemp->fullpath().image(), *errdesc);
               return;
           }

       } else {
           
           
           
           
           

           
           
           
           
           
           fileoffset system_info_dir_size;
           DIRELEMp tmpde(curlist.split_lookup(0, UNDOO_DIRECTORY_NAME));
           if (tmpde.isnull()) {
               Out->msg(ERR,"Could not find .system_info directory to determine its coverage size");
           } else {
               
               system_info_dir_size = tmpde->get_location().get_coverage_size();
               if (msg2) DB->msg("backemctardir6::finish_top_level_directory  Coverage size for .system_info directory is %"LL"d",
                                 (ubigint64)system_info_dir_size.value());
           }

           
           
           ubigint64 inode_number = 0;
           ubigint64 dir_header_size = 0;
           if (msg2) DB->msg("backemctardir6::finish_top_level_directory    Synth footer from current container (Offset:%"LL"d  Size:%"LL"d  Checksum:%u)",
                             top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum);
           synth_block(top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum, inode_number, dir_header_size, false );

           
           
           
           
           
           location loc(info->direlemp->get_location());
           loc.set_coverage_size(loc.get_coverage_size() + (merged_coverage_size + system_info_dir_size));
           info->direlemp->set_location(loc);
           if (msg2) DB->msg("backemctardir6::finish_top_level_directory  Coverage size for %s increased by (%"LL"d+%"LL"d) (now %"LL"d)",
                             *info->direlemp->name(), (ubigint64)merged_coverage_size.value(),
                              (ubigint64)system_info_dir_size.value(),(bigint64)loc.get_coverage_size().value());
       }
    }

    
    
    
    
    
    if (copy_entire_previous_backup) {
        
        
        assert(!info->direlemp->is_directory());  
        assert(my_cur_synthlistp->list_size() == 0);

        
        
        synth_volume_data(child, my_cur_synthlistp, my_prev_synthlistp);
    }

    if (info && info->use_container && !info->container.isnull()) {
        bool write_ddrfile = parser->is_empty_stream();
        main->finalizeucontainer(info->container, write_ddrfile);
    }
}

void backemctardir6::commit_directory_metadata()
{
    
    assert(ncollected == nforked);
    if(msg1)DB->msg("backemctardir6::childdone: All done, hash=%s", *hash.partialimage());
    
    
    info->direlemp->set_hash(hash);

    
    
    
    
    
    check_dirlisting_limit(flags);
    static const fileoffset dirsizelimit(flags.dirlisting_limit);
    if ((dirsizelimit > 0) && (consumed_size > dirsizelimit)) {
        double avgsize = (dirlistcount > 0) ? (consumed_size.dvalue() / double(dirlistcount)) : 0;
        Out->msg(INFO, "<10675>Directory data consumes %s bytes for %"Z"d entries, average storage used per directory entry is %lf bytes",
                 *consumed_size.image(), dirlistcount, avgsize);
        Out->msg(INFO, "<10676>Please reduce the size of this directory to allow future incremental backups.  See Avamar NDMP documentation for further details.");
    }

    
    
    
    if (!info->direlemp->is_dirrec_present(KIND_EXTRA_DIR_SIZES) && info->direlemp->is_directory()) {
        if (msg1) DB->msg("backemctardir6::commit_directory_metadata  Creating EXTRA_DIR_SIZES dirrec for empty directory '%s'", *info->direlemp->name());
        info->direlemp->increment_dirsizes(0, 0, 0);
    }

    
    
    
    if (info->use_container && flags.incremental && info->direlemp->is_directory()) {
        location loc(info->direlemp->get_location());
        loc.set_checksum_value(loc.get_checksum().value ^ merged_checksum);
        info->direlemp->set_location(loc);
        if (msg2) DB->msg("backemctardir6::commit_directory_metadata  Checksum for %s modified to %u (included %u from previous backup)",
                          *info->direlemp->name(), loc.get_checksum().value, merged_checksum);
    }
}
















#include "common.h"
#include "debug.h"
#include "restzfssslicefile.h"
#include "restdata.h"
#include "context.h"
#include "utar_flags_info.h"
#include "output.h"
#include "pipe_control.h"
#include "emctarpipe.h"
#include "platerror.h"
#include "utar_flags_enums.h"
#include "uwrapper.h"
#include "dirrec_pack.h"
#include "filerefx.h"
#include "backstate.h"
#include "zfstarstream.h"

#ifdef USEADE  
#include "msgpack_c.h"
#include "ade_mgrx.h"
#endif

#include "data_regions.h"
#include "ndmp_volume_entification.h"

using namespace zfstarstream;

#define sslice_msg ((xflag[2] & 4) != 0)


#define disablefilepipethrottling ((xflag[15] & 16777216) != 0)

void exit_error(const ustring &errmsg, const ustring &pathstr)
{
    Out->msg(ERR, "During restore of '%s': %s", *pathstr, *errmsg);
    uapp::staging().startTermination(EXIT_RESTORE_FAIL, ustring::sprintf("failed to restore '%s'", *pathstr));
}

restzfssslicefile::restzfssslicefile(bicycle* parent, DIRELEM& direlem, cycle* starter, ucontainer::basep rest_container)
  : bicycle(parent),
    ADERestore(parent->main),
    phase(phase_init),
    ppipe_control(NULL),
    realde(),
    curde(),
    realsize(0),
    realh(),
    isregularfile(false),
    islnk(false),
    isfirst(false),
    realparser(NULL),
    curparser(NULL),
    dir_offset(0),
    update_path(false),
    use_container(false),
    setactivelimit(false),
    catalog_enabled(main ? ((main->getAdeMgr()->getHfsInfo(dpn0)).metaStore != NULL) : false)
{
    ppipe_control = (main ? dynamic_cast<zfstarpipe *>(main->getpipe_control(&info)) : NULL);

    
    
    dataProvider.setup(this, this);

    assert(!direlem.is_directory());
    assert(ppipe_control);
    assert(flags.streamformat_out == utar_flags_enums::streamformat_zfs);

    nforked = 0;
    ncollected = 0;

    info.direlem = direlem;
    info.path = direlem.fullpath();

    dirrec_pack::regions drr(&info.direlem);
    if (!drr.get(eoff) || eoff.empty()) {
        exit_error("unable to find REGIONS dirrec, or is empty", *info.direlem.fullpath().image());
        phase = phase_forksdone;
        todoEnqueue(TODO_DONE, this);
        return;
    }
    cur_loc = info.direlem.get_location();
    use_container = (cur_loc.getMedia() > location::media::gsan);
    if (use_container) {
        if (rest_container.isdefined()) {
            
            info.container = rest_container;
        } else {
            
            if (sslice_msg) DB->msg("restzfssslicefile::restzfssslicefile opening container (ID:%d)", cur_loc.get_containerid());
            info.container = main->open_container_for_read(cur_loc);
        }
    }

    if (starter)
        starter->setnext(TODO_FILE, this, 0);
    else
        todoEnqueue(TODO_FILE, this);
}





void restzfssslicefile::init_real_location_data()
{
    realde = new DIRELEM;
    real_loc.setMedia(cur_loc.getMedia());
    real_loc.set_backupid(cur_loc.get_backupid());
    real_loc.set_containerid(cur_loc.get_containerid());
    real_loc.set_format(cur_loc.get_format());
    real_loc.set_abs_offset_in_container(dir_offset);
    real_loc.set_coverage_size(realsize);
    realde->set_location(real_loc);
}

void restzfssslicefile::throttle_file_cycles()
{
    
    
    
    
    
    
    
    
    
    if (!disablefilepipethrottling) {
        
        
        
        bigint64 maxfilepipedepth = (bigint64)flags.filecyclethrottlethresh * (1024 * 1024);
        
        
        
        bigint64 maxpipequeuedepth = (bigint64)flags.maxpipemb * (1024 * 1024);
        
        fileoffset reservedbytespending = ppipe_control->reserved_bytes_pending();
        
        
        fileoffset filesize = islnk ? realsize : eoff.back().second;
        
        
        
        if ( (reservedbytespending > 0) && ((reservedbytespending + filesize) > maxfilepipedepth) ) {
            
            todoEnqueueInsert(TODO_FILE, this, 1);
            return;
        }
        
        
        
        setactivelimit = ((reservedbytespending + filesize) > maxpipequeuedepth);
        if (setactivelimit) {
            
            
            main->safesetactivelimit(TODO_FILE_CACHE, "wait for large file cycle to complete", true);
        }
    }
}

void restzfssslicefile::init()
{
    
    
    
    
    islnk = main->check_zfstar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset, realeoff);

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    throttle_file_cycles();

    if (islnk) {
        if (sslice_msg)
            DB->msg("restzfssslicefile::restzfssslicefile %s inode %"LL"u, context says we're a hardlink: "
                    "isfirst:%d realde:%s realh:%s realsize:%s",
                    *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                    (realde.isnull()?"(nullde)":*realde->fullpath().image()),
                    *real_metadataid.partialimage(), *realsize.image());

        
        
        
        
        
        isregularfile = use_container ?
                    
                    ((ubigint64)info.direlem.get_location().get_abs_offset_in_container().value() == dir_offset) :
                    
                    (realh == info.direlem.file_hash());

        
        fileoffset startpos, endpos;
        if (!data_regions::findrange(eoff, data_regions::header, true, startpos, endpos)) {
            exit_error(ustring::sprintf("endoffset '%s' does not contain a header section",
                                        *data_regions::image_endoffsets(eoff)),
                                        *info.direlem.fullpath().image());
            return;
        }

        
        cycle *child1 = restore_range(info.direlem.file_hash(), startpos, endpos, true, hdrbuf, errmsg, info.direlem, info.container, use_container);
        if (!child1) {
            exit_error(ustring::sprintf("unable to create restdata cycle for header section with hash:'%s': %s",
                       *info.direlem.file_hash().partialimage(), *errmsg), *info.direlem.fullpath().image());
            return;
        }

        if (use_container)
            init_real_location_data();

        if (!data_regions::findrange(realeoff, data_regions::header, true, startpos, endpos)) {
            exit_error(ustring::sprintf("endoffset '%s' does not contain a header section",
                                        *data_regions::image_endoffsets(realeoff)),
                                        *realde->fullpath().image());
            return;
        }

        
        cycle* child2 = restore_range(realh, startpos, endpos, true, realbuf, errmsg,
                                      
                                      
                                      (use_container ? *realde : info.direlem),
                                      info.container, use_container);

        if (!child2) {
            exit_error(ustring::sprintf("unable to spawn restore of hardlink file header data: %s",
                       *errmsg), *info.direlem.fullpath().image());
            return;
        }

        phase = phase_sslice_real_header;
    } else {
        fileoffset startpos, endpos;
        if (!findrange(eoff, data_regions::header, false, startpos, endpos)) {
            exit_error(ustring::sprintf("endoffset '%s' does not contain a dirrec header section",
                       *data_regions::image_endoffsets(eoff)), *info.direlem.fullpath().image());
            return;
        }
        if (!restore_range(info.direlem.file_hash(), startpos, endpos, true, hdrbuf, errmsg, info.direlem, info.container, use_container)) {
            exit_error(ustring::sprintf("failed to restore header for file with hash:'%s': %s",
                       *info.direlem.file_hash().partialimage(), *errmsg),
                       *info.direlem.fullpath().image());
            return;
        }
        phase = phase_process_hdr_cycle;
    }

    main->set_cur_filename(info.direlem.fullpath());

    if (nforked == 0) {
        notifyparent();
        return;
    }
}

void restzfssslicefile::handleData(fileoffset foOffset, fileref& restoreData)
{
    Out->msg(ERR, "restzfssslicefile class does not implement nsAdeLib::ADERestore interface");
    assert(false);
}


void restzfssslicefile::process_header_buffer(const fileref& buf, DIRELEMp& de,
                                              const MetadataId& metadataid, parser &p)
{
    p.set_source_data(buf);
    fileref altref, stubref;
    if (!p.getentry(de, altref, stubref))
        return;

    p.recordmarks(de);
    dirrec_pack::regions drr(de.getimpl());
    data_regions::endoffsets_t tmpeoff;

    if (!drr.get(tmpeoff) || tmpeoff.empty()) {
        exit_error("unable to find data regions dirrec for hardlink realde streamslice data", *de->fullpath().image());
        return;
    }

    if (sslice_msg)
        DB->msg("restzfssslicefile::process_header_buffer parser found de for '%s', "
                "endoffsets %s, altref.size:%s stubref.size:%s",
                *de->fullpath().image(), *data_regions::image_endoffsets(tmpeoff),
                *altref.size64().image(), *stubref.size64().image());

    baselocation_sp blp(de->get_metadataLocation());
    de->set_hash(metadataid.tohashcode(), blp );

    if (rangesize(tmpeoff, data_regions::header, false) == 0) {
        exit_error("unable to determine the dirrec header section for hardlink file", *info.direlem.fullpath().image());
        return;
    }

    
    
    
    
    
    if (p.is_humongus_file())
        return;

    fileoffset startbyte;
    fileoffset endbyte;
    if (!findrange(tmpeoff, data_regions::primarydata, false, startbyte, endbyte)) {
        exit_error("unable to determine the dirrec primary data sections for hardlink file", *info.direlem.fullpath().image());
    }
}

void restzfssslicefile::childdone(cycle* child)
{
    if (sslice_msg)
        DB->msg("restzfssslicefile::childdone child:%p nforked:%d ncollected:%d phase:%d",
                child, nforked, ncollected, phase);

    if (child)   
        ncollected++;

    
    
    if (phase == phase_sslice_real_header) {
        if (ncollected < nforked)
            return;
        if (sslice_msg)
            DB->msg("realbuf:%s for '%s' %"LL"u", *realbuf.size64().image(),
                    *info.direlem.fullpath().image(), info.direlem.inode_number64());
        
        
        
        
        
        
        process_header_buffer(realbuf, realde, real_metadataid, realparser);
        dirrec_pack::regions drr(realde.getimpl());
        drr.set(realeoff);
        if (use_container)
            realde->set_location(real_loc);
        phase = phase_sslice_header;
    }
    if (phase == phase_forksdone) {
        
        
        if (ncollected < nforked)
            return; 

        
        
        if (setactivelimit)
            main->safesetactivelimit(TODO_MAX, "large file cycle complete", true);

        if (sslice_msg)
            DB->msg("restzfssslicefile::childdone %s num_open_files=%d",
                     *info.direlem.fullpath().image(), +main->num_open_files);

        databuf.free();

        notifyparent();
        return;
    }
    if (phase == phase_process_hdr_cycle) {
        if (ncollected < nforked)
            return;
        MetadataId de_metadataid(info.direlem.file_hash());
        process_header_buffer(hdrbuf, curde, de_metadataid, curparser);
        dirrec_pack::regions drr(curde.getimpl());
        drr.set(eoff);
        if (use_container)
            curde->set_location(cur_loc);
        update_path = curparser.path_changed(info.path.image());
        process_regular_file();
    }
    if (phase == phase_sslice_header) {
        if (ncollected < nforked) {
            if (sslice_msg)
                DB->msg("returning because we have not collected all forked children");
            return;
        } else {
            if (sslice_msg)
                DB->msg("continuing with phase_sslice_header: nforked %d ncollected %d", nforked, ncollected);
        }

        if (sslice_msg)
            DB->msg("tmpbuf:%s for '%s' %d", *hdrbuf.size64().image(),
                    *info.direlem.fullpath().image(), info.direlem.inode_number());

        
        MetadataId de_metadataid(info.direlem.file_hash());
        process_header_buffer(hdrbuf, curde, de_metadataid, curparser);
        dirrec_pack::regions drr(curde.getimpl());
        drr.set(eoff);
        if (use_container)
            curde->set_location(cur_loc);
        update_path = curparser.path_changed(info.path.image());

        if (!realde.isnull()) {
            if (sslice_msg)
                DB->msg("restzfssslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde:'%s' %s eattr:%d",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *curde->fullpath().image(), *curde->file_hash().partialimage(), curde->get_security_size(),
                                    *realde->fullpath().image(), *realde->file_hash().partialimage(), realde->get_security_size());
        } else {
            if (sslice_msg)
                DB->msg("restzfssslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde: (null)",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *curde->fullpath().image(), *curde->file_hash().partialimage(), curde->get_security_size());
        }
    }

    islnk = main->check_zfstar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset, realeoff);

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    if (islnk) {
        if (!isfirst) {
            Out->msg(INFO, "%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, %s to link",
                     *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                     *info.direlem.file_hash().partialimage(), isregularfile ? "regular" : "link");
            process_reg_or_link_to_link();
            
            main->record_one_hardlink_restore(info.direlem);
            main->byteprogress(context::restorestats, stats::hardlink, data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());
        } else {
            main->record_hardlinked_file(*curde.getimpl());
            if (isregularfile) {
                Out->msg(INFO, "%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, regular to regular",
                         *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                         *info.direlem.file_hash().partialimage());
                process_regular_file();
            } else {
                Out->msg(INFO, "%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, link to regular",
                         *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                         *info.direlem.file_hash().partialimage());

                
                
                
                if (!catalog_enabled) {
                    
                    realde->set_hash(realh);
                }
                process_link_to_reg();
            }
        }
    }

    main->print_path(info.direlem);
    
    
    
    
    
    main->addfilebytes(context::restorestats, data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());

    phase = phase_forksdone;
    childdone(0);
}

restzfssslicefile::~restzfssslicefile()
{
}




void restzfssslicefile::process_link_to_reg()
{
    realparser.set_path(info.path.image());
    realparser.get_header_image(hdrbuf);
    fileoffset datastartpos, dataendpos;
    fileoffset primarydatasize;
    if (findrange(realeoff, data_regions::primarydata, false, datastartpos, dataendpos)) {
        if (dataendpos > datastartpos) {
            primarydatasize = dataendpos - datastartpos;
            primarydatasize += get_padding(primarydatasize.value());
        }
    } else {
        exit_error("unable to determine the dirrec primary data sections for '%s'", *realde->fullpath().image());
        return;
    }
    fileoffset xattrstartpos, xattrendpos;
    fileoffset xattrsize;
    if (findrange(realeoff, data_regions::ads, false, xattrstartpos, xattrendpos)) {
        if (xattrendpos > xattrstartpos) {
            xattrsize = xattrendpos - xattrstartpos;
            xattrsize += get_padding(xattrsize.value());
        }
    }
    fileoffset startpos, endpos;
    if (primarydatasize > 0) {
        startpos = datastartpos;
        endpos = dataendpos;
        if (xattrsize > 0)
            endpos = xattrendpos;
    } else if (xattrsize > 0) {
        startpos = xattrstartpos;
        endpos = xattrendpos;
    }
    ppipe_control->set_data_slice(hdrbuf, "header");
    fileoffset totaldatasize = primarydatasize + xattrsize;
    if (totaldatasize > 0) {
        ppipe_control->init_data_slice(databuf, totaldatasize, "data");
        if (!restore_range(realde->file_hash(), startpos, endpos, true, databuf, errmsg, *realde.getimpl(), info.container, use_container)) {
            exit_error(ustring::sprintf("failed to restore data for file with hash:'%s': %s",
                       *realde->file_hash().partialimage(), *errmsg), *realde->fullpath().image());
        }
    }
}



void restzfssslicefile::process_reg_or_link_to_link()
{
    curparser.set_path(info.path.image());
    curparser.get_header_image(hdrbuf, true);
    ppipe_control->set_data_slice(hdrbuf, "header");
}

void restzfssslicefile::process_regular_file()
{
    if (update_path) {
        
        curparser.set_path(info.path.image());
        curparser.get_header_image(hdrbuf);
        fileoffset datastartpos, dataendpos;
        fileoffset primarydatasize;
        if (findrange(eoff, data_regions::primarydata, false, datastartpos, dataendpos)) {
            if (dataendpos > datastartpos) {
                primarydatasize = dataendpos - datastartpos;
                primarydatasize += get_padding(primarydatasize.value());
            }
        } else {
            exit_error("unable to determine the dirrec primary data sections for '%s'", *curde->fullpath().image());
            return;
        }
        fileoffset xattrstartpos, xattrendpos;
        fileoffset xattrsize;
        if (findrange(eoff, data_regions::ads, false, xattrstartpos, xattrendpos)) {
            if (xattrendpos > xattrstartpos) {
                xattrsize = xattrendpos - xattrstartpos;
                xattrsize += get_padding(xattrsize.value());
            }
        }
        fileoffset startpos, endpos;
        if (primarydatasize > 0) {
            startpos = datastartpos;
            endpos = dataendpos;
            if (xattrsize > 0)
                endpos = xattrendpos;
        } else if (xattrsize > 0) {
            startpos = xattrstartpos;
            endpos = xattrendpos;
        }
        ppipe_control->set_data_slice(hdrbuf, "header");
        fileoffset totaldatasize = primarydatasize + xattrsize;
        if (totaldatasize > 0) {
            ppipe_control->init_data_slice(databuf, totaldatasize, "data");
            if (!restore_range(curde->file_hash(), startpos, endpos, true, databuf, errmsg, *curde.getimpl(), info.container, use_container)) {
                exit_error(ustring::sprintf("failed to restore data for file with hash:'%s': %s",
                           *curde->file_hash().partialimage(), *errmsg), *curde->fullpath().image());
            }
        }
    } else {
        fileoffset totalslicesize = eoff.back().second;
        ppipe_control->init_data_slice(databuf, totalslicesize, "filedata");
        if (!restore_range(curde->file_hash(), 0, totalslicesize, true, databuf, errmsg, *curde.getimpl(), info.container, use_container)) {
            exit_error(ustring::sprintf("failed to restore data for file with hash:'%s': %s",
                       *curde->file_hash().partialimage(), *errmsg), *curde->fullpath().image());
        }
    }
}






restzfscrossfile::restzfscrossfile(cycle* parent, DIRELEM& de, cycle *starter, ucontainer::basep container)
    : cycle(parent), phase(phase_file_hdr), usecontainer(false)
{
    info.direlem = de;
    info.path = de.fullpath();
    dirrec_pack::regions drr(&info.direlem);
    if (!drr.get(eoff) || eoff.empty()) {
        exit_error("unable to find REGIONS dirrec, or is empty", *info.path.image());
        phase = phase_forksdone;
        todoEnqueue(TODO_DONE, this);
        return;
    }
    location cur_loc = info.direlem.get_location();
    usecontainer = (cur_loc.getMedia() > location::media::gsan);
    if (usecontainer) {
        if (container.isdefined()) {
            info.container = container;
        } else {
            info.container = main->open_container_for_read(cur_loc);
        }
    }
    if (starter)
        starter->setnext(TODO_FILE, this, 0);
    else
        todoEnqueue(TODO_FILE, this);
}

void restzfscrossfile::init()
{
    fileoffset startpos, endpos;
    if (!findrange(eoff, data_regions::header, false, startpos, endpos)) {
        exit_error("unable to find dirrec header section", *info.path.image());
        return;
    }
    read_data(startpos, endpos);
}

void restzfscrossfile::childdone(cycle* child)
{
    if (child) ncollected++;

    switch (uapp::staging().canRun() ? phase : phase_forksdone) {
    case phase_file_hdr:
        process_file_hdr();
        break;
    case phase_subfile_hdr:
        process_subfile_hdr();
        break;
    case phase_subfile_data:
        process_subfile_data();
        break;
    case phase_forksdone:
        if (ncollected < nforked) return;
        streambuf.free();
        info.direlem.set_file_attributes(flags.permissions);
        notifyparent();
        break;
    }
}

void restzfscrossfile::init_file_stream()
{
    bool security_lost;
    bool renamed;
    filerefx::initpipestream(streambuf,
                             info.direlem,
                             false,
                             false,
                             flags.restoreshortnames,
                             false,
                             security_lost,
                             flags.openfilerestoreoption,
                             renamed,
                             flags.restore_sparsekb*1024);
}

void restzfscrossfile::process_file_hdr()
{
    zfstarstream::parser p;
    p.set_source_data(readbuf);
    fileref altref, stubref;
    DIRELEMp tmpde;
    if (!p.getentry(tmpde, altref, stubref)) {
        exit_error("invalid data found, problem restoring file", *info.path.image());
        return;
    }
    fileoffset startpos, endpos;
    if (!findrange(eoff, data_regions::primarydata, false, startpos, endpos)) {
        exit_error("unable to determine the dirrec primary data sections", *info.path.image());
        return;
    }
    datasize = endpos - startpos;
    info.direlem.set_file_size(datasize);
    
    
    
    if (p.is_humongus_file() && (datasize > 0)) {
        
        
        
        datasize = p.file_size();
        
        
        info.direlem.set_file_size(datasize);
        init_file_stream();
        phase = phase_subfile_hdr;
        read_data(curoffset, BLOCKSIZE);
        return;
    }
    phase = phase_forksdone;
    init_file_stream();
    if (datasize > 0) {
        write_data(curoffset, datasize);
        return;
    }
    childdone(0);
}

void restzfscrossfile::process_subfile_hdr()
{
    zfstarstream::header h(readbuf);
    if (!h.isgood()) {
        exit_error("invalid data found, problem restoring file", *info.path.image());
        return;
    }
    if (h.is_long_name()) {
        curoffset += h.size;
        curoffset += get_padding(h.size);
        read_data(curoffset, BLOCKSIZE);
    } else {
        write_data(curoffset, h.size);
        curoffset += get_padding(h.size);
        phase = phase_subfile_data;
    }
}

void restzfscrossfile::process_subfile_data()
{
    if (streamoffset < datasize) {
        read_data(curoffset, BLOCKSIZE);
        phase = phase_subfile_hdr;
        return;
    }
    phase = phase_forksdone;
    childdone(0);
}

void restzfscrossfile::read_data(const fileoffset& pos, const fileoffset& size)
{
    readbuf.free();
    cycle *child = restore_range(info.direlem.file_hash(), pos, pos + size, true, readbuf, errmsg, info.direlem, info.container, usecontainer);
    if (!child) {
        exit_error(ustring::sprintf("unable to spawn cycle to restore file data: %s", *errmsg), *info.path.image());
        return;
    }
    curoffset += size;
}

void restzfscrossfile::write_data(const fileoffset& pos, const fileoffset& size)
{
    fileref writebuf;
    writebuf.initslice6464(streambuf, streamoffset, size);
    cycle *child = restore_range(info.direlem.file_hash(), pos, pos + size, true, writebuf, errmsg, info.direlem, info.container, usecontainer);
    if (!child) {
        exit_error(ustring::sprintf("unable to spawn cycle to write file data: %s", *errmsg), *info.path.image());
        return;
    }
    curoffset += size;
    streamoffset += size;
}
















#include "common.h"
#include "debug.h"
#include "filemap.h"
#include "restfile.h"
#include "restdata.h"
#include "restdephash.h"
#include "todoelem.h"
#include "context.h"
#include "hard_link_id.h"
#include "utar_flags_info.h"
#include "output.h"
#include "pipe_control.h"
#include "winversion.h"
#include "timecnv.h"
#include "platerror.h"
#include "utar_flags_enums.h"
#include "streamtransformzip.h"
#include "uwrapper.h"
#include "dirrec_pack.h"
#include "filerefx.h"
#include "restextents.h"
#include "backstate.h"
#include "ade_multivolume.h"

#if SYSTEM_WINDOWS
typedef BOOL (WINAPI *PFN_MoveFileEx)(LPTSTR, LPTSTR, DWORD);
static HINSTANCE hKernel32Inst = 0;
static PFN_MoveFileEx     MoveFileEx_pfn  = 0;
#include "ntsecurity.h"
#include "uwstring.h"
#include "mapistream.h"
#include "upath_win.h"
#include "windedup.h"
#endif

#ifdef USEADE  
#include "msgpack_c.h"
#include "ade_mgrx.h"
#endif

#include "data_regions.h"

#define restfile_msgs ((xflag[2]&4)!=0)
#define cmr10_msgs    ((xflag[19]&524288) != 0)

#define dowfs    ((xflag[15]&2)==0)


#define do_windows_license_check ((xflag[15] & 1048576) == 0)


#define disablenewcelerrahardlinkrest ((xflag[20]&32768)!=0)

enum phases { phase_init        = 0,  
              phase_emctar_dedup = 1, 
              phase_get_gsan_extents = 2, 
              phase_forksdone   = 3  
            };

restfile::restfile(bicycle *parent, const hashcode& hash,
                   DIRELEM& direlem,
                   ucontainer::basep container,
                   cycle *starter,
                   const volinfo vinfo,
                   fileoffset startoff, fileoffset endoff,
                   const unsigned _opts 
)
  : bicycle(parent),
    ADERestore(parent->main),
    m_bRenamed(false),
    m_bSecurityLost(false),
    threadStarter(false),
    threadShutdown(false),
    phase(phase_init),
    opts(_opts),
    original_file_size(0),
    size_reported(false)
{
#if !NOADECHUNKER
    dataProvider.setup(this, this);
#endif

    assert( !direlem.is_directory() );
    assert( flags.dtoexportstream || !direlem.is_symlink() || restelem::is_celerra_streamslice_restore(direlem, main->state->pid_of_backup, flags.pluginid) );
    assert( !direlem.should_skip_this_file() );

    

    
    if(direlem.should_skip_this_file()) {
        DB->msg("restfile::restfile(%p) thread:%d '%s' hash:%s was supposed to be skipped!", this, getThreadNbr(), *direlem.fullpath().image(), *direlem.file_hash().partialimage());
    }

    this->hash = hash;
    const bool isddrdata( direlem.get_location().getMedia() == location::media::ddr);
    if(hash == hashcode::zero && !isddrdata) {
        DB->msg("restfile::restfile(%p) hash is zero -- '%s' start:%.0f endbyte:%.0f hash=%s",
            this, *direlem.fullpath().image(), info.startbyte.dvalue(), info.endbyte.dvalue(), *hash.partialimage());
    }
    m_hcOriginalRoot = hash; 
    this->info.direlem = direlem;
    this->info.path = direlem.fullpath();
    this->info.vinfo = vinfo;
    this->info.container = container;
    this->info.startbyte = startoff;
    this->info.endbyte = endoff;
    this->info.checkrange = this->info.endbyte > fileoffset(0);
    this->delonerror = true;
    this->nforked = 0;
    this->ncollected = 0;
    this->decrementfilecount = false;

    
    multivolumeroot* root_info = getrootinfo();
    ustring filename = direlem.fullpath().patha();
    
    
    const upath pathToCheck(direlem.fullpath());
    if (root_info != NULL && isNewStreamThreadOK(getThreadNbr(), pathToCheck)) {
        
        info.container = NULL;

        
        
        root_info->enqueueRequestRC(TODO_RESPONSE, EMPTYCYCLE, -1, error);

        
        if (restfile_msgs) DB->msg("restdir::restdir() '%s' changing track (parent:%p) (this:%p)", *filename, parent, this);
        if (flags.parallel_type == utar_flags_enums::parallel_by_volume)
            threadStarter = root_info->enqueueOnVolumeThread(direlem.fullpath(), TODO_FILE, this, 0, NULL);
        else
            threadStarter = root_info->enqueueOnNewThreadRC(filename, TODO_FILE, this, 0);
    } else if(starter)
        starter->setnext(TODO_FILE, this, 0);
    else
        todoEnqueue(TODO_FILE, this); 

    
    if ((!enableslicerestore ||             
         flags.isexplicit("celerrai18n") || 
         (flags.streamformat_out != utar_flags_enums::streamformat_emctar)) &&
        
        !flags.dtoexportstream) {
        this->info.init_data_regions_primarydata();
    }

    if(restfile_msgs) {
        DB->msg("restfile::restfile path:'%s' startoff:%s endoff:%s start:%.0f endbyte:%.0f to-stdout:%d vinfo:%s loc:%s",
                *info.path.image(), *startoff.image(), *endoff.image(), info.startbyte.dvalue(), info.endbyte.dvalue(),
                flags.to_stdout, *vinfo.image(), *info.direlem.get_location().image());
    }
};


bool restfile::isemctardedup(const DIRELEM& de, hashcode &cdhash, fileoffset &cdsize) const
{
    dirrec_pack::emctar_dedup epd(&de);
    fileoffset streamsize, uncompsize;
    unsigned char cddepoff;

    if (epd.get(streamsize, uncompsize, cdsize, cddepoff)) {
        if (cmr10_msgs) DB->msg("restfile::isemctardedup %s is a dedup file %s %s, compressordata %s bytes at dephash:%d",
                                *de.fullpath().image(), *streamsize.image(), *uncompsize.image(), *cdsize.image(), cddepoff);
        hashvect hashes;
        de.getdephashes(hashes);
        if (hashes.size() <= (unsigned)cddepoff + 1) {
            DB->error("restfile::isemctardedup found cddepoff %d+1, but hashes.size():%"Z"d indicates that we don't have enough hashes in the dephashlist",
                      cddepoff, hashes.size());
            return false;
        }
        cdhash = hashes[cddepoff+1];
        if (cmr10_msgs) DB->msg("restfile::isemctardedup found compressordata %s, of %s bytes",
                                *cdhash.partialimage(), *cdsize.image());
        return true;
    }
    return false;
}

void restfile::init() {

    
    
    if(threadShutdown) {
        notifyparent();
        return;
    }

    if (phase == phase_init && flags.restoreprefetchmb > 0) {
        const location loc(info.direlem.get_location());
        if(loc.getMedia() == location::media::gsan) {
            
            restfile *rf = dynamic_cast<restfile*>(get_next_cycle());
            if (rf) {
                cycle *c = new smallfile_prefetcher(rf, main);
                c->noop();
            }
        }
    }

    

    if (restfile_msgs) DB->msg("restfile(%p)::init() file='%s'", this, *(info.path.image()));

    hashcode compressordatahash;
    fileoffset compressordatasize;
    if ((phase == phase_init) && isemctardedup(info.direlem, compressordatahash, compressordatasize)) {
        if (cmr10_msgs)
            DB->msg("restfile::init %s starting restdata cycle to restore %s bytes of compressordata %s",
                    *info.direlem.fullpath().image(), *compressordatasize.image(), *compressordatahash.partialimage());
        compressordata.initmem((size_t)compressordatasize.value());
        restelem cdinfo(compressordata);
        
        nforked++;
        restdata *cdcycle = new restdata(this, compressordatahash, NULL, true, cdinfo);
        phase = phase_emctar_dedup;
        cdcycle->noop();
        return;
    }

    
    if(main->getpipe_control(&info) != NULL && (flags.streamformat_out == utar_flags_enums::streamformat_pax)) {
        hashcode gsan_extents(getextentshash(info.direlem));
        if ((phase == phase_init) && gsan_extents != hashcode::zero) {
            DB->msg("restfile::init calling restextents %s", *gsan_extents.partialimage());
            gsan_extentsdata.initlist();
            restelem extents_info(info.direlem.fullpath(), info.direlem, info.fstats, gsan_extentsdata);
            nforked++;
            cycle *child = new restdata(this, gsan_extents, NULL, false, extents_info);
            child->noop();
            phase = phase_get_gsan_extents;
            return;
        }
    }

    
    

    
    main->set_cur_filename(info.direlem.fullpath());

    bool checknormalhardlink = true;
    if (process_emctar_hardlinks(checknormalhardlink)) {
        if (restfile_msgs) DB->msg("restfile::init %s returning after process_emctar_hardlink returned true", *info.direlem.fullpath().image());
        phase = phase_forksdone;
        childdone(NULL);
        return;
    }

    

    fileref altdataslice, stubdataslice;
    
    if( checknormalhardlink && main->hardlinked_file(info.direlem, this->m_hcOriginalRoot, altdataslice, stubdataslice) ) {
        
        
        


        main->print_path(info.direlem);
        main->addfilebytes(context::restorestats, info.direlem.file_size().dvalue()); 
        main->byteprogress(context::restorestats, stats::hardlink, info.direlem.file_size().dvalue());   

        const bool is_emctar_restore = ((main->getpipe_control(&info) != NULL) && main->getpipe_control(&info)->is_emctar());
        if (is_emctar_restore && (altdataslice.size64()>0 || stubdataslice.size64()>0)) {
            if (restfile_msgs) DB->msg("restfile::init found hardlink for direlem %s with altsize:%s stubsize:%s",
                                       *info.direlem.fullpath().image(), *altdataslice.size64().image(), *stubdataslice.size64().image());

            if(stubdataslice.size64()>0)         restore_pipe_stubdata(stubdataslice);
            if(dowfs && altdataslice.size64()>0) restore_pipe_altdata(altdataslice);

            phase = phase_forksdone;
            childdone(NULL);
        } else {
            notifyparent();
        }
        return;
    }

    
    if(!flags.streaming_an_archive() && !flags.validate) {
        bool    bExists = false;
        bool    bExistsAsFile = false;
        bool    bExistsAsSymlink = false;

        if( !should_restore(info, flags, bExists, bExistsAsFile, bExistsAsSymlink) ) {
            if (restfile_msgs) DB->msg("restfile::init about to call context::hardlinkable_file_read for '%s'", *info.direlem.fullpath().image());
            main->hardlinkable_file_ready(info.direlem);
            main->getstatsobj(context::restorestats)->update(stats::skipped, info.direlem.file_size().dvalue(), chunktype(0), main->handling_system_info());
            main->addfilebytes(context::restorestats, info.direlem.file_size().dvalue()); 
            main->addprogbytes(context::restorestats, info.direlem.file_size().dvalue());
            notifyparent();
            return;
        }

        
        
#if SYSTEM_WINDOWS
        if( bExistsAsSymlink && !ReparsePoints::ShouldCreateReparsePoint(REPARSE_USER_SYMLINK_FILE)) {
            Out->msg(INFO, 2, "<6226>Replacing existing symbolic link \"%s\" with file.  Use --reparse-restore-option=linksandtargets to replace the target.", *info.direlem.fullpath().image());
            upath up = upath(info.direlem.fullpath().image());

            if( _wremove( *up.pathw("_wremove",false,false) ) != 0 ) {
               platerror pe(platerror::use_clib);
               Out->msg(ERR, "<6227>Could not delete existing symbolic link \"%s\" (%s)", *info.direlem.fullpath().image(), *pe.description());
            }
        }
#else
        if( bExistsAsSymlink && !flags.dereference) {
            Out->msg(INFO, 2, "<6226>Replacing existing symbolic link \"%s\" with file.  Use --dereference to indirect through symbolic links.", *info.direlem.fullpath().image());
            if (::unlink(*info.direlem.fullpath().image()) < 0) {
               platerror pe;
               Out->msg(ERR, "<6227>Could not delete existing symbolic link \"%s\" (%s)", *info.direlem.fullpath().image(), *pe.description());
            }
        }
#endif
    }

    
    
    bool restdata_required(true);

    
    
    bool keep = flags.incremental;  


    if(pipe_control *ppipe_control = main->getpipe_control(&info)) {
        const pipe_control::filetype filetype(static_cast<pipe_control::filetype>(get_archive_filetype()));
        if (restfile_msgs) DB->msg("restfile(\"%s\"): PIPE_CONTROL", *info.path.image());
        if(flags.streamformat_out != utar_flags_enums::streamformat_avpax &&
           flags.streamformat_out != utar_flags_enums::streamformat_cdsf) {
            fileref altdataslice;
            fileref stubdataslice;

            
            
            ppipe_control->addfile(info.direlem, info.path.image(), info.data, altdataslice, stubdataslice, gsan_extentsdata, filetype);

            if(restfile_msgs)DB->msg(DBTXT("restfile::init found data:%s direlem:%s diff:%s extents.size:%d stubdataslice.size64():%s"),
                                     *info.data.size64().image(), *info.direlem.file_size().image(),
                                     *(info.data.size64() - info.direlem.file_size()).image(), gsan_extentsdata.size(), *stubdataslice.size64().image());

            
            if(stubdataslice.size()>0) {
                restore_pipe_stubdata(stubdataslice);
            }

            
            if(dowfs && altdataslice.size64()>0) {
                restore_pipe_altdata(altdataslice);
            }
        } else {
            

             
             const fileoffset realsizeofdata(info.direlem.file_size());
             
             if((opts & opt_nofilter) != 0) {
                 info.direlem.set_file_size(original_file_size);
             }

             ppipe_control->addobj(filetype,
                                   info.path.image(),
                                   info.direlem,
                                   realsizeofdata,
                                   info.data);

             
             
             if(info.data.isnull()) {
                 restdata_required = false;
             }

            
            if((opts & opt_dephash) != 0) {
                ppipe_control->finobj(filetype, info.path.image(), info.direlem);
            }

             
             info.direlem.set_file_size(realsizeofdata);
        }

    } else if(flags.streamformat_out == utar_flags_enums::streamformat_dump) {
        if (restfile_msgs) DB->msg("restfile(\"%s\"): DUMPFORMAT", *info.path.image());
    } else if(flags.validate && !main->handling_system_info()) {
        if (restfile_msgs) DB->msg(DBTXT("restfile(\"%s\"): Handling system_info"), *info.path.image());
        info.data.initmem(1);   
    } else if(flags.memmap) {
        if (restfile_msgs) DB->msg("restfile(\"%s\"): MEMMAP", *info.path.image());
        info.data.initmap(info.path.image(), info.direlem, filemap::write, keep);
    } else {
        if (restfile_msgs) DB->msg(DBTXT("restfile(\"%s\"): Normal initpipestream"), *info.path.image());

        
        
        
        
        
        
        
        
        
        const bool extract_backup_data = flags.incremental || (xflag[15]&1)!=0 ||
            flags.streaming_an_archive() || (get_system_version()==OS_windows_NT && !info.vinfo.isAdvancedFS());

#if SYSTEM_UNIX_MACOSX
        
        const bool use_BackupWrite = info.direlem.is_macosx_file() && (!flags.incremental) && (xflag[6]&4096)==0;
#else
        
        
        
        
        const bool use_BackupWrite = info.direlem.useBackupOps() && (get_system_version() == OS_windows_NT) && info.vinfo.isAdvancedFS() && (!flags.incremental) && (xflag[6]&4096)==0;
#endif

        
        if(use_BackupWrite) assert(!extract_backup_data);

        
        
        if (info.direlem.is_reparsePoint()) {
            ReparsePoints::HandleReparsePointForRestore(info.direlem, flags.permissions, flags.to_stdout, flags.validate, flags.existingfileoverwriteoption,
                                        flags.restoreshortnames, flags.existingdiraclrestore, flags.interceptorCheck);
        }

        main->num_open_files++;         
        decrementfilecount=true;
        if (restfile_msgs) DB->msg( "restfile::init calling filerefx::initpipestream %s use_Backup_Write=%d, extract_backup_data=%d, num_open_files=%d",
                                   *info.direlem.fullpath().image(), use_BackupWrite, extract_backup_data, +main->num_open_files );

        
        if(xflag[11]&32) {                  
            fname = ustring("(") + info.direlem.fullpath().image() + ustring(") ");
            main->open_files_list += fname;
        }

        
        
        
        filerefx::initpipestream(info.data,
                                info.direlem,
                                keep,
                                use_BackupWrite,                
                                flags.restoreshortnames,
                                extract_backup_data,            
                                m_bSecurityLost,
                                flags.openfilerestoreoption,
                                m_bRenamed,
                                flags.restore_sparsekb*1024);   
    }

    if( info.data.iserror(filebase::ERRCODE_WARN)) {
        delonerror = (exists()==false);
        if( info.data.iserror(filebase::ERRCODE_ERR)) {
            DB->msg(DBTXT("\"%s\": failure to restore file or permissions"), *info.direlem.fullpath().image());
            set_error(true, ustring(""));
        }
        notifyparent(); 
        return;
    }

    main->hardlinkable_file_ready(info.direlem);

    main->print_path(info.direlem);


    const location loc(info.direlem.get_location());
    if(restdata_required && loc.getMedia() > location::media::gsan && info.container.isnull()) {
        if(restfile_msgs)DB->msg("restfile::restfile opening new container for '%s'", *info.path.image());
        info.container = main->open_container_for_read(loc);
    }



    if(info.data.iserror(filebase::ERRCODE_WARN) && info.data.canretry()) {
        DB->msg(DBTXT("retrying file %s\n"), *info.direlem.fullpath().image());
        todoEnqueue(TODO_FILE, this); 
        main->safesetactivelimit(TODO_CHUNK);
        return;
    }

    
    int sizehint = -1;
    if(info.direlem.file_size().value() < 0xFFFF)
        sizehint = (int)info.direlem.file_size().value();

    fileoffset t = fileoffset(sizehint);

    
    
    {
        bool bIsSpecialZip = false;
        const ustring usExtension = info.direlem.file_name_extension();
        if( info.direlem.useBackupOps() && StreamtransformZip::isExtensionSpecialZip( usExtension.tostr() ) && ((opts & opt_nofilter) == 0) ) {
            bIsSpecialZip = info.enableSpecialZipProcessing(flags.shrinkofficexml);
        }
    }

    
    const bool process_extents = (main->getpipe_control(&info) != NULL && main->getpipe_control(&info)->have_extentsdata());

    ADEMgrX* adeMgr = main->getAdeMgr();

    
    const  bool isemctar ((flags.streamformat_out == utar_flags_enums::streamformat_emctar)
                       || (flags.streamformat_out == utar_flags_enums::streamformat_dump));
    
    
    if (adeMgr != NULL && !process_extents && !isemctar && adeMgr->ADEChunkerEnabled() && loc.get_format() != location::tformat::cdsf) {
#ifdef USEADE  
        

        
        
        
        phase = phase_forksdone;
#if !NOADECHUNKER
        dataProvider.getFileData(hash, info);
#endif
#endif

    } else {
        if (restfile_msgs)
            DB->msg("restfile::init(restdata_required=%d) %s about to spawn %s cycle with hash:%s or %s, isSpecialCelerraProcessing():%d info.direlem.file_size():%lf",
                    restdata_required, *info.direlem.fullpath().image(), process_extents?"restextents":"restdata",
                    *hash.image(), *m_hcOriginalRoot.image(),  
                    info.isSpecialCelerraProcessingEnabled(), info.direlem.file_size().dvalue());
        
        
        
        
        
        if (!size_reported) {
            main->addfilebytes(context::restorestats, info.direlem.file_size().dvalue());
            size_reported = true;
        }

        
        cycle *child(0);
        if (process_extents) {
            DB->msg("restfile::init calling restextents extents");
            child = new restextents(this, hash, NULL, info.direlem.is_atomic(), info, fileoffset(0), t);
        } else {
            if(restdata_required) {
                child = new restdata(this, m_hcOriginalRoot, NULL, info.direlem.is_atomic(), info, fileoffset(0), t,
                                     NULL, 0, fileref::empty, -1, NULL, (info.direlem.get_location().getMedia() > location::media::gsan));
            }
        }
        if(child) {
            nforked++;
            child->noop();
        }

        
        
        

        
        if(flags.dtoexportstream &&
           (flags.streamformat_out == utar_flags_enums::streamformat_avpax ||
            flags.streamformat_out == utar_flags_enums::streamformat_cdsf)) {
            hashvect hashes;
            info.direlem.getdephashes(hashes);

            
            if(hashes.size() > 1) {
                
                for(hashvect::size_type i = 1; i < hashes.size(); i++) {
                    nforked++;

                    
                    
                    
                    
                    

                    DIRELEM dephashde;

                    

                    
                    
                    
                    
                    

                    
                    

                    dephashde.set_name(tostr(i - 1));
                    dephashde.set_fullpath(info.direlem.fullpath());
                    dephashde.set_hash(hashes[i]);
                    dephashde.set_mtime(info.direlem.mtime());

                    restdephash* mychild = new restdephash(this, hashes[i], dephashde);

                    
                    mychild->set_info_pipe_control(info.ppipe_control);
                }
            }
        }

        phase = phase_forksdone;
        childdone(NULL);
    }
}





void restfile::handleData(fileoffset offset, fileref& restoreData)
{
    assert(main->ADEChunkerEnabled());
    if (!flags.validate)
        info.exportdata(offset, restoreData);   
    main->set_cur_filename(info.direlem.fullpath()); 
    main->addprogbytes(context::restorestats, restoreData.size());
}





hashcode restfile::getextentshash(const DIRELEM& de) const {
    dirrec_pack::data_extents ext(&de);
    int hashindex(0);
    if (!ext.get(hashindex)) return hashcode::zero;
    hashvect hashes;
    de.getdephashes(hashes);
    return hashes[hashindex+1];
}



unsigned restfile::get_archive_filetype() const
{
    unsigned ret(pipe_control::REGTYPE);

    
    if((opts & opt_nofilter) != 0) {
        ret = pipe_control::NOFILTERREGTYPE;
    }

    
    if((opts & opt_dephash) != 0) {
        
        
        
        const unsigned index(info.direlem.name().touint());

        ret = pipe_control::DEPHASHTYPE_FIRST + index;

        if(ret >= pipe_control::AFTERLASTFILETYPE) {
            DB->error("restfile::get_archive_filetype() range error: 0x%x '%s' '%s' %u %u",
                      opts, *info.direlem.fullpath().image(), *info.direlem.name(), index, ret);
        }
    }

    return ret;
}


bool restfile::handle_emctardedup_childdone() const
{
    
    if (compressordata.isnull()) {
        Out->msg(ERR, "<10501>Attempting to restore compressordata for emctardedup file '%s' resulted in null fileref",
                 *info.direlem.fullpath().image());
        return false;
    }
    if (compressordata.size() <= 0) {
        Out->msg(ERR, "<10502>Attempting to restore compressordata for emctardedup file '%s' resulted in fileref with %d byte size",
                 *info.direlem.fullpath().image(), compressordata.size());
        return false;
    }
    if (restfile_msgs) DB->msg("restfile::childdone '%s' in phase_emctar_dedup we have compressordata.size():%d with content:\n%s",
                               *info.direlem.fullpath().image(),
                               compressordata.size(),
                               *compressordata.headdump(std::min(compressordata.size(), 255)));

    hashcode checkhash;
    fileoffset checksize;
    bool checkdedup = isemctardedup(info.direlem, checkhash, checksize);
    if (!checkdedup) {
        Out->msg(ERR, "<10503>Restoring deduped file '%s', direlem no longer indicates a deduped file",
                 *info.direlem.fullpath().image());
        return false;
    }
    if (compressordata.size64() != checksize) {
        Out->msg(ERR, "<10504>Attempting to restore compressordata for emctardedup file '%s', %d bytes of restored data, does not match %s bytes for target hash %s",
                 *info.direlem.fullpath().image(), compressordata.size(), *checksize.image(), *checkhash.partialimage());
        return false;
    }

    return true;
}





void restfile::childdone(cycle *child) {
    if(restfile_msgs)DB->msg("restfile(%p)::childdone() (%s at %p) nforked:%d ncollected:%d phase:%d file='%s'", this, child ? typeid(*child).name() : "unk",
            child, nforked, ncollected, phase, *info.direlem.fullpath().image());

    if (child) {         
        ncollected++;

        if(child->has_error()) {
            if ( delonerror &&                        
                ! (flags.keeponerror || flags.streaming_an_archive() || flags.validate) )
            {
                Out->msg(INFO, "<5627>Removing \"%s\" - File could not be fully restored due to error.", *info.direlem.fullpath().image());
                
                uwrapper::uunlink(*info.direlem.fullpath().image());  
                return;
            }
        }
    }

    if (phase == phase_emctar_dedup) {
        if (handle_emctardedup_childdone()) {
            info.enableSpecialCelerraProcessing(compressordata);
        } else {
            
            
        }
        todoEnqueue(TODO_FILE, this);

        return;
    }

    if (phase == phase_get_gsan_extents) {
        DB->msg("restfile::childdone: phase_get_gsan_extents, gsan_extentsdata.size()=%d", (int)gsan_extentsdata.size());
        todoEnqueue(TODO_FILE, this);
        return;
    }

    if ((phase != phase_forksdone) || (ncollected < nforked)) {
        
        return;
    }

    if (restfile_msgs || info.data.getrefcount() != 1)
        DB->msg( "restfile::childdone %s, fileref.count = %d", *info.direlem.fullpath().image(), info.data.getrefcount() );

    if( info.querySecondPassRequired() ) { 
        
        int sizehint = -1;
        if(info.direlem.file_size().value() < 0xFFFF)
            sizehint = (int)info.direlem.file_size().value();

        fileoffset t = fileoffset(sizehint);
        cycle* child2 = new restdata(this, m_hcOriginalRoot, NULL, info.direlem.is_atomic(), info, fileoffset(0), t,
                                 NULL, 0, fileref::empty, -1,
                                 NULL, (info.direlem.get_location().getMedia() > location::media::gsan));
        child2->noop();
        return;
    }

    
    
    if(info.data.getrefcount()>1) DB->msg("restfile::childdone info.data.getrefcount():%d", info.data.getrefcount());
    info.data.free();   

    if( m_bRenamed ) {
        rename_windows_file();
    }

    
    if(! flags.streaming_an_archive() && ! flags.validate ) {
        #if SYSTEM_UNIX
            
            if (!info.direlem.set_file_attributes(flags.permissions))
                Out->msg(WARN, "<6025>Could not restore all access privileges on file \"%s\"", *info.path.image());
        #elif SYSTEM_WINDOWS
            
            
            
            if(!info.direlem.set_file_attributes(flags.permissions && info.direlem.is_encrypted()))
                Out->msg(WARN, "<6025>Could not restore all access privileges on file \"%s\"", *info.path.image());
        #endif
    }

    if( m_bSecurityLost && !flags.streaming_an_archive() ) {
        if( flags.itemizesecurityloss ) {
            Out->msg(WARN, "<5522>Restore was not able to reapply security due to lack of support in target file system: %s", *info.direlem.fullpath().image());
        }
        main->adjustfileACLstripped();
    }

    
    if(flags.streamformat_out == utar_flags_enums::streamformat_avpax ||
       flags.streamformat_out == utar_flags_enums::streamformat_cdsf) {
        if(pipe_control *ppipe_control = main->getpipe_control(&info)) {
            
            if((opts & opt_nofilter) != 0) {
                info.direlem.set_file_size(original_file_size);
            }

            
            if((opts & opt_dephash) == 0) {
                
                ppipe_control->finobj(static_cast<pipe_control::filetype>(get_archive_filetype()),
                                      info.path.image(), info.direlem);
            }
        }
    }

#if SYSTEM_WINDOWS
    
    upath origPath;
    Reparse_Type ignored;
    if (info.direlem.get_reparseType() == REPARSE_DEDUP && ReparsePoints::GetReparsePointDataFromDirelem(info.direlem, origPath, ignored)) {
        static bool dehydratedRestoreCheckDone = false;
        if (flags.windowsRestoreHydrated) {
            
            
            WinDedup::AddFileToRehydrate(origPath, info.direlem.fullpath());
        }
        
        
        
        
        
        
        else if (!dehydratedRestoreCheckDone && flags.args.size()) {
            
            
            Out->msg(WARN, "You are restoring one or more Windows Deduplicated Files as dehydrated files. If the Chunk Store has changed since the backup, or you are not restoring the Chunk Store, then you may not be able to open the file. If this is the case, you must either (a) do a full-volume restore or (b) use the --windows-restore-hydrated flag.");
            dehydratedRestoreCheckDone = true;
        }
    }
#endif

    if (restfile_msgs) DB->msg( "restfile::childdone %s num_open_files=%d", *info.direlem.fullpath().image(), +main->num_open_files );
    if(decrementfilecount) {
        main->num_open_files--;
        if(!fname.isempty() && xflag[11]&32) {                  
            main->open_files_list = main->open_files_list.replace(fname, "");       
        }
    }
    decrementfilecount=false;

    
    
    
    if(threadStarter) {
        DB->msg("restfile::childdone(%p) request stop thread:%d, new thread:%d for path '%s'",
                this, getThreadNbr(), parent->getThreadNbr(), *info.path.image());
        threadStarter = false;                  
        todoEnqueue(TODO_DONE);                 
        setThreadNbr(parent->getThreadNbr());   
        threadShutdown = true;                  
        todoEnqueue(TODO_FILE, this);           
    } else {
        notifyparent();
    }
}

restfile::~restfile() {
    if(threadStarter) {
        DB->msg( DBTXT("restfile::~restfile(%p) stopping thread %d for path '%s'"), this, getThreadNbr(), *info.path.image());
        todoEnqueue(TODO_DONE); 
    }
    if(decrementfilecount) {
        main->num_open_files--;
        if(!fname.isempty() && xflag[11]&32) {                  
            main->open_files_list = main->open_files_list.replace(fname, "");       
        }
    }

}


bool restfile::exists() {
    return DIRELEM::queryfileexists(info.path);
}

bool restfile::should_restore(restelem &info, const utar_flags_info& flags, bool &bExists, bool &bExistsAsFile, bool &bExistsAsSymlink)
{
    bExists = false;
    bExistsAsFile = false;
    bExistsAsSymlink = false;
    time_t tLastModified = 0;
    bool bAlreadyRestored = false;
    

#if SYSTEM_WINDOWS

    WIN32_FIND_DATA fdTmp;
    HANDLE          hFind;
    if( info.direlem.is_mapi() ) {
                mapistream check;
                
                bExists = bExistsAsFile = check.find_item( info.direlem, tLastModified, flags, bAlreadyRestored );
                fdTmp.dwFileAttributes = 0;
        } else {
       hFind = FindFirstFile(*info.path.patht("FindFirstFile"), &fdTmp);

        bExists = (hFind != INVALID_HANDLE_VALUE);
        if( bExists ) {
            bExistsAsFile = ((FILE_ATTRIBUTE_DIRECTORY & fdTmp.dwFileAttributes) == 0);
            bExistsAsSymlink = ((fdTmp.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT);
            tLastModified = unixtime(fdTmp.ftLastWriteTime);
            FindClose(hFind);
        }
    }

#else

    int         iStatus;
#if SYSTEM_UNIX_HPUX | SYSTEM_UNIX_SOLARIS | SYSTEM_UNIX_AIX | SYSTEM_UNIX_LINUX
    struct stat64 sbTmp;
#else
    struct stat sbTmp;
#endif

    
    
    
#if SYSTEM_UNIX_HPUX | SYSTEM_UNIX_SOLARIS | SYSTEM_UNIX_AIX | SYSTEM_UNIX_LINUX
    iStatus = ::lstat64(*info.path.image(), &sbTmp);
#else
    iStatus = ::lstat(*info.path.image(), &sbTmp);
#endif
    bExists = (iStatus == 0);
    if( bExists ) {
        bExistsAsFile = S_ISREG(sbTmp.st_mode);
        bExistsAsSymlink = S_ISLNK(sbTmp.st_mode);
        tLastModified = sbTmp.st_mtime;
    }

#endif

    bool do_restore = true;
    

    if( bExists ) {
        
        
        if (bExistsAsSymlink && info.direlem.is_reparsePoint()) {
            upath trgtPath;
            Reparse_Type repType;
            if (ReparsePoints::GetReparsePointDataFromDirelem(info.direlem, trgtPath, repType) &&
                    !ReparsePoints::ShouldRestoreContentsOfReparsePoint(info.direlem.fullpath(), trgtPath, repType)) {
                do_restore = false;
            }
        } else if ( flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newname) {
            upath sOriginalName(info.path);
            info.direlem.rename();
            info.path = info.direlem.fullpath();
            Out->msg(INFO, "<5600>Restoring file %s as %s", *sOriginalName.image(), *info.path.image());
        } else if( bExistsAsFile || bExistsAsSymlink ) {
            if( flags.existingfileoverwriteoption == utar_flags_enums::existowrite_never) {
                do_restore = false;
                Out->msg(VERBOSE, LOCTXT("Keeping existing file: %s"), *info.path.image());   
            } else if(flags.existingfileoverwriteoption == utar_flags_enums::existowrite_modified) {
                
                if( tLastModified == info.direlem.mtime() ) {
                    do_restore = false;
                    Out->msg(VERBOSE, LOCTXT("Keeping existing file (modify date/time matches backup): %s"), *info.path.image());
                }
            } else if( flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newest) {
                if( tLastModified >= info.direlem.mtime() ) {
                    do_restore = false;
                    Out->msg(VERBOSE, LOCTXT("Keeping existing file (not older than backup): %s"), *info.path.image());
                }
            } else if( bAlreadyRestored ) {
                
                
                do_restore = false;
                Out->msg(VERBOSE, LOCTXT("Keeping existing item: %s (item is alredy restored once)"), *info.path.image());
            }
#if SYSTEM_WINDOWS
            if( do_restore &&
                (fdTmp.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) &&
                !flags.restorehidden ) {
                
                Out->msg(VERBOSE, LOCTXT("Keeping existing file: %s because it has hidden attribute set"), *info.path.image());
                do_restore = false;
            }
            if( do_restore &&
                (fdTmp.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
                !flags.restoresystem ) {
                
                Out->msg(VERBOSE, LOCTXT("Keeping existing file: %s because it has system attribute set"), *info.path.image());
                do_restore = false;
            }
#endif
        } else {  
            do_restore = false;
            Out->msg(ERR, "<5604>Cannot restore file due to name collision: %s.  Existing name is a directory or unchangeable object.  Consider using --existing-file-overwrite-option=newname to restore file.",
                     *info.path.image());
        }
    }
    
    
#if SYSTEM_WINDOWS

    if(!flags.allow_bcd_overwrite &&
      win_os_version_info::is_windows_Vista_or_newer() &&
      upath(BCD_PATH).compare(info.direlem.fullpath()))
      do_restore = false;

    
    static bool Offline = win_os_version_info::is_winpe();
    if(do_windows_license_check && do_restore && !Offline && bExistsAsFile &&
      (ustring(WINDOWS_LICENSE_EXTENSION) == info.direlem.file_name_extension())) {
        Out->msg(VERBOSE, LOCTXT("Keep existing file %s because it is a Windows license file"),
          *info.path.image());
        do_restore = false;
    }
#endif

    return do_restore;
}

void restfile::rename_windows_file() {
#if SYSTEM_WINDOWS
    
    
    assert( m_bRenamed );
    if( (flags.openfilerestoreoption == utar_flags_enums::openrestore_deferred) ||
        (flags.openfilerestoreoption == utar_flags_enums::openrestore_newest) ) {
        

        
        
        bool    bReadOnlyReset = false;
        DWORD   dwCurrentAttr = GetFileAttributesW(*info.direlem.fullpath().pathw("GetFileAttributesW"));
        if( dwCurrentAttr != (DWORD)-1 ) {
            if( (dwCurrentAttr & FILE_ATTRIBUTE_READONLY) != 0 ) { 
                dwCurrentAttr &= ~FILE_ATTRIBUTE_READONLY;
                if( SetFileAttributesW( *info.direlem.fullpath().pathw("SetFileAttributesW"),
                                       dwCurrentAttr & CONVENTIONAL_ATTRIBUTES) != 0 ) {
                    bReadOnlyReset = true;
                }
            }
        }

        
        if( (MoveFileExW( *info.path.pathw("MoveFileExW",false,win_os_version_info::is_windows_XP_or_newer()),               
                                NULL,                                              
                                MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING) != 0)  &&
            (MoveFileExW( *info.direlem.fullpath().pathw("MoveFileEx", false, win_os_version_info::is_windows_XP_or_newer()), 
                                *info.path.pathw("MoveFileExW", false, win_os_version_info::is_windows_XP_or_newer()),               
                                MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING) != 0) )
        {
            if( bReadOnlyReset ) {
                Out->msg(WARN, "<5605>Open file %s has been queued for restore from temporary file %s during next system reboot, but original READONLY Attribute will be removed",
                    *info.path.image(), *info.direlem.fullpath().image());

            } else {
                Out->msg(WARN, "<5606>Open file %s has been queued for restore from temporary file %s during next system reboot",
                    *info.path.image(), *info.direlem.fullpath().image());
            }
        } else {
            platerror pe;
            Out->msg(ERR, "<5607>Open file %s could not be queued for restore from temporary file %s (error %s)",
                *info.path.image(), *info.direlem.fullpath().image(), *pe.description() );
        }
    } else { 
        Out->msg(INFO, "<5608>Open file %s has been preserved, restored version was renamed to %s",
                 *info.path.image(), *info.direlem.fullpath().image());
    }
#endif
}

int restfile::restore_pipe_altdata(fileref& altdataslice) {
    dirrec_pack::emctar_altdata ead(&info.direlem);
    ubigint64 altdatasize;
    unsigned char hashoffset;
    if(!ead.get(altdatasize, hashoffset)) {
        Out->msg(ERR, "<7348>pipe control extra bytes %s", *(info.data.size64() - info.direlem.file_size()).image());
    } else {
        hashvect hashes;
        info.direlem.getdephashes(hashes);
        if(restfile_msgs)
            DB->msg("restfile::restore_pipe_altdata hashes.size:%"Z"d altdatasize:%s hashoffset:%d",
                    hashes.size(), *altdataslice.size64().image(), hashoffset);
        
        if (hashes.size() > (unsigned int)(hashoffset+1)) {
            
            restelem altinfo(info.path, info.direlem, info.fstats, altdataslice);
            nforked++;
            cycle *altdatac = new restdata(this, hashes[hashoffset+1], NULL, false, altinfo,
                                           fileoffset(0), altdataslice.size64());
            altdatac->noop();
        } else {
            Out->msg(ERR, "<7412>restfile pipe control cannot find enough dephash values (%"Z"u present) for altdata hashoffset (%u)",
                     hashes.size(), hashoffset);
        }
        if(restfile_msgs)
            DB->msg("restfile::restore_pipe_altdata '%s' nforked:%d ncollected:%d", *info.path.image(), nforked, ncollected);
    }
    return 0;
}




int restfile::restore_pipe_stubdata(fileref& stubdataslice) {
    dirrec_pack::emctar_stubdata ead(&info.direlem);
    ubigint64 stubdatasize;
    unsigned char hashoffset;

    dirrec_pack::regions dr(&info.direlem);
    data_regions::endoffsets_t endoffsets;

    restelem altinfo;

    
    if(ead.get(stubdatasize, hashoffset)) {
        hashvect hashes;
        info.direlem.getdephashes(hashes);
        if(restfile_msgs)
            DB->msg("restfile::restore_pipe_stubdata '%s' hashes.size:%"Z"d stubdatasize:%s hashoffset:%d",
                    *info.path.image(), hashes.size(), *stubdataslice.size64().image(), hashoffset);

        
        if (hashes.size() <= (unsigned int)(hashoffset+1)) {
            Out->msg(ERR, "<8639>restfile pipe control cannot find enough dephash values (%"Z"u present) for stubdata hashoffset (%u)",
                     hashes.size(), hashoffset);
            return 0;
        }

        
        
        restelem altinfo(info.path, info.direlem, info.fstats, stubdataslice);
        nforked++;
        cycle *stubdatac = new restdata(this, hashes[hashoffset+1], NULL, false, altinfo,
                                        fileoffset(0), stubdataslice.size64());
        stubdatac->noop();
    
    } else if (dr.get(endoffsets)) {
        fileoffset stubstart, stubend;

        if (!data_regions::offattrsrange(endoffsets, stubstart, stubend)) {
            Out->msg(ERR, "restfile pipe control unable to find either dephash or streamslice with stub data");
            return 0;
        }
        restelem altinfo(info.path, info.direlem, info.fstats, stubdataslice);
        if(restfile_msgs)
            DB->msg("restfile::restore_pipe_stubdata '%s' found offattrs section at (%s [%s -> %s]) nforked:%d ncollected:%d",
                    *info.path.image(), *info.direlem.file_hash().partialimage(), *stubstart.image(), *stubend.image(), nforked, ncollected);
        altinfo.prep_restore_of_slice(info.direlem.file_hash(), stubstart, stubend);
        nforked++;
        cycle *stubdatac = new restdata(this, info.direlem.file_hash(), NULL, false, altinfo, stubstart, stubend);
        stubdatac->noop();
    } else {
        
        Out->msg(ERR, "<7348>pipe control extra bytes %s", *(info.data.size64() - info.direlem.file_size()).image());
    }

    return 0;
}














bool restfile::process_emctar_hardlinks(bool &checknormalhardlink)
{
    checknormalhardlink = true;
    if (disablenewcelerrahardlinkrest) {
        return false;
    }

    bool isfirst;
    ustring realfullpath;
    MetadataId metadataid;
    fileoffset sz;

    bool ismultilink = main->emctar_hardlinked_file(info.direlem, isfirst, realfullpath, metadataid, sz);

    
    
    
    
    
    hashcode h = metadataid.tohashcode();

    if (!ismultilink)
        return false;

    checknormalhardlink = false;

    bool islnk = info.direlem.is_tar_hardlink();

    if (isfirst) {
        if (islnk) {
            
            if (restfile_msgs) DB->msg("LNK -> REG, %s %s", *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()));
            process_emctar_lnk_to_reg(h, sz);
            return false; 
        } else {
            
            if (restfile_msgs) DB->msg("REG -> REG, %s %s", *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()));
            return false;
        }
    } else {
        if (islnk) {
            
            if (restfile_msgs) DB->msg("LNK -> LNK, %s %s, realpath:%s", *info.direlem.fullpath().image(),
                                       *tostr(info.direlem.emctar_inode_number64()), *realfullpath);
            process_emctar_lnk_to_lnk(realfullpath);
            return true;
        } else {
            
            if (restfile_msgs) DB->msg("REG -> LNK, %s %s, realpath:%s", *info.direlem.fullpath().image(),
                                       *tostr(info.direlem.emctar_inode_number64()), *realfullpath);
            process_emctar_reg_to_lnk(realfullpath);
            return true;
        }
    }
}


void restfile::process_emctar_lnk_to_reg(const hashcode &h, const fileoffset &sz)
{
    unsigned char hinx;
    data_regions::endoffsets_t eoff;
    dirrec_pack::tar_hardlink2 thl2(&info.direlem);

    if (thl2.get(hinx, eoff)) {
        hashvect dephashes;
        info.direlem.getdephashes(dephashes);
        if (dephashes.size() <= size_t(hinx+1)) {
            Out->msg(ERR, "Found tar_hardlink2 dirrec on direlem for '%s' indicating file content hash in dephash %u, but there are only %"Z"u dephashes on the direlem",
                     *info.direlem.fullpath().image(), hinx+1, dephashes.size()-1);
            return;
        }
        hashcode h = dephashes[hinx+1];
        if (restfile_msgs) DB->msg("process_emctar_lnk_to_reg found regular file %s with %s",
                                   *h.partialimage(), *data_regions::image_endoffsets(eoff));

        fileoffset sbyte, ebyte, range;
        if (!data_regions::findrange(eoff, data_regions::primarydata, true, sbyte, ebyte)) {
            Out->msg(ERR, "Restoring LNK record from '%s' as the full file, found primary file hash %s, but endoffsets %s has no primary data section",
                     *info.direlem.fullpath().image(), *h.partialimage(), *data_regions::image_endoffsets(eoff));
            return;
        }
        range = ebyte - sbyte;

        
        hash = h;
        m_hcOriginalRoot = h; 
        info.prep_restore_of_slice(h, sbyte, ebyte);

        
        info.direlem.del_dirrec(KIND_tar_hardlink);
        info.direlem.del_dirrec(KIND_REGIONS);
        return;
    }

    
    
    
    
    if (restfile_msgs) DB->msg("process_emctar_lnk_to_reg is not handling streamslice direlem, set to data from inode_table");
    hash = h;
    m_hcOriginalRoot = h;
    info.startbyte = 0;
    info.direlem.set_hash(h);
    info.direlem.set_file_size(sz);
    info.direlem.del_dirrec(KIND_tar_hardlink);
    info.direlem.del_dirrec(KIND_REGIONS);
}

void restfile::process_emctar_lnk_to_lnk(const ustring &realfullpath)
{
    pipe_control *ppipe_control = main->getpipe_control(&info);
    if (!ppipe_control) {
        Out->msg(ERR, "process_emctar_lnk_to_lnk, but no pipe_control object exists");
        return;
    }

    info.direlem.set_tar_hardlink(true);
    info.direlem.del_dirrec(KIND_REGIONS);

    fileref dataslice, altslice, stubslice, extentsslice;
    ppipe_control->addfile(info.direlem, *info.direlem.fullpath().image(),
                           dataslice, altslice, stubslice, extentsslice, pipe_control::LNKTYPE, realfullpath);

    
    
    if (!dataslice.isnull()) {
        Out->msg(ERR, "While re-writing LNK file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of file data, but no data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *dataslice.size64().image());
    }
    if (!altslice.isnull()) {
        Out->msg(ERR, "While re-writing LNK file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of alt data, but no alt data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *altslice.size64().image());
    }
    if (!stubslice.isnull()) {
        Out->msg(ERR, "While re-writing LNK file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of stub data, but no stub data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *stubslice.size64().image());
    }
    if (!extentsslice.isnull()) {
        Out->msg(ERR, "While re-writing LNK file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of extents data, but no extents data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *extentsslice.size64().image());
    }
}

void restfile::process_emctar_reg_to_lnk(const ustring &realfullpath)
{
    pipe_control *ppipe_control = main->getpipe_control(&info);
    if (!ppipe_control) {
        Out->msg(ERR, "process_emctar_reg_to_lnk, but no pipe_control object exists");
        return;
    }

    info.direlem.set_tar_hardlink(true);
    info.direlem.del_dirrec(KIND_REGIONS);

    fileref dataslice, altslice, stubslice, extentsslice;
    ppipe_control->addfile(info.direlem, *info.direlem.fullpath().image(),
                           dataslice, altslice, stubslice, extentsslice, pipe_control::LNKTYPE, realfullpath);

    
    
    if (!dataslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of file data, but no data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *dataslice.size64().image());
    }
    if (!altslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of alt data, but no alt data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *altslice.size64().image());
    }
    if (!stubslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of stub data, but no stub data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *stubslice.size64().image());
    }
    if (!extentsslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of extents data, but no extents data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *extentsslice.size64().image());
    }
}








































static fileoffset prefetches_totalbytes;
static fileoffset prefetches_activebytes;

void smallfile_prefetcher::getstats(fileoffset &totalbytes, fileoffset &runningbytes) {
    totalbytes   = prefetches_totalbytes;
    runningbytes = prefetches_activebytes;
}


smallfile_prefetcher::smallfile_prefetcher(restfile *rf, context *main) : cycle(NULL, main) {
    assert(main->restorecache_enabled());
    assert(main->get_flags().restoreprefetchmb > 0);

    
    if (!main->restorecache_enabled()) return;

    const int prefetch_limit = main->get_flags().restoreprefetchmb * 1024*1024;     
    const int safety_limit   = main->get_flags().restoreprefetchmb * 100;           

    int cnt=0;                          
    fileoffset totalprefetching = 0;    
    while(rf && cnt++ < safety_limit && totalprefetching < prefetch_limit) {
        const fileoffset fsize = rf->info.direlem.file_size();
        

        
        
        if (fsize >= prefetch_limit) break;

        
        if (!rf->info.isprefetching) {
            rf->info.isprefetching = true;

            bool restdata_cycle_created(false);
            
            hashvect hashes;    
            rf->info.direlem.getdephashes(hashes);
            const bool isddrdata(rf->info.direlem.get_location().getMedia() == location::media::ddr);
            for(unsigned int i=0; i<hashes.size(); i++) {
                const hashcode h = hashes[i];

                
                
                if(!isddrdata && h != hashcode::zero) {
                    DIRELEM de;                     
                    filestatsref fstats;            
                    fileref resdata;                
                    restelem elem(upath(""), de, fstats, resdata); 
                    elem.ignoreStats = (i > 0) || rf->info.direlem.is_internal();   

                    cycle *c = new restdata(this, h, NULL, false, elem, fileoffset(0), fileoffset(-1), NULL, 1);  

                    
                    if(i == 0) {
                        
                        c->size = fsize;
                        
                        restdata_cycle_created = true;
                    } else {
                        
                        c->size = 0;
                    }
                    c->noop();
                    nforked++;
                    
                }
            }

            if(restdata_cycle_created) {
                prefetches_totalbytes  += fsize;
                prefetches_activebytes += fsize;
            }
        }

        totalprefetching += fsize;
        cycle *next = rf->get_next_cycle();
        rf = dynamic_cast<restfile*>(next);     

        
        
        
        while(rf == NULL && next != NULL && cnt++ < safety_limit) {
            next = next->get_next_cycle();
            rf = dynamic_cast<restfile*>(next);
        }
    }
    
}

void smallfile_prefetcher::init() {
    assert(false);      
    childdone(NULL);
}

void smallfile_prefetcher::childdone(cycle *child) {
    if (child) {
        ncollected++;
        prefetches_activebytes -= child->size;
        assert(prefetches_activebytes >= 0);
      
    }

    if (ncollected >= nforked) {
        notifyparent();
    }
}


















#include "common.h"
#include "debug.h"
#include "backviewtop.h"
#include "backview.h"
#include "xml_message.h"
#include "exclude.h"
#include "context.h"
#include "backstate.h"
#include "runstage.h"
#include "workelem.h"
#include "timer.h"
#include "nbackdata.h"
#include "filenames.h"
#include "backhidden.h"
#include "utar_commands.h"
#include "uwrapper.h"
#include "ade_mgrx.h"
#include "restdirlist.h" 

#include "synccall.h"    
#include "acntmngr.h"    

#include <algorithm>
#include <set>

#define dmsg         ((xflag[2]&4194304)!=0)
#define plugin_merge (((xflag[5]&16384)!=0) || flags.makeview_pluginmerge)
























































#define SAVEACNT   "saveacnt"
#define EXPIRES    "expires"
#define SERVER     "server"
#define SAVELABEL  "savelabel"
#define ALLOWMIXEDBACKUPS "allowmixedbackups"




backviewtop::backviewtop(BackCycle* parent_, ustring filename_or_xml, fileoffset offset)
    : BackCycle(parent_)
{
    assert(parent_ != NULL);
    if (parent_->getInfo()) {
        DB->msg("backviewtop::backviewtop %p backview constructor with parent %p, parent->getInfo()->container:%p",
                this, parent_, parent_->getInfo()->container.getimpl());
    } else {
        DB->msg("backviewtop::backviewtop %p backview constructor with parent %p",
                this, parent_);
    }

    if (plugin_merge) {
        child = new backview_plugin_merge(parent_, filename_or_xml, offset);
    } else {
        child = new backview_global_merge(parent_, filename_or_xml, offset);
    }
}

backviewtop::~backviewtop() {
    
}

void backviewtop::init() {
    
}

void backviewtop::childdone(cycle *child) {
    notifyparent();
}





backviewbase::backviewbase(BackCycle* parent_, ustring filename_or_xml_, fileoffset offset_)
  : BackCycle(parent_),
    filename_or_xml(filename_or_xml_),
    saveacnt("/SEARCHES/default"),
    expires(7), 
    server(""), 
    savelabel(""),  
    allowmixedbackups(false),  
    files_included(0) 
{
    assert(parent_ != NULL);
    if (parent_ && parent_->getInfo()) {
        DB->msg("backviewbase::backviewbase %p backview constructor with parent %p, parent->getInfo()->container:%p",
                this, parent_, parent_->getInfo()->container.getimpl());
    } else {
        DB->msg("backviewbase::backviewbase %p backview constructor with parent %p", this, parent_);
    }

    this->offset = offset_;
    if (dmsg) DB->msg("backviewbase::backviewbase constructor (parent:%p) (this:%p)", parent, this);

    todoEnqueue(TODO_DIR, this);  
}

backviewbase::~backviewbase() {
    if (dmsg) DB->msg("backviewbase::~backviewbase (parent%p) (this%p)", parent, this );
}

void backviewbase::response(message& outargs) {
    if (dmsg)DB->msg("backviewbase::response (parent:%p) (this:%p)", parent, this);
    assert(false);
}

void backviewbase::notifyparent() {
    if (dmsg)  DB->msg("backviewbase::notifyparent (parent:%p) (this:%p) hash=%s", parent, this, *hash.partialimage());

    BackCycle::notifyparent();
    
}

bool backviewbase::setup() {
    if (!uapp::staging().canRun() || !read_input(filename_or_xml)) {
        
        
        return false;
    }

    keylist = table.keys();
    assert(keylist.size() <= INT_MAX);
    return true;
}













class vu_sort_elem {
  public:
    int index;      
    int label;      
    ustring path;   
    ustring account; 

    bool operator<(const vu_sort_elem& cmp) const {
        return this->path.lessthan(cmp.path);
    }
};












ustring standardized(const ustring& path)
{
    ustring result;
    ustring temp(path);
    int blen = path.bytelength();
    bool unc = false;

    
    
    
    if (blen >= 2) {
        if ((unc = (path.substr(0, 2) == "\\\\")) 
          ||      
          (isalpha(path.first()) && path.byteindex(1) == ':' &&
          blen > 2 && (path.byteindex(2) == '/' || path.byteindex(2) == '\\')))
            temp = path.stdseparators();

        if (unc)
            temp = temp.substr(1);        
    }
    

    
    result = temp.rreplace(ustring("//"), ustring("/")).chop('/');

    if (dmsg) DB->msg("standardized: path '%s' => '%s'", *path, *result);
    return result;
}



bool backviewbase::sort_valid_entries(snapview_xml& sv_xml)
{
    const int entries(sv_xml.entry_count());

    if (entries < 0) {
        Out->msg(ERR, "Backup view file is not valid (%d entries)", entries);
        return false;
    }

    
    if (flags.maxviewentries > 0 && entries > flags.maxviewentries) {
        Out->msg(ERR, "<7197>Backup view file contains %d entries, exceeding --maxviewentries=%d",
                 entries, flags.maxviewentries);
        return false;
    }

    
    
    try {
        std::vector<vu_sort_elem> vusortvec((unsigned) entries);      
        for (int i = 0; i < entries; i++) {
            ustring acnt, hextime, fullname, saveas;
            int label;
            bool isfile, internal;

            if (!sv_xml.get_entry(i, isfile, acnt, label, hextime, fullname, internal, saveas)) {
                Out->msg(ERR, "<6983>Unable to retrieve entry %d of snapview xml list", i);
                return false;
            }
            vusortvec[i].index = i;
            vusortvec[i].label = label;
            vusortvec[i].account = acnt;
            acnt = standardized(fullname);  
            vusortvec[i].path = acnt.replace('/', 0x1f);      
        }

        std::sort(vusortvec.begin(), vusortvec.end());

        
        

        int b = 0;
        if (!enter_path(sv_xml.get_entry(vusortvec[0].index))) {
            Out->msg(ERR, "Unable to enter path %d '%s' in makeview table.", vusortvec[0].index,
                    *vusortvec[0].path.replace(0x1f, '/'));
            return false;
        }
        
        for (unsigned x = 1; x < vusortvec.size(); x++) {
            bool samelabel = vusortvec[x].label == vusortvec[b].label;
            const bool sameaccount = vusortvec[x].account == vusortvec[b].account;

            if (vusortvec[x].path.contains(vusortvec[b].path) == 0) {
                int blen = vusortvec[b].path.bytelength();

                if (vusortvec[x].path.bytelength() == blen) {    
                    if (samelabel && sameaccount) {        
                        Out->msg(INFO, "Duplicate entry in snapview on path '%s' - already included", *vusortvec[b].path.replace(0x1f, '/'));
                        continue;
                    }

                    
                    
                    if (plugin_merge) {

                        
                        if (flags.allowpluginmergeduplicatepaths) {
                            Out->msg(INFO, "Duplicate path name '%s' in pluginmerge'd snapview with different labels %d vs. %d allowed",
                                     *vusortvec[b].path.replace(0x1f, '/'),
                                     vusortvec[x].label,
                                     vusortvec[b].label);
                            continue;  
                        } else {
                            Out->msg(ERR, "Duplicate path name '%s' in pluginmerge'd snapview with different labels %d vs. %d is not permitted",
                                     *vusortvec[b].path.replace(0x1f, '/'),
                                     vusortvec[x].label,
                                     vusortvec[b].label);
                            return false;
                        }

                    }
                }
                
                else if (vusortvec[x].path.byteindex(blen) == 0x1f) {
                    if (samelabel && sameaccount) {        
                        Out->msg(INFO, "Path '%s' in snapview includes '%s' - already included.", *vusortvec[b].path.replace(0x1f, '/'), *vusortvec[x].path.replace(0x1f, '/'));
                        continue;
                    }
                    
                    
                    if (plugin_merge) {
                        Out->msg(ERR, "Path '%s' in pluginmerge'd snapview includes '%s' with different labels %d vs. %d is not permitted", *vusortvec[b].path.replace(0x1f, '/'), *vusortvec[x].path.replace(0x1f, '/'), vusortvec[b].label, vusortvec[x].label);
                        return false;
                    }
                }
            }
            
            if (!enter_path(sv_xml.get_entry(vusortvec[x].index))) {
                Out->msg(ERR, "Unable to enter path %d '%s' in makeview table.", vusortvec[x].index,
                    *vusortvec[x].path.replace(0x1f, '/'));
                return false;
            }
            b = x;
        }
        Out->msg(INFO, "<7210>Finished generating makeview tables");
        return true;
    }
    catch(...) {
        DB->msg("backviewbase:sort_valid_entries exception at or after sort vector allocation.");
        Out->msg(FATAL, "Unable to process snapview XML specification - list of entries may be too long.");
        return false;
    }
}

bool backviewbase::read_input(ustring input) {
    
    Out->msg(INFO, "<6927>Reading input '%s'", *input);

    const bool isFile(!xml_message::isxml(input, VIEW_XMLELEMNAME));

    
#if !COMPILE_RAPIDXML
    if(isFile)
#else 
    if(use_old_xml_code && isFile)
#endif
        return read_and_quick_parse_file(input);

    
    snapview_xml sv_xml(input);
    Out->msg(INFO, "<7209>Finished reading makeview input");

    if (!sv_xml.valid()) {
        Out->msg(ERR, "<6928>Cannot parse input :\"%s\"", *input);
        return false;
    }

    
    sv_xml.get_attrs(saveacnt, expires, server, savelabel, allowmixedbackups);

    DB->msg("backviewbase::read_input saveacnt:\"%s\" expires:%d server:\"%s\" savelabel:\"%s\" allowmixedbackups:%d max:%d",
            *saveacnt, expires, *server, *savelabel, allowmixedbackups, flags.maxviewentries);

    
    if (!sort_valid_entries(sv_xml)) {
        uapp::staging().startTermination(EXIT_TARGETLIST, "Invalid target list");
        return false;
    }

    DB->msg("backviewbase::read_input DONE ------table-----\n%s\n------------------------", *table.image());

    return true;
}



ustring backviewbase::viewtable::makekey(ustring acnt, int labelnum) {
    return ustring::sprintf("%s#%d", *acnt, labelnum);
}

ustring backviewbase::viewtable::getacnt(ustring key) {
    stringlist vals(key.split('#'));
    return vals[0];
}

int backviewbase::viewtable::getlabelnum(ustring key) {
    stringlist vals(key.split('#'));
    return vals[1].toint();
}

ustring backviewbase::viewtable::image() {
    ustring result;
    undoo::vector<ustring> keylist(keys());
    for (unsigned int i=0; i<keylist.size(); i++) {
        if (dmsg) DB->msg("viewtabletop::image() trying to lookup '%s'", *keylist[i]);
        ustring curkey(keylist[i]);
        pathentrylist* curlist = lookup(curkey);
        if (curlist != NULL) {
            for (unsigned int j=0; j<curlist->size(); j++) {
                pathentry entry((*curlist)[j]);
                result += ustring::sprintf("  %-30s %d %d %s %s\n", *curkey,
                                           entry.internal, entry.isdir, *entry.fullname.image(), *entry.saveas);
            }
        }
    }
    return result;
}






static ustring get_oneline(FILE *f)
{
    ustring oneline;
    
    while(1) {
        oneline = ustring::getline(f, false);
        if (oneline.isempty() || oneline.byteindex(0) != '#') break;
    }
    return oneline;
}



bool backviewbase::read_and_quick_parse_file(ustring filename) {
    assert(!xml_message::isxml(filename, VIEW_XMLELEMNAME));
    Out->msg(INFO, "<7211>Reading view input file '%s'", *filename);
    FILE *f = uwrapper::ufopen(filename, "r");
    if (f == NULL) {
        Out->msg(ERR, "<7212>Cannot open filename:\"%s\"", *filename);
        return false;
    }

    ustring oneline(get_oneline(f));
    if (oneline.bytelength() == 0) { 
        fclose(f);
        return false;
    }

    xml_messagep mess(new xml_message(oneline, true));
    if ( mess->getcommand() != VIEW_XMLELEMNAME) {
      Out->msg(ERR, "<6929>Incorrect format for search results");
      DB->msg("backviewbase::read_quick_parse_input bad format:%s", *mess->simage());
      fclose(f);
      return false;
    }

    if (mess->defined(SAVEACNT))  saveacnt  = mess->getstring(SAVEACNT);
    if (mess->defined(EXPIRES))   expires   = mess->getint(EXPIRES);
    if (mess->defined(SERVER))    server    = mess->getstring(SERVER);
    if (mess->defined(SAVELABEL)) savelabel = mess->getstring(SAVELABEL);
    if (mess->defined(ALLOWMIXEDBACKUPS)) allowmixedbackups = mess->getbool(ALLOWMIXEDBACKUPS);
    DB->msg("backviewbase::read_quick_parse_input saveacnt:%s expires:%d server:%s savelabel:%s allowmixedbackups:%d",
            *saveacnt, expires, *server, *savelabel, allowmixedbackups);

    int count=0;

    
    
    snapview_xml sv_xml(saveacnt, expires, server, savelabel, allowmixedbackups);
    while(uapp::staging().canRun()) {
        ustring oneline(get_oneline(f));
        if (oneline.bytelength() == 0 ||
           (oneline.bytelength()==7 && oneline == "</view>")) { 
             DB->msg("backviewbase::read_quick_parse_input found end of file");
             break;
        }
        DB->msg("backviewbase::read_quick_parse_input size:%d read:%s", oneline.bytelength(), *oneline);
        sv_xml.add_entry(oneline);
        count++;
    }
    fclose(f);

    
    if (!sort_valid_entries(sv_xml)) {
        uapp::staging().startTermination(EXIT_TARGETLIST, "Invalid target list");
        return false;
    }

    DB->msg("backviewbase::read_quick_parse_input DONE ------table-----\n%s\n------------------------", *table.image());
    Out->msg(INFO, "<7214>Finished reading makeview input %d entries.", count);

    return true;
}



bool backviewbase::enter_path(xml_messagep mess) {

    bool    isfile(false);
    ustring acnt;
    int     labelnum;
    ustring hextime;
    ustring fullname;
    bool    internal;
    ustring saveas;
    if (!snapview_xml::get_values(mess, isfile, acnt, labelnum, hextime, fullname, internal, saveas)) {
        Out->msg(WARN, "<7213>Invalid entry '%s'", *mess->simage());
        return false;
    }

    if (fullname.isempty()) return false;
    if (isfile) files_included++;

    const ustring key(viewtable::makekey(acnt, labelnum));
    DB->msg("backviewbase::read_input key:%s fullname:%s", *key, *fullname);

    pathentrylist* cur = table.lookup(key);
    if (cur==NULL) {
      DB->msg("cur == creating table for (%s)", *key);
      cur = new pathentrylist;
      table.enter(key, cur);
    }

    
    const upath ufullname(fullname, upath::kind_unix, true);

    pathentry pathinfo;
    pathinfo.fullname = ufullname;
    pathinfo.saveas   = saveas;
    pathinfo.internal = internal;
    pathinfo.isdir    = !isfile;

    cur->push_back(pathinfo);

    return true;
}








backview_plugin_merge::backview_plugin_merge(BackCycle* parent_, ustring filename_or_xml_, fileoffset offset_)
    : backviewbase(parent_, filename_or_xml_, offset_),
      rhlistp(NULL),
      rhaccount(""), top_cycle(NULL), nsynth_reqs(0), nsynth_done(0)
{
    
    info = new workelem(NULL, upath("/"));

    
    if (parent_->getInfo()) {
        DB->msg("backview_plugin_merge::backview_plugin_merge %p backview constructor with parent %p, parent->getInfo()->container:%p",
                this, parent_, parent_->getInfo()->container.getimpl());
    } else {
        DB->msg("backview_plugin_merge::backview_plugin_merge %p backview constructor with parent %p",
                this, parent_);
    }

    set_phase(phase_init);
}


backview_plugin_merge::~backview_plugin_merge() {
    if (info != NULL) delete info;
    if (rhlistp) delete rhlistp;
}







struct rp_params {
    BackupRootInfo rp_rootbackup;
    const backviewbase::pathentrylist* rp_pathlist;
    ustring rp_acntname;
    ustring rp_clientid;
    SAFEPOOLALLOC(rp_params);
};

bool backview_plugin_merge::prepare_container(const std::set<int> &ddrindices)
{
    
    
    if ((!flags.ddrenabled) && ddrindices.empty()) {
        return true;
    }

    flags.ddrenabled = true;

    
    if (!ddrindices.empty()) {
        if (flags.isexplicit("ddrindex") && (flags.ddrindex != *(ddrindices.begin()))) {
            Out->msg(FATAL, "Snapview backup with --ddr-index=%d does not match source backup DDR#%d",
                     flags.ddrindex, *(ddrindices.begin()));
            uapp::staging().startTermination(EXIT_BAD_FLAGS, "mismatched --ddr-index and source data");
            uapp::staging().setStageFinal("mismatched --ddr-index and source data");
            return false;
        }
        if (!flags.isexplicit("ddrindex"))
            flags.ddrindex = *(ddrindices.begin());
    }

    if (utar_flags_enums::streamformat_none == flags.streamformat_out)
        flags.streamformat_out = utar_flags_enums::streamformat_cdsf;

    
    
    
    assert(main->getAdeMgr() != NULL);
    if (!main->getAdeMgr()->isDDRenabled()) {
        DB->msg("backview_plugin_merge::prepare_container disengaging DDR#%d, flags.ddrenabled:%d ddrindices.empty(): %d", flags.ddrindex, flags.ddrenabled, ddrindices.empty());
        Out->msg(INFO, "During snapview found source backups with DDR#%d, re-engaging ADE to connect to DDR", flags.ddrindex);
        main->disengageADE();
        if (!main->engageADE()) {
            Out->msg(FATAL, "Could not restart ADE for DDR#%d snapview", flags.ddrindex);
            uapp::staging().startTermination(EXIT_CONNECT, "unable to connect during engageADE");
            uapp::staging().setStageFinal("unable to connect during engageADE");
            return false;
        } else {
            DB->msg("backview_plugin_merge::prepare_container re-engaged DDR#%d, flags.ddrenabled:%d ddrindices.empty(): %d", flags.ddrindex, flags.ddrenabled, ddrindices.empty());
            Out->msg(INFO, "Successfully re-engaged ADE for DDR#%d snapview", flags.ddrindex);
            if (!flags.isexplicit("streamformat-out") && !main->getAdeMgr()->isSynthesisSupported()) {
                flags.streamformat_out = utar_flags_enums::streamformat_raw;
                Out->msg(INFO, "Writing %s stream format to DDR", *utar_flags_info::streamformat_image(flags.streamformat_out));
            }

        }
    } else {
        DB->msg("backview_plugin_merge::prepare_container is not re-engaging ade for ddr backup: isDDRenabled:%d flags.ddrenabled:%d ddrindices.empty():%d",
                main->getAdeMgr()->isDDRenabled(), flags.ddrenabled, ddrindices.empty());
    }

    
    
    
    DB->msg("backview_plugin_merge::prepare_container %p is calling main->initnextucontainer(?) with info %p and info->direlemp->fullpath():'%s'",
            this, this->info, *info->direlemp->fullpath().image());
    assert(info->container.isnull());
    assert(info->use_container == false);
    info->container = main->initnextucontainer(info->direlemp, false);
    info->use_container = !info->container.isnull();

    DB->msg("backview_plugin_merge::prepare_container is setting top_cycle workelem container (it's the only one in the table which won't get it set in find_parent)");
    assert(top_cycle);
    assert(top_cycle->getInfo());
    assert(top_cycle->getInfo()->container.isnull());
    assert(!top_cycle->getInfo()->use_container);
    top_cycle->getInfo()->use_container = true;
    top_cycle->getInfo()->container = info->container;

    return true;
}



void backview_plugin_merge::init() {
    if (dmsg)DB->msg("backview_plugin_merge::init (parent:%p) (this:%p)", parent, this);

  
    if(!backviewbase::setup()) {
        notifyparent();
        return;
    }

    
    if (!main->ADEChunkerEnabled()) {
        DIRELEMp rootde(new DIRELEM);
        rootde->set_name("");
        rootde->set_is_root_directory();
        workelem *w = new workelem(NULL, rootde);
        DB->msg("backview_plugin_merge::init creating nbackdir_manual before we know if we have cdsf data");
        top_cycle = new nbackdir_manual(this, w, fileoffset(0), nsynth_done, !flags.nohiddendir, true);
        nbackdir_cycle_table.enter("", top_cycle);
    } else {
        assert(false);
        
        
        
    }

    
    main->restorecache_enable(flags.restorecachesize);

    
    
    
    
    
    std::set<int> ddrindices;
    set_phase(phase_spawn_children);

    
    undoo::vector<rp_params> restpaths_paramvec(keylist.size());

    while (keylist.size() > 0) {
       ustring curkey(keylist.back()); 
       keylist.pop_back();
       DB->msg("backview_plugin_merge::init curkey:%s keylist.size():%"Z"u", *curkey, keylist.size());

       const ustring acntname(viewtable::getacnt(curkey));
       const int labelnum(viewtable::getlabelnum(curkey));
       Out->msg(INFO, "Starting copy of paths in account '%s' label number %d", *acntname, labelnum);

       const pathentrylist* pathlist(table.lookup(curkey));
       if(pathlist == NULL) {
           DB->msg("backview_plugin_merge::init bad key %s", *curkey);
           assert(false);
       }

       BackupRootInfo mysnapup;
       ustring clientid;
       if (!get_roothashlistrec(acntname, labelnum, mysnapup, clientid)) {
           Out->msg(ERR, "Unable to find data for account '%s' label number %d", *acntname, labelnum);
           continue;  
       }

       if (mysnapup.getDDRIndex() > 0) ddrindices.insert(mysnapup.getDDRIndex());
       if (ddrindices.size() > 1) {
           ustring indices;
           for (std::set<int>::const_iterator i=ddrindices.begin(); i != ddrindices.end(); i++) {
               indices = indices + ustring::sprintf(" %d", *i);
           }
           Out->msg(FATAL, "Multiple source DDR servers in snapview, saw ddrindex values of%s", *indices);
           uapp::staging().startTermination(EXIT_MISC, "multiple DDR servers in snapview");
           uapp::staging().setStageFinal("multiple DDR servers in snapview");
           set_phase(phase_forksdone);
           forksdone = true;
           notifyparent();
           return;
       }

       DB->msg("backview_plugin_merge::init knows by this point if nbackdir_manual should be using a container");

       
       rp_params rpp;
       rpp.rp_rootbackup = mysnapup;
       rpp.rp_pathlist = pathlist;
       rpp.rp_acntname = acntname;
       rpp.rp_clientid = clientid;
       restpaths_paramvec.push_back(rpp);
    }

    
    if (!prepare_container(ddrindices)) {
        set_phase(phase_forksdone);
        forksdone = true;
        notifyparent();
        return;
    }

    
    while (restpaths_paramvec.size() > 0) {
       rp_params rpc(restpaths_paramvec.back());
       restpaths_paramvec.pop_back();
       assert(rpc.rp_rootbackup.isFromGsan());  
       cycle* child = new restpaths(this, rpc.rp_rootbackup.getrootrec(), *rpc.rp_pathlist, rpc.rp_acntname, rpc.rp_clientid, nbackdir_cycle_table, nsynth_reqs, nsynth_done);
       child->noop();
       nforked++;
    }

    DB->msg("backview_plugin_merge::init done spawning children nforked:%d", nforked);
    set_phase(phase_forksdone);
    forksdone = true;
    childdone(NULL);
}




void backview_plugin_merge::childdone(cycle *child) {
    if (dmsg) DB->msg("backview_plugin_merge::childdone (this:%p) (parent:%p) (child:%p) ncollected:%d nforked:%d keylist.size:%d phase:%d, nsynth_reqs:%d, nsynth_done:%d",
                      this, parent, child, ncollected, nforked, (int)keylist.size(), phase, nsynth_reqs, nsynth_done);

    if(child != NULL) {
        ncollected++;
        
        if(child->has_error()) {
            notifyparent();
            uapp::staging().startTermination(EXIT_MISC, "unable to find paths in snapview");
            uapp::staging().setStageFinal("unable to find paths in snapview");
            return;
        }
    }

    if(phase==phase_forksdone && nforked==ncollected) {
        set_phase(phase_backup_table);
        if(!wrapup_merge()) 
            assert(!uapp::staging().canRun());  
        else
            return;
    }

    if(phase==phase_backup_table) {
        if (info && !info->container.isnull()) {
            main->finalizeucontainer(info->container, flags.nohiddendir); 
        }
        assert(nsynth_reqs == nsynth_done);  
        if (nsynth_reqs != nsynth_done)
            DB->msg("backview_plugin_merge::childdone: nsynth_reqs %d != nsynth_done %d", nsynth_reqs, nsynth_done);
        notifyparent();
    }
}





bool backview_plugin_merge::wrapup_merge()
{
    if (!uapp::staging().canRun()) return false;
    DB->msg("backview_plugin_merge::wrapup_merge");

    if (!main->ADEChunkerEnabled()) {
        const undoo::vector<ustring> ckey(nbackdir_cycle_table.keys());
        DB->msg("backview_plugin_merge::wrapup_merge non-ade ckey.size():%d", (int)ckey.size());
        for (unsigned int i=0; i<ckey.size(); i++) {
            const ustring curkey(ckey[i]);
            DB->msg("backview_plugin_merge::wrapup_merge for '%s'", *curkey);
            nbackdir_manual* kid = nbackdir_cycle_table.lookup(curkey);
            if (kid != NULL) {
                DB->msg("backview_plugin_merge::wrapup_merge for '%s' calling do_file_finish", *curkey);
                kid->do_file_finish();  
            } else {
                DB->msg("backview_plugin_merge::wrapup_merge for '%s' no child found", *curkey);
            }
        }
        top_cycle->do_stuff();
    } else {
        assert(false);
        return false;
    }
    return(true);   
}


bool backview_plugin_merge::set_phase(phases newphase) {
    if (newphase > phase) DB->msg("backview_plugin_merge changing phase from %d to %d", phase, newphase);
    phase = newphase;
    return true;
}








backview_plugin_merge::restpaths::restpaths(BackCycle* parent_,
                                            const roothashlistrec backup_record_,
                                            const pathentrylist& pathlist_,
                                            const ustring acntname_,
                                            const ustring clientid_,
                                            backview_plugin_merge::nbackdirtable& nbackdir_cycle_table_,
                                            int& _nsynth_reqs,
                                            int& _nsynth_done)
  : bicycle(parent_),
    backup_record(backup_record_), pathlist(pathlist_), acntname(acntname_),
    clientid(clientid_),
    nbackdir_cycle_table(nbackdir_cycle_table_),
    labelnum(backup_record.getLabelnum()),
    index(0), casesense(CASEUNDEFINED), nsynth_reqs(_nsynth_reqs), nsynth_done(_nsynth_done)
{
    if(dmsg) DB->msg("restpaths::restpaths constructor parent:%p, this:%p acntname:%s labelnum:%d clid:'%s'",
                    parent, this, *acntname, labelnum, *clientid);
    assert(parent != NULL);

    main->add_insert(TODO_DIR, this, 0);        
}

backview_plugin_merge::restpaths::~restpaths() {}

void backview_plugin_merge::restpaths::init() {

    DB->msg("backview_plugin_merge::restpaths::init acntname:%s labelnum:%d numpaths:%d, index:%ld casesense %d", *acntname, labelnum, (int)pathlist.size(), index, casesense);

    if (index == 0) {	
        loc = location(location::media::gsan, backup_record.getRoot());
        loc.set_backupid(location::tbackupid(backup_record.getMtime()));
        assert(loc.get_backupid() != 0);

        
        loc.set_clientid(clientid);

        
        
        
        if (backup_record.getDDRIndex() != 0) {
            loc.setMedia(location::media::ddr);
            loc.set_format(location_types::tformat::cdsf);
        }

        if (flags.isexplicit("case_sensitive"))
            casesense = flags.case_sensitive ? CASESENSITIVE : CASEINSENSITIVE;
        else	
            casesense = CASEUNDETERMINED;	
        if (dmsg) DB->msg("backview_plugin_merge::restpaths::init acntname:%s labelnum:%d numpaths:%d backupid:%s, casesense %d, loc: '%s'", *acntname, labelnum, (int)pathlist.size(), *loc.get_backupid().topath(), casesense, *loc.image());

        parentde.set_location(loc);
        if (backup_record.getDDRIndex() != 0) {
            const location parent_loc_of_parentde; 
            main->set_location_info("backview_plugin_merge::restpaths::init()", parent_loc_of_parentde, parentde);
        }
        
        parentde.set_hash(backup_record.getRoot());
    }

    
    
    
    upath fullpath(standardized(pathlist[index].fullname.image()), DEFAULT_UPATH_KIND, true);

    if (dmsg) DB->msg("restpaths::init acntname:%s labelnum:%d fullpath:%s, sense %d", *acntname, labelnum, *fullpath.image(), casesense);

    assert(parentde.get_location().get_backupid() != 0);
    cycle* child(new restdirelem(this, parentde, fullpath, casesense));
    child->offset = index++;
    nforked++;
    if (index < pathlist.size() && uapp::staging().canRun()) {	
        main->add_insert(TODO_DIR, this, 0);	
    } else {	
        forksdone = true;
        childdone(NULL);
    }
}

void backview_plugin_merge::restpaths::childdone(cycle* child) {
    if(dmsg)DB->msg("restpaths::childdone parent:%p, this:%p child:%p acntname:%s labelnum:%d size:%d nforked:%d ncollected:%d forksdone?%d",
                    parent, this, child, *acntname, labelnum, (int)pathlist.size(), nforked, ncollected, forksdone);
    if(child != NULL) {
        ncollected++;
        
        restdirelem* rcycle(dynamic_cast<restdirelem*>(child));  
        
        if (rcycle == NULL || !enter_in_table(rcycle)) {
            set_error(true, "");
            notifyparent();
            return;
        }
    }

    if (forksdone && nforked==ncollected) {
        notifyparent();
    }
}

bool backview_plugin_merge::get_roothashlistrec(const ustring acntname, const int labelnum, BackupRootInfo& one_snapup, ustring& clientid)
{

  
    utar_flags_info fakeflags;
    fakeflags.labelnum = labelnum;
    fakeflags.path = acntname;
    fakeflags.xmlunentitifydpnpaths = flags.xmlunentitifydpnpaths;
    fakeflags.incpartials           = flags.incpartials;
    fakeflags.case_sensitive = flags.case_sensitive;
    fakeflags.online_system_state = flags.online_system_state;

    
    assert(main);
    hfs_info_struct hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);
    blkpath dpnacnt(acntname);
    blktraj new_blktraj(dpnacnt);
    hfsinfo.blk = new_blktraj;

     
     
     {
         synccall sync(*main);
         acntmngr mgr(&sync);
         hashcode id;
         msgerrors rslt = mgr.getPathId(id, new_blktraj);
         if (rslt == MSG_ERR_NONE)
             clientid = id.image();
         else clientid = "";
     }

    if (dmsg) DB->msg("backview_plugin_merge::pick_roothashlistrec new blk:%s", *hfsinfo.blk.image());
    utar_flags_info dstflags;  
    utar_commands utar(fakeflags, hfsinfo, dstflags);
    if (dmsg) DB->msg("backview_plugin_merge::pick_roothashlistrec created utar object");

  
    
    
    if (acntname != rhaccount) {
        rhaccount = acntname;
        
        if (rhlistp != NULL) {
            
            delete rhlistp;
        }
        
        rhlistp = new BackupRootInfoList;       
    }

    if (!utar.pick_backup(one_snapup, false, rhlistp)) {
        Out->msg(ERR, "<7041>Unable to find backup#%d.", labelnum);
        return false;
    }

    const int ddrIndex = (int)one_snapup.getDDRIndex();
    DB->msg("backview_plugin_merge::get_roothashlistrec found prevbackup:%s, labelnum=%d, ddrindex=%d allowmixed:?", *one_snapup.image(), labelnum, ddrIndex);

    return true;  
}


bool backview_plugin_merge::restpaths::enter_in_table(const restdirelem* child) {
    if(child==NULL || child->offset > pathlist.size()) { assert(false); return false; }

    const upath fullpath(child->fullpath);
    const direlemp_list_type& direlems(child->answers);
    const ustring errdesc(child->errdesc);
    if (!errdesc.isempty() || direlems.size()==0 || direlems.back().isnull()) {
        DB->msg("restpaths::enter_in_table \"%s\" not found or is dir errcode %s", *fullpath.image(), *errdesc);
        Out->Abort("<7042>Failed to create snapview, as one of the elements required for path \"%s\" not found in backup account '%s' labelnum %d (%s).",
                   *fullpath.image(), *acntname, labelnum, *errdesc);
        return false;
    }
    assert(direlems.size() > 0);
    DIRELEMp file_de(direlems.back());

    const int index(child->offset.ivalue());  
    const pathentry& myentry(pathlist[index]);
    if (dmsg) DB->msg("restpaths::enter_in_table found direlem for fullpath:%s(%s) %s (loc: %s)", *fullpath.image(), *myentry.saveas, *file_de->print(fullpath, true, NULL, NULL, false, false ), *file_de->get_location().image());

    const bool internal(myentry.internal);
    file_de->set_internal(internal);  
    if (!myentry.saveas.isempty()) file_de->set_name(myentry.saveas); 

    
    
    const upath parentpath = fullpath.parentdir();

    
    const upath gsanfullpath(file_de->get_location().get_gsanpath());

    
    file_de->set_fullpath(gsanfullpath.isempty() ? parentpath / file_de->name() : gsanfullpath);

    if (!main->ADEChunkerEnabled()) {
        nbackdir_manual* parent = (nbackdir_manual *)find_parent_cycle(parentpath, direlems, static_cast<int>(direlems.size()-1), internal, false);
        parent->add_direlem(file_de);
    } else {
        assert(false);
    }
    if (file_de->get_location().getMedia() > location::media::gsan)
        nsynth_reqs++;

    return true;
}




void* backview_plugin_merge::restpaths::find_parent_cycle(upath dirpath, const direlemp_list_type& direlems, const int level,
                                                          const bool internal, const bool ADE_is_on)
{
    assert(level < (int)direlems.size());
    void* dircycle = NULL;  

    
    
    dirpath.set_end_dirsep(false);
    if(dmsg)DB->msg("restpaths::find_parent_cycle dirpath:%s level:%d internal:%d ade:%d", *dirpath.image(), level, internal, ADE_is_on);

    assert(!ADE_is_on);

    
    if (!ADE_is_on) {
        dircycle = (void *) nbackdir_cycle_table.lookup(dirpath.image());
    } else {
        assert(false);  
    
    
    }

    if (dmsg) DB->msg("restpaths::find_parent_cycle nbackdir_cycle_table.lookup('%s') returned %p",
                      *dirpath.image(), dircycle);

    
    if (dircycle == NULL) {
        upath parentpath;
        
        if (dirpath.image() != ustring(DIRSEPSTR)) {
            parentpath = dirpath.parentdir();
	    
	    parentpath.set_end_dirsep(false);
	} else {
	    parentpath = upath("");
	}
        if (dmsg) DB->msg("backview_plugin_merge::find_parent_cycle calling self dirpath:%s parent:'%s' level:%d", *dirpath.image(), *parentpath.image(), level);
        assert(level > 0);
        void* parent = find_parent_cycle(parentpath, direlems, level-1, internal, ADE_is_on);

        assert(level>0); 
        DIRELEMp dir_de(direlems[level-1]);  
        if (dir_de.isnull() || !dir_de->is_directory()) {
            Out->msg(ERR, "<5187>Path \"%s\" not found in backup when processing snapview.", *dirpath.image());
            DB->msg("backview_plugin_merge::find_parent_cycle path \"%s\" not found or is file", *dirpath.image());
            return NULL;
        }

        
        const upath gsanfullpath(dir_de->get_location().get_gsanpath());

        
        
        
        
        dir_de->set_fullpath(gsanfullpath.isempty() ? dirpath : gsanfullpath);

        if(dmsg)DB->msg("backview_plugin_merge::find_parent_cycle found direlem for findpath:%s '%s' (loc: %s)",
                        *dirpath.image(), *dir_de->name(), *dir_de->get_location().image());

        if (parent == NULL) {   
            DB->msg("backview_plugin_merge::find_parent_cycle got NULL parent unwinding path '%s'.", *dirpath.image());
            return NULL;
        }

        
	if (!ADE_is_on) {
            nbackdir_manual* parentX(((nbackdir_manual*)parent));

            
            
            
            
            
            
            
            
            

            
            fileoffset patchoffset;  
            

            
            
            
            workelem *w = new workelem(parentX->getInfo(), parentpath, dir_de, filestatsref());
            dircycle = (void *)(new nbackdir_manual(parentX, w, patchoffset, nsynth_done,
                                                    false, false, false));
            nbackdir_cycle_table.enter(dirpath.image(), (nbackdir_manual*)dircycle);
            parentX->add_subcycle((nbackdir_manual*)dircycle);  
	} else {
            assert(false);



	}
        if (dmsg) DB->msg("backview_plugin_merge::find_parent_cycle table.enter(%s)", *dirpath.image());
    }

    assert(dircycle);
    return dircycle;
}









backview_global_merge::backview_global_merge(BackCycle* parent_, ustring filename_or_xml_, fileoffset offset_)
    : backviewbase(parent_, filename_or_xml_, offset_),
      done(false)
{
    
    if (parent_->getInfo()) {
        DB->msg("backview_global_merge::backview_global_merge %p backview constructor with parent %p, parent->getInfo()->container:%p",
                this, parent_, parent_->getInfo()->container.getimpl());
    } else {
        DB->msg("backview_global_merge::backview_global_merge %p backview constructor with parent %p",
                this, parent_);
    }

    listing.initlist(20 * DIRELEM_DOLAYOUT_AVERAGE_SIZE);
}



void backview_global_merge::init() {
    if (dmsg) DB->msg("backview_global_merge::init (parent:%p) (this:%p)", parent, this);

    
    
    
    assert(main);
    hfs_info_struct& hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);
    
    utar_flags_info fakeflags, dstflags;        
    fakeflags.labelnum = flags.labelnum;
    fakeflags.path = flags.path;
    fakeflags.xmlunentitifydpnpaths = flags.xmlunentitifydpnpaths;
    fakeflags.incpartials = flags.incpartials;
    fakeflags.case_sensitive = flags.case_sensitive;
    fakeflags.online_system_state = flags.online_system_state;
    
    utar_commands utar(fakeflags, hfsinfo, dstflags);
    BackupRootInfo onebackup;
    (void)utar.pick_backup(onebackup);
    if (onebackup.getDDRIndex() != 0) {       
        Out->msg(ERR, "Non-plugin-merge snapview involving the DDR is not supported.");
        set_error(true, "");
        notifyparent();
        return;
    }

    if(!backviewbase::setup()) {
        set_error(true, "");
        notifyparent();
        return;
    }

    nforked = (int)keylist.size();  
    DB->msg("backview_global_merge::init nforked:%d", nforked);
    if (nforked<=0) {
        Out->msg(ERR, "<6982>Empty input '%s'", *filename_or_xml);
        forksdone=true;
        set_error(true, "");
        uapp::staging().startTermination(EXIT_TARGETLIST, "empty input");  
        notifyparent();
        return;
    }

    
    if (!flags.nohiddendir) {
        const epoch_t now((epoch_t)timer::now());
        hiddendir.initialize(hashcode::zero, now, now, now, fileoffset(0),
                            ATTR_DIRECTORY|ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);

        hiddendir.dolayout(listing, false, true, false);  
        nforked++;
    }

    
    
    main->state->includes.setup(true, false);

    do_next_snapup();
}





void backview_global_merge::childdone(cycle *child) {
    if (dmsg) DB->msg("backview_global_merge::childdone (parent:%p) (this:%p) (child:%p)", parent, this, child);
    DB->msg("backview_global_merge::childdone ncollected:%d nforked:%d done:%d size:%s", ncollected, nforked, done, *size.image());

    if (!done) {

        
        if (ncollected < nforked) {
            DB->msg("backview_global_merge::childdone child->offset:%s", *child->offset.image());

            if (!child->has_error()) {
                listing.setslice64(child->offset, sizeof(hashcode), &child->hash);
                DIRELEM::patch_size(child->size, listing, child->offset, main->isnewdir());
                size += child->size;  
            } else {
                set_error(false, "");
                
            }

            ncollected++;

            DB->msg("backview_global_merge::childdone calling do_next_snapup");
            if (!forksdone)  
                do_next_snapup(); 
        }

        
        if (forksdone && nforked-1 == ncollected ) {
            int files_found = int(main->getstatsobj(context::backupstats)->get_filecount());
            Out->msg(INFO, "<7038>Referenced %d out of %d files total.", files_found, files_included);
            if (files_found == 0 && files_included > 0) {
              set_error(true, "");
              uapp::staging().startTermination(EXIT_TARGETLIST, "no files found");
              notifyparent();
              return;
            };
        }

        if (forksdone && !flags.nohiddendir && nforked-1 == ncollected) {
            DB->msg("backview_global_merge::childdone calling backhidden nforked:%d ncollected:%d", nforked, ncollected);
            xflag[5] = 2|8|16|32|64|128|1024; 
            workelem *w = new workelem(NULL, upath(UNDOO_DIRECTORY_NAME));
            backhidden *hidden = new backhidden(this, w, 0, 0, false );
            hidden->noop();
        }

        
        if (forksdone && nforked == ncollected) {
            done = true;
            workelem *w = new workelem(NULL, listing);
            cycle *datachild = new nbackdata(this, w, fileoffset(0), true  );
            datachild->noop();
            
        }

    
    } else {
        if (dmsg) DB->msg("backview_global_merge::childdone this=%p", this);
        notifyparent();
        
    }
}




bool backview_global_merge::do_next_snapup() {
    assert(!plugin_merge);
    if (keylist.size() <= 0 || !uapp::staging().canRun()) {
      Out->msg(INFO, "<7039>Finished with all account/labels.");
      forksdone = true;
      return false;
    }
    ustring curkey(keylist.back()); 
    keylist.pop_back();
    DB->msg("backview_global_merge::do_next_snapup curkey:%s keylist.size():%"Z"u", *curkey, keylist.size());

    ustring acntname(viewtable::getacnt(curkey));
    int labelnum(viewtable::getlabelnum(curkey));
    DB->msg("Working on acount:%s snapup#%d", *acntname, labelnum);

    pathentrylist* pathlist = table.lookup(curkey);
    assert(!plugin_merge); 
    

    ustring snapupname(curkey.replace(DIRSEP, "_")); 

    
    DIRELEM     direlem;
    const epoch_t now((epoch_t)timer::now());
    direlem.initialize(hashcode::zero, now, now, now, fileoffset(0), ATTR_DIRECTORY|ATTR_EXTENDED, snapupname);  
    direlem.set_unix_attributes(0555, 0 , 0 );                                                      
    
    fileoffset patchoffset = listing.size();
    direlem.dolayout(listing, false, true, false);  

    
    backview *bv = new backview(flags, this, acntname, labelnum, *pathlist, patchoffset);
    bv->noop();
    return true;
}


























































































#define BIGDIRGROUP   50000





#define SENDGROUP_RATIO 10




#define MAXSPAWN 250



#define MAXLISTINGBYTES (128*1024)

#include "common.h"
#include "debug.h"
#include "priqueue.h"
#include "sortdirwalk.h"
#include "fileref.h"
#include "filestream.h"
#include "backstate.h"
#include "backstats.h"
#include "workelem.h"
#include "output.h"
#include "file.h"
#include "cache.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "nbackdir_manual.h"
#include "nbackfile.h"
#include "nbackdata.h"
#include "timer.h"
#include "dirrec.h"
#include "ade_mgrx.h"

#include "filenames.h"  
#include "runstage.h"


#include "backhidden.h"
#include "win_os_version_info.h"

enum phases { phase_init        = 0,  
              phase_x,
              phase_inlookup,         
              phase_incache,          
              phase_backupfile,       
              phase_done              
};


#define msg1 ((xflag[2]&8)!=0)
#define msg2 ((xflag[2]&16)!=0)
#define msg3 ((xflag[2]&1048576)!=0)

nbackdir_manual::nbackdir_manual(BackCycle *parent, workelem *info_, fileoffset offset,
                                 int& _nsynth_done,
                                 bool reserve_hiddendir_, bool top_level_,
                                 const bool use_container_ 
):
    BackCycle( parent, info_),
    elements(NULL),
    fillindex(0),
    sendindex(0),
    drainindex(0),
    more_dirgroups(false),
    flush_listing(false),
    maxgroupentries(BIGDIRGROUP),
    maxsendentries(BIGDIRGROUP/SENDGROUP_RATIO),
    group_count(0),
    entry_count(0),
    datachild(NULL),
    hiddendirp(NULL),
    top_level(top_level_),
    
    raw_format_makeview(flags.makeview  && flags.streamformat_out == utar_flags_enums::streamformat_raw),
    traverse_depth(0),
    use_container(use_container_),
    reserve_hiddendir(reserve_hiddendir_),
    hiddenoff(fileoffset::unknown),
    nsynth_done(_nsynth_done)
{
    
    
    
    if(use_container && info->use_container) {
        assert(!info->container.isnull());
    }

    elements  = new elem_vector(DEFAULTDIRSIZE); 

    if(!info) DB->bt_error(("nbackdir_manual::nbackdir_manual ---------------------> INFO is NULL <------------------------"));
    else {
        if (info->direlemp->get_location().getMedia() > location::media::gsan) {
            if ((!use_container) || (!info->use_container)) {
                if(raw_format_makeview) {
                    assert(info->container.isnull());
                    use_container       = false;
                    info->use_container = false;
                } else {
                    
                    
                    
                    assert(!info->container.isnull());
                    use_container = true;
                    info->use_container = true;
                    
                    
                }
            }
        }
    }

    cycle::offset = offset;
    this->cyexcluded = false;
    this->cyisdirectory = true; 
}

void nbackdir_manual::do_file_finish() {
    if(msg1)DB->msg("nbackdir_manual::do_file_finish()");
    forksdone=true;
}


void nbackdir_manual::init()
{
    DB->msg("nbackdir_manual::init");
    assert(false);
}

void nbackdir_manual::response(message& outargs ) {
    DB->msg("nbackdir_manual::response");
    assert(false);
}

void nbackdir_manual::childdone(cycle *child) {
    if( msg1 ) DB->msg( "nbackdir_manual::childdone (parent:%p) (this:%p) (child:%p) forksdone:%d", parent, this, child, forksdone);
    if( msg1 ) DB->msg( "nbackdir_manual::childdone ncollected=%d nforked=%d collectdone=%d more_dirgroups=%d", ncollected, nforked, collectdone, more_dirgroups );
    if(!collectdone) {
        if(child == NULL) {  
            forksdone = true;

        } else {  
            modify_child_de(child);
            sizeofchildren += child->size;  
            ncollected++;
        }

        
        if(forksdone && !more_dirgroups && reserve_hiddendir && hiddenoff == fileoffset::unknown && nforked == ncollected) {
            hiddenoff = do_direlem( UNDOO_DIRECTORY_NAME, ATTR_DIRECTORY|ATTR_INTERNAL, KIND_UNIX, true, false, &hiddendirp );  
            DB->msg("nbackdir_manual::childdone added system_info (hiddendir) to list at offset:%s  reserve_hiddendir:1", *hiddenoff.image());
            spawn_hiddendir(child);
            
        }

        
        if((forksdone || flush_listing) && nforked == ncollected) {
            if( msg1 ) DB->msg( "nbackdir_manual::childdone: done forking (nforked=%d, ncollected=%d): elements=%d", nforked, ncollected, (int)elements->size());
            assert(elements != NULL || !uapp::staging().canRun());

            do_flush_listing();
            drainindex = 0;
            if (forksdone) collectdone = true;
        }
    } else if (child!=NULL) { 
        assert(datachild != NULL);
        assert(child == datachild);
        assert(!uapp::staging().canRun() || !more_dirgroups);

        
        if (entry_count > maxgroupentries)
            Out->msg(WARN, "<5079>Large number of entries (%d > %d) in directory \"%s\" -- Listing not perfectly sorted.",
                     entry_count, maxgroupentries, *info->path.image());

        
        if( msg1 ) DB->msg( "nbackdir_manual::childdone this=%p size:%s sizeofchildren:%s name:'%s'", this, *size.image(), *sizeofchildren.image(), *info->direlemp->fullpath().image() );
        size = sizeofchildren;  
        info->direlemp->set_file_size(sizeofchildren);  
        this->notifyparent();
    }
}

void nbackdir_manual::notifyparent() {
    if( msg1 ) DB->msg( ("nbackdir_manual::notifyparent %p %s excluded:%d included:%d  (parent:%p) (this:%p)"),
                                this, *info->path.image(), cyexcluded, cyincluded, parent, this);
    if (cyincluded > 0) parent->cyincluded++; 
    delete elements;
    elements = NULL;
    
    
    BackCycle::notifyparent();
    
}

nbackdir_manual::~nbackdir_manual() {
    

    ustring path = info->path.image();   

    main->num_open_dirs--;

    
    if(hash != hashcode::zero && !info->direlemp->is_internal() && !top_level) main->getstatsobj(context::backupstats)->add_dircount(1);
    if( msg1 || msg2) DB->msg( "nbackdir_manual::~nbackdir_manual internal=%d, top_lev=%d (parent=%p) (this=%p) ""%s""", info->direlemp->is_internal(), top_level, parent, this, *path );
    if(! info->isapi) {
        if (msg1) DB->msg("nbackdir_manual::~nbackdir_manual deleting info %p", info);
        delete info;
    } else {
        if (msg1) DB->msg("nbackdir_manual::~nbackdir_manual NOT deleting info %p", info);
    }

    delete elements;
    elements = NULL;

}


bool nbackdir_manual::modify_child_de(const cycle* child)
{
    assert(elements != NULL);
    assert(child != NULL);
    assert(child->offset >= 0);
    assert(child->offset.value() < (bigint64)elements->size());

    const int child_index = (int)child->offset.ivalue();
    

    assert(!(*elements)[child_index].de.isnull());         
    DIRELEM &child_de = *((*elements)[child_index].de);  
    if(msg1)DB->msg("nbackdir_manual::modify_child_de offset:%d name:%s", child_index, *child_de.name());

    
    
    
    
    if( (child->hash == hashcode::zero && (child_de.is_directory()?true:child_de.get_location().getMedia() == location::media::gsan))
        || (child->cyexcluded && child->cyincluded==0) )
    {
        assert(false);
        child_de.set_internal(true);
    }

    if( main->isatombit() && child->cyisatomic )
        child_de.set_is_atomic();

    if(msg1)DB->msg( ("nbackdir_manual::childdone setslice hash:%s offset:%s"), *child->hash.partialimage(), *child->offset.image());
    assert(child_de.is_directory() || child->hash == child_de.file_hash());
    child_de.set_hash(child->hash);

    child_de.set_computed_file_size(child_de.file_size());        






















    const fileoffset changesize = child->size - child_de.file_size();
    if (!child->cyisdirectory && changesize > fileoffset(0)) { 
        main->addfilebytes(context::backupstats, changesize.dvalue());
    }
    return true;
}


void nbackdir_manual::do_stuff_ucontainer_pre() {
    assert(!info->container.isnull());
    

    
    if (msg1) DB->msg("nbackdir_manual ucontainer %d before begindir  '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());
    ucontainer::errortype errcode1(info->container->begindir(info->direlemp.getimpl()));
    if (errcode1 != ucontainer::pce__success) {
        Out->Abort("nbackdir_manual Problem calling begindir for %s (%s)",
                 *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode1));
        return;
    } else {
        if (msg1) DB->msg("nbackdir_manual ucontainer %d after  begindir  '%s' loc:%s",
                          info->container->containerid, *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());
    }

    
    if (msg1) DB->msg("nbackdir_manual ucontainer %d before begindirc '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    ucontainer::errortype errcode2(info->container->begindircontent(info->direlemp.getimpl()));
    if (errcode2 != ucontainer::pce__success) {
        Out->Abort("nbackdir_manual Problem calling begindircontent for %s (%s)",
                 *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode2));
        return;
    } else {
        if (msg1) DB->msg("nbackdir_manual ucontainer %d after  begindirc '%s' loc:%s",
                         info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    }
}

void nbackdir_manual::do_stuff_ucontainer_post() {
    assert(!info->container.isnull());
    

    
    if (msg1) DB->msg("nbackdir_manual ucontainer %d before enddir    '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    ucontainer::errortype errcode(info->container->enddir(info->direlemp.getimpl()));
    if (errcode != ucontainer::pce__success) {
        Out->Abort("nbackdir_manual::~nbackdir_manual Problem calling enddir for %s (%s)",
                 *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
        return;
    } else {
        if (msg1) DB->msg("nbackdir_manual ucontainer %d after  enddir    '%s' loc:%s",
                          info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    }
}


bool nbackdir_manual::timeoffcmp(const onechild& lh, const onechild& rh)
{
    const DIRELEMp lhs(lh.de);
    const DIRELEMp rhs(rh.de);

    if (lhs==NULL) return false;     
    if (rhs==NULL) return true;      

    const location lloc(lhs->get_location());
    const location rloc(rhs->get_location());

    
    if(lloc.getMedia() < rloc.getMedia()) return true;
    if(lloc.getMedia() > rloc.getMedia()) return false;

    
    if(lloc.getMedia() <= location::media::gsan) return strcmp(*lhs->name(), *rhs->name()) < 0;

    
    if(lloc.get_backupid() < rloc.get_backupid()) return true;
    if(lloc.get_backupid() > rloc.get_backupid()) return false;

    
    return(lloc.get_abs_offset_in_container() < rloc.get_abs_offset_in_container());
}

bool nbackdir_manual::source_object_is_entire_container(const DIRELEMp& de) const
{
    const location& loc = de->get_location();
    const ubigint64 filesize = loc.get_enclosing_container().isnull() ? 0 : loc.get_enclosing_container().getimpl()->fileSize;
    if (msg1)
    {
        DB->msg("filesize=%d, coveragesize=%d, offset=%d, loc='%s''", (int)filesize, (int)loc.get_coverage_size().ivalue(), loc.get_abs_offset_in_container().ivalue(), *loc.image());
    }
    
    if (loc.get_format() == location::tformat::cdsf && loc.get_abs_offset_in_container() == 0 && loc.get_coverage_size() + 4 == filesize )
        return true;
    else
        return false;
}

void nbackdir_manual::do_stuff() {
    if(msg1)DB->msg("nbackdir_manual::do_stuff begin use_container:%d info->use_container:%d '%s'",
            use_container, info->use_container, *info->direlemp->name());

    if (!raw_format_makeview && info->use_container) assert(!info->container.isnull());

    
    if (info->use_container && info->container.isnull()) {
        if(raw_format_makeview && top_level) {
            Out->msg(INFO, "Allowing makeview with no top level container for raw format output");
        } else {
            
            
            
            
            
            Out->msg(FATAL, "During snapview where no ucontainer output is being created, attempt to process '%s' in ucontainer mode",
                     *info->direlemp->fullpath().image());
            childdone(NULL);
            return;
        }
    }

    const bool include_self_in_ucontainer = (!info->direlemp->is_root() && info->direlemp->name()!="");

    if (info->use_container && include_self_in_ucontainer) do_stuff_ucontainer_pre();

    if (elements == NULL) {
        childdone(NULL);
        if (info->use_container && include_self_in_ucontainer) do_stuff_ucontainer_post();
        return;
    }

    
    
    if(msg3)DB->msg("nbackdir_manual::do_stuff calling sort reserve_hiddendir:%d elements:%d", reserve_hiddendir, (int)elements->size());
    
    
    std::sort(elements->begin(), elements->end(), timeoffcmp);

    
    
    for(int index=0; index < (int)elements->size(); index++) {
        const onechild curchild = (*elements)[index];
        DIRELEMp de = curchild.de;

        if (msg3) DB->msg("nbackdir_manual::do_stuff index:%d child:'%s' (loc: %s)", index, *(info->direlemp->fullpath() / upath(de->name())).image(), *de->get_location().image());

        
        if (curchild.subcycle == NULL) {
            if(de.isnull()) continue;

            
            
            DIRELEMp original_de(new DIRELEM(*de));

            const location loc(de->get_location());
            if(loc.getMedia() <= location::media::gsan) continue;  

            const upath gsanfullpath(info->direlemp->get_location().get_gsanpath());
            
            
            
            
            const upath objfullpath((gsanfullpath.isempty() ? info->direlemp->fullpath() : gsanfullpath) / upath(de->name()));
            if (msg3) DB->msg("nbackdir_manual::do_stuff element [%d] '%s' %c (loc: %s)", index, *objfullpath.image(), info->use_container?'C':'n', *loc.image());

            
            if (!info->use_container) {
                
                if(loc.getMedia() == location::media::ddr && loc.get_format() == location::tformat::raw) {
                    

                    if(!main->copy_whole_container(info->container, de, objfullpath)) {
                        Out->msg(ERR, "Unable to copy a new container for '%s' using container object '%s' with location '%s'", *objfullpath.image(), *de->fullpath().image(), *loc.image());
                    } else {
                        nsynth_done++;
                    }
                } else {
                    Out->msg(FATAL, "During snapview where no ucontainer output is being created, attempt to include direlem '%s' with location '%s' from ucontainer based backup is an error, since we can not SYNTH the container section representing the data.",
                             *de->fullpath().image(), *loc.image());
                    
                }
            } else {
                
                
                
                
                if(de->is_directory() && loc.get_format() == location::tformat::unknown) {
                    if (msg3) DB->msg("nbackdir_manual::do_stuff skipping unknown format directory '%s'", *objfullpath.image());
                    nsynth_done++;
                }
                else if (flags.makeview && !flags.makeview_consolidate_containers && !info->container.isnull() && source_object_is_entire_container(de))
                {
                    if (msg1)
                        DB->msg("nbackdir_manual::do_stuff call copy_whole_container for %s to %s", *de->fullpath().image(), *objfullpath.image());
                    
                    if(!main->copy_whole_container(info->container, de, objfullpath, true))
                    {
                        Out->Abort("nbackdir_manual copy_whole_container unable to copy a new container to '%s' using container object '%s' with location '%s'", *objfullpath.image(), *de->fullpath().image(), *loc.image());
                    }
                    else
                    {
                        if (msg1)
                            DB->msg("nbackdir_manual copy_whole_container copy a new container to '%s' using container object '%s' with location '%s'", *objfullpath.image(), *de->fullpath().image(), *loc.image());
                        nsynth_done++;
                    }
                }
                else {
                    const bool makeview_unconsolidate_ndmp_toplevel_containers(top_level && flags.makeview && !flags.makeview_consolidate_containers && (flags.pluginid.kind() == pidtype::ndmp));

                    
                    ucontainer::basep synth_container;
                    if(makeview_unconsolidate_ndmp_toplevel_containers) {
                        upath gsanpath(loc.get_enclosing_container().isnull() ? upath() : upath(loc.get_enclosing_container()->gsanFullPath));
                        if(!loc.get_emd_relative_path().isempty()) {
                            
                            gsanpath = loc.get_emd_relative_path();
                        }
                        if(!gsanpath.isempty()) {
                            de->set_fullpath(gsanpath);
                        }
                        synth_container = main->initnextucontainer(de, true);
                    } else {
                        synth_container = info->container;
                    }

                    
                    const bool raw_format_source_file(!de->is_directory() && loc.get_format() == location::tformat::raw);

                    
                    assert((synth_container != NULL));
                    if (msg1) DB->msg("nbackdir_manual ucontainer %d before synthx  '%s' loc:%s ndmp_unconsolidate:%d",
                                      synth_container->containerid, *de->fullpath().image(), *loc.image(),
                                      makeview_unconsolidate_ndmp_toplevel_containers);
                    assert(loc.get_backupid() != 0);

                    
                    ucontainer::errortype errcode2(ucontainer::pce__null);
                    if(raw_format_source_file) {
                        
                        Out->Abort("DD checksums might not be valid after using a raw container as data for a cdsf container object");
                        errcode2 = synth_container->beginfile(de.getimpl(), loc.get_coverage_size());
                        if (errcode2 == ucontainer::pce__success) {
                            errcode2 = synth_container->synthdata(loc);
                            
                            const ucontainer::errortype errcode3(synth_container->endfile(de.getimpl(), loc.get_coverage_size()));
                            if (errcode2 == ucontainer::pce__success) {
                                
                                errcode2 = errcode3;
                            }
                        }
                    } else {
                        errcode2 = synth_container->synthobj(de.getimpl());
                    }

                    if (errcode2 != ucontainer::pce__success) {
                        Out->Abort("nbackdir_manual Problem calling synthx        for %s (%s)",
                                   *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode2));
                        return;
                    } else {
                        if (msg1) DB->msg("nbackdir_manual ucontainer %d after  synthx  '%s' loc:%s",
                                          info->container->containerid, *de->fullpath().image(), *de->get_location().image());
                        nsynth_done++;
                    }

                    if(makeview_unconsolidate_ndmp_toplevel_containers) {
                        
                        
                        main->finalizeucontainer(synth_container, false);
                    }
                }
            }

            
            

            
            
            
            
            
            
            
            if(de->is_directory()) {
                if (msg3) DB->msg("nbackdir_manual::do_stuff copy all subcontainers with upath() (copy_all_subcontainers() will determine the object path)");

                
                
                
                

                if(!main->copy_all_subcontainers(info->container, original_de, upath())) {
                    Out->msg(ERR, "Unable to copy sub-containers for '%s'", *original_de->loc_image());
                }
            }

        
        } else {
            assert(curchild.subcycle != NULL);
            if (msg3) DB->msg("nbackdir_manual::do_stuff '%s' subcycle %d %p", *de->name(), index, curchild.subcycle);
            curchild.subcycle->offset = index;
            curchild.subcycle->do_stuff();
        }
    }

    if (info->use_container && include_self_in_ucontainer) do_stuff_ucontainer_post();

    if(msg1)DB->msg("nbackdir_manual::do_stuff done  use_container:%d info->use_container:%d '%s'",
            use_container, info->use_container, *info->direlemp->name());
    childdone(NULL);
}

bool nbackdir_manual::spawn_hiddendir(const cycle *child)
{
    
    DB->servlog("LOGSTATS", main->getstatsobj(context::backupstats)->xml(main->getAdeMgr()), main->get_errorsummary_xml());  
    

    fileoffset   incdumpsize;
    if((flags.streamformat_in == utar_flags_enums::streamformat_dump) &&
       flags.incremental && child != NULL) 
        incdumpsize = child->size;

    
    if(BackCycle *bc = dynamic_cast<BackCycle *>(parent)) {
        const workelem *parentinfo(bc->getInfo());

        
        if(parentinfo && parentinfo->use_container && !parentinfo->container.isnull()) {
            cycle::main->finalizeucontainer(parentinfo->container, false);
        }
    }

    DB->msg("nbackdir_manual::childdone calling backhidden nforked:%d ncollected:%d", nforked, ncollected);
    workelem *w = new workelem(info, hiddendirp->fullpath(), hiddendirp, filestatsref());
    w->use_container = false;
    backhidden *hidden = new backhidden(this, w, hiddenoff, incdumpsize, false);
    hidden->noop();
    
    return true;
}

bool nbackdir_manual::do_flush_listing()
{
    








    
    if (datachild == NULL) {
        fileref x;
        workelem *w = new workelem(NULL, x);
        datachild   = new backdataconsumer(this, w, this, true  );  
    } else {
        
        todoEnqueue(TODO_CHUNK, datachild);
    }
    return true;
}











fileref nbackdir_manual::nextdatablock(bool& suppress_requeue)
{
    assert(collectdone || flush_listing);

    fileref dirlisting;
    suppress_requeue = false;

    if (elements == NULL) return dirlisting;    

    if (msg3) DB->msg(("nbackdir_manual::nextdatablock(\"%s\"), elements=%d, group=%d, drainindex=%d, more_dirgroups=%d"),
                       *info->path.image(), (int)elements->size(), group_count, drainindex, more_dirgroups);

    assert(drainindex >= 0 && drainindex <= (int)elements->size());

    
    

    
    if (drainindex >= (int)elements->size()) {
        if (flush_listing || more_dirgroups) {
            if (msg3) DB->msg("nbackdir_manual::nextdatablock: Done with this group");

        
            elements->clear();                  
            fillindex=0;
            sendindex=maxsendentries;

            
            todoEnqueueInsert(TODO_DIR, this, -(traverse_depth+1));     

            suppress_requeue = true;            
            dirlisting.initlist(1);             
            return dirlisting;
        }

        if (msg3) DB->msg("nbackdir_manual::nextdatablock: All done!");
        return dirlisting;                      
    }

    
    
    
    
    dirlisting.initlist(DEFAULTDIRSIZE * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    
    for (int tmpindex=drainindex; tmpindex < (int)elements->size(); tmpindex++) {
        if ((*elements)[tmpindex].de != NULL) {
            DIRELEM &dir = *((*elements)[tmpindex].de);

            
            
            
                
                
                if (msg3) DB->msg("nbackdir_manual::nextdatablock laying out tmp element %d '%s'", tmpindex, *dir.name());
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[tmpindex].de = NULL;     
                entry_count++;
                
            

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (msg3) DB->msg("nbackdir_manual::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            tmpindex++;               
            break;
        }
    }

    for (; drainindex < (int)elements->size(); drainindex++) {
        if ((*elements)[drainindex].de != NULL) {
            DIRELEM &dir = *((*elements)[drainindex].de);

            
            DB->msg("nbackdir_manual::nextdatablock: ELEMENT %d '%s' WAS NOT EMPTY!!!", drainindex, *dir.name());

            if(dir.is_directory()) {
                
                
                DB->msg("nbackdir_manual::nextdatablock laying out drain element %d '%s'", drainindex, *dir.name());
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[drainindex].de = NULL;     
                entry_count++;
                
            }

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (msg3) DB->msg("nbackdir_manual::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            drainindex++;               
            break;
        }
    }

    if (msg3 || msg2) DB->msg("nbackdir_manual::nextdatablock returning %s (drainindex=%d)", *dirlisting.desc(), drainindex);

    return dirlisting;
}


void nbackdir_manual::cancelled() {
}









fileoffset nbackdir_manual::add_element(DIRELEMp de, nbackdir_manual* childcycle)
{
     scope s(elements_mut);
     const fileoffset index = elements->size();
     elements->push_back(onechild(de, childcycle));
     return index;
}



fileoffset nbackdir_manual::add_direlem(DIRELEMp de, bool haschild)
{
    const fileoffset patchoffset = add_element(de, NULL);
    const location loc(de->get_location());
    if(loc.get_format() >= location::tformat::cdsf) {
        use_container=true;
        assert(loc.get_backupid() != 0);  
    }
    if(haschild) {
        nforked++;
    } else {
        sizeofchildren += de->file_size();
        main->byteprogress(context::backupstats, stats::ispresent, de->file_size().dvalue());
    }
    if(msg1)DB->msg("nbackdir_manual::add_direlem %s use_container:%d loc:%s ", *de->name(), use_container, *loc.image());
    return patchoffset;
}

void nbackdir_manual::add_subcycle(nbackdir_manual* subcycle) {
    if(subcycle == NULL) return;
    add_element(subcycle->info->direlemp, subcycle);
    nforked++;
    if(msg1)DB->msg("nbackdir_manual::add_subcycle %s", *(subcycle->info->direlemp->name()));
}

void nbackdir_manual::do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also )
{
  assert(false);
}








fileoffset nbackdir_manual::do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink, DIRELEMp *direlemp ) 
{
    if( msg1 || msg2) DB->msg("nbackdir_manual::do_direlem(\"%s\", attributes=%d, kind=%d, dont_stat=%d, follow=%d, direlemp=%p)", *name, attributes, kind, dont_stat_file, follow_symlink, direlemp);

    DIRELEMp de;
    

    if( dont_stat_file ) {
        de = new DIRELEM;
        de->zero();
        epoch_t now((epoch_t)timer::now());
        de->initialize( hashcode::zero, now, now, now, fileoffset(0), attributes, name);
        de->set_fullpath(upath(name));
        if(kind == KIND_UNIX)
            de->set_unix_attributes(0666, 0, 0);
        else if(kind == KIND_UNIX_SP)
            de->set_unix_special(0, 0, 0, 1);
    } else {
        
        de = new DIRELEM( (upath)name, false, follow_symlink );
    }

    if( flags.mapi )
        de->set_is_mapi();

    if( flags.from_stdin ) {
        de->set_stdin();
        if (flags.streamformat_in==utar_flags_enums::streamformat_none) de->set_file_size(0);       
    }

    const fileoffset patchoffset = add_element(de, NULL);

    
    if(flags.xmlunentitifydpnpaths) {
        
        const ustring name(de->name());
        const ustring unentitified_name(xml_message::convert_xmlstring(name));
        if(name != unentitified_name) {
            DB->msg(("unentitified name '%s' to '%s'"), *name, *unentitified_name);
        }
        de->set_name(unentitified_name);
    }

    if (direlemp != NULL) *direlemp = de;       

    nforked++;
    return patchoffset;
}








































#include "backupboostdir.h"
#include "workelem.h"
#include "nbackdir.h"
#include "nbackfile.h"
#include "filenames.h"
#include "timer.h"
#include "nbackdir_manual_unc.h"
#include "ndmp_volume_entification.h"
#include "restdirlist.h"
#include "version.h"

#if !SYSTEM_WINDOWS
#include "processlock.h"
#endif





#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define inject_ddr_checksum_error ((xflag[26]&4)!=0) 

using namespace backupboost;

ubigint64 backupboostdir::session_time = 0;

backupboostdir::backupboostdir(BackCycle *parent, cycle *root_,
                               workelem *info, int traverse_depth_, ubigint64 session_id_,
                               backupboost::backupboost_interface::lfs_handle token_,
                               inode_table &inode_tab_, hardlink_path_table &hardlink_path_tab_,
                               path2event_table &bbeventlist_, utar_flags_info *vol_flags_,
                               BackupRootInfo &prev_backup_)
    : BackCycle(parent, info),
      root(root_),
      inodetab(inode_tab_),
      hardlink_path_tab(hardlink_path_tab_),
      bbeventlist(bbeventlist_),
      vol_flags(vol_flags_),
      prev_backup(prev_backup_),
      thread_started(false),
      cur_list_index(0),
      prev_list_index(0),
      session_id(session_id_),
      token(token_),
      incremental(vol_flags_->incremental),
      top_level(false),
      traverse_depth(traverse_depth_),
      new_directory(false),
      current_phase(phase_init),
      synthblock_checksum(0),
      file_desc(-1)
{
    assert(info);
    upath target_path(info->path);
    target_path.set_end_dirsep(false);
    dir_path = target_path.image();
    mount_point_path = ndmp_unentify_volume(vol_flags_->ndmp_prefix);

    if(msg1) DB->msg("backupboostdir::backupboostdir constructor (parent:%p), (this:%p), (traverse_depth:%d), path:'%s'",
                     parent, this, traverse_depth, *dir_path);

    
    
    if (traverse_depth == 0) {
        top_level = true;

        
        
        
        prectime cur_prec_time(prectime::now());
        session_time = cur_prec_time.toUnixTime64();


        
        bbeventlist.init_next_entry();

        
        determine_volume_offset();

        
        info->direlemp->set_name(ndmp_entify_volume(dir_path));

    } else {
        
        
        assert (incremental);

        
        
        
        
        
        if (traverse_depth > 1) {
            
            backupboost::path2event_table::event_list_entry event;
            upath event_path;

            
            
            
            
            bbeventlist.decrement_itr();
            if (!bbeventlist.get_next_entry(event, event_path)) {
                
                Out->msg(ERR, "Unable to retrieve event from list for directory '%s'", *dir_path);

            } else {
                
                if (event.event_info.is_create_type()) {
                    new_directory = true;
                }
            }
        }

        
        
        
        
        
        info->direlemp->set_is_directory();
        add_directory_to_container();
        set_phase(phase_read_events);
    }

    todoEnqueueInsert(TODO_DIR, this, -traverse_depth); 
}


backupboostdir::~backupboostdir()
{
    if(msg1) DB->msg("backupboostdir::~backupboostdir destructor (parent:%p), (this:%p), (traverse_depth:%d), path:'%s'",
                     parent, this, traverse_depth, *dir_path);
    delete info;
}


void backupboostdir::init()
{
    static int count;
    ++count;
    if(msg1 || (count%1000) == 0)
        DB->msg("backupboostdir::init cnt=%d (parent:%p) (this:%p), depth=%d path:'%s'",
                count, parent, this, traverse_depth, *dir_path);

    if (top_level) {
        nbackdir_manual_unc *root_cycle = dynamic_cast<nbackdir_manual_unc *>(root);
        assert(root_cycle != NULL);
        DIRELEMp child_de;

        
        
        
        
        
        
        
        fileoffset parent_offset;
        if (root_cycle != NULL)
            parent_offset = root_cycle->do_direlem(info->direlemp->name(),
                                                   ATTR_DIRECTORY,
                                                   0,       
                                                   true,    
                                                   false,   
                                                   &child_de);

        backstream *parent_cycle = dynamic_cast<backstream *>(parent);
        assert(parent_cycle != NULL);
        
        
        
        if (parent_cycle != NULL)
            parent_cycle->offset = parent_offset;
        workelem *w = new workelem(info, upath(dir_path), child_de);

        if (!incremental) {
            
            
            
            
            BackCycle *child = create_nbackdir(this,
                                               w,
                                               fileoffset(0),
                                               false,               
                                               false,               
                                               false,               
                                               false,               
                                               0,                   
                                               0,                   
                                               false,               
                                               NULL,                
                                               info->use_container,
                                               false,               
                                               &inodetab,           
                                               &hardlink_path_tab); 
            child->noop();

        } else {
            
            
            

            
            const bbevent top_level_event(bbevent::event_b, bbevent::node_dir, false );
            if (!populate_direlem(top_level_event, 2, (upath)dir_path, w->direlemp)) {
                Out->Abort("Unable to retrieve metadata for '%s'", *dir_path);
                delete w;
                notifyparent();
                return;
            }
            
            
            w->direlemp->set_name(info->direlemp->name());
            w->direlemp->set_fullpath(upath(info->direlemp->name()));

            
            
            if(msg2) DB->msg("backupboostdir::init: Spawning subdir for %s", *child_de->name());
            backupboostdir *child = new backupboostdir(this, parent, w, traverse_depth+1,
                                                        session_id, token, inodetab,
                                                        hardlink_path_tab, bbeventlist,
                                                        vol_flags, prev_backup);

            child->noop();
        }

        nforked++;
        set_phase(phase_get_listing);

    } else if (incremental) {
        
        assert (current_phase == phase_read_events);

        if(get_next_direlem(save_obj_direlem)) {
            
            
            
            
            
            
            if (!save_obj_direlem.isnull()) {
                
                process_direlem(save_obj_direlem);

            } else {
                
                
                
                
                
                insert_self(save_obj_direlem);
            }

        } else {
            
            
            
            
            
            if (msg1) DB->msg("backupboostdir::init: Finished reading events for '%s'", *dir_path);

            if (new_directory) {
                
                
                
                
                
                childdone(NULL);
            }
        }
    }  
}

void backupboostdir::childdone(cycle *child)
{
    if(msg1) DB->msg("backupboostdir::childdone: parent:%p this:%p child:%p nforked=%d ncollected=%d phase:'%s' path:'%s'",
                     parent, this, child, nforked, ncollected, *phase_image(current_phase), *dir_path);

    
    
    
    if (child) {
        ncollected++;
    }

    switch (current_phase) {
    { 
        case phase_init: {
            
        }
        case phase_read_events: {
            
            
            const nbackfile *dc_file = dynamic_cast<nbackfile *>(child);
            if (dc_file != NULL) {
                
                
                DIRELEMp de(dc_file->getInfo()->direlemp);
                if (msg2) DB->msg("backupboostdir::childdone: Set hash for '%s.' (%s)", *de->name(), *de->file_hash().partialimage());
                de->set_hash(dc_file->hash);

                
                
                
                
                
                if (msg2) DB->msg("backupboostdir::%s free symlink_target_path_ref.", __FUNCTION__);
                symlink_target_path_ref.free();

                
                
                
                
                
                
                
                if ((de->hard_links() > 1) || de->is_tar_hardlink()) {
                    const ubigint64 inode(de->inode_number64());
                    const MetadataId metadataid(de->file_hash());
                    inodetab.add_entry(inode, metadataid, de->file_size(), true, false, 0);

                    
                    childlist.add_child(inode);
                    if (msg2) DB->msg("backupboostdir::childdone: Added hardlink inode %s to child list. List size=%s",
                                      *tostr(inode), *tostr(childlist.list_size()));
                }

            } else {
                
                const backupboostdir *dc_dir = dynamic_cast<backupboostdir *>(child);
                if (dc_dir != NULL) {
                    
                    
                    const ubigint64 inode(dc_dir->getInfo()->direlemp->inode_number64());

                    
                    childlist.add_child(inode);
                    if (msg2) DB->msg("backupboostdir::childdone: Added directory inode %s to child list. List size=%s",
                                      *tostr(inode), *tostr(childlist.list_size()));
                }
            }

            
            
            
            
            insert_self(NULL);
            break;
        }
        case phase_wait_for_prevlist: {
            if (msg2) DB->msg("backupboostdir::childdone: Retrieved prevlist for '%s'.  List size=%s",
                              *dir_path, *tostr(prev_direlem_list.size()));

            set_phase(phase_merge);
            
        }
        case phase_merge: {
            merge_prevlist();

            if (!top_level) {
                
                
                set_phase(phase_write_listing);

                
                childdone(NULL);
                break;

            } else {
                
                
                set_phase(phase_get_listing);
                
            }
        }
        case phase_get_listing: {
            const location loc(location::media::gsan, hash);
            
            cycle *rdp = new restdirlistproducer(this,
                                                   this, 
                                                   loc,
                                                   info->direlemp->get_location(),
                                                   ustring::sprintf("backupboostdir of '.system_info'"),
                                                   info->dpninx);
            rdp->noop();
            nforked++;
            if (child) size = child->size;
            set_phase(phase_sys_info);
            break;
        }
        case phase_sys_info: {
            set_sysinfo_data();
            set_work_results();
            set_session_time_entry();
            do_sysinfo_hidden();
            set_phase(phase_write_listing);
            break;
        }
        case phase_write_listing: {
            if (top_level) {
                
                main->target_sysinfo_files_and_data.remove(dir_path);
                sysinfo_de->set_hash(hash);
                
                
                
                
                
                prev_direlem_list.push_back(sysinfo_de);

            } else {
                
                
                assert (incremental);

                
                
                ucontainer::errortype errcode;
                if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                    ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                    Out->msg(ERR,"Problem creating container enddir for %s (%s)",
                            *info->direlemp->fullpath().image(), *errdesc);
                }
            }

            fileref fref;
            workelem *w = new workelem(0, fref);
            backdataconsumer *consumer = new backdataconsumer(this, w, this, true);
            consumer->noop();
            nforked++;
            set_phase(phase_done);
            break;
        }
        case phase_done: {
            assert (nforked == ncollected);

            if (incremental) {
                DIRELEMp de(info->direlemp);
                de->set_hash(hash);

                
                
                
                
                if (traverse_depth > 1) {
                    
                    
                    
                    const MetadataId metadataid(de->file_hash());
                    const ubigint64 dir_offset((de->get_location().get_abs_offset_in_container() + de->get_location().get_header_size()).value());

                    DB->msg("backupboostdir::childdone: dir %s done, calling inodetab.add_entry(%s, %s, %s, true, %d, %s)",
                            *dir_path, *tostr(de->inode_number64()), *metadataid.partialimage(),
                                              *de->file_size().image(), de->is_directory(), *tostr(dir_offset));
                    inodetab.add_entry(de->inode_number64(), metadataid, de->file_size(), true,
                                       de->is_directory(), dir_offset, &childlist);
                }
            }

            notifyparent();
            break;
        }
    } 
    }
}

void backupboostdir::rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer *const producer)
{
    
    direlemp_list_type::const_iterator de_iter = direlems->begin();
    while (de_iter != direlems->end()) {
        cur_direlem_list.push_back(*de_iter);
        de_iter++;
    }
}






























fileref backupboostdir::nextdatablock(bool &suppress_requeue)
{
    suppress_requeue = false;
    fileref fref;
    const int cur_list_size = (int)cur_direlem_list.size();
    const int prev_list_size = (int)prev_direlem_list.size();

    
    
    
    if (((cur_list_size - cur_list_index) == 0) &&
        ((prev_list_size - prev_list_index) == 0)) {
        return fref;                 
    }

    const unsigned direlem_count = (unsigned)((cur_list_size - cur_list_index) + (prev_list_size - prev_list_index));
    fref.initlist(std::min(unsigned(1000), direlem_count) * DIRELEM_DOLAYOUT_AVERAGE_SIZE);
    DIRELEMp temp_de;
    fileoffset totalsize = 0;

    
    while ((cur_list_index < cur_list_size) ||
           (prev_list_index < prev_list_size)) {
        
        
        if (cur_list_index < cur_list_size) {
            
            
            temp_de = cur_direlem_list[cur_list_index];
            cur_list_index++;

        } else {
            
            temp_de = prev_direlem_list[prev_list_index];
            prev_list_index++;
        }

        
        main->layout_direlem(*temp_de, fref, false, true, true);

        
        
        
        
        if (incremental && !temp_de->is_internal()) {
            totalsize += temp_de->file_size();
            info->direlemp->increment_dirsizes(*temp_de);
        }

        
        




        if (fref.size64() > 1024*1024)
            break;
    }

    
    
    
    
    if (incremental) {
        info->direlemp->increment_dirsizes(fref.size64(), 0, 0); 
        info->direlemp->set_file_size(info->direlemp->file_size()+totalsize);
    }

    return fref;
}

void backupboostdir::set_sysinfo_data()
{
    
    
    fileref inode_tab_ref;
    inode_tab_ref.initlist(10 * 1024);
    inodetab.image(inode_tab_ref, inodetab.currentversion());
    main->target_sysinfo_files_and_data.set(dir_path, INODE2HASH_TABLE_FILENAME, inode_tab_ref);

    
    
    fileref hardlink_tab_ref;
    hardlink_tab_ref.initlist(10 * 1024);
    hardlink_path_tab.image(hardlink_tab_ref, hardlink_path_tab.current_version());
    main->target_sysinfo_files_and_data.set(dir_path, HARDLINK_PATH_TABLE_FILENAME, hardlink_tab_ref);
}

void backupboostdir::set_work_results()
{
    
    
    
    main->work_results.set_avtar_version(CLIENT_VERSION);
    main->work_results.set_ddr_index(flags.ddrindex);
    target_session_result session_result;
    session_result.target = dir_path;

    session_result.backup_mode = (incremental ? "synthetic_full" : "level0_full");

    
    
    
    session_result.session_id = (incremental ? session_id + 1 : session_id);

    
    assert(session_time > 0);
    session_result.backup_time = session_time;

    
    
    
    
    
    session_result.exit_code = 0;
    main->work_results.add_result(session_result);
}

void backupboostdir::set_session_time_entry()
{
    const ustring session_id_time_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILENAME);

    
    
    
    
#if !SYSTEM_WINDOWS
    const ustring lock_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILELOCK);
    processlock lock_obj(lock_file);

    
    
    
    const int max_tries(60);
    int tries(0);
    while (!lock_obj.checkandobtainlock()) {
        if (++tries > max_tries) {
            Out->msg(WARN, "Unable to get access to file '%s' for mapping session IDs to session times of mount '%s'",
                           *session_id_time_file, *dir_path);
            Out->msg(WARN, "Previous session id and time entries for mount '%s' are overwritten.", *dir_path);
        }
        Out->msg(INFO, "File '%s' for mapping session IDs to session times of mount '%s' is locked, "
                       "waiting for release with '%d' tries remaining.",
                       *session_id_time_file, *dir_path, max_tries - tries);
        uapp::sleep(1000);
    }
#endif

    
    
    if (!main->session_id_time_table.parse(session_id_time_file))
        Out->msg(WARN, "Unable to parse file '%s' for mapping session IDs to session times", *session_id_time_file);

    if (!incremental) {
        
        
        
        main->session_id_time_table.remove_target_entry(upath(dir_path));
    }

    
    
    
    
    ubigint64 workresult_session_id = (incremental ? session_id + 1 : session_id);
    assert(session_time> 0);
    main->session_id_time_table.add_session_entry(upath(dir_path),
                                                  workresult_session_id,
                                                  session_time);

    if (main->session_id_time_table.image(session_id_time_file)) {
        Out->msg(INFO, "BackupBoost backup added session ID: %s and session time: %s of "
                       "mount path: %s to file '%s' for mapping session IDs to session times",
                       *tostr(workresult_session_id),
                       *tostr(session_time),
                       *dir_path,
                       *session_id_time_file);
    } else {
        Out->msg(ERR, "Failed to write file '%s' for mapping session IDs to session times", *session_id_time_file);
    }
}



void backupboostdir::do_sysinfo_hidden()
{
    sysinfo_de = new DIRELEM;
    const epoch_t now((epoch_t)timer::now());
    sysinfo_de->initialize(hashcode::zero, now, now, now, fileoffset(0), ATTR_DIRECTORY | ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);
    workelem *w = new workelem(info, sysinfo_de);
    w->use_container = false;
    backhidden *hidden = new backhidden(this, w, fileoffset(0), 0, false, false, NULL);
    nforked++;
    hidden->set_target_path(dir_path);
}





void backupboostdir::determine_volume_offset()
{
    assert (info->use_container);

    if (!incremental) {
        
        inodetab.volume_offset = 0;

    } else {
        
        
        
        location prev_loc(info->direlemp->get_location());
        inodetab.volume_offset = (ubigint64)prev_loc.get_abs_offset_in_container().value();
        DB->msg("backupboostdir::determine_volume_offset: Saved offset (%s) for volume:%s",
                *tostr(inodetab.volume_offset), *vol_flags->ndmp_prefix);

        
        if (msg2) DB->msg("backupboostdir::save_location_template  Saving location information for base backup container");
        inodetab.base_container_location = prev_loc.make_template(true );
        if (msg1) DB->msg("backupboostdir::save_location_template  base location:%s", *inodetab.base_container_location.image());
    }
}



void backupboostdir::add_directory_to_container()
{
    ucontainer::errortype errcode;
    if ((errcode = info->container->begindir(info->direlemp.getimpl())) != ucontainer::pce__success)
    {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem creating container begindir for %s (%s)",
                *info->direlemp->fullpath().image(), *errdesc);
        return;

    } else {

        
        if ((errcode = info->container->begindircontent(info->direlemp.getimpl())) != ucontainer::pce__success) {
            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
            Out->Abort("Problem starting container begindircontent for directory '%s' (%s)",
                       *info->direlemp->fullpath().image(), *errdesc);
            return;
        }

        if (msg2) DB->msg("DDR: backupboostdir::add_directory_to_container: abs_offset_in_container:%s begindir for dir %s",
                          *tostr(info->direlemp->get_location().get_abs_offset_in_container().value()),
                          *info->direlemp->fullpath().image());

        
        
        synthblock_offset = info->direlemp->get_location().get_abs_offset_in_container();
        synthblock_coversize = 0;
        synthblock_checksum = 0;
        if (msg2) DB->msg("backupboostdir::add_directory_to_container: synthblock (offset:%s coversize:%s checksum:%s)",
                          *synthblock_offset.image(), *synthblock_coversize.image(), *tostr(synthblock_checksum));
    }
}



void backupboostdir::set_phase(int new_phase)
{
    if (new_phase <= current_phase) return; 

    if(msg1)DB->msg("backupboostdir::set_phase: Changing phase from '%s' to '%s' for directory '%s'",
                    *phase_image(current_phase), *phase_image(new_phase), *dir_path);

    current_phase = new_phase;
}




bool backupboostdir::get_next_direlem(DIRELEMp& obj_direlem)
{
    assert(incremental);

    
    backupboost::path2event_table::event_list_entry event;
    upath event_path;
    bbevent event_info;
    ubigint64 event_inode(0);

    
    
    
    
    
    
    

    
    const upath curpath(dir_path);
    const int cur_path_elems(curpath.numelems()); 

    
    bool more_events(true);
    bool need_direlem(false);

    while (more_events && !need_direlem) {
        
        if (!bbeventlist.get_next_entry(event, event_path)) {
            
            DB->msg("backupboostdir::get_next_direlem: Reached end of event list for '%s'.  Processed %s events.",
                    *vol_flags->ndmp_prefix, *tostr(bbeventlist.table_size()));
            more_events = false;  
            continue;
        }

        
        if (event_path.image() == upath::root_element) continue;

        
        
        
        event_path = upath(mount_point_path + event_path.image());

        
        
        const int event_path_elems(event_path.numelems());  
        if (event_path_elems <= cur_path_elems) {
            
            
            
            if (msg2) DB->msg("backupboostdir::get_next_direlem: Exiting because next event path is in parent (%d <= %d) event_path:'%s'",
                            event_path_elems, cur_path_elems, *event_path.image());

            
            
            bbeventlist.decrement_itr();
            more_events = false;  
            continue;
        }

        
        event_info = event.event_info;
        event_inode = event.inode;
        if (msg2) DB->msg("backupboostdir::get_next_direlem: Read event: event_code:'%s', node_kind:'%s', hardlink:'%s', inode:'%s', path:'%s'",
                          *bbevent::image(bbevent::event_code(event_info.get_code())),
                          *bbevent::image(bbevent::node_kind(event_info.get_kind())),
                          event_info.is_hardlink() ? "HL": "",
                          *tostr(event_inode), *event_path.image());

        if (skip_event(event_info)) {
            
            continue;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if (event_path_elems > cur_path_elems + 1) {
            if (msg2) DB->msg("Skipping path %s because it is within a deleted subdirectory.", *event_path.image());
            continue;
        }

        if (event_info.is_delete_type()) {
            
            
            remove_list.insert(event_inode);
        } else {
            
            need_direlem = true;
        }
    }

    if (!more_events) {
        
        request_prevlist();
        return false;
    }

    
    assert(need_direlem);
    obj_direlem = new DIRELEM;
    obj_direlem->zero();
    if (!populate_direlem(event_info, event_inode, event_path, obj_direlem)) {
        Out->msg(ERR, "Unable to retrieve metadata for '%s'", *event_path.image());
        return false;
    }
    
    
    
    
    if (obj_direlem.isnull())
        return true;

    
    remove_list.insert(obj_direlem->inode_number64());
    if (msg2) DB->msg("backupboostdir::get_next_direlem: Added event to remove_list: event_code:'%s', node_kind:'%s', inode:'%s', path:'%s'",
                      *bbevent::image(bbevent::event_code(event_info.get_code())),
                      *bbevent::image(bbevent::node_kind(event_info.get_kind())),
                      *tostr(obj_direlem->inode_number64()), *event_path.image());

    return true;
}



void backupboostdir::process_direlem(DIRELEMp obj_direlem)
{
    assert(incremental);

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)
        DB->msg("backupboostdir::process_direlem: obj_direlem:%s file_size=%s",
                *obj_direlem->fullpath().image(), *datasize.image());

    cur_direlem_list.push_back(obj_direlem);

    if(msg2)
        DB->msg("backupboostdir::process_direlem: Added to cur_direlem_list('%s', '%s')",
                *obj_direlem->name(), *obj_direlem->fullpath().image());

    workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
    if(obj_direlem->is_directory()) {
        
        
        if(msg2) DB->msg("backupboostdir::process_direlem: Spawning subdir for %s", *obj_direlem->fullpath().image());
        backupboostdir *subdir = new backupboostdir(this, parent, w, traverse_depth+1,
                                                    session_id, token, inodetab,
                                                    hardlink_path_tab, bbeventlist,
                                                    vol_flags, prev_backup);
        subdir->noop();
        nforked++;

    } else { 
        if(msg2) DB->msg("backupboostdir::process_direlem: Spawning nbackfile cycle for '%s', size=%s",
                         *obj_direlem->fullpath().image(), *tostr(datasize.value()));

        fileoffset patchoffset = 0;

        nbackfile *child = new nbackfile(this, w, patchoffset, NULL, file_desc, symlink_target_path_ref);
        child->noop();
        nforked++;
        size += datasize;
    }

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    if(msg2)DB->msg("backupboostdir::process_direlem: DONE obj_direlem1:%s file_size=%s",
                    *obj_direlem->fullpath().image(), *datasize.image());

    return;
}









bool backupboostdir::populate_direlem(const bbevent &event_info, const ubigint64 &event_inode,
                                      const upath &event_path, DIRELEMp& obj_direlem)
{
    assert(incremental);

    
    obj_direlem->set_name(event_path.stripdir());
    obj_direlem->set_fullpath(event_path);

    
    
    file_desc = -1;

    
    if (!obj_direlem->initialize(false ) ||
        ((obj_direlem->inode_number64() != event_inode) && !event_info.is_inserted_dir())) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        

#if !BACKUPBOOSTSUPPORTED


        assert("Unsupported platform for BackupBoost" == 0);
        return false;

#else

        backupboost_interface bb_int;

        if (!bb_int.initialize()) {
            Out->msg(ERR, "Failed to load BackupBoost shared library");
            return false;
        }

        int err_code = LFS_SUCCESS;
        ustring symlink_target_path;
        struct stat64 sbuf;
 
        if (event_info.is_lnk()) {
            
            
            
            err_code = bb_int.get_link_update(token, event_inode, event_path.image(), symlink_target_path, sbuf);
            
            if (msg2) DB->msg("backupboostdir::populate_direlem called backupboost_interface::get_link_update event_inode:'%s', event_path:'%s', symlink_target_path:'%s', errcode:('%s':'%s')", 
                              *tostr(event_inode), 
                              *event_path.image(), 
                              *symlink_target_path, 
                              *tostr(err_code), 
                              *bb_int.err_code_to_desc(err_code));
        } else {
            
            
            
            
            file_desc = bb_int.openfile(token, event_inode, event_path.image(), err_code);

            if (msg2) DB->msg("backupboostdir::populate_direlem called backupboost_interface::openfile event_inode:'%s', event_path:'%s', errcode:('%s':'%s')", 
                              *tostr(event_inode), 
                              *event_path.image(), 
                              *tostr(err_code), 
                              *bb_int.err_code_to_desc(err_code));
        }
        
        
        if ((event_info.is_lnk() && LFS_ENTRY_NOT_FOUND == err_code) || 
            (!event_info.is_lnk() && file_desc < 0)) {
            
            
            if (msg2) DB->msg("backupboostdir::populate_direlem: Could not stat '%s' (probably deleted): event_code:'%s', node_kind:'%s', hardlink:'%s', inode:'%s'",
                              *event_path.image(),
                              *bbevent::image(bbevent::event_code(event_info.get_code())),
                              *bbevent::image(bbevent::node_kind(event_info.get_kind())),
                              event_info.is_hardlink() ? "HL": "",
                              *tostr(event_inode));
            obj_direlem = NULL;
            return true;
        } else if (event_info.is_lnk() && LFS_SUCCESS != err_code) {
            Out->msg(ERR, "Invalid stat information for symlink '%s' (inode:%s), errcode:('%s':'%s')",
                     *event_path.image(), *tostr(event_inode), *tostr(err_code), *bb_int.err_code_to_desc(err_code));
            return false;
        } else { 
            
            
            
            
            
            if (!event_info.is_lnk()) {
                if (0 > fstat64(file_desc, &sbuf)) {
                    Out->msg(ERR, "Unable to retrieve stat information for '%s' (inode:%s)", *event_path.image(), *tostr(event_inode));
                    return false;
                }
            } else {
                
                
                
                
                symlink_target_path_ref.initmem(symlink_target_path);
            }
            
            
            
            
            
            
            
            
            
            if (!obj_direlem->initialize(sbuf, true )) {
                
                Out->msg(ERR, "Invalid stat information for '%s' (inode:%s)", *event_path.image(), *tostr(event_inode));
                return false;
            }
        }
#endif  
    }

    
    
    assert((event_info.is_dir() && obj_direlem->is_directory()) || (!event_info.is_dir() && !obj_direlem->is_directory()));

    
    obj_direlem->set_tar_hardlink(event_info.is_hardlink());
    if (event_info.get_kind() == bbevent::node_lnk) {
        obj_direlem->set_is_symlink();
    }

    

    return true;
}




bool backupboostdir::skip_event(const bbevent &event_info)
{
    bbevent::node_kind kind(event_info.get_kind());

    switch (kind) {
      case bbevent::node_none :   
        
      case bbevent::node_bdev :   
        
      case bbevent::node_cdev :   
        
      case bbevent::node_soc  :   
        
      case bbevent::node_fifo : { 
        return true;  
      }

      default: return false;
    };
}





void backupboostdir::insert_self(DIRELEMp obj_direlem)
{
    ustring name(obj_direlem.isnull() ? ustring("NULL") : obj_direlem->fullpath().image());
    if(msg1) DB->msg("backupboostdir::insert_self (%p)  name:%s depth:%d",
                    this, *name, -traverse_depth);
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth); 
}



void backupboostdir::request_prevlist()
{
    if(!incremental)
        return;

    
    
    
    
    
    if (new_directory) {
        set_phase(phase_write_listing);
        return;
    }

    ubigint64 de_inode = info->direlemp->inode_number64();
    MetadataId metadataid;
    fileoffset size;
    bool wasdir = false;
    ubigint64 dir_offset;
    upath path("");

    if(!inodetab.find_entry(de_inode, metadataid, size, wasdir, dir_offset)) {
        if (msg2)
            DB->msg("backupboostdir::request_prevlist for '%s' no entry in inode_table for inode:%s",
                    *info->direlemp->fullpath().image(), *tostr(de_inode));
        if (de_inode == 2) {
            
            
            
            
            
            wasdir = true;
            metadataid = prev_backup.getRootLocation().getMetadataId();
            if (msg2) DB->msg("backupboostdir::request_prevlist: Retrieved MetadataId '%s' for previous backup", *metadataid.partialimage());
            path = upath(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), true);
            dir_offset = 0;

            
            
            
            remove_list.insert(0);

        } else {
            
            
            if (msg1)
                DB->msg("backupboostdir::request_prevlist for '%s' inodetab.find_entry(%s) returned false",
                        *info->direlemp->fullpath().image(), *tostr(de_inode));
            return;
        }
    }

    if (!wasdir) {
        if (msg1) DB->msg("backupboostdir::request_prevlist entry in inode_table for inode:%s was not a directory", *tostr(de_inode));
        return;
    }

    if(msg1)
        DB->msg("backupboostdir::request_prevlist for '%s' starting restdirlist using MetadataId:%s diroffset:%s path:%s",
                *info->direlemp->fullpath().image(), *metadataid.partialimage(), *tostr(dir_offset), *path.image());

    
    location prev_loc(inodetab.base_container_location);
    prev_loc.set_abs_offset_in_container(dir_offset);

    
    
    
    
    
    
    
    
    if (de_inode == 2) {
        prev_loc.set_containerid(0);
        prev_loc.set_enclosing_container(NULL);  
    }

    const location dirloc(main->prev_backup.getMedialoc(), metadataid);
    cycle *child = new restdirlist(this, dirloc, path, prev_loc, prev_direlem_list, remove_list);
    child->noop();
    nforked++;

    set_phase(phase_wait_for_prevlist);
}



void backupboostdir::merge_prevlist()
{
    
    
    
    

    assert(incremental);

    if(msg1) {
        DB->msg("backupboostdir::merge_prevlist: directory %s (inode %s), prev_direlem_list.size():%s",
                *dir_path, *tostr(info->direlemp->inode_number64()), *tostr(prev_direlem_list.size()));
    }

    
    if (msg2) {
        DB->msg("backupboostdir::merge_prevlist: Dump prev_direlem_list for directory '%s' inode:%s",
                *dir_path, *tostr(info->direlemp->inode_number64()));
        for (size_t i = 0; i < prev_direlem_list.size(); i++) {
            const DIRELEMp de(prev_direlem_list[i]);
            DB->msg("    '%s' inum:%s loc.cid:%d loc.absoff:%s",
                    *de->name(), *tostr(de->inode_number64()), de->get_location().get_containerid(), *de->get_location().get_abs_offset_in_container().image());
        }
    }

    
    for (size_t i = 0; i < prev_direlem_list.size(); i++) {
        const DIRELEMp prevDE(prev_direlem_list[i]);

        
        
        
        main->getstatsobj(context::backupstats)->mergeprogress(prevDE);

        
        if (prevDE->is_directory() || (prevDE->hard_links() > 1) || prevDE->is_tar_hardlink()) {
            
            
            
            
            childlist.add_child(prevDE->inode_number64());
            if (msg2) DB->msg("backupboostdir::merge_prevlist: Added inode %s to child_dir_list. List size=%s",
                              *tostr(prevDE->inode_number64()), *tostr(childlist.list_size()));

            
            
            
            
            if (!prevDE->is_directory()) {
                inodetab.set_created_or_updated(prevDE->inode_number64(), true);
            }
        }

        location loc(prevDE->get_location());
        
        
        
        if (prevDE->is_directory()) {
            
            
            synth_file_block();

            
            
            const ubigint64 block_begin = (ubigint64)loc.get_abs_offset_in_container().value();
            const bigint64 block_size = (bigint64)loc.get_coverage_size().value();
            const tchecksum::tchecksumval block_checksum = loc.get_checksum().header_value;
            const ubigint64 dir_header_size = (ubigint64)loc.get_header_size().value();

            synth_block(block_begin, block_size, block_checksum, prevDE->inode_number64(), dir_header_size);

        } else {
            
            ubigint64 prevDE_offset(loc.get_abs_offset_in_container().value());

            
            
            
            
            if ((synthblock_offset + synthblock_coversize) != prevDE_offset) {
                
                synth_file_block();
            }

            
            
            if (synthblock_coversize == 0) {
                
                
                
                synthblock_offset = prevDE_offset;
            }
            synthblock_coversize += (bigint64)loc.get_coverage_size().value();
            synthblock_checksum ^= (ubigint64)loc.get_checksum().value;
        }

    }

    
    
    synth_file_block();
}







void backupboostdir::synth_block(const ubigint64 &block_begin,
                                 const bigint64 &block_size,
                                 const tchecksum::tchecksumval &block_checksum,
                                 const ubigint64 &inode_number,
                                 const ubigint64 &dir_header_size)
{
    if (msg2) DB->msg("backupboostdir::synth_block: Synth from previous container (Offset:%s  Size:%s  inode:%s  header size:%s)",
                      *tostr(block_begin), *tostr(block_size), *tostr(inode_number), *tostr(dir_header_size));

    
    
    DIRELEMp srcDE(new DIRELEM);
    location src_loc;
    ustring absolute_path("");

    
    src_loc = inodetab.base_container_location;

    src_loc.set_abs_offset_in_container(block_begin);
    src_loc.set_coverage_size(block_size);

    
    
    if (inject_ddr_checksum_error) {
        src_loc.set_checksum_value(+block_begin & 0xFFFFFFFF); 
        
    } else {
        src_loc.set_checksum_value(block_checksum);
    }
    srcDE->set_location(src_loc, false);
    srcDE->set_name("block");  

    ucontainer::errortype errcode;
    udirelemp destUDE;
    
    if ((errcode = info->container->synthobj(srcDE.getimpl(), destUDE, absolute_path, false)) != ucontainer::pce__success) {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem synthesizing data in container; error: (%s)", *errdesc);
        return;
    } else {
        DIRELEMp destDE(destUDE.getDIRELEMp());  
        const fileoffset abs_dir_offset(destDE->get_location().get_abs_offset_in_container());
        

        
        
        
        
        
        
        
        
        if (inode_number > 0) {
            
            
            
            const ubigint64 new_dir_offset(dir_header_size + abs_dir_offset.value());

            
            if (msg2) DB->msg("backupboostdir::synth_block: Calling update_dir_offset with inode:%s new_dir_offset:%s",
                             *tostr(inode_number), *tostr(new_dir_offset));
            inodetab.update_dir_offset(inode_number, new_dir_offset, true , true , true );
        }
    }
}




void backupboostdir::synth_file_block()
{
    if (synthblock_coversize == 0) {
        
        return;
    }

    const ubigint64 block_begin = (ubigint64)synthblock_offset.value();
    const bigint64 block_size = (bigint64)synthblock_coversize.value();

    
    synth_block(block_begin, block_size, synthblock_checksum);

    
    synthblock_coversize = 0;
    synthblock_checksum = 0;
}
#if !defined(CHUNKER_H_INCLUDED)
#define CHUNKER_H_INCLUDED
























#include "fileref.h"
#include "quickhash.h"
#include "chunktype.h"
#include "chunktree.h"
#include "filestats.h"
#include "workelem.h"
#include "streambuffer.h"
#include "streamtransform.h"
#include "streamtransformbackupread.h"




#define MIN_STICKY_BIT_VALUE  2
#define MAX_STICKY_BIT_VALUE 16  

class connection;
class nbackroot;
class backstate;
class BackCycle;
class utar_flags_info;

class chunker {

public:

  friend class ChunkerDump;

  virtual ~chunker();

  
  
  void append_tree(const fileref& data, chunktree * childtree);

  
  hashcode flush_tree(chunktree * childtree, bool& wasatomic);

  
  
  
  
  static chunker *pick_atomic(utar_flags_info& flags, workelem *info,
			      chunktype chunkkind, BackCycle *parent_cycle, 
			      fileoffset maxsize,
			      const fileref& mapbuffer = fileref::empty);

  
  
  
  void append_init(const fileref& data_);

  
  
  
  fileref append_getchunk();

  
  
  void append_computehash(fileref& chunk, hashcode& chunkhash, chunktype& kind);

  
  void append_process(chunktree *childtree, hashcode& chunkhash, const chunktype kind, fileref& chunk, int origsize);

  
  void pre_restore_into_chunker( const fileref& pre_data );

  void set_post_restore_data( const fileref& post_data );

  static void list_composite( fileref& data, chunktype ckind );

  
  static void expand_composite( fileref& data, chunktype ckind ); 

  
  static fileoffset get_last_endoff( fileref& data, chunktype ckind ); 

  
  
  fileref getRemainingBytesInSteam();

  
  enum compress_states { compress_undecided,    
                         compress_no,           
                         compress_yes,          
                         compress_tweak,        
                         compress_ntfs_nondata, 
                         compress_ntfs_datahdr}; 

  
  compress_states get_compress_state() const { return compress_state; }

   void set_chunker_name( const char *name ) { chunker_name  = name; };
   void set_chunker_parent( chunker *parent_ );  
   const char *get_chunker_name() { return chunker_name; };  

   chunktype get_chunker_kind() const { return chunkkind; }

   void fixup_depth();  
   chunker *child;  

private:
  chunker *parent;  
  workelem *info;
  chunker();
  void checkcompress(chunktype& kind, fileref& chunk);
  compress_states compress_state;

protected:
  chunker (utar_flags_info&, workelem *info, chunktype chunkkind, BackCycle *parent_cycle,
           fileoffset maxsize = fileoffset(0), const fileref& mapbuffer = fileref::empty); 
           

  void set_compress_state(compress_states csNewValue) { compress_state = csNewValue;}

  utar_flags_info& flags;

  
  
  


  void reduce_composite( fileref& data); 

    
  virtual int find_sticky(fileref &stickychunk) = 0;

  
  Streambuffer   m_sb; 
  StreamtransformBackupRead m_stBackupRead; 
  Streamtransform           m_st; 
  Streamtransform          *m_pst; 

  int m_iStickyScanBookmark;  

  fileoffset maxsize; 
  quickhash qhash;

  fileoffset data_endoff; 
  backstate *state;
  chunktree tree;
  int depth;
  chunktype chunkkind;
  BackCycle *root_cycle;  
  backtree *cur_cycle;
  bool flushed;
  fileref post_change_block_previous_data;
  friend class restdata;
  const char *chunker_name;
};



class directory_chunker: public chunker {
public:
  directory_chunker (utar_flags_info& flags, workelem *info, chunktype chunkkind, BackCycle *parent_cycle)
      : chunker(flags, info, chunkkind, parent_cycle) {};
  int find_sticky(fileref &stickychunk);
  SAFEPOOLALLOC(directory_chunker);
private:
  directory_chunker();
};


class composite_chunker: public chunker {
public:
  composite_chunker (utar_flags_info& flags, workelem *info, chunktype chunkkind, BackCycle *parent_cycle)
      : chunker(flags, info, chunkkind, parent_cycle) {};
  int find_sticky(fileref &stickychunk);
  SAFEPOOLALLOC(composite_chunker);
private:
  composite_chunker();
};


class fixed_composite_chunker: public chunker {
public:
  fixed_composite_chunker (utar_flags_info& flags, int elemcount, workelem *info, chunktype chunkkind, BackCycle *parent_cycle);
  int find_sticky(fileref &stickychunk);
  SAFEPOOLALLOC(fixed_composite_chunker);
private:
  fixed_composite_chunker();
  int chunksize;
};

#endif
#if !defined(RESTPIPE_H_INCLUDED)
#define RESTPIPE_H_INCLUDED















#include "cycle.h"
#include "chunktype.h"
#include "restelem.h"
#include "ade_restore.h"
#include "ucontainer_base.h"

class ADEMgrX;



class restpipe : public bicycle, nsAdeLib::ADERestore {
public:
    
    
    
    
    restpipe(bicycle *parent_, const hashcode& hash, bigint64 cycle_priority_,
             fileref& resdata, chunktype* ctypep_, const dpns dpninx=dpn0);

    restpipe(bicycle *parent_, const hashcode& hash, fileref& resdata, bool todo_chunk_priority ,
             fileoffset startoff, fileoffset endoff, bool rawmode, chunktype *ctypep, const dpns dpninx=dpn0);
    restpipe(bicycle *parent_, fileref& resdata, const DIRELEM* direlem, bool todo_chunk_priority ,
             const fileoffset startoff=fileoffset(0), const fileoffset endoff=fileoffset(0), ucontainer::basep containerp=NULL, const dpns dpninx=dpn0);
    virtual ~restpipe();
    SAFEALLOC(restpipe);
    
    virtual void init();
    
    virtual void handleData(fileoffset foOffset, fileref& restoreData);
    virtual void childdone(cycle *child);
    
    
    virtual void handleBlockData(fileoffset offset, fileref& restoreData);
    virtual void blockDataComplete(bigint64 startOffset);
    
    
    virtual void setErrorResponse(msgerrors lastError_);    
    
private:
    restelem        info;
    chunktype*      ctypep;
    BlockProvider*  blockProvider;
    ADEMgrX*        adeMgr;
};

#endif
















#include "common.h"
#include "debug.h"
#include "zfstarpipe.h"
#include "output.h"
#include "utar_flags_enums.h"
#include "dirrec_pack.h"
#include "ndmp_volume_entification.h"
#include "restelem.h"
#include "data_regions.h"
#include "zfstarstream.h"

using namespace data_regions;
using namespace zfstarstream;

#define deb ((xflag[11]&2048)!=0)

#define BLOCKSIZE 512
#define NDMP_REC_SIZE 64512

zfstarpipe::zfstarpipe(fileref &data_, int zeroblockcount)
    : pipe_control(data_, BLOCKSIZE, utar_flags_enums::streamformat_zfs)
{
}

bool zfstarpipe::addfile(const DIRELEM& elem,
                 const ustring& path,
                 fileref& dataslice,
                 fileref& altdataslice,
                 fileref& stubdataslice,
                 fileref& gsanextentsdata,
                 const filetype ftype,
                 const ustring& linkname,
                 const fileoffset startoff)
{
    if (ftype == ZFS_DIRECTORY) {
        ubigint64 sslicesize;
        unsigned char hashoff;
        dirrec_pack::streamslice s(&elem);
        if (!s.get(sslicesize, hashoff)) {
            Out->msg(ERR, "Unable to extract streamslice dirrec for directory '%s' during restore",
                     *elem.fullpath().image());
            return false;
        }

        hashvect dephashes;
        elem.getdephashes(dephashes);
        if (dephashes.size() <= (size_t)(hashoff+1)) {
            Out->msg(ERR, "Expected dependent hash[%u] (zero indexed) to contain streamslice data for directory '%s' during restore, but only %"Z"d dephashes are present",
                     hashoff+1, *elem.fullpath().image(), dephashes.size());
            return false;
        }
        m_slicehash = dephashes[hashoff+1];

        data_regions::endoffsets_t eoff;
        dirrec_pack::regions r(&elem);
        if (!r.get(eoff) || eoff.empty()) {
            Out->msg(ERR, "Unable to find data regions dirrec for streamslice data for directory '%s' during restore",
                     *elem.fullpath().image());
            return false;
        }
        fileoffset slicelen = eoff.back().second;
        if (slicelen != fileoffset(sslicesize)) {
            Out->msg(ERR, "Found endoffset for data of %s, but streamslice data contains %"LL"u bytes for '%s' during restore",
                     *slicelen.image(), sslicesize, *elem.fullpath().image());
            return false;
        }
        
        dataslice.initmem(slicelen.ivalue());
    }
    return true;
}

bool zfstarpipe::addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                        const fileoffset datasize, fileref& dataslice)
{
    
    zfstarstream::parser parser;
    parser.set_source_data(dataslice);
    DIRELEMp de;
    fileref altref, stubref;
    if (!parser.getentry(de, altref, stubref))
        return false;
    parser.recordmarks(de);

    
    dirrec_pack::regions drr(&elem);
    data_regions::endoffsets_t eoff;
    if (!drr.get(eoff) || eoff.empty()) {
        Out->msg(ERR, "Unable to find data regions dirrec for streamslice data for '%s' during restore",
                 *elem.fullpath().image());
        return false;
    }

    if (deb)
        DB->msg("zfstarpipe::addobj parser found de for '%s', endoffsets %s, altref.size:%s stubref.size:%s",
                *elem.fullpath().image(), *data_regions::image_endoffsets(eoff),
                *altref.size64().image(), *stubref.size64().image());

    ustring pathstr = elem.fullpath().image();
    
    
    
    if (parser.path_changed(pathstr)) {
        parser.set_path(pathstr);
        parser.get_header_image(dataslice);
    }
    
    set_data_slice(dataslice, "header");
    return true;
}

bool zfstarpipe::fillheader(fileref& header, fileoffset& filesize,
                            fileoffset& altdatasize, fileoffset& stubdatasize,
                            const DIRELEM& elem,  const ustring& path,
                            const filetype ftype, const ustring& linkname,
                            const fileoffset startoff)
{
    return true;
}


void zfstarpipe::set_data_slice(const fileref& hdrslice, const ustring& desc)
{
    if (!hdrslice.isnull()) {
        data.setslice64(curroffset, hdrslice, false);
        add_to_curroffset(hdrslice.size64(), desc);
    }
}


void zfstarpipe::init_data_slice(fileref& dataslice, const fileoffset& size, const ustring& desc)
{
    dataslice.initslice6464(data, curroffset, size);
    add_to_curroffset(size, desc);
}

void zfstarpipe::padd_end(fileoffset& size_of_stream)
{
    
    
    
    
    fillblock_normal();
    fileoffset padsize = get_padding(curroffset.value()) + 2 * BLOCKSIZE;
    padsize += get_padding((curroffset + padsize).value(), NDMP_REC_SIZE);
    fileref zeros = makezeros(padsize.ivalue());
    data.setslice64(curroffset, zeros, false);
    add_to_curroffset(zeros.size(), "zfs_padd_end");
    size_of_stream = curroffset;
}

const hashcode zfstarpipe::get_dirslice_hash() const
{
    return m_slicehash;
}






























#include "common.h"
#include "debug.h"
#include "backappend.h"
#include "todoelem.h"
#include "context.h"

#include "chunktype.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "backstate.h"
#include "backchunk.h"
#include "workelem.h"

#include "msgpack_c.h"
#include "ade_mgrx.h"
#include "collator.h"
#include "chunker.h"

#include "chunker.h"
#include "backdump.h"
#include "runstage.h"
#include "parsestream_base.h"
#include "uwrapper.h"
#include "restdata.h"
#include "restelem.h"

#if CELERRA_CMR10
#include "streambuffer.h"
#include "streamtransformemctardedup.h"
#endif

#include "data_regions.h"



#define backappend_msg ((xflag[2]&1024)!=0)
#define bdmsg2         ((xflag[2]&16384)!=0)    
#define sysinfo_on_ddr ((xflag[13]&4194304)!=0)   
#define chgblkmsg      ((xflag[19]&4096)!=0)
#define issavestream (flags.streamformat_in == utar_flags_enums::streamformat_savestream)

#define InUseBlocksOptimizationEnabled ((xflag[31]&65536)==0)


namespace {
    fileref zeroatomic;
}


#if SYSTEM_UNIX
  #include <sys/socket.h>
#endif



#define CHANGEBLOCK_APPEND_BASEFILE_SIZE_DIFF 1



bool backappend::file_is_socket(false);
int backappend::file(-1);

backappend::backappend(BackCycle *parent,
                       context *main,
                       workelem *info_,
                       fileref f_,
                       const bool isdir_,
                       const fileoffset size_, 
                       const append_format fmt_, 
                       const dump_header *headerp_, 
                       parsestream_base *parser_, 
                       const bool destroy_workelem_ 
) :
    BackCycle(parent, info_),
    f(f_),
    m_chunker(NULL),
    m_collater(NULL),
    isdir(isdir_),
    isSystemInfo(main->handling_system_info()),
    parser(parser_),
    fmt(fmt_),
    headerp(headerp_),
    destroy_workelem(destroy_workelem_),
    adeMgr(NULL),
    chunkerID(0),
    adsctx(NULL),
    lastChunkWasZeros(false)
{
    assert(parent != NULL);     
    if (info == NULL) {
        
        assert(!"NULL Info Parameter to backappend ctor");
        return;
    }

    if (backappend_msg) {
        const ustring parserClass(parser ? typeid(*parser).name() : "");
        const ustring parentClass(typeid(*parent).name());
        DB->msg ("backappend(%p)::backappend() parent:(%s @ %p), info:%p info.direlemp.path:'%s' info.path:'%s' info.hold_data:%c info->data.size:%d f.size:%s parser (%s @ %p) fmt:%d",
                    this, *parentClass, parent, info, *info->direlemp->fullpath().image(), *info->path.image(), info->hold_data ? 'T' : 'F', info->data.size(),
                    *f.size64().image(), *parserClass, parser, fmt);
    }

    if (info->use_container) {
        assert(!info->container.isnull());
    }

    adeMgr = BackCycle::getAdeMgr();
    if(adeMgr == NULL) {
        assert(adeMgr != NULL);
        Out->msg(FATAL, "<11033>ADE must be running for the backup to operate properly.");
        DB->msg ("backappend::backappend() -- ADE must be running for this class to operate!");
        return;
    }

    this->size = size_;

    
    buff_size = flags.blocksize;
    if (parser && parser->processingExtentedObject()) {

        
        
        
        parser->setMaxZeroBlockSize(NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS * 1000);
        if (zeroatomic.isnull()) {
            zeroatomic.initzero(NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS);
        }
    }
    got_flush = false;
    m_chunker     = NULL;
    chunk_top = NULL;
    restdata_child = NULL;
    back_restelem = NULL;

    if (fmt == af_emctar_ads) {
        adsctx = new emctar_ads_context();
    }

    if (info->hold_data) {
        if (backappend_msg)
            DB->msg ("backappend(%p)::backappend() info:%p path:'%s' hold_data:1 info->data.size():%d", this,
                     info, *info->direlemp->fullpath().image(), info->data.size());
        info->data.initlist();
    }

    if( backappend_msg ) DB->msg("backappend(%p)::backappend() path:'%s' size:%"LL"d fmt:%d adsctx:%p%s (parent:%p)",
                                 this, *info->path.image(), f.size64().value(), fmt, adsctx, (adsctx ? *adsctx->image() : ""), parent);

    
    
    if(!f.isnull() && f.contiguous()) {  
        if(size == 0) size = f.size64();
        if(backappend_msg) {
            DB->msg("backappend::backappend is_fileref, size=%s", *size.image());
#if 0  
            if(size <= 256) f.hexdump(false);
                       else f.makeslice(0,256).hexdump(false);
#endif
        }
    } else if(info->direlemp->is_stdin()) {
        if(backappend_msg) DB->msg("is_stdin");

        
        
        if(!parser && file < 0) {
            

            

            
            
            
            
            if(flags.xdrctl || flags.media_in.isempty()) {
                
                file = 0; 
            } else {
                
                file = uwrapper::open_streamdesc(flags.media_in, false, flags.stream_timeoutsecs);
                if(backappend_msg) DB->msg("using fileno %d", file);
                if(file < 0) {
                    Out->msg(FATAL, "<8448>Unable to open '%s'", *flags.media_in);
                } else {
                    
                    
                    file_is_socket = uwrapper::is_socket_streamdesc(flags.media_in);
                }
            }
        }

        if(fmt == af_dumpstream) {
            if (backappend_msg) DB->msg(("DUMP FORMAT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"));
            if (headerp == NULL) {
                Out->msg(ERR, "<5748>Missing header for dump format read");
                
                return;
            }
            totalsize = fileoffset(+headerp->c_dinode.di_size); 
            offset = headerp->c_inumber;  

            if(bdmsg2)DB->msg(("backappend::backappend ndmp dump format totalsize:%s"), *totalsize.image());
        }

    } else if(info->direlemp->is_fifo()) {
        if(backappend_msg) DB->msg("is_fifo");

        
        file = uwrapper::uopen(info->path.image(), O_RDONLY);
    } else if(!f.isnull() && !f.contiguous()) {
        if (size == 0) size = f.size64();
        if(backappend_msg) DB->msg("backappend::backappend is_filedisk, size=%s", *size.image());
    }
    
    if(adeMgr != NULL && adeMgr->ADEChunkerEnabled()) {
        if(isdir) {
            chunkerID = adeMgr->getNewChunker(info, true, isSystemInfo);         
        } else {
            const double fileSize = info->fstats->f_size.value();       
            chunkerID = adeMgr->getNewChunker(info, false, isSystemInfo, (bigint64)fileSize);    
        }
    } else {
        
        adeMgr = NULL;
        if( !info->changeblock ) { 
                                   
            if(isdir) {
                m_chunker = new directory_chunker(flags, info, chunktype::atomicdir, this);
                m_chunker->set_chunker_name( "directory chunker from backappend" );
            } else {
                
                if( ! info->use_container ) {  
                    m_chunker = chunker::pick_atomic(flags, info, chunktype::atomic, this, size);
                    m_chunker->set_chunker_name( "atomic chunker from backappend" );
                }
            }
        }
    }

    if( info->changeblock ) {
        if( chgblkmsg ) DB->msg( "CHGBLK info->changeblock==true" );
        if( chgblkmsg ) DB->msg( "CHGBLK info->path.image()=%s", *info->path.image() );
        if( chgblkmsg ) DB->msg( "CHGBLK info->resulthash=%s", *info->resulthash.partialimage() );
        
        
        
        

	fileoffset cb_offset = info->changeblockoff;

        

	fileoffset cb_length = info->streamslice;

        if( flags.maxentries )
            cb_offset = flags.maxentries;

        DB->msg( "CHGBLK processing change block code inside of backappend.cpp for file=%s offset=%s len=%s",
                  
                                  *info->path.image(),
                                  *cb_offset.image(),
                                  *cb_length.image() );

        if( chgblkmsg ) DB->msg( "CHGBLK *******************processing change block code inside of backappend.cpp for file=%s offset=%s len=%s h=%s",
                  *info->path.image(),
                  *cb_offset.image(),
                  *cb_length.image(),
                  *info->resulthash.partialimage() );

        hashcode basis_hash = info->resulthash;
        if( info->resulthash == hashcode::zero ) {
            Out->msg( FATAL, "<8449>basis hash is zero when info->changeblock == true" );
            set_error( true, ustring("basis hash is zero in changeblock") );
            todoEnqueue(TODO_RESPONSE, this);
            return;
        }

        if( chgblkmsg ) DB->msg( "CHGBLK workelem size=%s", *info->size.image() );
        if( chgblkmsg ) DB->msg( "CHGBLK workelem direlem size=%s", *info->direlemp->file_size().image() );

        old_data.initmem(10);  
        back_restelem = new restelem( old_data );

        
        if(info->cb_append) {
            
            
            cb_offset -= CHANGEBLOCK_APPEND_BASEFILE_SIZE_DIFF;
        }

        back_restelem->startbyte = cb_offset;
        back_restelem->endbyte   = cb_offset+cb_length-1;
        back_restelem->checkrange = true;
        back_restelem->rawmode = false;
        back_restelem->ischangeblockappend = info->cb_append;

        restdata_child = new restdata(this,       
            basis_hash,     
            &rest_ctype,    
            false,          
            *back_restelem, 
            0,              
            cb_length,      
            NULL,           
            0,              
            fileref::empty, 
            -1,             
            this );         

        if( chgblkmsg ) DB->msg( "restdata_child  = %p", restdata_child );
    }
    if(adeMgr == NULL) {
        
        m_collater = new collator(m_chunker);
    }
    main->files_in_process++;
    main->num_open_files++;
    if(xflag[11]&32) {                  
        fname = ustring("(") + info->path.image() + ustring(") ");
        main->open_files_list += fname;
    }

    
    
    if( restdata_child == NULL )
        todoEnqueue(TODO_CHUNK, this);

}



void backappend::doappend(fileref& data, bool checkData ) {

     if (info == NULL) {
        
        assert(!"NULL Info Parameter in backappend doappend()");
        return;
    }

    if (checkData) {
#if CELERRA_CMR10
        
        
        
        

        
        
        if (info->st.isdefined() && info->sb.isdefined()) {
            if (backappend_msg) DB->msg("backappend::doappend using streamtransform on slice of %s bytes", *data.size64().image());

            info->st->appendInput(*(info->sb), data);
            data = info->st->extractOutput(*(info->sb), info->st->getBytesAvailable(*(info->sb)));

            if (backappend_msg) DB->msg("backappend::doappend extracted %s bytes after transform", *data.size64().image());
        }
#endif

        
        if (info->hold_data) {
            info->data.append(data);
        }
    }


    if (info->use_container) {
        assert( m_chunker == NULL );

        const fileoffset mysize(data.size());
        const ustring mypath(info->direlemp->fullpath().image());
        if(backappend_msg)DB->msg("backappend::doappend  ucontainer %d before continue '%s' (mysize:%s)",
                                  info->container->containerid, *mypath, *mysize.image());

        ucontainer::errortype errcode;
        if ((errcode = info->container->continuefile(info->direlemp.getimpl(), mysize, 0)) != ucontainer::pce__success) {
            Out->Abort("backappend::doappend: Problem calling continuefile for '%s' (%s)",
                     *mypath, *ucontainer::error_description(errcode));
            return;
        }

        if(backappend_msg)DB->msg("backappend::doappend  ucontainer %d before appenddata '%s' (mysize:%s)",
                                  info->container->containerid, *mypath, *mysize.image());
        if ((errcode = info->container->appenddata(data)) != ucontainer::pce__success) {
            Out->Abort("backappend::doappend: Problem calling appenddata for '%s' (%s)",
                     *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        }
        if(backappend_msg)DB->msg("backappend::doappend  ucontainer %d after  appenddata '%s' loc:%s", info->container->containerid, *mypath, *info->direlemp->get_location().image());

        if(!isSystemInfo && !isdir) {
            main->getstatsobj(context::backupstats)->add_filebytes_prog(data.size());
        }

    } else if(adeMgr != NULL) {
        
        adeMgr->appendSlice(chunkerID, data);
        if(!isSystemInfo && !isdir) main->getstatsobj(context::backupstats)->add_filebytes_prog(data.size());

    } else {  
        
        if(backappend_msg)DB->msg("backappend::doappend() size=%s desc=%s  is_contiguous=%d num_children=%d",
                                    *data.size64().image(), *data.desc(), data.contiguous(), data.numchildren());
        assert( m_chunker );
        assert(m_chunker->get_chunker_kind().is_anyatomic());

        
        
        if (data.iszero() && data.size() == NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS) {
             if (backappend_msg) DB->msg("backappend::doappend processing filezero data");
            

            
            
            if (!lastChunkWasZeros) {
                if (backappend_msg) DB->msg("backappend::doappend checking for any whole chunks in chunker and spawning");
                
                
                getAndSpawnChunks();

                
                
                
                
                fileref tail = m_chunker->getRemainingBytesInSteam();
                if (tail.size() > 0) {
                    if (backappend_msg) DB->msg("backappend::doappend runt chunk = %s", *tail.desc());
                    assert(tail.offset() == fileoffset(0));
                    spawnChunk(tail);
                }
            }

            spawnChunk(data);
            lastChunkWasZeros = true;
        }
        else {
            
            
            if (backappend_msg) DB->msg("backappend::doappend adding data to chunker input stream");
            m_chunker->append_init(data);
            getAndSpawnChunks();

            lastChunkWasZeros = false;

        }
    }
}


void backappend::getAndSpawnChunks() {
    while(true) {
        fileref datachunk = m_chunker->append_getchunk();
        if(datachunk.size() == 0)
            break;
        if ( backappend_msg ) DB->msg("backappend::getAndSpawnChunks found chunk %s", *datachunk.desc());
        spawnChunk(datachunk);
    }
}


void backappend::spawnChunk(const fileref& datachunk) {
    chunktype ctype(chunktype::atomic);     
    if(isdir) ctype.set_dir();              
    if (backappend_msg) DB->msg("backappend::spawnChunk creating backchunk(%d) to process %s", nforked+1, *datachunk.desc());
    backchunk *b = new backchunk(this, m_chunker, datachunk, ctype, m_collater);
    nforked++;
    b->noop();
}

void backappend::set_chunk( chunker *chunk_ )
{
    
    
    
    
    
    if (adeMgr != NULL && adeMgr->ADEChunkerEnabled()) { 
        DB->msg("backappend::set_chunk with ddr_filesystem");
    } else {
        if( m_chunker == NULL ) {
            if( chgblkmsg ) DB->msg( "backappend::set_chunk previous=NULL" );
        } else {
            if( chgblkmsg ) DB->msg( "backappend::set_chunk previous=%p name=%s", m_chunker, m_chunker->get_chunker_name() );
        }
        m_chunker = chunk_;
        m_collater->set_chunk( chunk_ );
    }
}

void backappend::set_chunk_top( chunker *chunk_ )
{
    
    assert(!info->use_container); 
    chunk_top = chunk_;
}

void backappend::init() {
    const fileoffset startoff = totalsize;

    
    if( backappend_msg )
        DB->msg("backappend(%p)::init() info:%p path:'%s' num_children:%d tsize:%s fmt:%d",
                this, info, *info->path.image(), nforked, *totalsize.image(), fmt);

    if( chgblkmsg ) DB->msg( "CHGBLK backappend::init this=%p", this );


    
    if( uapp::staging().isExitCancel() &&
        !info->path.isempty() && 
        !info->direlemp->is_internal() &&
        !info->direlemp->is_directory()) {
        
        info->direlemp->set_is_partial();
        if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> cancel request, file:%d size:%s", file, *size.image());
        todoEnqueue(TODO_RESPONSE, this);
        return;

    } else if(fmt == af_dumpstream) { 

        
        if (!read_dump_stream()) {
            if (backappend_msg) DB->msg (("backappend::init adding TODO_RESPONSE for ourself."));
            todoEnqueue(TODO_RESPONSE, this);
            return;
        }
    } else if (fmt == af_emctar_ads) { 
        
        if (!read_emctar_ads(info->direlemp->fullpath().image(), adsctx)) {
            if (backappend_msg) DB->msg(("backappend::init adding TODO_RESPONSE for emctar alternate data stream."));
            todoEnqueue(TODO_RESPONSE, this);
            return;
        }

    
    } else if(info->prefetchqueue) {        
        if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> prefetch queue");

        
        bool terminated;
        prefetchbuf *data = (prefetchbuf *)(info->prefetchqueue->dequeue(terminated));
        if(backappend_msg) DB->msg("backappend::init() - From info(%p) prefetchqueue(%p), data = %p terminated = %s",
                                   info, info->prefetchqueue, data, terminated?"yes":"no");
        if(terminated) {
            if( f.iserror(filebase::ERRCODE_ERR) ) {    
                DB->msg("backappend::init error:%s . aborting cycle", *info->path.image() );
                set_error( true, ustring("") );
            }
            todoEnqueue(TODO_RESPONSE, this);
            return;
        }
        totalsize += data->buf.size();
        doappend(data->buf);                        
        curr += data->buf.size();
        delete data;

    
    
    
    } else if(info->direlemp->is_fifo() && (f.isnull() || !f.contiguous()) ) { 
        if(backappend_msg)
            DB->msg("BACKAPPEND ----------------------------> is_fifo  file:%d size(toread):%s totalsize(readsofar):%s", file, *size.image(), *totalsize.image());

        
        
        
        
        

        
        
        if (InUseBlocksOptimizationEnabled && !info->use_container && parser != NULL && parser->processingExtentedObject()) {
            
            if (DoOptimizedExtentsRead()) {
                
                return;
            }
        }
        else {
            

            
            int requestsize = buff_size;
            if(size > 0 && totalsize+requestsize > size)
                requestsize = (size - totalsize).ivalue();
            fileref buf;  
            buf.initmem(requestsize);
            if(backappend_msg) DB->msg("    is_fifo  file:%d size:%s totalsize:%s requestsize:%d",
                                       file, *size.image(), *totalsize.image(), requestsize);

            
            

	        
	        
	        
	        
	        
	        bigint64 runningsize = 0;
	        char* where = buf.start();      
	        while (requestsize > 0) {	
                
                const bigint64 loopsize = (parser == 0) ?
                    (file < 0 ? -1 : (file_is_socket ?
                                      ::recv(file, where, requestsize, 0) :
                                      ::read(file, where, requestsize))) :
                    parser->readdata(where, requestsize);
	            if (backappend_msg) DB->msg("backappend::init: requested %d, read %s", requestsize, *tostr(loopsize));
	            if (loopsize < 0) {	
                    runningsize = loopsize;
	            }
	            if (loopsize <= 0) {	
                    break;
	            }
	            where += loopsize;	        
	            runningsize += loopsize;	
	            requestsize -= (int) loopsize;	
	        }	

            const bigint64 retsize = runningsize;	

            
            if (retsize <= 0) {
                if (parser && (retsize == 0)) {
                    
                    
                    
                    
                    
                    
                    if(requestsize > 0 &&
                       (flags.streamformat_in == utar_flags_enums::streamformat_tar ||
                        flags.streamformat_in == utar_flags_enums::streamformat_pax)) {
                        Out->msg(FATAL, "Received EOF/EOS while reading data for '%s' from archive stream", *info->direlemp->fullpath().image());
                    }
                    parser->recordmarks(info->direlemp);
                }
                todoEnqueue(TODO_RESPONSE, this);
                return;
            }
            totalsize += fileoffset(retsize);
            fileref slice;
            slice.initslice6464(buf, 0, retsize);

#if CELERRA_CMR10
            
            
            
            

            
            
            if (info->st.isdefined() && info->sb.isdefined()) {
                if (backappend_msg)
                    DB->msg("backappend::init using streamtransform on slice of %s bytes",
                            *slice.size64().image());
                info->st->appendInput(*(info->sb), slice);
                slice = info->st->extractOutput(*(info->sb), info->st->getBytesAvailable(*(info->sb)));
                if (backappend_msg)
                    DB->msg("backappend::init extracted %s bytes after transform",
                            *slice.size64().image());
            }
#endif

            
            
            
            
            
            if (info->hold_data) {
                info->data.append(slice);
                if(backappend_msg)
                    DB->msg("backappend::init requestsize:%d path:%s is_tar_hardlink:%d info->hold_data:1 info->data:'%s'",
                            requestsize, *info->path.image(), info->direlemp->is_tar_hardlink(), *ustring(info->data.start(), info->data.size()));
            }

            doappend(slice);                                
        }
    } else if(info->direlemp->is_internal()) {
        if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> is internal"); 

        if( curr >= size ) {
            todoEnqueue(TODO_RESPONSE, this);
            return;
        }

        if (size-curr < fileoffset(buff_size)) {
            fileoffset tmp = size-curr;
            buff_size = tmp.ivalue();
        }

        
        fileref slice;
        slice.initslice64(f, curr, buff_size);
        if (!slice.contiguous())
            slice.makecontiguous();
        
        doappend(slice);                                
        curr += buff_size;
        totalsize += buff_size;

    } else {
        if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> else");

        
        if( isdir || f.contiguous() ) {
            if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> contiguous");
            doappend(f);                                
            curr += size;
            todoEnqueue(TODO_RESPONSE, this);
            return;

        } else {
            if(backappend_msg) DB->msg("BACKAPPEND ----------------------------> default");

            
            fileref buf;
            buf.initmem(buff_size);
            int bytes_read = f.readfilenext(buff_size, buf.start());

            if (bytes_read <= 0) {
                if( f.iserror(filebase::ERRCODE_ERR) ) {
                    DB->msg(("filestream::readfilenext error:%s . aborting cycle"), *info->path.image() );
                    set_error( true, ustring("") );
                }
                todoEnqueue(TODO_RESPONSE, this);
                return;
            }
            totalsize += bytes_read;

            fileref slice;
            slice.initslice(buf, 0, bytes_read);
            
            

            
            if (info->domorph) {
                const int byteoff = (startoff.value()&1)==0 ? 0 : 1;    
                assert(flags.morphfactor >= 0);                         
                assert(!main->morphdata.isnull());
                assert(main->morphdata.size() >= slice.size()+byteoff);
                assert(main->morphdata.size() % 65536 == 0);            
                slice ^= main->morphdata.makeslice(byteoff, slice.size()+byteoff);
            }

            doappend(slice);                    
            curr += bytes_read;
        }
    }

    
    
    if (backappend_msg) DB->msg (("backappend::init adding TODO_CHUNK for ourself again."));
    todoEnqueue(TODO_CHUNK, this);
}


bool backappend::DoOptimizedExtentsRead() {
    int requestsize = buff_size;
    if(size > 0 && totalsize+requestsize > size)
        requestsize = (size - totalsize).ivalue();

    if(backappend_msg) DB->msg("backappend::DoOptimizedExtentsRead:: requestsize:%d doing extents optimization", requestsize);

    
    

	
	
	
	
	


    fileref databuf;
    databuf.initmem(requestsize);
    if (databuf.isnull()) {
        
        DB->msg("backappend::DoOptimizedExtentsRead failed to allocate %d bytes", requestsize);
        set_error(true, "Failed to allocate memory for read buffer");
        return true;
    }
    char * dataptr = databuf.start();
    fileref zerobuf;
    bigint64 runningdatasize = 0;       
    bigint64 runningsize = 0;           

    
    while (requestsize > 0 && !zerobuf.iszero()) {

        
        
        
        const bigint64 loopsize = parser->readdata(dataptr, requestsize, zerobuf);
        assert(!(loopsize > 0 && zerobuf.size() > 0));
        if (backappend_msg) DB->msg("backappend::DoOptimizedExtentsRead: requested %d, read %s filezero:%c", requestsize, *::tostr(loopsize), zerobuf.iszero()?'T':'F');
        if (loopsize < 0) {	
            runningsize = loopsize;
        }
        if (loopsize <= 0 && zerobuf.size() == 0) {	
            break;
        }
        dataptr += loopsize;
        requestsize -= static_cast<int>(loopsize);	
        runningdatasize += loopsize;
        runningsize += (loopsize + zerobuf.size());
    }

    
    if (runningdatasize > 0) {
        
        
        fileref slice;
        slice.initslice6464(databuf, 0, runningdatasize);
        if (backappend_msg) DB->msg("backappend::DoOptimizedExtentsRead regular data = %s", *slice.desc());
        
        doappend(slice, true);
    }

    
    if (zerobuf.iszero()) {
        
        const int numzeros = zerobuf.size();
        const int numFullSizedZeroBlocks = (numzeros / NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS);
        const int remainderZeros = (numzeros % NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS);

        if (backappend_msg) DB->msg("backappend::DoOptimizedExtentsRead got a blob of %d zeros (%d full atomics, %d remainder)", numzeros, numFullSizedZeroBlocks, remainderZeros);

        for (int i = 0; i < numFullSizedZeroBlocks; i++) {
            doappend(zeroatomic, true);
        }

        if (remainderZeros > 0) {
            fileref pzero;

            
            pzero.initmem(remainderZeros);
            pzero.clrdata();
            doappend(pzero, true);
        }
    }

    
	const bigint64 retsize = runningsize;	

    
    if (retsize <= 0) {
        if (parser && (retsize == 0)) {
            
            
            
            
            
            
            if(requestsize > 0 &&
                (flags.streamformat_in == utar_flags_enums::streamformat_tar ||
                flags.streamformat_in == utar_flags_enums::streamformat_pax)) {
                Out->msg(FATAL, "Received EOF/EOS while reading data for '%s' from archive stream", *info->direlemp->fullpath().image());
            }
            parser->recordmarks(info->direlemp);
        }
        todoEnqueue(TODO_RESPONSE, this);
        return true;
    }
    totalsize += fileoffset(retsize);

    return false;
}






void backappend::response(message& outargs)
{
    if(adeMgr != NULL) {
        
        if(forksdone && collectdone) {  
            
            assert(! outargs.isnull());
            msgpack_c::ade_computehash ch(outargs);
            chunktype kind;
            fileref nada;
            ch.res(UNPACK, hash, kind, nada);
            if(kind.is_anyatomic()) cyisatomic = true;  
            if(backappend_msg) {
                DB->msg(("backappend::response(%d) isdir=%d, isatomic=%d name=%s, hash=%s"),
                    id(), cyisdirectory, cyisatomic, *info->path.image(), *hash.partialimage());
            }
            assert(hash != hashcode::zero);
            notifyparent();
            return;
        }
    }
    else {   
        if ( ! info->use_container ) {
            
            
            
            m_collater->flush();
        } 
    }

    
    if( backappend_msg ) DB->msg("backappend::response() path:%s num_children:%d", *info->path.image(), nforked);
    main->files_in_process--; 

    set_sizes_as_needed(totalsize); 

    if( backappend_msg ) DB->msg( "backappend::response child:%d", nforked);
    childdone(NULL);  
}

void backappend::set_sizes_as_needed(const fileoffset& totalsize) {
    
    
    
    if (set_sizes_from_data_regions()) { return; }

    info->size = totalsize;   

    
    if(issavestream) return;

    
    if(adsctx) return;

    
    if((fmt == af_emctar_dedup) || (fmt == af_not_primary)) return;

    
    
    info->direlemp->set_computed_file_size(totalsize);
    if(!info->direlemp->has_accurate_metadata())     
        info->direlemp->set_file_size(totalsize);
}


bool backappend::set_sizes_from_data_regions() {
    data_regions::endoffsets_t endoffsets;
    dirrec_pack::regions dr(info->direlemp.getimpl());

    
    if (!dr.get(endoffsets))
        return false;

    if (endoffsets.size() <= 0) {
        Out->msg(WARN, "Attempting to set direlem size from KIND_REGIONS dirrec, but endoffsets is empty for '%s'",
                 *info->direlemp->fullpath().image());
        return false;
    }

    fileoffset startbyte(0), endbyte(0);
    bool has_primarydata = data_regions::findrange(endoffsets, data_regions::primarydata, true, startbyte, endbyte);
    if (!has_primarydata) {
        Out->msg(WARN, "Attempting to set direlem size from KIND_REGIONS dirrec (%s), but no primarydata section exists for '%s'",
                 *data_regions::image_endoffsets(endoffsets),
                 *info->direlemp->fullpath().image());
    }

    info->direlemp->set_file_size(endbyte - startbyte);
    fileoffset lastendoffset(endoffsets.back().second);
    if (lastendoffset != totalsize) {
        Out->msg(WARN, "Attempting to set direlem size from KIND_REGIONS dirrec, but lastendoffset:%s doesn't match totalsize:%s for '%s'",
                 *lastendoffset.image(), *totalsize.image(), *info->direlemp->fullpath().image());
    }

    
    
    

    info->size = (endbyte - startbyte);
    return true;
}


void backappend::notifyparent() {
    if( backappend_msg ) DB->msg(("backappend::notifyparent() path:%s"), *info->path.image());
    if(parent) {
        if(has_error()) {
            DB->msg(("backappend::notifyparent() aborting cycle:%s"), *info->path.image());
            parent->set_error(true, "");
        }
        if( backappend_msg ) DB->msg(("backappend::notifyparent Changing parent->hash %s = %s"), *parent->hash.partialimage(), *hash.partialimage() );
        parent->hash = hash;
        if( chgblkmsg && info->changeblock ) DB->msg( "backappend::notifyparent hash=%s", *hash.partialimage());
        parent->childdone(this);
    }
    if (autodelete)
        deleteself();
}

void backappend::childdone(cycle *child) {
    if(backappend_msg || chgblkmsg) {
        DB->msg("backappend(%p)::childdone(child=%s @ %p) nforked=%d ncollected=%d forksdone=%d path:'%s'", this,
            (child != NULL ? typeid(*child).name() : ""), child, nforked, ncollected, forksdone, *info->path.image());
    }

    if( chgblkmsg && info->changeblock ) DB->msg( "CHGBLK backappend(%p)::childdone(%s) forksdone=%d nforked=%d oldncollected=%d\n", this, *info->path.image(), forksdone, nforked, ncollected);
    if( chgblkmsg && info->changeblock ) DB->msg( "CHGBLK backappend(%p)::childdone() restdata_child = %p child=%p", this, restdata_child, child );







    if( info->changeblock &&
        restdata_child && child == restdata_child ) {
        
        
        
        todoEnqueue(TODO_CHUNK, this);
        if( chgblkmsg ) DB->msg( "CHGBLK backappend::childdone completed restdata pre portion of backappend %p", child );
        return;
    }

    if( child == NULL ) {
        forksdone = true;
        if (backappend_msg) DB->msg("backappend(%p)::childdone forks done!", this);
    }
    else {
        ncollected++;
    }

    if(forksdone && nforked == ncollected) {
        collectdone = true;
        if(adeMgr != NULL) {  
            
            
            
            adeMgr->getChunkerResultAsyncX(chunkerID, this);
        } else { 
            if (info->use_container) {
                assert( m_chunker == NULL );
            } else {
                m_collater->result(hash, cyisatomic); 
                assert(hash != hashcode::zero);
            }
            if( backappend_msg ) DB->msg( "backappend::childdone(notifyparent) %s", *hash.partialimage());
          
          
            if( info->changeblock ) {
                if( chgblkmsg ) DB->msg( "backappend::childdone changeblock" );
                





                    if( chgblkmsg ) DB->msg( "backappend::childdone changeblock+!truncate%s", info->cb_append ? "+append" : "+!append" );
                    fileoffset cb_offset = info->changeblockoff;
                    fileoffset cb_length = info->streamslice;
                    if( cb_offset+cb_length > max_offset )
                        max_offset = cb_offset+cb_length;
                    size = max_offset;

                info->direlemp->set_file_size( size );
            }
            
            
            
            
            
            
            
            
            
            
            else if (f.size64() != fileoffset::unknown) {
                
                if ((totalsize < f.size64()) && (!f.contiguous())) {
                    
                    if( backappend_msg ) DB->msg("backappend::childdone path \"%s\" total processed bytes %s less than original data size %s.",
                                                 *info->path.image(), *totalsize.image(), *f.size64().image());
                    if( uapp::staging().isExitOkay() )      
                        Out->msg(ERR, "Path \"%s\": Total processed bytes %s is inconsistent with original data size %s",
                                 *info->path.image(), *totalsize.image(), *f.size64().image());
                    info->direlemp->set_internal();  
                    info->direlemp->set_file_size(totalsize);  
                }
                else {
                    if (backappend_msg) DB->msg("backappend(%p)::childdone() path '%s' sizes match", this, *info->path.image());
                }
            }
            notifyparent();
        }
    }
}

backappend::~backappend() {
    main->num_open_files--;
    if(!fname.isempty()) main->open_files_list = main->open_files_list.replace(fname, "");       
    
    if( backappend_msg ) DB->msg( "backappend::~backappend (delete m_chunker)" );

    
    if(fmt == af_axionfs)
        todoEnqueue(TODO_DONE);

    delete adsctx;

    if(m_collater != NULL) {
        delete m_collater;
        m_collater = NULL;
    }
    if(m_chunker != NULL) {
        delete m_chunker;
        m_chunker = NULL;
    }

    if (info && destroy_workelem) {
        if( backappend_msg ) DB->msg( "backappend::~backappend (delete info)" );
        delete info;
        info = NULL;
    }
}

bool backappend::read_dump_stream() {
    bool usednewheader = false;
    if (headerp == NULL) {
        dump_header *new_header = new dump_header;
        if (backappend_msg) DB->msg(("backappend::init  .. reading a header "));
        backdump::read_header(*new_header);
        
        if (new_header->c_type != TS_ADDR) {
            Out->msg(FATAL, "<5749>Lost in dump stream....");
            delete new_header;  
            return false;
        }
        assert(fileoffset(+new_header->c_dinode.di_size) == totalsize);
        headerp = new_header;
        usednewheader = true;
    }
    int readsize = TP_BSIZE;
    bool restisjunk = false;
    if (backappend_msg) DB->msg("backappend::init() do_dumpformat totalsize:%s headerp:%p c_count:%d", *totalsize.image(), headerp, +headerp->c_count);

    fileref zerobuf;
    zerobuf.initmem(readsize);
    zerobuf.clrdata();

    for (int i=0; i<+headerp->c_count; i++) {
        char isdata = headerp->c_data.s_addrs[i];
        
        int bytes_read = 0;
        fileref buf;
        if (isdata == 1) {    
            buf.initmem(readsize);
            bytes_read = backdump::read_stuff(buf.start(), readsize);
            if (bytes_read <= 0) {    
                if (bytes_read != 0) Out->msg(ERR, "<5750>Unable to read file data in dump stream");
                return false;
            }

        } else if (isdata == 0) {   
            
            buf.initslice(zerobuf, 0, readsize);
            bytes_read = readsize;

        } else {  
            Out->msg(ERR, "<5751>Unexpected value in c_data[%d] %d", i, isdata);
            todoEnqueue(TODO_RESPONSE, this);
            return false;
        }
        total_bytes_read += fileoffset(bytes_read);
        if (restisjunk) continue;

        if ( total_bytes_read  > totalsize) {
          bytes_read = ( totalsize - (total_bytes_read- fileoffset(bytes_read)) ).ivalue();
          restisjunk = true;
        }

        fileref slice;
        slice.initslice(buf, 0, bytes_read);  

        if(adeMgr != NULL) {    
            
            adeMgr->appendSlice(chunkerID, buf, true);  
            if(!isSystemInfo && !isdir) main->getstatsobj(context::backupstats)->add_filebytes_prog(buf.size());
        } else {
            assert( m_chunker );
            m_chunker->append_tree(slice, NULL);
        }
    }
    if (usednewheader) {
        struct s_spcl *t = const_cast<struct s_spcl *>(headerp); 
        delete t;
    }
    headerp = NULL;

    if(backappend_msg)DB->msg(("backappend::read_dump_stream done with loop total_bytes_read:%s  totalsize:%s"), *total_bytes_read.image(), *totalsize.image());
    if (total_bytes_read >= totalsize) {        
        if(backappend_msg)DB->msg(("backappend::read_dump_stream we are done"));
        
        return false;
    }
    return true;
}



bool
backappend::read_emctar_ads(const ustring &fname, emctar_ads_context *ctx)
{
    fileref buf;
    bigint64 readsize;

    assert(ctx != NULL);
    if (ctx == NULL) return false;

    if ((ctx->state == s_done) || !uapp::staging().canRun()) {
        if (backappend_msg)
            DB->msg(("backappend::read_emctar_ads state:%d runstage:%s returning false"),
                    ctx->state, *uapp::staging().getRunStageImage());
        return false;
    }

    switch (ctx->state) {
    case s_namelen:
        if (fileoffset::unknown == ctx->startpos)
            ctx->startpos = parser->getbytepos();

        readsize = parser->getdata(sizeof(uint32_t), buf, "emcalt_namelen");
        if (readsize != sizeof(uint32_t)) {
            Out->msg(ERR, "<8007>backappend::read_emctar_ads failed to read 4 bytes for ADS stream name size");
            todoEnqueue(TODO_RESPONSE, this);
            return false;
        }
        ctx->namelen = parsestream_base::extractuint32(buf, 0);
        if (0 == ctx->namelen) ctx->state = s_done;
        else ctx->state = s_name;
        if (backappend_msg)
            DB->msg(("backappend::read_emctar_ads found namelen %lu for %s"),
                    ctx->namelen, *fname);
        break;
    case s_name:
        readsize = parser->getdata(ctx->namelen, buf, "emcalt_name");
        if (readsize != (bigint64)ctx->namelen) {
            Out->msg(ERR, "<8008>backappend::read_emctar_ads failed to read %lu bytes for ADS stream name on %s",
                     ctx->namelen, *fname);
            todoEnqueue(TODO_RESPONSE, this);
            return false;
        }
        ctx->sname = ustring(buf);
        if (backappend_msg)
            DB->msg(("backappend::read_emctar_ads found name %s for %s"),
                    *ctx->sname, *fname);
        ctx->state = s_datalen;
        break;
    case s_datalen:
        readsize = parser->getdata(sizeof(uint64_t), buf, "emcalt_datalen");
        if (readsize != sizeof(uint64_t)) {
            Out->msg(ERR, "<8009>backappend::read_emctar_ads failed to read 8 bytes for datalen of ADS stream '%s' on '%s'",
                     *ctx->sname, *fname);
            todoEnqueue(TODO_RESPONSE, this);
            return false;
        }
        ctx->datalen = parsestream_base::extractulonglong(buf, 0);
        if (0 == ctx->datalen) ctx->state = s_namelen;
        else ctx->state = s_data;
        if (backappend_msg)
            DB->msg(("backappend::read_emctar_ads found %"LL"u datalen for %s on %s"),
                    ctx->datalen, *ctx->sname, *fname);
        break;
    case s_data:
        if (!read_emctar_ads_streambytes(ctx->datalen)) {
            Out->msg(ERR, "<8010>backappend::read_emctar_ads failed to read %"LL"u bytes for ADS stream data '%s' on '%s'",
                     ctx->datalen, *ctx->sname, *fname);
            return false;
        } else {
            if (backappend_msg)
                DB->msg(("backappend::read_emctar_ads read %"LL"u data bytes for %s on %s"),
                        ctx->datalen, *ctx->sname, *fname);
            ctx->state = s_namelen;
        }
        buf.free(); 
        break;
    case s_done:
        break;
    default:
        assert(false);
        ctx->state = s_done;
        break;
    }

    if(adeMgr != NULL) {    
        
        adeMgr->appendSlice(chunkerID, buf, true);  
        if(!isSystemInfo && !isdir) main->getstatsobj(context::backupstats)->add_filebytes_prog(buf.size());
    } else {  
        assert( m_chunker );
        m_chunker->append_tree(buf, NULL);
    }
    bool readmore = s_done != ctx->state;

    
    
    if (!readmore) {
        parser->zero_alignpos();
        ctx->endpos = parser->getbytepos();
        totalsize = ctx->endpos - ctx->startpos;
    }

    return readmore;
}

bool
backappend::read_emctar_ads_streambytes(ubigint64 datalen)
{
    ubigint64 bytesleft = datalen;
    ubigint64 blocksize(1 << 20), toread, didread; 
    fileref buf;

    while ((bytesleft > 0) && uapp::staging().canRun()) {
        toread = (bytesleft < blocksize) ? bytesleft : blocksize;
        didread = parser->getdata(toread, buf, "emcalt_data");
        if (didread != toread) {
            todoEnqueue(TODO_RESPONSE, this);
            return false;
        }

        if(adeMgr != NULL) {    
            
            adeMgr->appendSlice(chunkerID, buf, true);  
            if(!isSystemInfo && !isdir) main->getstatsobj(context::backupstats)->add_filebytes_prog(buf.size());
        } else { 
            assert( m_chunker );
            m_chunker->append_tree(buf, NULL);
        }

        bytesleft -= didread;
    }

    return true;
}

#if !defined(REPLDIR_H_INCLUDED)
#define REPLDIR_H_INCLUDED












#include "cycle.h"
#include "filepipe.h"
#include "restdata.h"


class repldir : public replcycle {
public:
    repldir(replcycle *parent, hashcode& myhash, fileref& listing,
            const bool can_cancel, const chunktype ctype,
            const ustring& name, const time_t filetime,
            const int traverse_depth, workelem* info);
    virtual void init();
    void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual ~repldir();
    SAFEPOOLALLOC(repldir);
private:
    hashcode& myhash;
    fileref& listing;    
    const bool can_cancel;
    const chunktype ctype;
    const ustring name;
    const time_t filetime;
    const int traverse_depth;
    BackCycle* migrateinfochild;
    BackCycle* ddrfilechild;
    BackCycle* workresultschild;
    bool modified_data;
    DIRELEM* workresults_de;  
    DIRELEM* migrateinfo_de;  

    bool should_write_sysinfo() const;  
    void spawn_ddrfiles_child();        
    void spawn_migrateinfo_child();     
    void spawn_workresults_child();     
    void remove_from_listing(const ustring filename, fileref &listing);  
    BackCycle* spawn_sysinfo_child(const ustring filename, const fileref infodata);  
};








class replwholedir : public replcycle {
public:
    replwholedir(replcycle *parent, const hashvect& hv, const int sliceoff,
                 const bool can_cancel, const ustring& name,
                 const chunktype ctype, const epoch_t filetime, const int traverse_depth,
                 workelem* info, cycle* starter);
    virtual void init();
    void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual ~replwholedir();

    DIRELEMp const get_meta_de() { return meta_de; }
    ucontainer::errortype begin_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc);
    ucontainer::errortype begin_dir_content(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc);

    SAFEPOOLALLOC(replwholedir);
private:
    
    class repldumper : public filepipedump_base {
    public:
        
        repldumper(replwholedir* repl_, workelem* info);

        
        ~repldumper();

        
        virtual int dump(const fileref& data);

    private:
        replwholedir *repl;
        workelem *info;
    };

    enum phases { dir_metadata,    
                  dir_content };   

    hashcode rhash;
    const hashvect hvect;
    const bool can_cancel;
    const ustring name;
    const chunktype ctype;
    const epoch_t filetime;
    const int traverse_depth;
    restelem restinfo;
    bool use_raw_container;
    bool has_container_began_dir;
    DIRELEMp meta_de;
    cycle *dep_child;
    phases phase;

    
    bool container_cachehit(DIRELEMp direlem, location loc, hashcode dsthash);

    bool is_ndmp_dephash_available(unsigned char& hashoffset);
    void process_dephash_data(const hashcode& dephash, workelem *info);
};



class migratedir : public replcycle {
public:
    migratedir(replcycle *parent, hashcode& myhash, fileref& listing,
            const bool can_cancel, const chunktype ctype,
            const ustring& name, const time_t filetime,
            const int traverse_depth, workelem* info,
            const int sysinfo_comp_off=0 ,const bool search_sysinfo=false);
    virtual void init();
    void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual ~migratedir(){};
    SAFEPOOLALLOC(migratedir);
private:
    hashcode& myhash;
    fileref& listing;    
    const bool can_cancel;
    const chunktype ctype;
    const ustring name;
    const time_t filetime;
    const int traverse_depth;

    direlemp_list_type de_listing;
    mtex               de_listing_mut; 
    fileoffset         add_de(DIRELEMp de);
    void update_location(workelem *info, DIRELEMp direlem);
    bool process_dirlisting(DIRELEMp del, int curroff, int nextoff, cycle*& prevcycle, bool is_sysinfo = false);
    const int sysinfo_comp_off;
    const bool search_sysinfo;
};

#endif









































#include "common.h"
#include "debug.h"
#include "restdirpart.h"
#include "restdir.h"
#include "export_netappvol.h"
#include "restdata.h"
#include "restfile.h"
#include "restsslicefile.h"
#include "restdephash.h"
#include "restnofilter.h"
#include "todoelem.h"
#include "context.h"
#include "restlink.h"
#include "output.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "pipe_control.h"
#include "backdump.h"
#include "utar_commands.h"
#include "backstate.h"
#include "backview.h"
#include "platerror.h"
#include "emctarpipe.h"
#include "filenames.h"
#include "restisilonsslicefile.h"
#include "restzfssslicefile.h"
#include "ddrfiles_xml.h"

#if SYSTEM_WINDOWS
#include "ntsecurity.h"
#include "winpriv.h"
#include "wss_sis_manager.h"
#include "ntrestore_at_reboot.h"
#endif

#if SYSTEM_UNIX
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif


#define msg1 ((xflag[2]&8)!=0)
#define sis_feature_enabled ((xflag[22]&262144)==0)

#define disablesslicerestfile ((xflag[20]&65536)!=0)
#define dbg_reparse_points      ((xflag[30]&8)!=0)

enum phases { phase_init       = 0, 
              phase_restore_ls = 1, 
              phase_process_ls = 2, 
              phase_forksdone  = 3, 
            };


inline bool OkToRestoreWithoutRestoreSystemFlag(const DIRELEMp direlem);




restdirpart::restdirpart(cycle *parent, const location& _metadatalocation,
                         const restelem& restinfo, cycle *starter,
                         int listingsize_, restdir::Regulator *regulator_)
  : bicycle(parent),
    
    metadatalocation(_metadatalocation),
    pdumpcontext(NULL),     
    dumpdirlist(NULL),      
    pbackdump(NULL),        
    ppipe_control(NULL),    
    for_emctar(false),      
    pbackview(NULL),        
    overwriteexistingSISlink(false),    
    listingOffset(0),
    maxListingOffset(0),
    container_entry_idx(-1),
    previousChild(NULL),    
    info(restinfo),
    listingsize(listingsize_),
    phase(phase_init),      
    regulator(regulator_)
{
    launch(hash, starter);
}


restdirpart::restdirpart(cycle * parent,
                const location& _metadatalocation,
                const restelem&     restinfo,
                const direlemp_list_type_sp& direlems,
                cycle              *starter,
                restdir::Regulator *regulator
               )
  : bicycle(parent),
    
    metadatalocation(_metadatalocation),
    pdumpcontext(NULL),     
    dumpdirlist(NULL),      
    pbackdump(NULL),        
    ppipe_control(NULL),    
    for_emctar(false),      
    pbackview(NULL),        
    overwriteexistingSISlink(false),    
    listingOffset(0),
    maxListingOffset(0),
    container_entry_idx(-1),
    previousChild(NULL),    
    info(restinfo),
    listingsize(0),
    phase(phase_init),       
    regulator(regulator),
    direlemList(direlems)
{
    launch(hash, starter);
}




void restdirpart::launch(const hashcode& hash, cycle *starter)
{
    this->hash = hash;

    if (msg1) {
        const location parent_loc(info.direlem.get_location());
        DB->msg("restdirpart::launch(), destdir:%s, metadataloc:%s\n parentloc:%s direlemList.size=%s", info.direlem.fullpath().image().tostr(),
                    metadatalocation.image().tostr(), parent_loc.image().tostr(), direlemList ? *::tostr(direlemList->size()) : 0);
    }


    cyisdirectory = true;
    
    assert(info.direlem.is_directory() || info.direlem.is_symlink() || direlemList);
    assert(info.restdircycle);


    

    if ((xflag[21]&32)!=0) {    
        if(starter)
            starter->setnext(TODO_DIR, this, 0);
        else
            todoEnqueue(TODO_DIR, this); 
    } else {
        
        
        
        
        if (starter)
            starter->setnext(TODO_DIR, this, -info.restdircycle->traverse_depth);
        else
            todoEnqueueInsert(TODO_DIR, this, -info.restdircycle->traverse_depth);
    }
}




void restdirpart::init() {
    if (phase == phase_process_ls) {    
        DB->msg("restdirpart(%p)::init() requeuing ourself for \"%s\"", this, *info.path.image());
        childdone(NULL);
        return;
    }

    
    if(!info.data.isnull() || direlemList) {
        
        set_phase(phase_restore_ls);
        childdone(NULL);
        return;
    }

    
    
    if(flags.dtoexportstream && (metadatalocation.isFromGsan() && metadatalocation.getHash() == hashcode::zero)) {
        if(msg1) DB->msg("restdirpart::init attempt to export directory with zero hash, using empty data");
        info.data = fileref::empty;
        set_phase(phase_restore_ls);
        childdone(NULL);
        return;
    }

    

    
    
    
    
    
    
    if(msg1) DB->msg(DBTXT("restdirpart::init creating restdata to restore our slice of the listing"));
    if (listingsize == 0) listingsize = 1024;
    info.data.initlist(listingsize);
    if (metadatalocation.isFromCatalog()) {
        hfs_info_struct hfsInfo = main->getAdeMgr()->getHfsInfo(dpn0);
        if (hfsInfo.metaStore != NULL) {
            if (hfsInfo.metaStore->getMetadataChildren(metadatalocation.getMetadataId(), info.data, -1, catalog_state) == storeSuccess) {
                set_phase(phase_restore_ls);
                childdone(NULL);
            }else{
                DB->msg("restdirpart::init failed to get metadata children!");
            }
        }
        else {
            DB->msg("ERROR!! Metadata is on catalog, but there's no interface to the catalog");
        }
    }
    else {
        if(msg1) DB->msg(DBTXT("restdirpart::init creating restdata to restore our slice of the listing"));
        bool isatomic = false; 
        cycle *child = new restdata(this, metadatalocation.getHash(), NULL, isatomic, info);
        if (regulator) regulator->addChild(child);
        set_phase(phase_restore_ls);
    }
}

void restdirpart::childdone(cycle *child) {
    if(msg1)DB->msg("restdirpart::childdone this:%p (child: %s at %p) phase:%d nforked:%d ncollected:%d", this, child ? typeid(*child).name() : "SELF", child, phase, nforked, ncollected);

    
    if (regulator && dynamic_cast<restdephash *>(child) == 0) regulator->removeChild(child);

    assert(phase > phase_init);
    switch (phase) {

    case phase_restore_ls: { 
        if(has_error()) {
            DB->error(DBTXT("error restoring directory %s"), *info.path.image());
            notifyparent();
            return;
        }
        
        if (!process_listing_setup()) return;
        
        
        
        set_phase(phase_process_ls);
        childdone(NULL);    
        break;
    }

    case phase_process_ls: {    
        if(child != NULL) {
            nforked--;
            assert(nforked >= 0);
            if(child == previousChild) {
                previousChild = NULL;
            }
        }

        
        if((flags.streamformat_out == utar_flags_enums::streamformat_avpax ||
            flags.streamformat_out == utar_flags_enums::streamformat_cdsf) &&
           flags.dtoexportstream) {
            if(msg1)DB->msg("restdirpart::childdone() dephashes_restored:%d", info.restdircycle->dephashes_restored);

            
            if(info.restdircycle && !info.restdircycle->dephashes_restored) {
                const int dephashes_nforked(do_restore_dephashes(this, previousChild, info.restdircycle->info));
                nforked += dephashes_nforked;
                info.restdircycle->dephashes_restored = true;
                if(msg1)DB->msg("restdirpart::childdone() dephashes_nforked:%d", dephashes_nforked);
            }
        }

        
        
        
        
        const bool continueProcessing = process_listing();
        if(continueProcessing) {
            if(nforked == 0) {
                DB->msg("restdirpart::childdone: requeuing ourself for \"%s\"", *info.path.image());
                todoEnqueueInsert(TODO_DIR, this, -info.restdircycle->traverse_depth);
            }
            return;
        }
        
        
        
        set_phase(phase_forksdone);
        if(child == NULL) {
            
            return;
        }
        break;
    }

    default:   
        assert(false);
    case phase_forksdone: {
        if(flags.restore_acls_only) {
	        restdata *tmp = dynamic_cast<restdata *>(child);
	        if(tmp != NULL && !tmp->info.direlem.is_directory() && !tmp->info.data.isnull()) {
	            if(tmp->info.direlem.set_win_attributes(tmp->info.data))
	                tmp->info.direlem.set_file_attributes(flags.permissions, (void*)-1, true);
	            else
	                Out->msg(WARN, "<8715>No ACL info for file %s.", *tmp->info.direlem.fullpath().image());
	        }
        }
        
        if(msg1) DB->msg("restdirpart::childdone (this:%p)  done with file/dir(%d) of dir:%s", this, nforked, *info.path.image());
        nforked--;
        assert(nforked >= 0);
        break;
    }
    } 

    
    
    
    
    if(phase == phase_forksdone && nforked == 0) {
        notifyparent();
    }
}

restdirpart::~restdirpart() {
}


void restdirpart::set_phase(int phasenum) {
    if(msg1)DB->msg("restdirpart(%p)::set_phase() setting phase from %d to %d", this, phase, phasenum);
    
    phase = phasenum;
}







bool restdirpart::queryshouldnotcreate(const DIRELEMp direlem) const
{
    bool dontCreate(false);
    const upath path(direlem->fullpath());

    

#if SYSTEM_WINDOWS
    const int numelems(path.numelems());

    
    
    if (numelems == 1) {
        ustring elem_name;
        upath::elemcat elem_cat;
        if(path.get(0, elem_name, elem_cat) && elem_cat == upath::elem_drive) {
            dontCreate = true;
        }
    }

    
    if (path.isUncPath() && (numelems == 1 || numelems == 2)) {
        dontCreate = true;
    }

    
    
    if (direlem->is_globalroot_volume() && (numelems == 2 || numelems == 3 || numelems == 4)) {
        dontCreate = true;
    }

#endif

    
    
    return dontCreate ? dontCreate : direlem->querydirectoryexists(path);
}





bicycle* restdirpart::createrestfile(DIRELEMp direlem, cycle *prevchild, ucontainer::basep container)
{
    if (!disablesslicerestfile
        && (flags.streamformat_out == utar_flags_enums::streamformat_emctar) && (main->getpipe_control(&info) != 0)
        && (direlem->is_stream_slice()
            && direlem->get_location().getMedia() >= location::media::gsan) 
    ) {
        return new restsslicefile(this, direlem->file_hash(), *direlem, prevchild, container);
    }

    if ((main->getpipe_control(&info) != 0) &&
       (flags.streamformat_out == utar_flags_enums::streamformat_isilon))
    {
        if (msg1) DB->msg("restdirpart::createrestfile path=%s, hash=%s, isdir=%d",
                          *info.direlem.fullpath().image(), *direlem->file_hash().partialimage(), direlem->is_directory());
        return new restisilonsslicefile(this, direlem->file_hash(), *direlem, prevchild, container);
    }

    if (main->state->pid_of_backup == pidtype(pidtype::os_zfs, pidtype::ndmp)) {
        if (msg1) DB->msg("restdirpart::createrestfile path=%s, hash=%s, isdir=%d",
                          *info.direlem.fullpath().image(), *direlem->file_hash().partialimage(), direlem->is_directory());
        if ((main->getpipe_control(&info) != 0) && (flags.streamformat_out == utar_flags_enums::streamformat_zfs)) {
            return new restzfssslicefile(this, *direlem, prevchild, container);
        }
        if ((main->getpipe_control(&info) == 0) && (flags.streamformat_out == utar_flags_enums::streamformat_none)) {
            
            
            
            return new restzfscrossfile(this, *direlem, prevchild, container);
        }
    }

    
    restfile* rfp(0);
    
    
    
    if (flags.archive_unfiltered_data && flags.streaming_an_archive() && (main->getpipe_control(&info) != 0)) {
        rfp = new restnofilter(this, direlem->file_hash(), *direlem, container, prevchild, info.vinfo);
    } else {
        rfp = new restfile(this, direlem->file_hash(), *direlem, container, prevchild, info.vinfo);
    }

    
    if(rfp) {
        rfp->set_info_pipe_control(info.ppipe_control);
    }

    return rfp;
}




bool restdirpart::process_listing_setup()
{
    if(msg1)DB->msg("restdirpart(%p)::process_listing_setup() de.path='%s' restdircycle:%p nforked:%d", this, *info.direlem.fullpath().image(), info.restdircycle, info.restdircycle->nforked);

    
    if (!info.restdircycle) {
        assert(false);
        ustring err1(ustring::sprintf(DBTXT("restdirpart::process_listing_setup() mising restdircycle pointer for dir %s"), *info.path.image()));
        DB->error("%s", *err1);
        set_error(true, err1);
        return false;
    }
    rdc = info.restdircycle;

    
    
    
    pdumpcontext = main->getdumpcontext();
    if(pdumpcontext != NULL)
        dumpdirlist = pdumpcontext->add_directory(info.direlem, info.data, rdc->dumpparent);

    pbackdump = main->getbackdump();
    if(pbackdump != NULL)
        pbackdump->add_directory(info.direlem, info.data);

    ppipe_control = main->getpipe_control(&info);
    for_emctar = (ppipe_control != NULL) && ppipe_control->is_emctar();
    pbackview = main->getbackview();

    
    maxListingOffset = info.data.size();
    if (maxListingOffset == 0 && !direlemList) {
        Out->msg(VERBOSE, "No data to work on: %s%s", *info.path.image(), DIRSEPSTR);
        notifyparent();
        return false;
    }

    
    if (maxListingOffset > 0 && direlemList) {
        const ustring errmsg = ustring::sprintf("restdirpart::process_listing_setup Data in two sources: %s", *info.path.image());
        set_error(true, errmsg);
        notifyparent();
        return false;
    }

    
    if (direlemList) {
        direlemListIt = direlemList->begin();
    }

#if SYSTEM_WINDOWS
    
    
    overwriteexistingSISlink = ((flags.existingfileoverwriteoption == utar_flags_enums::existowrite_always)
        || (flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newest));
#endif
    listingOffset = 0;
    return(true);
}


bool restdirpart::get_next_direlem_to_process(DIRELEMp& de) {

    if (direlemList) {
        if (direlemListIt != direlemList->end()) {
            de = *direlemListIt;
            direlemListIt++;

            
            
            de->set_fullpath(de->calculate_file_path(info.path, false));
            if (msg1) DB->msg("restdirpart(%p)::get_next_direlem_to_process direlem(%s) being restored to %s", this, *de->name(), *de->fullpath().image());
            return true;
        }
        else {
            if (msg1) DB->msg("restdirpart(%p)::get_next_direlem_to_process direlemListIt at end", this);
        }
    }
    else if (maxListingOffset > 0) {
        if (listingOffset < maxListingOffset) {
            de = DIRELEMp(new DIRELEM());
            if( de->populate( info.data, listingOffset, info.path ) ) {
                if (msg1) DB->msg("restdirpart(%p)::get_next_direlem_to_process direlem(%s) being restored to %s", this, *de->name(), *de->fullpath().image());
                return true;
            }
            else {
                if (msg1) DB->msg("restdirpart(%p)::get_next_direlem_to_process listingOffset reached maxListingOffset", this);
            }
        }
    }

    return false;
}






bool restdirpart::process_listing()
{
    if (msg1) DB->msg("restdirpart(%p)::process_listing. Restoring contents of '%s' to '%s', parent info->loc:%s", this, *metadatalocation.image(), *info.path.image(), *info.direlem.get_location().image());

    const DIRELEM& parentde = info.direlem;
    const location parent_loc(info.direlem.get_location());

    while (true) {

        if( regulator && !regulator->okToProcessMore() ) {
            
            
            return(true);       
        }

        DIRELEMp direlem_p;
        if (!get_next_direlem_to_process(direlem_p)) {
            break;
        }

        DIRELEM& direlem = *direlem_p;     
        const location locb4 = direlem.get_location();
        if(msg1) DB->msg("restdirpart::process_listing before loc:%s %s",
                         *locb4.image(), *direlem.fullpath().image());
        if (main->handleEsc24121LocMissing(parentde, direlem)) {
            
            
            DB->msg("Direlem's Location was updated by handleEsc24121LocMissing()");
        }

        if (flags.mapi) { direlem.set_is_mapi(); }

        if (msg1) DB->msg("restdirpart::process_listing(targetdir=%s) working on '%s' \n direlemloc:%s", *info.path.image(), *direlem.name(), *direlem.get_location().image());

        location loc(direlem.get_location());
        ucontainer::basep container(NULL); 

        
        if(loc.is_stream() && loc.get_containerid() == 0) {
            container_entry_idx++;
            

            
            main->set_location_info("restdirpart::process_listing()", parent_loc, direlem);

            loc = direlem.get_location(); 
            if (msg1) DB->msg("restdirpart::process_listing(restoretarget=%s) after set_location_info \n direlemloc:%s", *direlem.fullpath().image(), *direlem.get_location().image());

            if (loc.get_containerid() == 0 && !(direlem.is_directory() && loc.get_format() == location::tformat::unknown)) {
                DB->warn("restdirpart::process_listing found de '%s' with containerid:0, but says it's media is %d (> gsan)",
                         *direlem.fullpath().image(), loc.getMedia());
            }

            loc.set_abs_offset_in_container(running_coverage_size[loc.get_containerid()]);
            
            if(loc.get_containerid() == parent_loc.get_containerid()) {
                
                
                if (loc.getMedia() != parent_loc.getMedia() && parent_loc.getMedia() != location::media::unknown)
                    DB->warn("restdirpart::process_listing has parent_loc:%s loc:%s for %s, media doesn't match",
                             *parent_loc.image(), *loc.image(), *direlem.fullpath().image());
                loc.set_abs_offset_in_container(loc.get_abs_offset_in_container() + parent_loc.get_abs_offset_in_container() + parent_loc.get_header_size());
                container = info.container; 
            } else {
                
                
                if(direlem.is_directory()) {
                    DB->msg("restdirpart::processlisting switching containers from %d to %d",
                            parent_loc.get_containerid(), loc.get_containerid());
                    container = main->open_container_for_read(loc);
                }
            }
            location newloc;
            
            
            
            (void)main->handleEsc24121LocAdjustment(parentde, direlem, loc, container_entry_idx, newloc);
            direlem.set_location(newloc);
            loc = direlem.get_location();
            running_coverage_size[loc.get_containerid()] += loc.get_coverage_size();
        }

        if(msg1) DB->msg("restdirpart::process_listing after loc:%s %s",
                         *loc.image(), *direlem.fullpath().image());

        
        if(msg1)
            DB->msg("restdirpart(%p)::process_listing()  new restore (#%d,de.isDir=%d,de.i=%d f.i=%d,de.D:%d,de.M:%d,vinfo:%s): de.fullPath:'%s', loc%s",
                         this, nforked, direlem.is_directory(), direlem.is_internal(),
                         flags.internal, direlem.is_device_file(), direlem.is_device_file_mknode_only(),
                         *info.vinfo.image(), *direlem.fullpath().image(), *loc.image());
        
        if(MULTIPATH_RESTORE && flags.streamformat_out != utar_flags_enums::streamformat_dump) {
            const bool continueProcessing = process_multipath_direlem(direlem_p, container);
            if(!continueProcessing) return(false);  
        }
        else {
            const bool continueProcessing = process_direlem(direlem_p, container);
            if(!continueProcessing) return(false);  
        }
    }
    return(false);   
}







bool restdirpart::process_multipath_direlem(DIRELEMp direlem_p, ucontainer::basep container)
{
    
    ustring pathname;
    int match_level = INVALID_LEVEL_MATCH;
    int match_threshold = 0;

    DIRELEM& direlem = *direlem_p;     

    if((xflag[22]&16)==0 && main->state->targets.root == "." && info.matchpath.isempty())
        pathname = ustring(".");

    pathname = pathname/info.matchpath/direlem.name();
    if(msg1) DB->msg("restdirpart(%p)::process_multipath_direlem() direlem.fullpath = %s, pathname = %s",
            this, *direlem.fullpath().image(), *pathname);

    if(pbackdump != NULL) {
        flags.preservepaths = true;  
    } else if ((xflag[22]&16) == 0) {     
        bool forcematch = true;
        if(main->state->targets.includelist().size() == 0) forcematch = false;
        if(main->state->targets.includelist().size() == 1) match_threshold = 1;

        if (!main->state->targets.pathmatch(upath(pathname), direlem.is_directory(), match_level, forcematch)) {
            if(msg1) DB->msg(DBTXT("restdirpart::process_multipath_listing()- direlem.fullpath = %s has no match."), *direlem.fullpath().image());
            pathname = ustring("");
            return(true);  
        }
    }
    cycle *child = NULL;
    if( !flags.internal && direlem.is_internal() ) {
        if(msg1) DB->msg(DBTXT("     skipping internal direlem: %s"), *direlem.fullpath().image());
        return(true);  

    } else if(direlem.file_hash() == hashcode::zero && !direlem.is_device_file() && !(direlem.get_location().getMedia() > location::media::gsan)) { 
        
        
        
        if(!flags.validate) {
            if(!((direlem.get_kind() == KIND_MACOSX) && direlem.is_fifo()))  
                Out->msg(WARN, "<5167>Permission denied by Server: %s", *direlem.fullpath().image());
        }
        return(true);  
    }

    
    if (!flags.validate) {

        if( !flags.restorehidden && direlem.is_hidden() ) {
            Out->msg(INFO, "<5519>Not Restoring (Hidden): %s", *direlem.fullpath().image());
            return(true);  
        } else if( !flags.restoresystem && direlem.is_system() && !OkToRestoreWithoutRestoreSystemFlag(direlem_p)) {
            Out->msg(INFO, "<5520>Not Restoring (System): %s", *direlem.fullpath().image());
            return(true);  
        } else if( flags.notemporary && direlem.is_markedtemporary() ) {
            Out->msg(INFO, "<5521>Not Restoring (Temporary): %s", *direlem.fullpath().image());
            return(true);  
        }

#if SYSTEM_WINDOWS
        if( !flags.mapi ) {
            if (ntsecurity::IsProtectedFile(direlem.fullpath())) {
                if (flags.restorewfp) {
                    if(!flags.dtoexportstream) {
                        
                        ntsecurity::SetAllowProtectedRenames();
                    }
                } else {
                    Out->msg(INFO, "<6198>Not Restoring (Windows File Protection): %s", *direlem.fullpath().image());
                    return(true);  
                }
            }
        }
#endif
    }

    
    
    bool exclude_dir=false;
    int matchkind=0;
    if (main && main->state &&
        
        
        (rdc->cyexcluded || main->state->excludes.match(direlem.fullpath()))
        ) {
            const upath path(direlem.fullpath());
            matchkind = main->state->includes.match(path);

            DB->msg(DBTXT("restdirpart found exclude %s, matches include?%d"),
                *path.image(), matchkind);
            if (matchkind) {
                cyincluded++;
                
                const upath parentdir(path.parentdir());
                if(msg1)DB->msg(DBTXT("restdirpart include matches %s (%s), dirs:%s"), *direlem.name(), *path.image(), *parentdir.image());
                

            } else if (direlem.is_directory() && !main->state->includes.isempty()
                && ((!flags.makeview     
                && !flags.no_recursion)  
                || (match_level <= match_threshold))) 
            {
                Out->msg(INFO, 3, "<6084>Traversing excluded directory \"%s\"(%s)", *direlem.name(), *direlem.fullpath().image());
                if(!flags.preservepaths && (match_level < match_threshold))  
                    exclude_dir = true;                                        

            } else {
                Out->msg(INFO, 3, "<6085>Excluding \"%s\" (%s) from restore.", *direlem.name(), *direlem.fullpath().image());
                
                return(true);  
            }
    }
    

    
    if (pbackview !=NULL) {
        pbackview->add_direlem(info.direlem, direlem, rdc->traverse_depth, matchkind);
        
        
        assert(flags.makeview);
        if (matchkind==EXCLUDE_ISDIR)
            return(true);  
    }

    if(direlem.is_directory()) {
        if(msg1) DB->msg(DBTXT("     directory: %s"), *direlem.fullpath().image());
        if (!flags.no_recursion || (match_level <= match_threshold)) {
            bool bChildWasPreexisting = true;
            if (!exclude_dir && !flags.validate &&      
                (flags.preservepaths || (match_level >= match_threshold)) &&
                (flags.streamformat_out == utar_flags_enums::streamformat_none)) {   
                    bool    bSecurityRemoved;
                    bool    bFileWasOpen; 

                    ustring namestr = direlem.name();
#if SYSTEM_WINDOWS  
                    if((!flags.preservepaths) || (main->target_path.bytelength() != 0))
                        namestr = DIRELEM::convert_drive_letter((upath)namestr);
#endif
                    if(!flags.preservepaths) {
                        if(match_level == match_threshold)
                            direlem.set_fullpath(upath(main->target_path/namestr));
                        else
                            direlem.set_fullpath(upath(info.direlem.fullpath().image()/namestr));
                        if(msg1) DB->msg(DBTXT("restdirpart:: set restdir full path %s"), *direlem.fullpath().image());
                    }
                    
                    if( flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newname &&
                        direlem.queryexists() &&
                        ! info.isroot &&                    
                        (match_level > match_threshold) &&  
                        ! direlem.is_dot_or_dot_dot() )     
                    {
                        const ustring origname(direlem.fullpath().image());
                        direlem.rename();
                        Out->msg(INFO, "<6528>Restoring directory %s as %s", *origname, *direlem.fullpath().image());
                    }

                    
                    
                    bool bSuccess(queryshouldnotcreate(direlem_p));
                    if(flags.restore_acls_only) {
                        if(!bSuccess){
                            Out->msg(WARN, "<8716>Directory %s does not exist for ACL restore.", *direlem.fullpath().image());
                            return(true);  
                        }
                        if(!flags.existingdiraclrestore)
                            flags.existingdiraclrestore = true;
                    }
                    bool existingoverwritesl(false);
                    
                    
                    if(flags.existingfileoverwriteoption == utar_flags_enums::existowrite_always){
                        existingoverwritesl = true;
                    }
                    bSuccess = direlem.createforrestore(flags.permissions,
                        flags.to_stdout | flags.validate,
                        false, 
                        flags.restoreshortnames,
                        bSecurityRemoved,
                        bFileWasOpen,
                        bChildWasPreexisting,
                        flags.existingdiraclrestore,
                        flags.interceptorCheck, 
                        existingoverwritesl);
                    if( !bSuccess ) {
                        if(bChildWasPreexisting) {
                            if (flags.restoreatreboot) { 
                                DB->msg("restdirpart::process_multipath_direlem: Pre-existing directory cannot be restored, path:\"%s\".", *direlem.fullpath().image());
                            } else {
                                Out->msg(WARN, "<7920>Pre-existing directory cannot be restored, path:\"%s\".",
                                    *direlem.fullpath().image() );
                            }
                        }
                        else {
                            ustring errmsg(errno ? ustring::sprintf(" (%s)", *platerror().description()) : "");
                            Out->msg(FATAL, "<5381>Unable to create directory \"%s\"%s.",   
                                *direlem.fullpath().image(), *errmsg );
                        }
                        return(true);  
                    }
                    if( bSecurityRemoved && !flags.streaming_an_archive() ) {
                        main->adjustdirACLstripped();
                    }
            }
            

            
            restelem restinfo(pathname, direlem.fullpath(), direlem, info.fstats, false, info.vinfo);
            restinfo.container = container;
            restinfo.ppipe_control = info.ppipe_control;

            
            baselocation_sp baseloc(direlem.get_metadataLocation());
            if (!baseloc || baseloc->isFromGsan()) {
                
                baseloc = undoo::make_shared<baselocation>(location::media::gsan, direlem.file_hash());
            }
            child = new restdir(this, location(*baseloc), restinfo, previousChild, dumpdirlist,
                                exclude_dir, rdc->traverse_depth+1, bChildWasPreexisting);

            if (regulator) regulator->addChild(child);
        } else return(true);  

    } else if( flags.dtoexportstream || restelem::is_celerra_streamslice_restore(direlem, main->state->pid_of_backup, flags.pluginid) ) {
        
        
        
        if (skipfifoonrestore && emctarpipe::isfifo(direlem))
        {
            Out->msg(INFO, "<12534>Ignoring FIFO file '%s' during Celerra NDMP restore", *direlem.fullpath().image());
            return true;
        }

        
        
        
        
        
        
        
        if(info.direlem.name() == UNDOO_DIRECTORY_NAME && info.direlem.is_internal() &&
           direlem.name() == EXPORTSTREAM_METADATA_FILENAME && direlem.is_internal()) {
            if(msg1) DB->msg(DBTXT("     skip exporting 'file': %s"), *direlem.fullpath().image());
            return true;  
        }

        
        if(msg1) DB->msg(DBTXT("     exported (or streamslice restore) 'file': %s"), *direlem.fullpath().image());
        
        child = createrestfile(direlem_p, previousChild, container);
        if (regulator) regulator->addChild(child);

        main->addfilecount(context::restorestats, 1);
        main->addfilebytes(context::restorestats, direlem.file_size().dvalue());

    } else if(pdumpcontext != NULL || pbackdump != NULL || pbackview != NULL) {
        return(true);  

    } else if( (flags.streamformat_out != utar_flags_enums::streamformat_isilon) &&
        (flags.streamformat_out != utar_flags_enums::streamformat_zfs) &&
        (direlem.is_device_file_mknode_only() ||
        (for_emctar && (emctarpipe::isfifo(direlem) ||
        emctarpipe::ischr(direlem) ||
        emctarpipe::isblk(direlem)))))
    {   
        if(msg1) DB->msg(DBTXT("     device file: %s"), *direlem.fullpath().image());

        if( flags.validate ) return(true);  

        
        
        
        if( for_emctar || (flags.permissions && flags.restoresystem) || direlem.is_fifo() ) {
            main->addfilecount(context::restorestats, 1);
            main->addfilebytes(context::restorestats, direlem.file_size().dvalue());
            assert( !direlem.is_symlink() );
            assert( !direlem.is_internal() );
            assert( direlem.is_unix_special_file() );
            assert( !direlem.should_skip_this_file() );
            
            
            
            if( !for_emctar ) {
                
                direlem.set_file_attributes(flags.permissions);              
                
            } else {
                hashcode rh;
                fileref altdum, stubdum;
                bool is_tar_hl = main->hardlinked_file(direlem, rh, altdum, stubdum);
                DB->msg (DBTXT("restdirpart::childdone found device file for emctar output, calling ppipe_control->addfile() for '%s' device:%d rdev:%u, context::hardlinked_file returned %d"),
                    *direlem.fullpath().image(), direlem.device_number(), direlem.unix_rdev(), is_tar_hl);
                if (is_tar_hl) {
                    
                    assert(altdum.isnull());
                    assert(stubdum.isnull());
                } else {
                    
                    if (skipfifoonrestore && emctarpipe::isfifo(direlem)) {
                        Out->msg(INFO, "<12534>Ignoring FIFO file '%s' during Celerra NDMP restore", *direlem.fullpath().image());
                    } else {
                        
                        fileref dataref, altref, stubref, extentsdata;
                        ppipe_control->addfile(direlem, direlem.fullpath().image(), dataref, altref, stubref, extentsdata);
                    }
                }
            }
        } else {
            Out->msg(INFO, 2, "<5080>Special file '%s' not restored.  Use --restoresystem as root to restore", *direlem.fullpath().image());
        }
        return(true);  

    } else if(direlem.is_symlink()) {           
        if(msg1) DB->msg("     sym link: %s", *direlem.fullpath().image());
        main->addfilecount(context::restorestats, 1);
        main->addfilebytes(context::restorestats, direlem.file_size().dvalue());
#if SYSTEM_UNIX
        ustring ufullpath = direlem.fullpath().image()/direlem.name();
        if(!flags.preservepaths) {
            if(match_level == 0)
                direlem.set_fullpath(upath(main->target_path/direlem.name()));
            else
                direlem.set_fullpath(upath(info.direlem.fullpath().image()/direlem.name()));
            if(msg1) DB->msg(DBTXT("restdirpart:: set restlink full path %s"), *direlem.fullpath().image());
        }
        child = new restlink(this, direlem.file_hash(), ufullpath, direlem.fullpath().image(), direlem, previousChild);
        if (regulator) regulator->addChild(child);
#else
        
        
        
        
        return(true);  
#endif
    } else {
        if(!flags.preservepaths) {
            if(match_level == 0)
                direlem.set_fullpath(upath(main->target_path/direlem.name()));
            else
                direlem.set_fullpath(upath(info.direlem.fullpath().image()/direlem.name()));
            if(msg1) DB->msg(DBTXT("restdirpart:: set restfile full path %s"), *direlem.fullpath().image());
        }
        if(msg1) DB->msg(DBTXT("     normal file or streamslice file: %s"), *direlem.fullpath().image());
        
        main->addfilecount(context::restorestats, 1);
        if(msg1)DB->msg("restdirpart:: file hash %s, info.path %s, info.direlem.fullpath %s",
            *direlem.file_hash().partialimage(), *info.path.image(), *info.direlem.fullpath().image());
        if(flags.restore_acls_only) {
            if(!direlem.queryfileexists(direlem.fullpath())) {
                Out->msg(WARN, "<8717>File %s does not exist for ACL restore.", *direlem.fullpath().image());
                return(true);  
            }
#if SYSTEM_WINDOWS
            const int acldatasize =100000;
            restelem restinfo(direlem.fullpath(), direlem, info.fstats, true, info.vinfo, 0, acldatasize - 1);
            restinfo.ppipe_control = info.ppipe_control;
            restinfo.data.initlist(acldatasize);
            child = (bicycle*)new restdata(this, direlem.file_hash(), NULL, direlem.is_atomic(), restinfo);
            if (regulator) regulator->addChild(child);
#else
            direlem.set_file_attributes(flags.permissions, (void*)-1, true);
            return(true);  
#endif
        } else {
            
            child = createrestfile(direlem_p, previousChild, container);
            if (regulator) regulator->addChild(child);
        }
    }

    assert(child != NULL);
    nforked++;
    if(ppipe_control != NULL) {
        
        previousChild = child;
    }
    if(msg1) {
        if(direlem.is_directory()) {
            DB->msg(DBTXT("  new restore dir():'%s', forked=%d"), *direlem.fullpath().image(), nforked );
        }
        else {
            DB->msg(DBTXT("  new restore file():'%s', forked=%d"), *direlem.fullpath().image(), nforked );
        }
    }
    return(true);  
}





bool restdirpart::process_direlem(DIRELEMp direlem_p, ucontainer::basep container)
{
    DIRELEM& direlem = *direlem_p;     

    if (msg1) DB->msg("restdirpart(%p)::process_direlem() de.Path(destpath)='%s'\nparentloc:%s", this, *direlem.fullpath().image(), *direlem.get_location().image());

    
    if (!flags.validate) {
        if( !flags.internal && direlem.is_internal() ) {
            if(msg1) DB->msg(DBTXT("     skipping internal direlem: %s"), *direlem.fullpath().image());
            return(true);  

        } else if(direlem.file_hash() == hashcode::zero && direlem.get_location().getMedia() <= location::media::gsan) {
            
            
            
            if(!flags.dtoexportstream) {
                
                
                
                
                
                if(!direlem.is_device_file() && !direlem.is_reparsePoint()) {
                    
                    if(!((direlem.get_kind() == KIND_MACOSX) && direlem.is_fifo()))  
                        Out->msg(WARN, "<5167>Permission denied by Server: %s", *direlem.fullpath().image());

                    return(true);  
                }
            }
        }

        if( !flags.restorehidden && direlem.is_hidden() ) {
            Out->msg(INFO, "<5519>Not Restoring (Hidden): %s", *direlem.fullpath().image());
            return(true);  
        } else if( !flags.restoresystem && direlem.is_system() && !OkToRestoreWithoutRestoreSystemFlag(direlem_p)) {
            Out->msg(INFO, "<5520>Not Restoring (System): %s", *direlem.fullpath().image());
            return(true);  
        } else if( flags.notemporary && direlem.is_markedtemporary() ) {
            Out->msg(INFO, "<5521>Not Restoring (Temporary): %s", *direlem.fullpath().image());
            return(true);  
        }

#if SYSTEM_WINDOWS
        if( !flags.mapi ) {
            if (ntsecurity::IsProtectedFile(direlem.fullpath())) {
                if (flags.restorewfp) {
                    
                    ntsecurity::SetAllowProtectedRenames();
                } else {
                    Out->msg(INFO, "<6198>Not Restoring (Windows File Protection): %s", *direlem.fullpath().image());
                    return(true);  
                }
            }
        }
#endif
    } else { 

        
        
        
        
        const bool is_system_info_dir(direlem.is_directory() && direlem.name().equal(UNDOO_DIRECTORY_NAME) && direlem.is_internal() && (rdc->traverse_depth == 0));

        if( is_system_info_dir && !flags.internal ) {
            return(true);  
        }

        main->validate_direlem(direlem);  
    }

    
    
    bool exclude_dir=false;
    int matchkind=0;
    if (main && main->state &&
        
        
        (rdc->cyexcluded || main->state->excludes.match(direlem.fullpath()))
        ) {
            const upath path(direlem.fullpath());
            matchkind = main->state->includes.match(path);

            DB->msg(DBTXT("restdirpart found exclude %s, matches include?%d"),
                *path.image(), matchkind);
            if (matchkind) {
                cyincluded++;
                
                const upath parentdir(path.parentdir());
                if(msg1)DB->msg(DBTXT("restdirpart include matches %s (%s), dirs:%s"), *direlem.name(), *path.image(), *parentdir.image());
                if (!flags.validate) utar_commands::mkdir_full(flags, parentdir.image());

            } else if (direlem.is_directory() && !main->state->includes.isempty()
                && !flags.makeview 
                && !flags.no_recursion 
                ) {
                    Out->msg(INFO, 3, "<6084>Traversing excluded directory \"%s\"(%s)", *direlem.name(), *direlem.fullpath().image());
                    exclude_dir = true;

            } else {
                Out->msg(INFO, 3, "<6085>Excluding \"%s\" (%s) from restore.", *direlem.name(), *direlem.fullpath().image());
                
                return(true);  
            }
    }
    

    
    if (pbackview !=NULL) {
        pbackview->add_direlem(info.direlem, direlem, rdc->traverse_depth, matchkind);
        
        
        assert(flags.makeview);
        if (matchkind==EXCLUDE_ISDIR)
            return(true);  
    }

    cycle *child = NULL;
    if(direlem.is_directory()) {
        if(msg1) DB->msg("     target directory: '%s'", *direlem.fullpath().image());
        if (!flags.no_recursion) {
            bool bChildWasPreexisting = true;
            if (!exclude_dir && !flags.validate &&      
                (flags.streamformat_out == utar_flags_enums::streamformat_none)) {   
                    bool    bSecurityRemoved;
                    bool    bFileWasOpen; 

                    
                    if( flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newname &&
                        direlem.queryexists() &&
                        ! info.isroot &&                    
                        ! direlem.is_dot_or_dot_dot() )     
                    {
                        const ustring origname(direlem.fullpath().image());
                        direlem.rename();
                        Out->msg(INFO, "<6528>Restoring directory %s as %s", *origname, *direlem.fullpath().image());
                    }

                    
                    
                    bool bSuccess(queryshouldnotcreate(direlem_p));
                    if(flags.restore_acls_only) {
                        if(!bSuccess){
                            Out->msg(WARN, "<8716>Directory %s does not exist for ACL restore.", *direlem.fullpath().image());
                            return(true);  
                        }
                        if(!flags.existingdiraclrestore)
                            flags.existingdiraclrestore = true;
                    }

                    
                    
                    const bool existingoverwritesl = (flags.existingfileoverwriteoption == utar_flags_enums::existowrite_always);

                    
                    bSuccess = direlem.createforrestore(flags.permissions,
                        flags.to_stdout | flags.validate,
                        false, 
                        flags.restoreshortnames,
                        bSecurityRemoved,
                        bFileWasOpen,
                        bChildWasPreexisting,
                        flags.existingdiraclrestore,
                        flags.interceptorCheck, 
                        existingoverwritesl);
                    if( !bSuccess ) {
                        if (!flags.restoreatreboot) { 
                            if(bChildWasPreexisting) {
                                Out->msg(WARN, "<7920>Pre-existing directory cannot be restored, path:\"%s\".",
                                    *direlem.fullpath().image() );
                            }
                            else {
                                ustring errmsg(errno ? ustring::sprintf(" (%s)", *platerror().description()) : "");
                                Out->msg(FATAL, "<5381>Unable to create directory \"%s\"%s.",   
                                    *direlem.fullpath().image(), *errmsg );
                            }
                            return(true);  

                        } else {  
#if SYSTEM_WINDOWS
                            if(bChildWasPreexisting) {
                                ustring direlem_path = direlem.fullpath().image();
                                if (!direlem.is_directory_writable()) {
                                    if (flags.restorewfp) {
                                        DB->msg("restdirpart::process_direlem(): Restoring windows protected directory %s to temp location", *direlem_path);

                                        
                                        if (!create_in_temp_for_restore(direlem_p)) {
                                            Out->msg(ERR, "Unable to create restore directory in temp location, path:\"%s\".", *direlem_path);
                                            return false;
                                        } else {
                                            DB->msg("restdirpart::process_direlem(): Created restore directory in temp location, path:\"%s\".", *direlem_path);
                                        }

                                        
                                        ntsecurity::SetAllowProtectedRenames();

                                        
                                        bChildWasPreexisting = false;

                                        bSuccess = true;
                                    } else {
                                        Out->msg(ERR, "Specify '--restorewfp' flag to restore windows protected directories, path:\"%s\"", *direlem_path);
                                        return false;
                                    }
                                }
                            } else {
                                Out->msg(FATAL, "<5381>Unable to create directory \"%s\".",   
                                    *direlem.fullpath().image() );
                                return false;
                            }
#endif
                        }
                    }
                    if( bSecurityRemoved && !flags.streaming_an_archive() ) {
                        main->adjustdirACLstripped();
                    }
            }

            

            
            restelem restinfo(direlem.fullpath(), direlem, info.fstats, false, info.vinfo);
            restinfo.container = container;
            restinfo.ppipe_control = info.ppipe_control;

            
            
            const bool is_netapp(main->state->pid_of_backup == pidtype(pidtype::os_netapp, pidtype::ndmp));
            if((is_netapp && info.isroot && flags.dtoexportstream) && !direlem.is_internal()) {
                const location theloc(location::media::gsan, direlem.file_hash());
                child = new export_netappvol(this, theloc, restinfo, previousChild, dumpdirlist,
                                             exclude_dir, rdc->traverse_depth+1, bChildWasPreexisting,
                                             false );
            } else {
                
                bool restoreContents = true;
                if (direlem.is_reparsePoint()) {
                    restoreContents = ReparsePoints::HandleReparsePointForRestore(direlem, flags.permissions, flags.to_stdout, flags.validate, flags.existingfileoverwriteoption,
                                        flags.restoreshortnames, flags.existingdiraclrestore, flags.interceptorCheck);
                }
                if (restoreContents) {
                    if (metadatalocation.isFromCatalog()) {
                        location nextmetaloc(metadatalocation);
                        nextmetaloc.setMetadataId(MetadataId(direlem.get_metadataLocation()->getMetadataId()));
                        child = new restdir(this, nextmetaloc, restinfo, previousChild, dumpdirlist,
                                        exclude_dir, rdc->traverse_depth+1, bChildWasPreexisting);
                    }
                    else {
                        child = new restdir(this, location(location::media::gsan, direlem.file_hash()), restinfo, previousChild, dumpdirlist,
                                        exclude_dir, rdc->traverse_depth+1, bChildWasPreexisting);
                    }
                }
            }

            if (regulator) regulator->addChild(child);
        } else return(true);  

    } else if( flags.dtoexportstream || restelem::is_celerra_streamslice_restore(direlem, main->state->pid_of_backup, flags.pluginid) ) {
        
        
        
        if (skipfifoonrestore && emctarpipe::isfifo(direlem))
        {
            Out->msg(INFO, "<12534>Ignoring FIFO file '%s' during Celerra NDMP restore", *direlem.fullpath().image());
            return true;
        }

        
        if(info.direlem.name() == UNDOO_DIRECTORY_NAME && info.direlem.is_internal() &&
           direlem.name() == EXPORTSTREAM_METADATA_FILENAME && direlem.is_internal()) {
            if(msg1) DB->msg(DBTXT("     skip exporting 'file': %s"), *direlem.fullpath().image());
            return true;  
        }

        
        if(msg1) DB->msg(DBTXT("     exported (or streamslice restore) 'file': %s"), *direlem.fullpath().image());
        
        child = createrestfile(direlem_p, previousChild, container);
        if (regulator) regulator->addChild(child);

        main->addfilecount(context::restorestats, 1);
        main->addfilebytes(context::restorestats, direlem.file_size().dvalue());

    } else if(pdumpcontext != NULL || pbackdump != NULL || pbackview != NULL) {
        return(true);  

    } else if( direlem.is_device_file_mknode_only() ||
        (for_emctar && (emctarpipe::isfifo(direlem) ||
        emctarpipe::ischr(direlem) ||
        emctarpipe::isblk(direlem))))
    {   
        if(msg1) DB->msg(DBTXT("     device file: %s"), *direlem.fullpath().image());

        if( flags.validate ) return(true);  

        
        
        
        if( for_emctar || (flags.permissions && flags.restoresystem) || direlem.is_fifo() ) {
            main->addfilecount(context::restorestats, 1);
            main->addfilebytes(context::restorestats, direlem.file_size().dvalue());
            assert( !direlem.is_symlink() );
            assert( !direlem.is_internal() );
            assert( direlem.is_unix_special_file() );
            assert( !direlem.should_skip_this_file() );
            
            
            
            if( !for_emctar ) {
                
                direlem.set_file_attributes(flags.permissions);              
                
            } else {
                hashcode rh;
                fileref altdum, stubdum;
                bool is_tar_hl = main->hardlinked_file(direlem, rh, altdum, stubdum);
                DB->msg (DBTXT("restdirpart::childdone found device file for emctar output, calling ppipe_control->addfile() for '%s' device:%d rdev:%u, context::hardlinked_file returned %d"),
                    *direlem.fullpath().image(), direlem.device_number(), direlem.unix_rdev(), is_tar_hl);
                if (is_tar_hl) {
                    
                    assert(altdum.isnull());
                    assert(stubdum.isnull());
                } else {
                    if (skipfifoonrestore && emctarpipe::isfifo(direlem)) {
                        Out->msg(INFO, "<12534>Ignoring FIFO file '%s' during Celerra NDMP restore", *direlem.fullpath().image());
                    } else {
                        
                        fileref dataref, altref, stubref, extentsdata;
                        ppipe_control->addfile(direlem, direlem.fullpath().image(), dataref, altref, stubref, extentsdata);
                    }
                }
            }
        } else {
            Out->msg(INFO, 2, "<5080>Special file '%s' not restored.  Use --restoresystem as root to restore", *direlem.fullpath().image());
        }
        return(true);  

    }
    
    else if(direlem.is_symlink()) {           
        if(msg1) DB->msg("     sym link: %s", *direlem.fullpath().image());
        main->addfilecount(context::restorestats, 1);
        main->addfilebytes(context::restorestats, direlem.file_size().dvalue());
#if SYSTEM_UNIX
        child = new restlink(this, direlem.file_hash(), direlem.fullpath().image(), direlem, previousChild);
        if (regulator) regulator->addChild(child);
#else
        
        
        
        
        return(true);  
#endif
    }
    else {
        if(msg1) DB->msg(DBTXT("     normal file: %s"), *direlem.fullpath().image());

        bool reparseRestoreFile = true;
        if (direlem.is_reparsePoint()) {
            reparseRestoreFile = ReparsePoints::HandleReparsePointForRestore(direlem, flags.permissions, flags.to_stdout, flags.validate, flags.existingfileoverwriteoption,
                                        flags.restoreshortnames, flags.existingdiraclrestore, flags.interceptorCheck);
        }

        
        main->addfilecount(context::restorestats, 1);
        if(flags.restore_acls_only) {
            if(!direlem.queryfileexists(direlem.fullpath())) {
                Out->msg(WARN, "<8717>File %s does not exist for ACL restore.", *direlem.fullpath().image());
                return(true);  
            }
#if SYSTEM_WINDOWS
            const int acldatasize =100000;
            const location loc(direlem.get_location());
            restelem restinfo(direlem.fullpath(), direlem, info.fstats, true, info.vinfo, 0, acldatasize - 1);
            if(restinfo.container.isnull()) {
                if (container.isdefined())
                    restinfo.container = container;
                else if (loc.getMedia() > location::media::gsan)
                    restinfo.container = main->open_container_for_read(loc);
            }
            restinfo.ppipe_control = info.ppipe_control;
            restinfo.data.initlist(acldatasize);
            child = (bicycle*)new restdata(this, direlem.file_hash(), NULL, direlem.is_atomic(), restinfo, (loc.getMedia() > location::media::gsan) );
            if (regulator) regulator->addChild(child);
#else
            direlem.set_file_attributes(flags.permissions, (void*)-1, true);
            return(true);  
#endif
        }
        else {
#if SYSTEM_WINDOWS
            if ((wss_sis_manager::sis_manager != NULL) && direlem.get_reparseType() == REPARSE_SIS) {
                
                if(!ReparsePoints::restore_sislink(direlem, overwriteexistingSISlink)) {
                    if(!sis_feature_enabled)
                        return(true);
                }
                if(!wss_sis_manager::sis_manager->is_sis_enabled()) {

                    DIRELEM de_alt;
                    upath common_store_file_path;

                    if(!wss_sis_manager::sis_manager->collect_common_store_file_name(common_store_file_path)) {
                        Out->msg(ERR, "<10682>Common Store hash not found. Skipping '%s' file.", *direlem.fullpath().image());
                        return(true);  
                    }

                    hashcode cs_hash;
                    if(!wss_sis_manager::sis_manager->lookup_cs_file_hash(common_store_file_path.image(), cs_hash)) {
                        Out->msg(WARN, "<10683>Failed to lookup SIS common Store file: %s", *direlem.fullpath().image());
                        return(true);  
                    }

                    
                    
                    child = new restfile(this, cs_hash, direlem, container, previousChild, info.vinfo);
                    if (regulator) regulator->addChild(child);
                } else {
                    
                    child = new restfile(this, direlem.file_hash(), direlem, container, previousChild, info.vinfo);
                    if (regulator) regulator->addChild(child);
                }
            } else 
#endif
            {
                
                bool restoreFile = true;
                if (!reparseRestoreFile) {
                    restoreFile = false;
                }
                if (restoreFile) {
                    child = createrestfile(direlem_p, previousChild, container);
                    if (regulator) regulator->addChild(child);
                }
            }
        }
    }

    
    if (child != NULL) {
        nforked++;
        if(ppipe_control != NULL) {
            
            previousChild = child;
        }
        if(msg1) {
            if(direlem.is_directory()) {
                if (msg1) DB->msg("restdirpart::process_direlem (this: %p) new restore dir():'%s', forked=%d", this, *direlem.fullpath().image(), nforked );
            }
            else {
                if (msg1) DB->msg("restdirpart::process_direlem (this: %p) new restore file():'%s', forked=%d", this, *direlem.fullpath().image(), nforked );
            }
        }
    }
    else {
        if (msg1) DB->msg("  skipping restore of direlem contents (was a reparse point?)");
    }
    return(true);  
}







int restdirpart::do_restore_dephashes(bicycle *parent,
                                      cycle* &prevchild,
                                      const restelem& linfo)
{
    int forked_count(0);

    hashvect hashes;
    linfo.direlem.getdephashes(hashes);

    
    if(hashes.size() > 1) {
        
        for(hashvect::size_type i = 1; i < hashes.size(); i++) {
            
            
            
            
            

            DIRELEM dephashde;

            

            
            
            
            
            

            
            

            dephashde.set_name(tostr(i - 1));
            dephashde.set_fullpath(linfo.direlem.fullpath());
            dephashde.set_hash(hashes[i]);
            dephashde.set_mtime(linfo.direlem.mtime());

            cycle *child = new restdephash(parent, hashes[i], dephashde, prevchild);
            if(child) {
                child->noop();
                forked_count++;
                
                prevchild = child;
            }
        }
    }

    return forked_count;
}

#if SYSTEM_WINDOWS




bool restdirpart::create_in_temp_for_restore(DIRELEMp direlem_p)
{
    
    ustring restore_time_stamp;
    ntrestore_at_reboot::get_restore_time_stamp(restore_time_stamp);

    const upath drive(direlem_p->fullpath().slice(upath::elem_drive, true, true)); 
    const upath path_without_drive(direlem_p->fullpath().slice(upath::elem_drive, false, false)); 

    
    ustring temp_restore_dir(drive.image());
    temp_restore_dir += "\\temp_restore\\";
    temp_restore_dir += restore_time_stamp;

    
    
    ntrestore_at_reboot::set_temp_restore_dir_list(temp_restore_dir);

    
    temp_restore_dir += path_without_drive.image();

    const upath temp_dir_path(temp_restore_dir);
    if (!DIRELEM::queryexists(temp_dir_path)) {

        direlem_p->set_fullpath(temp_dir_path);

        DB->msg("restdirpart::create_in_temp_for_restore(): Creating restore directory in temp location, path:\"%s\"", *temp_restore_dir);
        return (utar_commands::mkdir_full(flags, temp_restore_dir));
    }

    return true;
}
#endif



inline bool OkToRestoreWithoutRestoreSystemFlag(const DIRELEMp direlem_p) {
#if SYSTEM_WINDOWS
    
    
    if (direlem_p->is_directory() && direlem_p->is_reparsePoint() && !direlem_p->is_readOnly()) {
        return true;
    }
#endif

    return false;
}




















#include "common.h"
#include "debug.h"
#include "restcompdata.h"
#include "context.h"
#include "chunktype.h"
#include "msgpack_c.h"
#include "output.h"
#include "runstage.h"
#include "compelem.h"
#include "tagduns.h"

#define msg1 ((xflag[1]&0x10)!=0) 
#define msg2 ((xflag[1]&0x20)!=0) 
#define msg3 ((xflag[11]&4)!=0)   

restcompdata::restcompdata(
             cycle *parent,                
             restelem& restinfo,           
             fileref& compdata_,           
             const fileoffset offset_,     
             chunktype compkind_,          
             cycle *starter,               
             const bigint64 prior_,        
             int hintconn,                 
             backappend *root_file_cycle_  
             ) 
  : cycle(parent),
    info(restinfo),
    compdata(compdata_),
    compkind(compkind_),
    redocount(0),
    conn(hintconn),
    prior(prior_),
    root_file_cycle( root_file_cycle_ )
{
    assert(!compdata.isnull());
    
    this->offset = offset_;
    
    if (starter)
        starter->setnext(TODO_CHUNK, this, prior);
    else
        todoEnqueueInsert(TODO_CHUNK, this, prior);
}

restcompdata::~restcompdata()
{
    
}

void restcompdata::init() 
{
    if(msg1) DB->msg("restcompdata: path=%s, prior=%"LL"d", *info.path.image(), prior);
    send();
}

void restcompdata::send()
{
    message m;
    msgpack_c::getcompdata gcd(m);
    gcd.arg(PACK, compkind, compdata);
    
    if (msg1) DB->msg("restcompdata:send off:%s", *offset.image());
    
    main->remotecall(this, m, conn);    
}

void restcompdata::response(message& outargs) {
    if (outargs.isnull()) {
        if (msg2) DB->msg("restcompdata::response %s, fileref.count = %d", *info.direlem.fullpath().image(), info.data.getrefcount() );
        info.data.free();
        notifyparent();
        return;
    }

    fileref outdata;
    chunktype ckind;
    {
        undoo::vector<tagduns> chunksizes;
        msgpack_c::getcompdata gcd(outargs);
        gcd.res(UNPACK, ckind, chunksizes, outdata);
    
        if (msg2)
            DB->msg("MSG recv getcompdata %s %"Z"u %d", 
                         *ckind.image(), chunksizes.size(), outdata.size());
    
        if (msg2) 
            DB->msg(DBTXT("restcompdata response: this=%p, err=%s msg=(%s)"),
                                        this, *outargs.found_image(), *outargs.ximage());
    
        if (outargs.iserrorresponse()) {
            if (outargs.responsecode() == MSG_ERR_ENTER_INCOMPLETE) {
                Out->msg(FATAL, "<5679>The CAT server does not support this operation.");
                uapp::staging().startTermination(EXIT_MISC, "CAT server doesn't support this operation");
                return;
            }
            
            info.data.free();
            notifyparent();
            return;
        }
        
        
        if (info.data.iserror(filebase::ERRCODE_ERR) ) {
            info.data.free();
            notifyparent(); 
            
            
            return; 
        }
        
        
        int sentsize = processchunks(outargs, ckind, chunksizes, outdata);
        if (!sentsize)
            return;    
    
        if (!flags.replicate) {
            main->getstatsobj(context::restorestats)->update(stats::sent, sentsize, ckind, main->handling_system_info());
    
            if (ckind.is_data_atomic())  {
                main->addfilebytes(context::restorestats, outdata.size());
                main->addprogbytes(context::restorestats, outdata.size());
            }
        }
    }
    
    
    if (msg2) DB->msg("restcompdata storing size=%d offset=%s", outdata.size(), *offset.image());
    exportdata(ckind, outdata, offset);
    
    if (info.data.getrefcount() > 1)  
        info.data.free();
    notifyparent();
}

int restcompdata::processchunks(message& outargs, chunktype& ckind, const undoo::vector<tagduns>& chunksizes, fileref& outdata)
{
    
    
    
    
    
    
    compelem elem(compkind);
    int dataoffs = 0;
    int compoffs = 0;
    size_t idx = 0;
    int totalsent = 0;
    bool sometimecompressed = false;
    
    fileref uncompressed;
    uncompressed.initlist(outdata.size());    
    
    while (compoffs < compdata.size()) {
        
        assert(idx < chunksizes.size());
        elem.init(compdata, compoffs);    
        
        hashcode hash(elem.gethash());
        fileref currentchunk;
        uint32_t sz = +chunksizes[idx];
        bool compressed = chunksizes[idx].istagged();
        currentchunk.initmem(outdata.start()+dataoffs, sz);
        
        if (!verifyhash(ckind, currentchunk, hash, outargs))
            return 0;
        
        int sentsize = currentchunk.size();
        chunktype kind = ckind;
        bool wascompressed = compressed && uncompress(kind, currentchunk, sentsize);
        totalsent += sentsize;
        
        if (wascompressed) {
            sometimecompressed = true;
            kind = chunktype::atomic;
        }
        
        if (main->restorecache_enabled() && main->restorecache_cache_atomics()) {
            
            
            message m;
            msgpack_c::gethashdata ghd(m);
            int cachelevel = CACHELEVEL_NONE;
            ghd.res(PACK, kind, currentchunk, cachelevel);
            main->restorecache_enter(hash, m);
        }
        
        
        uncompressed.append(currentchunk);
        
        dataoffs += sz;
        ++idx;
    }
    
    outdata = uncompressed;
    
    if (sometimecompressed)
        ckind = chunktype::atomic;
    
    return totalsent;
}


bool restcompdata::verifyhash(chunktype ckind, fileref& outdata, const hashcode& hash, message& outargs)
{
    if (!outargs.isflagset(MSGFLAG_NODATACRC) || flags.nohashrestdata)
        return true;

    hashcode reshash;
    outdata.binhash(reshash);
    
    if(reshash != hash || redocount) {
        
        
        

        if(reshash != hash) {
            Out->msg(WARN, LOCTXT("<10685>Retrieved incorrect data from server: redo:%d kind:%s "
                            "size:%d  computed %s, requested %s"), 
                     redocount, *ckind.image(), outdata.size(), 
                     *reshash.image(), *hash.image());
            show_data(outdata, "Incorrect data", reshash);
            if (++redocount <= REDOLIMIT) {
                send();
                return false;
            }
            set_error(true, 
                  ustring::sprintf(DBTXT("bad response in restcompdata.response "
                                         "redo:%d kind:%s %s != %s (%s)"),
                                         redocount, *ckind.image(), *hash.image(), 
                                         *reshash.image(), *outargs.found_image()));
        
            Out->msg(ERR, "<5518>\"%s\" Server data error restoring chunk %s (%s)",
                          *info.path.image(), *hash.image(), *outargs.found_image());

            DB->msg("restcompdata response outargs.found_image(%s) %s\n"
                          "                      hash:%s\n\n",
                           *outargs.found_image(), *outargs.ximage(), *hash.partialimage());

            info.data.free();
            notifyparent();
            return false;
        }
        show_data(outdata, "Correct data", reshash);
    }
    return true;
}


bool restcompdata::uncompress(chunktype ckind, fileref& outdata, int& sentsize)
{
    bool wascompressed = false;
    
    if(ckind.is_extatomic()) {
        if(msg3) {
            DB->msg("restcompdata::response: ckind=%s, hash %s raw compressed data, %d bytes", *ckind.image(), *hash.partialimage(), outdata.size());
            outdata.hexdump(false);
        }
    
        int csize = outdata.size();
     
    
        
        bool res = outdata.uncompress(main->get_enckey());
    
        if(!res) 
            Out->msg(ERR, "<7692>\"%s\": INTERNAL uncompress/decrypt failure, data not restored correctly", 
                     *info.path.image());
        main->getstatsobj(context::restorestats)->add_compress(0 , csize, outdata.size());
    
        if(outdata.size() > csize) {                    
            main->getstatsobj(context::restorestats)->update(stats::reduced, outdata.size() - csize, ckind, main->handling_system_info());       
        } 
        else {
        
            sentsize += outdata.size() - csize;         
        }
    
        if(msg3) {
            DB->msg("restcompdata::response: hash %s uncompressed data, %d bytes", *hash.partialimage(), outdata.size());
            outdata.hexdump(false);
        }
        wascompressed = true;
    }
    return wascompressed;
}


void restcompdata::exportdata(chunktype ckind, fileref& outdata, fileoffset& offset)
{
    if (outdata.isnull())
        return;

    
    
    

    bool validate = (flags.validate && ckind.is_data_atomic() && !main->handling_system_info());
    if(!validate) {
        
        

        fileoffset restoffset(offset - info.startbyte);  
        if(info.checkrange && !ckind.is_dir() ) {
            fileoffset start(0);  
            fileoffset size(outdata.size64());
            
            if (info.startbyte > offset) { 
                start = info.startbyte - offset; 
                size = size-start; 
                restoffset = fileoffset(0);
            }
            if (info.endbyte < offset+outdata.size64())
                size = (info.endbyte-offset) - start + fileoffset(1);
            
            if (start < fileoffset(0) || size < fileoffset(0))
                return;
            
            
            
            

            outdata = outdata.makeslice64(start, size);
            
            
        }

        
        
        info.exportdata(restoffset, outdata); 

        if( info.data.iserror(filebase::ERRCODE_ERR) ) {
            
            
            set_error(true, ustring("") ); 
        }
    }
}


void restcompdata::show_data(fileref &data, const ustring &msg, hashcode &computed_hash)
{
    if (DB->messages_on) {
        DB->msg("%s (requested %s, actual %s, %d bytes)", *msg, *hash.partialimage(), *computed_hash.partialimage(), data.size());
        data.hexdump(true);
        DB->msg(" ");
    }
}

#include <algorithm>

#include "common.h"
#include "debug.h"
#include "output.h"
#include "ndmp_history.h"
#include "msgpack_c.h"
#include "timer.h"
#include "context.h"
#include "message.h"
#include "runstage.h"
#include "file.h"
#include "cycle.h"

















































#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define dumphist  ((xflag[14]&131072)!=0)  

ndmp_history::ndmp_history(context *main,
                           upath fifopath, upath savehistpath)
  : todoqueue('n'),
    readhist_thread(NULL),
    processhist_thread(NULL),
    flags(main->get_flags())
{
    DB->msg("ndmp_history::ndmp_history starting fifopath:%s",
            *fifopath.image());

    readhist_thread = new readhist(todoqueue, fifopath, savehistpath, histsem);
    processhist_thread = new processhist(todoqueue, this);
    readhist_thread->start();
    processhist_thread->start();
}

ndmp_history::~ndmp_history() {
    DB->msg("ndmp_history::~ndmp_history");
    todoqueue.terminate();
    histsem.signal();
    readhist_thread->kick();
    readhist_thread->wait();
    processhist_thread->wait();
    delete readhist_thread;
    delete processhist_thread;
}

void ndmp_history::data_stream_done() {
    DB->msg("ndmp_history::data_stream_done, signal the history stream reader...");
    histsem.signal();
    readhist_thread->wait();
    if (flags.ndmpmemthrottlethresh <= 0) {
        
        
        DB->msg("ndmp_history::data_stream_done terminating todoqueue");
        todoqueue.terminate();
    }
    DB->msg("ndmp_history::data_stream_done--");
}

void ndmp_history::send(BackCycle* cycle, message& m) {
    if(msg2)DB->msg("ndmp_history::send enqueuing message '%s'", *m.ximage());
    const bool willPackOK = (sizeof(void*) <= sizeof(time_t)); 
    assert(willPackOK);   
    m.info().sendtime = (time_t)cycle;  
    m.info().connection = -1;       
    todoqueue.enqueue(m);
}

bool ndmp_history::directory_complete(unsigned int directory_inodenum) {
    if (directory_inodenum == 0)
        return true;

    if (processhist_thread)
        return processhist_thread->delete_child_inodes(directory_inodenum);

    return false;
}



ndmp_history::readhist::readhist(msgqueue& todoqueue_, upath fifopath, upath savehistpath_, semaphore& histsem_)
  : todoqueue(todoqueue_),
    fifo(namedpipe::inbound, fifopath),
    savehistpath(savehistpath_),
    histsem(histsem_),
    is_done(false),
    msg_count(0)

{
    setdesc(ustring::sprintf("rhist"));
}

ndmp_history::readhist::~readhist() {
    DB->msg("ndmp_history::readhist::~readhist calling wait()...");
    wait();
    DB->msg("ndmp_history::readhist::~readhist done");
}

static char buf[8192];
static int buflen;
static int bufidx;


static ustring readline(int d) {
    char res[8192];
    int i=0;
    while(1) {
        while (bufidx < buflen) {
            const char c = buf[bufidx];
            if (c == '\n') {
                res[i] = 0;
                if(i > 0) {
                    bufidx++;
                    return ustring(res);
                }
            } else if (c != '\r') {
                if (i >= (int)sizeof(res) - 1) {
                     res[sizeof(res)-1]=0;
                     Out->msg(ERR, "<7368>ndmp_history readline: Line too long, truncating: '%s'", res);
                     return ustring(res);
                }
                res[i++]= c;
           }
            bufidx++;
        }

        bufidx = 0;
        buflen = ::read(d, buf, sizeof(buf));
        if (buflen <= 0) {
            if (buflen < 0) Out->msg(ERR, "<7369>ndmp_history readline: I/O error (%d, errno=%d) on fd %d", buflen, errno, d);
            return "";
        }
    }
}

void ndmp_history::readhist::body() {
    DB->msg("ndmp_history::readhist::body start");

    bool mainloopdone = false;

    
    if(!fifo.connect()) {
        Out->msg(FATAL, "<7235>Cannot open history stream for reading, files will not be deleted");
        DB->msg("ndmp_history::readhist::body exiting body with error");
        todoqueue.terminate();
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "cannot open history stream for read");
        mainloopdone=true;   
    }
    DB->msg("ndmp_history::readhist::body connected to history pipe");

    file savehist;
    if (!savehistpath.isempty()) {
        if (!savehist.open(savehistpath.image(), O_RDWR | O_CREAT | O_TRUNC)) {
            Out->msg(ERR, "<8665>NDMP history reading thread failed to open or create file '%s' for saving history stream",
                                   *savehistpath.image());
        } else {
            Out->msg(INFO, "<8666>NDMP history reading thread opened file '%s' to save history stream",
                     *savehistpath.image());
        }
    }

    sum_timer sumt;
    while(!mainloopdone && uapp::staging().canRun()) {
        
        
        
        ustring oneline(readline(fifo.filedescriptor()));
        
        if(oneline.bytelength() == 0) { 
            DB->msg("ndmp_history::readhist::body end of file");
            break;
        }
        if (savehist.isopen()) {
            savehist.append(*oneline, oneline.bytelength());
            savehist.append("\n", 1);
        }

        message m;
        msgpack_c::ndmphistlistline nhll(m);
        nhll.arg(PACK, oneline);
        m.setresponsecode(MSG_ERR_NONE);
        m.setflag(MSGFLAG_NOACK);
        msg_count++;
        todoqueue.enqueue(m);

        savehist.close();
        sumt.check_cputime_update("ndmpreadhist");
    }
    is_done = true;

    DB->msg("ndmp_history::readhist::body finished reading fifo, wait for data stream to signal us");
    histsem.wait();
    DB->msg("ndmp_history::readhist::body--");
}




ndmp_history::processhist::processhist(msgqueue& todoqueue_, ndmp_history *parent_)
    : todoqueue(todoqueue_), parent(parent_), mainloopdone(false), todoqueue_terminated(false)
{
    setdesc(ustring::sprintf("phist"));
}

ndmp_history::processhist::~processhist() {
    DB->msg("ndmp_history::processhist::~processhist");
    terminate();
    wait();
    DB->msg("ndmp_history::processhist::~processhist done");
}

void ndmp_history::processhist::terminate() {
    DB->msg("ndmp_history::processhist::terminate()");
    todoqueue.terminate();
    kick();
}

void ndmp_history::processhist::body() {
    if(msg2)DB->msg("ndmp_history::processhist::body");

    bool todoqueue_terminated = false;
    static size_t count_ndmp_histlistline_processed = 0;

    int prevparent = 2;
    int curparent = 2;

    bool some_processed(false);
    while(uapp::staging().canRun() && !todoqueue_terminated) {
        int waittime(10000);       
        
        message m = todoqueue.dequeue(todoqueue_terminated, waittime);
        
        if(todoqueue_terminated) {
          DB->msg("ndmp_history::processhist::body todoqueue terminated %d", todoqueue_terminated);
          break;
        }

        if (m.requestcode() == NO_MESSAGE) {
            
            
            
            
            
            
            
            
            

            

            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("ndmp_history::processhist::body handled %"Z"d NDMPHISTLISTLINE "
                        "messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_dir_done(prevparent);
                }
            }

            continue;
        }

        if(!m.isgoodresponse()) {
          DB->msg("ndmp_history::processhist::body bad response %s, code:%s flag:%d",
                  *m.image(), *message::err_image(m.responsecode()), m.isflagset(MSGFLAG_RECVERROR));
          continue;
        }

        some_processed = true;

        
        
        switch(m.requestcode()) {
        case CLIENTONLY_GETNDMPHISTLIST:
            handle_getndmphistlist(m);
            break;
        case CLIENTONLY_NDMPHISTLISTLINE:
            count_ndmp_histlistline_processed++;
            handle_ndmphistlistline(m, curparent, prevparent);
            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("ndmp_history::processhist::body handled %"Z"d NDMPHISTLISTLINE messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_dir_done(prevparent);
                }
            }
            break;
        default:
            DB->msg("ndmp_history::processhist::body strange message %s", *m.image());
            continue;
        }
        
    }

    if (some_processed && (parent->flags.ndmpmemthrottlethresh <= 0)) {
        
        
        mark_dir_done(prevparent);
    }

    
    
    ustring streamoffset;
    message m;
    if (todoassoc.size() > 0) {
        Out->msg(ERR, "<8667>NDMP history processing thread has read all file history data and is unable to answer remaining %u GETNDMPHISTLIST messages from the data processing thread",
                 todoassoc.size());
    }
    while (todoassoc.pop(streamoffset, m)) {
        postprocess_getndmphistlist(streamoffset, m);
    }
    DB->msg("ndmp_history::processhist::body done");
}

void ndmp_history::processhist::handle_getndmphistlist(message &m)
{
    msgpack_c::getndmphistlist thl(m);
    ustring streamoffset;
    int nchildren;
    ubigint64 itable(0);
    ubigint64 hlitable(0);
    ubigint64 hardlinknames(0);
    thl.arg(UNPACK, streamoffset, nchildren, itable, hlitable, hardlinknames);

    if (msg1) DB->msg("ndmp_history::processhist::handle_getndmphistlist streamoffset:%s nchildren:%d itable:%p hlitable:%p hardlinknames:%p",
                      *streamoffset, nchildren, (void*)itable, (void*)hlitable, (void*)hardlinknames);

    if (msg2) {
        undoo::vector<ustring> *hardlinknamesp = (undoo::vector<ustring> *)((ptrint)hardlinknames);
        DB->msg("ndmp_history::processhist::handle_getndmphistlist got new message for offset '%s' nchildren:%d itable:%"LL"d hlitable:%"LL"d hardlinknames:%p",
                *streamoffset, nchildren, itable, hlitable, hardlinknamesp);
        if (hardlinknamesp && hardlinknamesp->size()) {
            DB->msg("hardlinknames contains %"Z"u entries", hardlinknamesp->size());
            undoo::vector<ustring>::const_iterator iter;
            for (iter=hardlinknamesp->begin(); iter != hardlinknamesp->end(); iter++) {
                DB->msg("\t%s", *(*iter));
            }
        } else {
            DB->msg("hardlinknamesp empty");
        }
    }
    message preexistingmsg;
    bool entered = todoassoc.enter_if_undef(streamoffset, m, preexistingmsg);
    if (!entered) {
        Out->msg(WARN, "<8668>NDMP history processing thread received another message requesting history for directory at data stream offset %s",
                 *streamoffset);
    }

    
    historytree.process_getndmphistlist(this, streamoffset, nchildren);
}

void ndmp_history::processhist::handle_ndmphistlistline(message &m, int &curparent, int &prevparent)
{
    msgpack_c::ndmphistlistline nhll(m);
    ustring oneline;
    nhll.arg(UNPACK, oneline);

    
    int tmp = read_and_enter_xml(oneline);
    if(tmp != -2) curparent=tmp;
    if (curparent <= 0) return;
    if (curparent != prevparent) { 
        if(msg1) DB->msg("ndmp_history::processhist::handle_ndmphistlistline end dir, was %d now %d",
                         prevparent, curparent);
        mark_dir_done(prevparent);
        prevparent=curparent;
    }

    
}

void
ndmp_history::processhist::postprocess_getndmphistlist(ustring& streamoffset,
                                                       message &m)
{
    assert(!m.isnull());
    assert(m.info().connection == -1);   
    BackCycle* cycle = (BackCycle*)m.info().sendtime;
    element_child_list *elem = historytree.remove_dir_entry(streamoffset);
    if (elem)
        assert(elem->streamoffset == streamoffset);

    msgpack_c::getndmphistlist mp(m);
    ustring msgstreamoffset;
    int nchildren;
    ubigint64 itable(0);
    ubigint64 hlitable(0);
    ubigint64 hardlinknames(0);
    mp.arg(UNPACK, msgstreamoffset, nchildren, itable, hlitable, hardlinknames);
    assert(streamoffset == msgstreamoffset);

    Out->msg(INFO, "<8669>    DEBUG: answering GETNDMPHISTLIST message:%s with done=false and best effort data for streamoffset:%s nchildrenreq:%d from elem:%s",
             *m.ximage(), *streamoffset, nchildren, (elem ? *elem->image() : "NULL"));
    bool done = false;

    unsigned int eleminode = elem ? elem->inodenum : 0;
    mp.res(PACK, streamoffset, itable, done, eleminode, hlitable);
    sendResponse(cycle, m);
}















int ndmp_history::processhist::read_and_enter_xml(ustring oneline) {
    
    xml_messagep mess(new xml_message(oneline, true));
    if (!mess->valid()
        || (mess->getcommand() != "hist" && mess->getcommand() != "node")
    ) {
      Out->msg(ERR, "<7236>unknown history string: '%s'", *oneline);
      return -1;
    }
    if(dumphist) DB->msg("ndmp_history::processhist::read_and_enter_xml xml: %s", *mess->simage());

    unsigned int nodenum = mess->getint("num");
    if (mess->getcommand() == "hist") {
        unsigned int curparent  = mess->getint("parent");
        
        ustring elemname = xml_message::fromathexat(mess->getstring("name"));
        if(msg2)DB->msg("ndmp_history::processhist::read_and_enter_xml read hist num:%4d curparent:%4d name:%s", nodenum, curparent, *elemname);
        if ((nodenum == curparent) && curparent == 2) { elemname = "/"; }
        return historytree.enter_hist(this, nodenum, curparent, elemname);
    } else if (mess->getcommand() == "node") {
        ustring streamoffset(mess->getstring("off"));
        unsigned int links = mess->getuint("links");
        if (links == 0) {
            links = 1; 
        }
        return historytree.enter_node(this, nodenum, streamoffset, links);
    }
    return -1;


}

bool
ndmp_history::processhist::check_complete(element_child_list *elem)
{
#define cc_msg2 msg2
    
    assert(historytree.islocked());
    if (cc_msg2)
        DB->msg("check_complete elem:%p", elem);
    if (elem == NULL) return false;

    if (cc_msg2)
        DB->msg("check_complete called with %s", *elem->image());

    if (elem->streamoffset.isempty()) {
        if(cc_msg2)DB->msg("check_complete elem:%p returning false since elem->streamoffset.isempty():true", elem);
        return false;
    }

    
    
    message m(todoassoc.lookup(elem->streamoffset));
    if (m.isnull()) {
        
        if (cc_msg2) DB->msg("check_complete returning false since no message received for offset %s yet",
                             *elem->streamoffset);
        return false;
    }
    
    assert(m.info().connection == -1);   
    BackCycle* cycle = (BackCycle*)m.info().sendtime;

    
    
    msgpack_c::getndmphistlist thl(m);
    ustring streamoffset("-1");
    int nchildrenrequired(0);
    ubigint64 itable(0);
    ubigint64 hlitable(0);
    ubigint64 hardlinknames(0);
    thl.arg(UNPACK, streamoffset, nchildrenrequired, itable, hlitable, hardlinknames);
    if (cc_msg2)
        DB->msg("check_complete elem:%p unpacked message (off:%s nchildrenreq:%d)",
                elem, *streamoffset, nchildrenrequired);
    assert(elem->streamoffset == streamoffset);

    
    if (nchildrenrequired && !elem->done) {
        if(cc_msg2)DB->msg("check_complete elem:%p returning false since elem->done:false", elem);
        return false;
    }

    if (elem->childlist.size() < (size_t)nchildrenrequired) {
        if(cc_msg2)
            DB->msg("check_complete elem:%p returning false since childlist.size():%"Z"u < nchildrenrequired:%d",
                    elem, elem->childlist.size(), nchildrenrequired);
        return false;
    }

    if (elem->nchildrendone >= (unsigned)nchildrenrequired) {
        if (elem->nchildrendone > (unsigned)nchildrenrequired) {
            Out->msg(WARN, "<8670>NDMP history processing thread found %u children done for directory with inode %u while data stream indicated we should find only %d: %s",
                     elem->nchildrendone, elem->inodenum, nchildrenrequired, *elem->image());
        }

        
        
        todoassoc.remove(elem->streamoffset);

        
        if(cc_msg2)
            DB->msg("check_complete send answer for %s since elem->nchildrendone:%d >= nchildrenrequired:%d",
                    *elem->image(), elem->nchildrendone, nchildrenrequired);
        histmap *histtable = (histmap *)((ptrint)itable);
        hlhistmap *hlhisttable = (hlhistmap *)((ptrint)hlitable);
        undoo::vector<ustring> *hardlinknamesp = (undoo::vector<ustring> *) ((ptrint)hardlinknames);
        
        get_childname_list3(elem, histtable, hlhisttable, hardlinknamesp);
        if (cc_msg2) DB->msg("check_complete get_childname_list3 completed");

        itable = (ubigint64)((ptrint)&histtable);
        hlitable = (ubigint64)((ptrint)&hlhisttable);
        bool elemdone = true;
        
        thl.res(PACK, streamoffset, itable, elemdone, elem->inodenum, hlitable);
        sendResponse(cycle, m);

        
        

        return true;
    }

    if(cc_msg2)DB->msg("check_complete elem:%p returning false since elem->nchildrendone:%d < msg.nchildrenrequired:%d",
                       elem, elem->nchildrendone, nchildrenrequired);
    return false;
}




void ndmp_history::processhist::sendResponse(BackCycle* cycle, message &m)
{
    cycle->enqueueResponse(cycle, m, false);
}


void
ndmp_history::processhist::historytree_class::process_getndmphistlist(ndmp_history::processhist *ph,
                                                                      const ustring &streamoffset,
                                                                      int nchildren)
{
    assert(ph);
    assert(!streamoffset.isempty());
    scope s(m);
    element_child_list *elem = off2elem.lookup(streamoffset);
    if (elem && (nchildren == 0))
        elem->done = true;
    
    ph->check_complete(elem);
    
}


bool ndmp_history::processhist::delete_child_inodes(unsigned int inodenum) {
    return historytree.delete_child_elems(inodenum);
}

ndmp_history::processhist::element_child_list::element_child_list(unsigned int inode_,
                                                                  unsigned int parentinode_,
                                                                  ustring elemname_)
    : elemname(elemname_), inodenum(inode_), parentinodenum(parentinode_),
      link_count(1), nchildrendone(0), done(false),

      
      
      childlist(1)
{
}

ustring
ndmp_history::processhist::element_child_list::image() const
{
    ustring res;
    res = ustring::sprintf("element_child_list:%p (elemname:%s inodenum:%d parentinodenum:%d link_count:%u nchildrendone:%d done:%d streamoffset:%s childlist.size():%"Z"d)",
                           this, *elemname, inodenum, parentinodenum, link_count, nchildrendone, done, *streamoffset, childlist.size());
    return res;
}


ndmp_history::processhist::historytree_class::~historytree_class()
{
    DB->msg("historytree_class::~historytree_class with %d entries in off2elem, %"Z"u entries in nodes",
            off2elem.size(), nodes.size());
    if (1) { 
        if (off2elem.size()) {
            DB->msg("  off2elem entries:");
            ustring key;
            element_child_list *val;
            while (off2elem.pop(key, val)) {
                DB->msg("    %s -> %s", *key, (val ? *val->image() : "NULL"));
            }
        }
        if (nodes.size()) {
            DB->msg("  nodes entries:");
            for (iter i = nodes.begin(); i != nodes.end(); i++) {
                uint inode = i->first;
                DB->msg("    %d -> %s", inode, (i->second ? *i->second->image() : "NULL"));
            }
        }
    }

	
    if (assert_error_count1)
        Out->msg(ERR, "<10670>int ndmp_history::processhist::historytree_class::enter_node: assert(n->second->streamoffset.isempty()) failed %ld times.",assert_error_count1);
    if (assert_error_count2)
        Out->msg(ERR, "<10671>int ndmp_history::processhist::historytree_class::enter_node: assert(pr.first != pr.second) failed %ld times.",assert_error_count2);
    if (assert_error_count3)
        Out->msg(ERR, "<10672>int ndmp_history::processhist::historytree_class::enter_node: assert(tmp == pr.second) failed %ld times.",assert_error_count3);

}


void ndmp_history::processhist::historytree_class::get_element_path(unsigned int inode, ustring &path)
{
    iter itr;
    while ((itr = nodes.find(inode)) != nodes.end()) {
        ustring elemname = itr->second->elemname;
        if (elemname == "/") break;
        path = elemname.concat(path, '/');
        inode = itr->second->parentinodenum;
    }
    path = path.get_dotdot();
}

int
ndmp_history::processhist::historytree_class::enter_hist(processhist *ph,
                                                         unsigned int inode,
                                                         unsigned int parentinode,
                                                         const ustring &name)
{
    scope s(m);
    rngiter r;
    iter tmp;
    r = nodes.equal_range(inode);
    
    
    
    
    
    
    unsigned int link_count = 1;
    ustring oldstreamoffset;
    if (r.first != r.second) {
        
        iter n;
        for (n=r.first; n != r.second; n++) {
            element_child_list *c;
            c = (*n).second;
            assert(inode == c->inodenum);
            
            
            
            
            
            
            
            
            
            
            
            
            
            if (parentinode == c->parentinodenum && name.equal(c->elemname)) { 
                
                
                
                
                
                ustring path;
                get_element_path(inode, path);
                Out->msg(WARN, "Detection of hardlinks in the same directory with non-utf8 file names found. This is not supported for this Avamar NDMP backup. Please change hardlink names in %s to supported utf8 characters.", !path.isempty() ? *path : "target directory");
                Out->Abort("<8671>NDMP history processing thread received (hist num=%u name=%s parent=%u) when a node is already present with those values: %s",
                         inode, *name, parentinode, *c->image());
                return -3;
            }
            c->link_count++;
            oldstreamoffset = c->streamoffset; 
        }
        link_count = r.first->second->link_count;
    }
    element_child_list *childelem = new element_child_list(inode, parentinode, name);
    childelem->link_count = link_count;
    if (oldstreamoffset.isempty())
        oldstreamoffset = inode2offset.lookup(inode);
    childelem->streamoffset = oldstreamoffset;
    nodes.insert(std::make_pair(inode, childelem));

    
    r = nodes.equal_range(parentinode);
    if (r.first == r.second) {
        
        Out->msg(ERR, "<8672>NDMP history processing thread attempting to add child %p:%s to parent's list of children but unable to find parent with inode %u in tree",
                 childelem, *childelem->image(), parentinode);
        assert(false);
        return -3;
    }
    tmp = r.first; tmp++;
    if (r.second != tmp) {
        Out->msg(ERR, "<8673>NDMP history processing thread found multiple nodes for parentinode=%u while processing message (hist num=%u name=%s parent=%u)",
                 parentinode, inode, *name, parentinode);
        int counter = 0;
        for (tmp=r.first; tmp!=r.second; tmp++) {
            Out->msg(INFO, "<8674>   DEBUG: node %i: %u -> %s",
                     counter++, (unsigned int)tmp->first, (tmp->second == NULL ? "NULL" : *tmp->second->image()));
        }
        Out->msg(INFO, "<8675>    DEBUG: will put childelem on node 0's childlist, childelem:%s",
                 *childelem->image());
    }

    element_child_list *parent = r.first->second;
    parent->childlist.push_back(childelem);
    if (!oldstreamoffset.isempty())
        parent->nchildrendone++;
    ph->check_complete(parent);

    return parentinode;
}

int
ndmp_history::processhist::historytree_class::enter_node(ndmp_history::processhist *ph,
                                                         unsigned int inode,
                                                         const ustring &streamoffset,
                                                         unsigned int links)
{
    scope s(m);

    if (inode2offset.defined(inode)) {
        Out->msg(WARN, "ndmp_history::processhist::historytree_class::enter_node got inode:%u offset:%s links:%u, but already have entry in inode2offset for that, ignoring!",
                 inode, *streamoffset, links);
        return -2;
    }
    inode2offset.enter(inode, streamoffset);

    rngiter r;
    iter tmp;
    r = nodes.equal_range(inode);
    if (r.first == r.second) {
        
        
        
        DB->msg("ndmp_history::processhist::historytree_class::enter_node could not find an existing entry or reached end of byte stream for inode %d", inode);
        Out->msg(WARN, "<8546>Can't find existing entry for inode %d or path length for the inode may exceed Celerra/VNX limitation. Ignore tree update.", inode);
        return -3;
    }

    
    
    
    
    
    
    tmp = r.first; tmp++;
    if (tmp == r.second) {
        off2elem.enter(streamoffset, r.first->second);
    }

    
    for (iter n=r.first; n!=r.second; n++) {
        
        
        
        if (assert_error_count1 < assert_error_count_limit) assert(n->second->streamoffset.isempty());
        if (n->second->streamoffset.isempty() == false) assert_error_count1++;

        n->second->streamoffset = streamoffset;
        n->second->link_count = links;

        ph->check_complete(n->second);

        
        
        rngiter pr = nodes.equal_range(n->second->parentinodenum);

        if (assert_error_count2 < assert_error_count_limit) assert(pr.first != pr.second);
        if (pr.first == pr.second) assert_error_count2++;

        tmp = pr.first; tmp++;

        if (assert_error_count3 < assert_error_count_limit) assert(tmp == pr.second); 
        if (tmp != pr.second) assert_error_count3++;

        element_child_list *parent = pr.first->second;
        parent->nchildrendone++;

        ph->check_complete(parent);
    }

    return 0;
}

bool
ndmp_history::processhist::historytree_class::delete_child_elems(unsigned int inodenum)
{
    scope s(m);
    bool noerrors = true;
    rngiter rng;
    rng = nodes.equal_range(inodenum);
    if (rng.first == rng.second) {
        Out->msg(ERR, "<8676>NDMP history processing thread attempting to delete children for inode %u but found no matching records in the nodes tree",
                 inodenum);
        return false;
    }
    iter tmp = rng.first; tmp++;
    if (tmp != rng.second) {
        Out->msg(ERR, "<8677>NDMP history processing thread attempting to delete children for inode %u but found multiple matching records in the nodes tree",
                 inodenum);
        unsigned int counter;
        for (tmp=rng.first, counter=0; tmp!=rng.second; tmp++, counter++) {
            Out->msg(INFO, "<8678>    DEBUG: node %u, %u -> %s",
                     counter, (unsigned int)tmp->first,
                     (tmp->second == NULL ? "NULL" : *tmp->second->image()));
        }
        Out->msg(INFO, "<8679>    DEBUG: will delete children from 0'th node");
    }
    element_child_list *parentelem = rng.first->second;
    childvector::iterator c;
    if (msg2)
        DB->msg("historytree_class::delete_child_elems deleting children for %s", *parentelem->image());
    for (c=parentelem->childlist.begin(); c != parentelem->childlist.end(); c++) {
        
        
        
        

        
        

        
        
        element_child_list *ci = (element_child_list *)(*c);
        if (ci->inodenum == ci->parentinodenum) {
            assert(ci->inodenum == 2);
            continue;
        }
        if (msg2) {
            DB->msg("delete_child_elems delete child %p", ci);
            DB->msg("   inode:%d", ci->inodenum);
            DB->msg("   parentinode:%d", ci->parentinodenum);
            DB->msg("   elemname:%s", *ci->elemname);
            DB->msg("   streamoffset:%s", *ci->streamoffset);
        }
        
        if (ci->streamoffset.bytelength()) {
            element_child_list *ci_off2elem = NULL;
            bool found = off2elem.remove(ci->streamoffset, ci_off2elem);
            if (msg2) {
                if (found)
                    DB->msg("delete_child_elems removed (%s, %p) from off2elem for ci:%p", *ci->streamoffset, ci_off2elem, ci);
                else
                    DB->msg("delete_child_elems did not find elem for offset %s in off2elem", *ci->streamoffset);
            }
        }

        
        
        rngiter rng2 = nodes.equal_range(ci->inodenum);
        
        if(rng2.first == rng2.second)    
            Out->msg(ERR, "<8547>Path for inode %d may exceed Celerra/VNX limitation.  Please see Celerra/VNX manual", ci->inodenum);
        if (0) 
            DB->msg("delete_child_elems deleting child (%s), searching tree for all elems indexed by inode %d...",
                     *ci->image(), ci->inodenum);
        bool deleted = false;
        for (iter i=rng2.first; i!=rng2.second; i++) {
            element_child_list *ii = i->second;
            
            assert(ii->inodenum == ci->inodenum);
            if (ii == ci) {
                if (msg2)
                    DB->msg("delete_child_elems erasing iterator for %p in nodes", ii);
                nodes.erase(i);
                
                delete ci;
                
                deleted = true;
                break;
            }
        }
        
        if (!deleted) {
            if(rng2.first == rng2.second)
                Out->msg(ERR, "<8680>ndmp_history::processhist::historytree_class::delete_child_elems ");
            noerrors = false;
        }
    }

    return noerrors;
}


bool
ndmp_history::processhist::historytree_class::mark_dir_done(ndmp_history::processhist *ph,
                                                            const unsigned int parentnum)
{
    assert(ph);
    scope s(m);
    rngiter rng = nodes.equal_range(parentnum);

    
    
    
    if (rng.first == rng.second) {
        if (msg1) DB->msg("historytree_class::mark_dir_done could not find an entry for inode %u", parentnum);
        return false;
    }

    
    iter tmp = rng.first; tmp++;
    if (tmp != rng.second) {
        Out->msg(ERR, "<8681>NDMP history processing thread found multiple node entries for inode %u in mark_dir_done",
                 parentnum);
        int counter = 0;
        element_child_list *e;
        for (tmp=rng.first; tmp!=rng.second; tmp++) {
            e = tmp->second;
            Out->msg(INFO, "<8682>    DEBUG: node %i: %u -> %s", counter++, (unsigned int)tmp->first, (e == NULL ? "NULL" : *e->image()));
        }
        e = rng.first->second;
        Out->msg(INFO, "<8683>    DEBUG: will set 'done' on the 0th node:%s", (e == NULL ? "NULL" : *e->image()));
    }

    element_child_list *elem = rng.first->second;
    if (NULL == elem) {
        Out->msg(ERR, "<8684>NDMP history processing thread found NULL element_child_list for directory inode %u in mark_dir_done",
                 parentnum);
        return false;
    }
    elem->done = true;

    if(msg2)
        DB->msg("ndmp_history::processhist::mark_dir_done %s", *elem->image());

    ph->check_complete(elem);

    return true;
}

ndmp_history::processhist::element_child_list *
ndmp_history::processhist::historytree_class::remove_dir_entry(const ustring &streamoffset)
{
    scope s(m);
    element_child_list *elem = NULL;
    bool found = off2elem.remove(streamoffset, elem);
    if (!found || !elem)
        return NULL;

    rngiter rng = nodes.equal_range(elem->inodenum);
    assert(rng.first != rng.second); 
    iter tmp = rng.first; tmp++;
    assert(tmp == rng.second); 
    nodes.erase(rng.first);
    return elem;


}

size_t ndmp_history::processhist::get_childname_list3(const element_child_list *elem,
                                                      histmap *childnames,
                                                      hlhistmap *hardlinklist,
                                                      const undoo::vector<ustring> *hardlinknamesp)
{
    if (msg2) DB->msg("ndmp_history::processhist::get_childname_list3++ elem->childlist.size():%"Z"d childnames->size():%"Z"d hardlinklist->size():%d hardlinknamesp->size():%"Z"d",
                      elem->childlist.size(), childnames->size(), hardlinklist->size(), hardlinknamesp->size());
    assert(historytree.islocked());
    assert(elem != NULL);

    size_t retval=0;

    size_t count = 1;
    childvector::const_iterator c;
    for (c = elem->childlist.begin(); c != elem->childlist.end(); c++) {
        element_child_list *ci = *c;
        if (++count % 20000 == 1)
            if (msg2) DB->msg("ndmp_history::processhist::get_childname_list3 working on the %"Z"d'th childlist element: %s",
                              (count-2), *ci->image());

        
        undoo::vector<ustring>::const_iterator hli = hardlinknamesp->begin();
        while (hli != hardlinknamesp->end()) {
            if (ci->elemname.equal(*hli))
                break;
            hli++;
        }

        assert(ci->inodenum > 0);
        if (hli != hardlinknamesp->end()) {
            assert(!ci->elemname.isempty());
            
            hardlinklist->enter(ci->elemname, ci->inodenum);
        } else {
            if (ci->streamoffset.isempty()) {
                composite_key inode_and_name(ci->inodenum, *ci->elemname);
                childnames->insert(std::make_pair(inode_and_name, ustring("")));
            } else {
                ustring offset_plus_link_count(ustring::sprintf("%s,%u",
                                                                *ci->streamoffset,
                                                                ci->link_count));
                composite_key sid(ci->inodenum, ustring(""));
                childnames->insert(std::make_pair(sid, offset_plus_link_count));
            }
        }
        retval++;
    }

    if (msg2) DB->msg("ndmp_history::processhist::get_childname_list3-- elem->childlist.size():%"Z"d childnames->size():%"Z"d hardlinklist->size():%d hardlinknamesp->size():%"Z"d",
                      elem->childlist.size(), childnames->size(), hardlinklist->size(), hardlinknamesp->size());
    return retval;
}







#if !defined(RESTDUMPDIR_H_INCLUDED)
#define RESTDUMPDIR_H_INCLUDED












#include "cycle.h"
#include "restelem.h"
#include "dumpcontext.h"




class restdumpdir : public cycle {
public:
    restdumpdir(cycle *parent, dumpcontext *dumpctx, dumpcontext::dirlistelem *head);
    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~restdumpdir();
    SAFEPOOLALLOC(restdumpdir);
private:
    restdumpdir();
    void set_phase(int phasenum);
    dumpcontext *dumpctx;
    dumpcontext::dirlistelem *dirlist_head;
    dumpcontext::dirlistelem *curdir;
    int phase;
};

#endif

#if !defined(DPNSESSION_H_INCLUDED)
#define DPNSESSION_H_INCLUDED












#include "roothashlistrec.h"

class debug;
class output;
class memman;
class utar_flags_info;
class context;
class clientpersistent;
class connection;
class client;
class synccall;
class sendcallbase;
class backstate;
class acntmngr;
class mtex;
struct hfs_info_struct;
class backstats;
class utar_commands;
class login;
class ADEMgrX;

class dpnsession : public countptr {
  public:
    dpnsession(utar_flags_info *flags, hfs_info_struct& hfs_info_, context::statstype st);
    ~dpnsession();

    utar_flags_info  *getflags()        const { return flags; }
    context          *getctx()          const { return main; }
    connection       *getconnection()   const { return hfs; }
    acntmngr         *getacnt()         const { return acnt; }
    hfs_info_struct  *getinfo()         const { return info; }
    utar_commands    *getutarcommands() const { return utarcommands; }
    int              getblktype()       const { return blktype; }
    hashcode         getlocation()      const { return location; }
    bool             login_succeeded()  const { return loginsucceeded; }
    clientpersistent *getps()           const { return ps; }  

    SAFEPOOLALLOC(dpnsession);
  private:
    debug *mydb;
    memman *mymemman;
    output *myout;
    utar_flags_info *flags;
    context *main;
    synccall *sync;
    backstate *state;
    clientpersistent *ps;
    connection *hfs;
    acntmngr *acnt;
    hfs_info_struct *info;
    int blktype;
    hashcode location;
    backstats *mainstats;
    utar_commands* utarcommands;
    bool loginsucceeded;
};

#endif































#include "common.h"
#include "debug.h"
#include "chunker.h"
#include "backstate.h"
#include "connection.h"
#include "layout.h"
#include "nbackroot.h"
#include "utar_flags_info.h"
#include "output.h"
#include "compelem.h"
#include "cycle.h"
#include "timer.h"
#include "backtree.h"
#include "runstage.h"
#include "streamtransformzip.h"

#define chunker_msg ((xflag[2]&512)!=0)
#define chgblkmsg   ((xflag[19]&4096)!=0)


class ChunkerDump {
public:
    ChunkerDump(const ustring& title, chunker * thechunker, Streambuffer * sb) : m_title(title), m_chunker(thechunker), m_sb(sb) { }
    ~ChunkerDump() {
        if (false && m_chunker != NULL && m_sb != NULL) {
            DB->msg("%s complete, StickyScanBookmark:%d, qhash.value=%x, data_endoff:%s, streambuffer:%s",
                *m_title, m_chunker->m_iStickyScanBookmark, m_chunker->qhash.value, *m_chunker->data_endoff.image(), *m_sb->image());
        }
    }
    const ustring m_title;
    const chunker * m_chunker;
    const Streambuffer * m_sb;
};


class sticky_atom_chunker : public chunker {
public:
  sticky_atom_chunker (utar_flags_info& flags, workelem *info, chunktype chunkkind, BackCycle *root_cycle,
                       fileoffset maxsize, const fileref& mapbuffer = fileref::empty);
  int find_sticky(fileref &stickychunk);
  SAFEPOOLALLOC(sticky_atom_chunker);
private:
  sticky_atom_chunker();
};



class fixed_atom_chunker : public chunker {
public:
  fixed_atom_chunker (utar_flags_info& flags, int& chunksize_, workelem *info, chunktype chunkkind,
                    BackCycle *root_cycle, fileoffset maxsize, const fileref& mapbuffer = fileref::empty)
      : chunker(flags, info, chunkkind, root_cycle, maxsize, mapbuffer),
        chunksize(chunksize_)
  {
       
       bug14204_checkchunkalignment = (flags.fixedatomsize > 0 ) && (flags.migratethreshold > 0);
  };
  
  int find_sticky(fileref &stickychunk);

  SAFEPOOLALLOC(fixed_atom_chunker);
private:
  fixed_atom_chunker();
  bool bug14204_checkchunkalignment;    
  int& chunksize;                       
};




chunker::chunker (utar_flags_info& flags_, workelem *info, chunktype chunkkind, BackCycle *root_cycle_,
                  fileoffset maxsize, const fileref& mapbuffer) 
  : flags(flags_), m_sb(mapbuffer), 
  m_stBackupRead(StreamtransformZip::isExtensionSpecialZip(info->direlemp->file_name_extension().tostr()), true), 
  m_st()
{
    assert(!root_cycle_->main->ADEChunkerEnabled());

    this->parent = NULL;
    this->child = NULL;
    this->m_iStickyScanBookmark = 0;
    this->data_endoff = fileoffset(0);
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::chunker data_endoff=%s chunk=%p", *data_endoff.image(), this );
    this->info = info;
    this->depth=1;
    this->chunkkind = chunkkind;
    this->maxsize = maxsize;
    this->root_cycle = root_cycle_;
    this->state = root_cycle->main->state;
    this->cur_cycle = new backtree(root_cycle, info->dpninx, info->ignoreStats);
    this->flushed = false;
    this->compress_state = compress_no;                         
     
    if(flags.compress) this->compress_state = (flags.cpercent >= 100 || (xflag[10]&256))?compress_yes:compress_undecided;

    m_pst = &m_st; 
    this->chunker_name = "default";
    if( chunker_msg ) DB->msg( "chunker::chunker root_cycle=%p this=%p name=%s kind=%s", root_cycle, this, chunker_name, *chunkkind.image() );
}


chunker::~chunker() {

    if( chunker_msg ) {
        DB->msg( "chunker::~chunker+++ this=%p flushed=%d depth=%d kind=%s", this, flushed, depth, *chunkkind.image() );
        tree.print( "chunker::~chunker" );
    }
    if (parent != NULL) { delete parent;}

    if( chunker_msg ) DB->msg( "chunker::~chunker--- this=%p", this );
}

void chunker::set_chunker_parent( chunker *parent_ )
{ 
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::set_chunker_parent this=%p", this );
    if( this ) {
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::set_chunker_parent this=%p old_parent=%p parent=%p", this, parent, parent_ );
        parent = parent_;
    } 
}




sticky_atom_chunker::sticky_atom_chunker (utar_flags_info& flags, workelem *info,
                                          chunktype chunkkind, BackCycle *root_cycle, fileoffset maxsize,
                                          const fileref& mapbuffer)
    : chunker(flags, info, chunkkind, root_cycle, maxsize, mapbuffer)
{
    if( info->direlemp->useBackupOps() && flags.chunkntfsstreams) {
        ustring usExtension = info->direlemp->file_name_extension();
        if( StreamtransformZip::isExtensionSpecialZip( usExtension.tostr() ) ) {
            DB->msg("Office XML ZIP Detected %s", info->direlemp->name().tostr() ); 
        }

        m_pst = &m_stBackupRead; 
        if( chunker::compress_undecided == get_compress_state() ) {
            set_compress_state( chunker::compress_ntfs_nondata );
        }
    }
};




chunker *chunker::pick_atomic(utar_flags_info& flags, workelem *info,
                              chunktype chunkkind, BackCycle *root_cycle, fileoffset maxsize,
                              const fileref& mapbuffer)

{
    chunker *chunk;

    if(flags.fixedatomsize)
        chunk = new fixed_atom_chunker(flags, flags.fixedatomsize, info, chunkkind, root_cycle, maxsize, mapbuffer);
    else
        chunk = new sticky_atom_chunker(flags, info, chunkkind, root_cycle, maxsize, mapbuffer);

    if( chgblkmsg ) DB->msg( "CHGBLK chunker::pick_atomic atomic_chunker=%p", chunk );
    return chunk;
}










void chunker::reduce_composite( fileref& data ) {
    if(!chunkkind.is_anycomposit())
        return;
    if(chunkkind.is_recipe8()) {      
        if( chunker_msg ) {
            hashcode thash;
            data.binhash( thash );
            DB->msg( "chunker::reduce_composite kind=%s %s", *chunkkind.image(), *thash.partialimage() );
        }
        
        
        compelem last_compelem(chunktype::recipe8);
        int compelem8_size = (sizeof(hashcode)+last_compelem.getsize());
        int offset =data.size()-compelem8_size;
        int count = data.size()/compelem8_size;
        last_compelem.init( data, offset );
        chunktype optimal_comp_type = compelem::bestfit( last_compelem.getendoff() );
        if( !optimal_comp_type.is_recipe8() ) {
            if( chunker_msg ) DB->msg( "reducing composite newtype = %s", *optimal_comp_type.image());
            compelem smaller_compelem(optimal_comp_type);
            compelem compelem8(chunktype::recipe8);
            int newsize = count * (sizeof(hashcode)+smaller_compelem.getsize());
            fileref newdata;
            newdata.initlist(newsize);
            bool isdir = chunkkind.is_dir();
            for( int offset = 0; offset < data.size();) {
                compelem8.init( data, offset );
                if( !isdir && ! compelem8.getisatom() ) {
                    if( chunker_msg || chgblkmsg ) DB->msg( "chunker::reduce_composite  returning because isdir=%d compelem8.getisatom=%d", isdir, compelem8.getisatom() );
                    
                }
                fileoffset toff = compelem8.getendoff();
                if( chunker_msg ) DB->msg( "child %s", *compelem8.gethash().partialimage());
                if( toff > fileoffset(0xFFFF) && 
                    optimal_comp_type.is_recipe2()) {
                    if( chunker_msg ) DB->msg( "bad little offset %s element offset = %d %d", *toff.image(), offset, offset/compelem8_size);
                }
                smaller_compelem = compelem8;
                newdata.append( smaller_compelem.getdata() ); 
            }
            if( chunker_msg || chgblkmsg ) DB->msg( "Old size = %d new size = %d", data.size(), newdata.size() );
            data = newdata;
            if( chunker_msg ) {
                hashcode thash;
                data.binhash( thash );
                if( chunker_msg || chgblkmsg ) DB->msg( "chunker::reduce_composite new kind=%s %s", *chunkkind.image(), *thash.partialimage() );
            }
            if (chunkkind.is_dir()) optimal_comp_type.set_dir();
            chunkkind = optimal_comp_type;
        }
    }
}

void chunker::list_composite( fileref &data, chunktype ckind ) {
    int compsize = data.size();
    int elements = compsize / ckind.compelemsize();
    int offset = 0;
    DB->msg( "CHGBLK chunker::list_composite kind=%s size=%d", *ckind.image(), data.size() );
    DB->msg( "CHGBLK chunker::list_composite compsize=%d", compsize );
    DB->msg( "CHGBLK chunker::list_composite elements=%d", elements );
    DB->msg( "CHGBLK chunker::list_composite %p", &data );
    compelem elemin(ckind);
    for( int i=0; i<elements; i++ ) {
        elemin.init( data, offset);
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::list_composite [%d]=(%s,%s)", i, *elemin.gethash().partialimage(), *elemin.getendoff().image() );
    }
    if( chgblkmsg ) DB->msg( "CHGBLK --" );
}


void chunker::expand_composite( fileref& data, chunktype ckind ) {
    assert( ckind.is_anycomposit() );
    if( chgblkmsg ) DB->msg( "chunker::expand_composite ckind=%s", *ckind.image() );
    chunktype newkind = chunktype::recipe8;
    if( ckind.is_recipe8() ) {
        return;  
    }

    int compsize = data.size();
    int elements = compsize / ckind.compelemsize();
    int newsize = elements * newkind.compelemsize();
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::expand_comosite newsize=%d", newsize );
    fileref newdata;
    newdata.initmem( newsize );
    compelem elemin(ckind);
    compelem elemout(newkind);
    int offset = 0;
    for( int i=0; i<elements; i++ ) {
        elemin.init( data, offset);
        elemout.sethash( elemin.gethash());
        elemout.setendoff( elemin.getendoff(),  false );
        newdata.setslice( i*newkind.compelemsize(), elemout.getdata());
    }
    data = newdata;
    
    if( chgblkmsg ) list_composite( newdata, newkind );
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::expand_composite Done" );
}

fileoffset chunker::get_last_endoff( fileref& data, chunktype ckind ) {
    
    compelem elem(ckind);
    int off = data.size()-(elem.getsize()+sizeof(hashcode));
    if( off < 0 ) return fileoffset(0);
    elem.init( data, off );
    return elem.getendoff();
}



fileref chunker::getRemainingBytesInSteam() {

    ChunkerDump x("chunker::getRemainingBytesInSteam", this, &m_sb);
    const int fenced = m_sb.getInternalBytesAvailable();
    assert(fenced == 0);
    const int bytesRemaining = m_pst->getBytesAvailable(m_sb);
    fileref data = m_pst->extractOutput(m_sb, bytesRemaining);
    data.makecontiguous();

    
    m_iStickyScanBookmark = 0;
    qhash.value = 0;

    return data;
}











void chunker::checkcompress(chunktype& kind, fileref& chunk) {
    
    if(root_cycle == NULL || compress_state == compress_no)
        return;

    
    context *main = root_cycle->main;
    if (main == NULL || main->handling_system_info() || ! flags.compress || ! kind.is_data_atomic() ) {
        compress_state = compress_no;
        return;
    }

    
    int usize = chunk.size();


    
    bool met_maxpercent = false;
    if (chunk.compress(flags.cpercent, 
                       fileref::compressionlevels(flags.clevel), 
                       fileref::compmodes(flags.compress), 
                       main->get_encmode(), 
                       met_maxpercent, 
                       main->get_enckey())) {
        kind = chunktype::extatomic;

        if(compress_state == compress_undecided) {
            if (met_maxpercent) {
                compress_state = compress_yes;
            } else {
                compress_state = compress_tweak;

                
                if(chunker_msg && info) DB->msg("Bypassing compression of %s, %.0f bytes", *info->path.image(), info->direlemp->file_size().dvalue());
                main->getstatsobj(context::backupstats)->inc_compressbypassed();
            }
        } 
    } else {
        DB->msg("compression of '%s' failed (or tweaking disabled)", *info->path.image()),
        compress_state = compress_no;
    }


    
    main->getstatsobj(context::backupstats)->add_compress(0 , chunk.size(), usize);

    
    assert(compress_state != compress_undecided);

    if( compress_ntfs_datahdr == compress_state ) { 
        compress_state = compress_undecided; 
    }
}




void chunker::append_init(const fileref& data) {
    m_pst->appendInput(m_sb, data);
    if( chunker_msg ) DB->msg("chunker::append_init buffer.size=%d", m_pst->getBytesAvailable(m_sb) );
}





fileref chunker::append_getchunk() {
    fileref chunk;
    int size = find_sticky(chunk);
    if(size == 0)
        return fileref();
    
    

    reduce_composite( chunk );  
    return chunk;
}


void chunker::append_computehash(fileref& chunk, hashcode& chunkhash, chunktype& kind) {
    kind = chunkkind;
    checkcompress(kind, chunk);

    chunk.binhash(chunkhash);
    int binhashcount = 1;
    while(xflag[23]&33554432) {
        hashcode h1;
        chunk.binhash(h1);
        DB->msg("chunker::append_computehash - chunkhash = %s, h1 = %s, %d", *chunkhash.partialimage(), *h1.partialimage(), binhashcount);
        if((chunkhash == h1) || (binhashcount > 10)) break;
        binhashcount++;
        chunkhash = h1;
    }

    root_cycle->main->getstatsobj(context::backupstats)->mainthread_hashed_bytes += chunk.size();   
    if (flags.chunkstats || chunker_msg ) DB->msg("%s CHUNK %d %s", *kind.image(), chunk.size(), *chunkhash.partialimage());
}


void chunker::append_process(chunktree *childtree, hashcode& chunkhash, const chunktype kind, fileref& chunk, int origsize) {
    
    assert( this != NULL );
    if (parent == NULL) {
        if( chunker_msg ) DB->msg( "chunker::append_process Creating parent node" );
        chunktype xkind(chunktype::recipe8);
        if (chunkkind.is_dir()) xkind.set_dir();
        if (flags.fixedcomposite)
             parent = new fixed_composite_chunker(flags, flags.fixedcomposite, info, xkind, root_cycle);
        else
             parent = new composite_chunker(flags, info, xkind, root_cycle);
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::append_process composite_chunker=%p", parent );
        set_chunker_name( "composite chunker from append_process" );

        parent->depth = this->depth+1;
        if( chunker_msg ) DB->msg("chunker::append_process new composite_chunk depth=%d", parent->depth);
    }

    if( chunker_msg ) DB->msg("%s CHUNK %d %s", *kind.image(), chunk.size(), *chunkhash.partialimage());
    if( chunker_msg ) DB->msg("before call to new chunknode");
    chunktree::node *tempnode = new chunktree::node(info, chunk, chunkhash, kind, origsize, depth, parent->cur_cycle, cur_cycle );
    cur_cycle = new backtree(root_cycle, info->dpninx, info->ignoreStats);
    if( chunker_msg ) DB->msg("AFTER call to new chunknode, cur_cycle=%p", cur_cycle);
    chunk.free();
    this->tree.add(tempnode, childtree);

    if (depth >= state->hfs_send_depth) {
      if( chunker_msg ) DB->msg("before send parent->cur_cycle=%p", parent->cur_cycle );
      tree.send(root_cycle->main->getstatsobj(context::backupstats));
      if( chunker_msg ) DB->msg("after send");
    }

    if( chunker_msg ) DB->msg("chunker::append_process, kind:%s, depth:%d size:%d", *kind.image(), depth, m_pst->getBytesAvailable(m_sb));
    

    
    
    compelem elem(chunktype::recipe8);
    elem.sethash(chunkhash);

    if( chgblkmsg ) DB->msg( "CHGBLK data_endoff=%s chunk->parent=%p", *parent->data_endoff.image(), parent );

    if ( chunkkind.is_atomic() ) {
       parent->data_endoff += origsize;
    } else {
       parent->data_endoff += data_endoff; 
    }
    if( chgblkmsg ) DB->msg( "CHGBLK data_endoff=%s chunk->parent=%p", *parent->data_endoff.image(), parent );

    elem.setendoff(parent->data_endoff, root_cycle->main->isatombit() & chunkkind.is_atomic() );

    parent->append_tree(elem.getdata(), &tree);

    if ( chunkkind.is_anycomposit() ) { 
        data_endoff = fileoffset(0);  
        if( chgblkmsg ) DB->msg( "CHGBLK data_endoff=0 chunk=%p", this );
        if( chunker_msg ) DB->msg( "chunker::append setting type back to recipe8 was %s", *chunkkind.image() );
        chunktype newkind(chunktype::recipe8);
        if(chunkkind.is_dir())
            newkind.set_dir();
        chunkkind = newkind;
    }
}

void chunker::fixup_depth() {  
    chunker *mychunker = this;
    int mydepth = depth+1;
    while( (mychunker = mychunker->parent) ) {
        mychunker->depth = mydepth++;
    }
}

void chunker::pre_restore_into_chunker( const fileref& pre_data ) {
    
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::pre_restore_into_chunker data.size()=%d ckind=%s chunker=%p name=%s", pre_data.size(), *chunkkind.image(), this, chunker_name );
    if( pre_data.size() < 0 ) {
        if( chgblkmsg ) DB->msg( "CHGBLK size <0" );
        DB->fatal( "chunker::pre_restore_into_chunker data.size()=%d ckind=%s", pre_data.size(), *chunkkind.image() );
        return;
    }
  
    if( chunkkind.is_anycomposit() ) {
        compelem elem(chunktype::recipe8);
        int off = 0;
        fileoffset loc_dataoff;

        const int savemin = flags.mincompsize;  
        flags.mincompsize=30000;                
                                
        if( chgblkmsg ) DB->msg(">>> PRE_RESTORE_INTO_CHUNKER START");
        
        while( off < pre_data.size() ) {
            if( chgblkmsg ) DB->msg( "CHGBLK chunker::pre_restore_into_chunker off=%d", off );
            elem.init( pre_data, off );
            loc_dataoff = elem.getendoff();
            if( chgblkmsg ) DB->msg( "CHGBLK pre_restore_into_chunker off=%d loc_dataoff=%s", off, *loc_dataoff.image() );
            append_tree(elem.getdata(), &tree);
        }
        if( chgblkmsg ) DB->msg(">>> PRE_RESTORE_INTO_CHUNKER END");

        flags.mincompsize = savemin;
        
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::pre_restore_into_chunker composite data_endoff=%s new data_endoff=%s", *data_endoff.image(), *loc_dataoff.image() );
        data_endoff = loc_dataoff; 
        
    } else {
        

        append_tree(pre_data, NULL);            
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::pre_restore_into_chunker atomic data_endoff=%s new size=%d", *data_endoff.image(), pre_data.size() );
        
    }
    if( chgblkmsg ) DB->msg( "CHGBLK chunker::pre_restore_into_chunker-- data_endoff=%s", *data_endoff.image() );

}

void chunker::set_post_restore_data( const fileref& post_data ) {
    assert(post_change_block_previous_data.isnull());
    if(!post_change_block_previous_data.isnull() && post_data.size() == 0) {
        Out->msg(ERR,"post_change_block_previous_data size = %d, post_data size = %d",post_change_block_previous_data.size(),post_data.size());
    }
    post_change_block_previous_data = post_data;
}

void chunker::append_tree(const fileref& data, chunktree * childtree) {
    if( chunker_msg ) DB->msg("chunker::append++ buffer bytes avail=%d data.size()=%d depth=%d", m_pst->getBytesAvailable(m_sb), data.size(), depth);

    append_init(data);
    while(true) {
        fileref chunk = append_getchunk();
        int origsize = chunk.size();
        if(origsize == 0)
            break;
        hashcode chunkhash;
        chunktype kind;
        append_computehash(chunk, chunkhash, kind);  
        append_process(childtree, chunkhash, kind, chunk, origsize);
    }
    if( chunker_msg ) DB->msg("chunker::append--");
}


hashcode chunker::flush_tree(chunktree *childtree, bool& wasatomic) {
    fileref chunk;
    hashcode chunkhash = hashcode::empty;
    int iBytesFlushed = 0;










    if( chunkkind.is_atomic() && post_change_block_previous_data.size() > 0 ) {
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::flush_tree Change Block atomic Flushing size=%d", post_change_block_previous_data.size() );

        append_tree(post_change_block_previous_data, NULL);   
    }

    if( !chunkkind.is_atomic() && post_change_block_previous_data.size() > 0 ) {
        if( chgblkmsg ) DB->msg( "CHGBLK chunker::flush_tree Change Block composite Flushing size=%d", post_change_block_previous_data.size() );
        
        int off = 0;
        while( off < post_change_block_previous_data.size() ) {
            compelem elem( chunktype::recipe8 );
            elem.init( post_change_block_previous_data, off );
            
            
            
            
            data_endoff += elem.getendoff();
            elem.setendoff( data_endoff, false );
            m_pst->appendInput(m_sb, elem.getdata());
        }
    }

    if( m_pst->signalEndOfStream(m_sb) ) { 
        iBytesFlushed = m_pst->getBytesAvailable(m_sb);
    } else { 
        ; 
    }
    if (chunker_msg ) DB->msg( "chunker::flush++ bytesflushed=%d this=%p name=%s post_change_block_previous_data.size()=%d", iBytesFlushed, this, chunker_name, post_change_block_previous_data.size() );
    wasatomic = false;

    if( chgblkmsg ) DB->msg( "CHGBLK chunker::flush bytesflushed=%d this=%p name=%s previous_data.size()=%d", iBytesFlushed, this, chunker_name, post_change_block_previous_data.size() );

    if (iBytesFlushed > 0) { 
        chunk = m_pst->extractOutput(m_sb, iBytesFlushed ); 
        reduce_composite( chunk );  
        int origsize = chunk.size();
        chunktype kind = chunkkind;
        checkcompress(kind, chunk);
        chunk.binhash(chunkhash);
        int binhashcount = 1;
        while(xflag[23]&33554432) {
            hashcode h1;
            chunk.binhash(h1);
            DB->msg("chunker::flush_tree - chunkhash = %s, h1 = %s, %d", *chunkhash.partialimage(), *h1.partialimage(), binhashcount);
            if((chunkhash == h1) || (binhashcount > 10)) break;
            binhashcount++;
            chunkhash = h1;
        }

        root_cycle->main->getstatsobj(context::backupstats)->mainthread_hashed_bytes += chunk.size();        
        if (chunker_msg || flags.chunkstats) DB->msg("%s CHUNK %d %s (flush)", *kind.image(), chunk.size(), *chunkhash.partialimage());

        cycle *parent_cycle_to_use = NULL;
        if (parent != NULL)
            parent_cycle_to_use = parent->cur_cycle;
        else parent_cycle_to_use = root_cycle; 
        chunktree::node *tempnode = new chunktree::node( info, chunk, chunkhash, kind, origsize, depth, 
                                                         parent_cycle_to_use,
                                                         cur_cycle );
        chunk.free();
        this->tree.add(tempnode, childtree);
        if (depth >= state->hfs_send_depth)
                tree.send(root_cycle->main->getstatsobj(context::backupstats));

        if (parent != NULL) {
            chunktype parentkind(chunktype::recipe8);
            if(chunkkind.is_dir())
                parentkind.set_dir();
            compelem elem(parentkind);
            elem.sethash(chunkhash);
            if (chunkkind.is_atomic()) {
               parent->data_endoff += iBytesFlushed;
            } else {
               parent->data_endoff += data_endoff; 
            }
            if( chgblkmsg ) DB->msg( "CHGBLK chunker::flush_tree data_endoff=%s chunk=%p", *data_endoff.image(), this );
            if( chgblkmsg ) DB->msg( "CHGBLK chunker::flush_tree parent->data_endoff=%s parent=%p", *parent->data_endoff.image(), parent );

            elem.setendoff(parent->data_endoff, root_cycle->main->isatombit() & chunkkind.is_atomic() );
            parent->append_tree(elem.getdata(), &tree);
        }
    } else {
        delete cur_cycle; 
    }

    flushed = true;
    if (parent != NULL) { 
        bool unused_atomic;
        chunkhash = parent->flush_tree(&tree, unused_atomic);
    } else { 
        wasatomic = true;
        tree.send(root_cycle->main->getstatsobj(context::backupstats));
    }
    if (chunker_msg ) DB->msg( "chunker::flush-- %s", *chunkhash.partialimage() );
    return chunkhash;
}



static bool findloop(const char *buff, int maxcurr, quickhash& qhash,
                    int& curr, int threshold) {
    bool ret = false;
    unsigned int v = qhash.value;
    const char *p = buff + curr;
    const char *max = buff + maxcurr;
    unsigned int length = curr;
    unsigned int limit = threshold;
    unsigned int x = limit - length;
    
    while (p < max) {
        v = (v >> 1) ^ scramble[(unsigned char)*p];
        if((v ^ (v-1)) >= --x) {
            ret = true;
            break;
        }
        p++;
    }
    qhash.value = v;
	assert( (p - buff) <= INT_MAX );
    curr = (int)(p - buff);
    assert(curr >= 0);
    
    return ret;
}

int sticky_atom_chunker::find_sticky(fileref &stickychunk) {
    int size = m_pst->getBytesAvailable(m_sb);
    if ( chunker_msg ) DB->msg("sticky_atom_chunker:find_sticky size=%d", size);
    
    if( (0 == size) &&
        m_pst->queryStreamProcessingIsComplete() &&
        m_pst->queryStreamContentIsValid() ) { 
        m_sb.garbagecollect();
    }

    bool foundit = false;

    
    if(flags.minchunksize != 0 && size - m_iStickyScanBookmark <= flags.minchunksize)

        return 0;

    
    
    

    if(flags.minchunksize != 0 && m_iStickyScanBookmark == 0) { 
        assert(flags.minchunksize >= QHASHBYTES);
        
        m_iStickyScanBookmark += flags.minchunksize + 1;
        fileref fr = m_pst->peekOutput(m_sb, m_iStickyScanBookmark-QHASHBYTES, QHASHBYTES);
        qhash.compute(fr, 0);
    }

    
    
	if (m_iStickyScanBookmark == 0 && qhash.value == 0) {
        if(size >= QHASHBYTES) {
            fileref fr = m_pst->peekOutput(m_sb, 0, QHASHBYTES);
            qhash.compute(fr, 0);
            m_iStickyScanBookmark = QHASHBYTES;
        }
	}

    int maxcurr = flags.maxchunksize;
	if(maxcurr > size) {
        maxcurr = size;
	}


    bool    bBoundaryPresent = false;
    if(flags.threshold > 0) {
        
        const char *buff = m_pst->peekOutputPtr(m_sb, m_iStickyScanBookmark, maxcurr - m_iStickyScanBookmark);
        
        
        buff -= m_iStickyScanBookmark;

        
        Streambuffer::Breakpoint bp = m_sb.peekNextBreakpoint();

        
        while( (bp.getType() != Streambuffer::Breakpoint::BPTYPE_UNINITIALIZED) && 
            (!flags.chunkntfsstreams ||                     
             bp.getOffset() <= m_sb.getAbsoluteOffset()) )  
        {
            
            
            
            
            
            if( bp.getType() != Streambuffer::Breakpoint::BPTYPE_ENDOFNTFSDATAHDR ) {
                if( compress_ntfs_nondata == get_compress_state() ) {
                    set_compress_state( compress_ntfs_datahdr );
                }
            }
            
            m_sb.extractNextBreakpoint(); 
            bp = m_sb.peekNextBreakpoint();
        }

        
        
        
        
        int iBreakpointType = bp.getType();
        if( iBreakpointType != Streambuffer::Breakpoint::BPTYPE_UNINITIALIZED ) { 
            if ( chunker_msg ) DB->msg("sticky_atom_chunker:find_sticky, breakpoint!=BPTYPE_UNINITIALIZED");
            if( iBreakpointType != Streambuffer::Breakpoint::BPTYPE_ENDOFNTFSDATAHDR ) {
                if( compress_ntfs_nondata == get_compress_state() ) {
                    set_compress_state( compress_ntfs_datahdr );
                }
            }
            if( (flags.minchunksize > 0) && 
                (bp.getOffset() - m_sb.getAbsoluteOffset()) < (ubigint64)flags.minchunksize ) {
				
				
                int stickysize = (int)(bp.getOffset() - m_sb.getAbsoluteOffset());
				
                m_sb.extractNextBreakpoint(); 
                
                
                
                
                
                
                stickychunk = m_pst->extractOutput(m_sb, stickysize);
                m_iStickyScanBookmark = 0;
                qhash.value = 0;
                return stickysize;          
            }
            if( (bp.getOffset() - m_sb.getAbsoluteOffset()) <= (ubigint64)maxcurr ) {
                bBoundaryPresent = true;
                maxcurr = (int)(bp.getOffset() - m_sb.getAbsoluteOffset());;
            }
        }
        else {
            if ( chunker_msg ) DB->msg("sticky_atom_chunker:find_sticky, breakpoint==BPTYPE_UNINITIALIZED");
        }
        

        
        foundit = findloop(buff, maxcurr, qhash, m_iStickyScanBookmark, flags.threshold);
    }

    
    if( bBoundaryPresent && !foundit ) {
        
        
        
        int stickysize = maxcurr;
		
        m_sb.extractNextBreakpoint(); 
        stickychunk = m_pst->extractOutput(m_sb, stickysize);
        m_iStickyScanBookmark = 0;
        qhash.value = 0;
        return stickysize;  
    }    
    

    if( foundit && ((unsigned int)m_iStickyScanBookmark > flags.dpnmaxatomchunksize) ) 
        DB->bt_error( "sticky_atom_chunker::find_sticky length too large = %d max = flags.dpnmaxatomchunksize) = %d", 
                      m_iStickyScanBookmark, flags.dpnmaxatomchunksize );

    if(foundit &&                        
       maxsize != fileoffset(0) &&       
       maxsize > fileoffset(m_iStickyScanBookmark) &&     
       flags.minchunksize != 0 &&        
       maxsize - m_iStickyScanBookmark < fileoffset(flags.minchunksize)) 
        return 0;                            

    if (foundit) {
        
        if(!uapp::staging().canRun(RSTAGE_WRAPUP)) throw EXC_CANCEL;

        int stickysize = m_iStickyScanBookmark + 1;
        stickychunk = m_pst->extractOutput(m_sb, stickysize);
        m_iStickyScanBookmark = 0;

        return stickysize;
    }
    return 0;
}




#define DIRELEM_SIZE 60

int directory_chunker::find_sticky(fileref &stickychunk) {
    int size = m_pst->getBytesAvailable(m_sb);
    fileref fr = m_pst->peekOutput(m_sb, 0, size);
    while(m_iStickyScanBookmark < size) {
        int tmp = DIRELEM::get_direlem_size(fr, m_iStickyScanBookmark);
        if( tmp + m_iStickyScanBookmark > size ) {
            DB->msg( "DIRELEM crossing boundary hack m_iScanBookmark=%d size=%d, DIRELEM=%d", m_iStickyScanBookmark, size, tmp );
            return 0;
        }
        int v = DIRELEM::get_directory_chunker_v(fr, m_iStickyScanBookmark);

        m_iStickyScanBookmark += tmp;
        assert(m_iStickyScanBookmark <= size);
        
        int length = m_iStickyScanBookmark;

        if( (unsigned int)length > root_cycle->main->getmaxdirelemsize(dpn0) )
            DB->bt_error( "directory_chunker::find_sticky length too large = %d", length );
        if(length < flags.mindirsize)
            continue;
        int x = (v ^ (v-1)) * DIRELEM_SIZE + length;
        if(x > flags.dirthreshold) {
            if(!uapp::staging().canRun(RSTAGE_WRAPUP)) throw EXC_CANCEL;
            stickychunk = m_pst->extractOutput(m_sb, length);
            m_iStickyScanBookmark = 0;
            return length;
        }
    }
    return 0;
}

int composite_chunker::find_sticky(fileref &stickychunk) {
    int size = m_pst->getBytesAvailable(m_sb);

    while(m_iStickyScanBookmark < size) {
        hashcode hash;
        fileref fr = m_pst->peekOutput(m_sb, m_iStickyScanBookmark, sizeof(hashcode));
        fr.getslice(0, sizeof(hashcode), &hash);
        int v = hash[0];  
        m_iStickyScanBookmark += sizeof(COMPELEM8);
        assert(m_iStickyScanBookmark <= size);
        assert( (m_iStickyScanBookmark % sizeof(COMPELEM8)) == 0);
        int length = m_iStickyScanBookmark;
        if( (unsigned int)length > flags.dpnmaxcompchunksize ) 
            DB->bt_error( "composite_chunker::find_sticky length too large = %d", length );
        if(length < flags.mincompsize)
            continue;
        int x = (v ^ (v-1)) * sizeof(COMPELEM8) + length;
        if(x > flags.compthreshold) {
            if(!uapp::staging().canRun(RSTAGE_WRAPUP)) throw EXC_CANCEL;
            stickychunk = m_pst->extractOutput(m_sb, length);
            m_iStickyScanBookmark = 0;
            return length;
        }
    }
    return 0;
}

int fixed_atom_chunker::find_sticky(fileref &stickychunk) {
    int csize = chunksize;

    
    if ( bug14204_checkchunkalignment && (m_sb.getAbsoluteOffset() % ubigint64(csize)) != 0 && (m_sb.getAbsoluteOffset() % ubigint64(csize/2)) == 0) {
      DB->msg("Chunker shifted offset=%0.2f chunks, resetting to %d for this chunk", double(m_sb.getAbsoluteOffset())/csize, csize/2);
      csize /= 2;
    }

    if ( m_pst->getBytesAvailable(m_sb) >= csize ) {
        stickychunk = m_pst->extractOutput(m_sb, csize);
        m_iStickyScanBookmark = 0; 
        return csize;
    }
    return 0;
}

fixed_composite_chunker::fixed_composite_chunker 
      (utar_flags_info& flags, int elemcount, workelem *info, chunktype chunkkind, BackCycle *parent_cycle)
: chunker(flags, info, chunkkind, parent_cycle)
{
    compelem x(chunkkind);
    int elem_size = x.getsize() + sizeof(hashcode);
    chunksize = elemcount * elem_size;
    DB->msg("fixed_composite_chunker count:%d * elemsize:%d = chunksize:%d", elemcount, elem_size, chunksize);
};

int fixed_composite_chunker::find_sticky(fileref &stickychunk) {
    if ( m_pst->getBytesAvailable(m_sb) >= chunksize ) {
        stickychunk = m_pst->extractOutput(m_sb, chunksize);
        m_iStickyScanBookmark = 0; 
        return chunksize;
    }
    return 0;
}

#if !defined(BACKTREE_H_INCLUDED)
#define BACKTREE_H_INCLUDED











               








class message;

#include "cycle.h"
#include "fileref.h"
#include "chunktree.h"
#include "ade/hash_cache.h"
#include "filestats.h"
class backstats;




class backtree : public BackCycle {
public:
    SAFEPOOLALLOC(backtree);
    backtree(BackCycle *parent, const dpns dpninx, const bool ignorestats = false);
    
    
    
    void setup(cycle *parent, chunktree::node *tree,
             backstats *stats=NULL, const filestatsref& fstats = filestatsref(),
             hash_cache *cache_=NULL );
    virtual void init();
    virtual void response(message& outargs);
    virtual void notifyparent();
    virtual void childdone(cycle *child);
    virtual ~backtree();
    void set_stats(backstats *stats_) { stats = stats_; };
    void ispresentonly() { skipaddhashdata = true; }
private:
    bool checkrefs(int child_count) const;
    bool buildconsolidated(message& outargs);
    bool hashispresentlist(message& m);
    void saveispresent(const hashcode& hash, bool ispresent);
    void saveaddcompdata();

    const dpns dpninx;
    bool inlookup;
    bool inlistlookup;
    bool didlistlookup;
    bool ispresent;
    bool doconsolidate;
    unsigned int ncons;
    bool skipaddhashdata;
    const bool ignorestats;
    chunktree::node *tree;
    backstats *stats;
    filestatsref fstats;
    hash_cache *cache;
};

#endif


















#include "common.h"
#include "debug.h"
#include "restdirlistproducer.h"
#include "hfs_info_struct.h"

#include "MetadataStore.h"







#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define NUM_ENTRIES_TO_GET  33     

restdirlistproducer::restdirlistproducer(cycle* parent, consumer *callback_, const location& _metadataloc, const location &parent_loc_, const ustring& msgid_, const dpns dpninx_)
    : bicycle(parent),
      childrdp(NULL),
      inorder(true),
      have_parent_loc(true), 
      parent_loc(parent_loc_),
      callback(callback_),
      terminated(false),
      msgid(msgid_),
      metadataloc(_metadataloc),
      dpninx(dpninx_)
{
    if ((parent_loc.get_containerid() == 0) && (parent_loc.get_abs_offset_in_container() == fileoffset::unknown)) {
        DB->msg("restdirlistproducer::restdirlistproducer setting inorder to false because parent_loc says not in a container");
        inorder = false;
    } else {
        assert(parent_loc.get_abs_offset_in_container() != fileoffset::unknown);
    }

    if(msg1)DB->msg("restdirlistproducer::restdirlistproducer for '%s' with parent_loc:%s",
                     *metadataloc.image(), *parent_loc.image());
    launch();
}


restdirlistproducer::~restdirlistproducer()
{
}


void restdirlistproducer::launch() {
    assert(NULL != callback);

    
    
    
    
    if(parent_loc.getMedia() == location::media::unknown) {
        running_coverage_size[parent_loc.get_containerid()] = parent_loc.get_abs_offset_in_container();
    }

    if (metadataloc.isFromCatalog()) {
        todoEnqueueInsert(TODO_DIR, this, 0);      
    }
    else if (metadataloc.isFromGsan()) {
        childrdp = new restdataproducer(this, metadataloc.getHash(), fileoffset::unknown, this, inorder, msgid, dpninx);
        childrdp->noop();
    }
    else {
        
        const ustring errmsg = ustring::sprintf("restdirlistproducer::launch called with unrecognized media location(%s)", *metadataloc.image());
        set_error(true, errmsg);
    }

}





void restdirlistproducer::init()
{
    if (terminated) {
        
        childdone(NULL);
        return;
    }

    static const MetadataStore * metaStore = main->getAdeMgr()->getHfsInfo(dpn0).metaStore;
    if (metaStore != NULL) {
        direlemp_list_type_sp direlems = undoo::make_shared<direlemp_list_type>();
        const int numToGet = NUM_ENTRIES_TO_GET;
        storeResultCodes res = metaStore->getMetadataChildren(metadataloc.getMetadataId(), *direlems, numToGet, catalog_state);
        if (res == storeSuccess) {

            
            process_direlem_list(direlems);

            
            
            if (!terminated) {
                todoEnqueueInsert(TODO_DIR, this, 0);      
            }
        }
        else {
            
            if (res != storeNoMoreChildren) {
                const ustring errmsg = ustring::sprintf("restdirlistproducer::init unexpected error from metaStore->getMetadataChildren(%s) -- %d", *metadataloc.getMetadataId().image(), res);
                set_error(true, errmsg);
            }

            terminated = true;
        }

        if (terminated) {
            childdone(NULL);
        }
    }
    else {
        
        assert(false);
    }
}






void restdirlistproducer::rdpconsume(const fileref& buf, const fileoffset& dataoffset, restdataproducer * const producer)
{
    if (terminated) {
        if (msg1) DB->msg("restdirlistproducer for '%s': ::rdpconsume called with %s byte of data at listingoffset %s while terminated, ignoring.",
                          *msgid, *buf.size64().image(), *dataoffset.image());
        terminated = true;
        if (producer != NULL) {
            producer->terminate();
        }
        return;
    }

    if (msg1) DB->msg("restdirlistproducer for '%s': ::rdpconsume processing %s bytes of data at listingoffset %s",
                      *msgid, *buf.size64().image(), *dataoffset.image());

    
    
    const baselocation metaloc(metadataloc.getMedia());

    direlemp_list_type_sp direlems = undoo::make_shared<direlemp_list_type>();
    for (int off = 0; off < buf.size(); ) {
        DIRELEMp de(new DIRELEM);
        upath emptyparentpath;
        if (!de->populate(buf, off, emptyparentpath)) {
            
            DB->msg("restdirlistproducer::rdpconsume unable to populate a direlem (metadataloc=%s, listingoffset=%s)", *metadataloc.image(), *dataoffset.image());
            Out->msg(ERR, "Unable to restore part of a directory (%s)", *metadataloc.image());
            break;
        }

        de->set_metadataLocation(metaloc);

        process_direlem(de);
        if (msg2) DB->msg("restdirlistproducer::rdpconsume    de.location(%s) for inode %s is %s at %s in listing",
                            inorder ? *de->get_location().image() : "", *tostr(get_direlem_inode_number(de)), *de->name(), *(dataoffset+off).image());

        

        direlems->push_back(de);
    }

    if (msg1) DB->msg("restdirlistproducer for '%s': ::rdpconsume now has %s entries in listing data", *msgid, *::tostr(direlems->size()));
    callback->rdlpconsume(direlems, this);
}




void restdirlistproducer::process_direlem_list(direlemp_list_type_sp& delist) {

    if (msg1) DB->msg("restdirlistproducer::process_direlem_list for '%s' called with %s entries in delist", *msgid, *::tostr(delist->size()));

    direlemp_list_type::const_iterator it = delist->begin();
    for (; it != delist->end(); it++) {
        DIRELEMp de(*it);

        process_direlem(de);
        if (msg2) DB->msg("restdirlistproducer::process_direlem_list: de.location(%s) for inode %s is %s", *de->get_location().image(), 
            *tostr(get_direlem_inode_number(de)), *de->name());

    }

    callback->rdlpconsume(delist, this);
}


void restdirlistproducer::process_direlem(DIRELEMp de) {

    if (inorder) {
        location loc(de->get_location());
        if (loc.get_backupid() == location::tbackupid()) loc.set_backupid(parent_loc.get_backupid());
        if (loc.get_clientid() == ustring()) loc.set_clientid(parent_loc.get_clientid());
        
        
        
        
        
        
        bool skip_set_location(false);
        bool skip_set_location_info(false);
        if ((loc.getMedia() > location::media::gsan) && (loc.get_containerid() == 0) && have_parent_loc) {
            
            
            bool processing_ndmp_data = flags.pluginid.kind() == pidtype::ndmp ||
                                        flags.destination_data != client_config_flags::same_destination;  
            if (parent_loc.get_containerid() != 0){
                
                
                
                if (msg2) DB->msg("restdirlistproducer::process_direlem, de '%s', setting containerid == %d (parent_loc.containerid), ndmp data? %s",
                                *de->fullpath().image(), parent_loc.get_containerid(), processing_ndmp_data? "Yes" : "No");
                loc.set_containerid(parent_loc.get_containerid());

                if (processing_ndmp_data) {
                    
                    
                    
                    skip_set_location_info = true;
                }
            } else if (processing_ndmp_data) {
                
                
                
                
                
                if (msg2) DB->msg("restdirlistproducer::process_direlem de '%s', parent_loc.containerid is zero; set_location_info() will be called to retrieve containerid and emd",
                                    *de->fullpath().image());
                
                
                
                skip_set_location = true;
            }
        }
        
        
        if(!skip_set_location) {
            de->set_location(loc);
        }

        
        if(loc.getMedia() > location::media::gsan) {
            if (!skip_set_location_info && have_parent_loc && (parent_loc.getMedia() > location::media::gsan)) {
                main->set_location_info("restdirlistproducer::process_direlem()", parent_loc, *de);
                loc = de->get_location(); 
            }

            
            
            
            if(loc.get_containerid() == 0 && (loc.get_format() == location::tformat::cdsf || loc.get_format() == location::tformat::raw)) {
                
                
                
                loc.set_containerid(1);
            }

            
            loc.set_abs_offset_in_container(running_coverage_size[loc.get_containerid()]);
            
            

            
            if(loc.get_format() == location::tformat::cdsf) {
                
                
                
                if(loc.get_containerid() == parent_loc.get_containerid()) {
                    
                    
                    if (loc.getMedia() != parent_loc.getMedia() && parent_loc.getMedia() != location::media::unknown)
                        DB->warn("restdirlistproducer::process_direlem has parent_loc:%s loc:%s for %s, media doesn't match",
                                    *parent_loc.image(), *loc.image(), *de->fullpath().image());
                    if (msg2)
                        DB->msg("restdirlistproducer::process_direlem loc.abs:%s += parentloc.abs:%s + parentloc.headersize:%s == %s",
                                *loc.get_abs_offset_in_container().image(), *parent_loc.get_abs_offset_in_container().image(),
                                *parent_loc.get_header_size().image(),
                                *(loc.get_abs_offset_in_container() + parent_loc.get_abs_offset_in_container() + parent_loc.get_header_size()).image());
                    loc.set_abs_offset_in_container( loc.get_abs_offset_in_container() + parent_loc.get_abs_offset_in_container() + parent_loc.get_header_size() );
                } else {
                    if (msg2) DB->msg("restdirlistproducer::process_direlem '%s' (container %d) not in the same container as it's parent (container %d), so didn't increment its absoffset",
                                        *de->fullpath().image(), loc.get_containerid(), parent_loc.get_containerid());
                }
            }

            
            de->set_location(loc);
            if (msg2) DB->msg("restdirlistproducer::process_direlem absolute offset calculated for '%s' abs:%s", *de->fullpath().image(), *de->get_location().get_abs_offset_in_container().image());

            
            if(loc.get_format() == location::tformat::cdsf) {
                running_coverage_size[loc.get_containerid()] += loc.get_coverage_size();
                
                
            }
        }

        if (msg2) DB->msg("    de.location(%s) for inode %s is %s in listing", *loc.image(), *tostr(get_direlem_inode_number(de)), *de->name());
    }
    else {
        if (msg2) DB->msg("    inode %s is %s in listing", *tostr(get_direlem_inode_number(de)), *de->name());
    }
}


void restdirlistproducer::childdone(cycle *child)
{
    
    notifyparent();
}

void restdirlistproducer::terminate()
{
    if (!terminated) {
        if (msg1) DB->msg("restdirlistproducer for '%s': ::terminate for %p with final running_coverage_size (for container %s) %s",
                          *msgid, this, *tostr(parent_loc.get_containerid()), *tostr(running_coverage_size[parent_loc.get_containerid()].value()));
        terminated = true;

        
        
        if (childrdp != NULL) {
            childrdp->terminate();
        }
    }
}

ubigint64 restdirlistproducer::get_direlem_inode_number(DIRELEMp de) {
    if (flags.streamformat_in == utar_flags_enums::streamformat_isilon ||
        flags.streamformat_in == utar_flags_enums::streamformat_zfs) {
            return de->inode_number64();
    }
    else if (flags.streamformat_in == utar_flags_enums::streamformat_emctar) {
        return de->emctar_inode_number64();
    }
    else {
        return de->inode_number();
    }
}












#include "common.h"
#include "exportstream_xml.h"

#include "debug.h"
#include "output.h"

#include "roothashlist.h"

#define APPVERSION "appversion"


#define BACKUPEXPORT_METAINFO   "exportstream_metainfo"

const ustring exportstream_xml::section::image() const
{
    ustring ret("unassigned");

    static const char* images[] =
    {
        "none",
        "error",
        
        "archive_info",
        "workorder",
        "backup",
        "location",
        "build",
        "flagsettings",
        "commandline",
        
        "ddr_files_xml_gsan",
        "ddr_files_xml_ddr",
        

        "end_of_msection_enum",    
    };

    if(sect >= none && sect <= end_of_msection_enum) {
        ret = images[sect];
    } else {
        assert("exportstream_xml::section::image() value out of range" == 0);
    }

    return ret;
}


intassoc exportstream_xml::section::image_mapping;


bool exportstream_xml::section::image_mapping_initialized = false;



const exportstream_xml::section::type exportstream_xml::section::value(const ustring& sectimage)
{
    if(!image_mapping_initialized) {
        for(type sect = section::first(); sect <= section::last(); sect = type(sect + 1)) {
            const ustring sectimage(section(sect).image());

            image_mapping.enter(sectimage, sect);
        }

        image_mapping_initialized = true;
    }

    type ret = error;

    if(image_mapping.defined(sectimage)) {
        ret = type(image_mapping.lookup(sectimage));
    }

    return ret;
}


const ustring exportstream_xml::attr::image() const
{
    ustring ret("unassigned");

    static const char* images[] =
    {
        "none",
        "error",
        

        
        "flags",
        "pid",
        "pidnum",
        "newformat",
        "ispresentbytes",
        "percentnew",
        "isencrypted",
        "label",
        "rhllabel_taghash",
        "rhllabel_aux1",
        "rhllabel_aux2",
        "labelnum",
        "created",
        "created_prectime",
        "totalbytes",
        "expires",
        "expires_prectime",
        "retentiontype",
        "partial",
        "backuptype",
        "backuptype_internal",   
        "ddrindex",
        "backuptag",
        "savesetid",
        "appversion",
        "appconsistent",
        "tier",

        "end_of_attr_enum",   
    };

    if(at >= none && at <= end_of_attr_enum) {
        ret = images[at];
    } else {
        assert("exportstream_xml::attr::image() value out of range" == 0);
    }

    return ret;
}


intassoc exportstream_xml::attr::image_mapping;


bool exportstream_xml::attr::image_mapping_initialized = false;



const exportstream_xml::attr::type exportstream_xml::attr::value(const ustring& atimage)
{
    if(!image_mapping_initialized) {
        for(type at = attr::first(); at <= attr::last(); at = type(at + 1)) {
            const ustring atimage(attr(at).image());

            image_mapping.enter(atimage, at);
        }

        image_mapping_initialized = true;
    }

    type ret = error;

    if(image_mapping.defined(atimage)) {
        ret = type(image_mapping.lookup(atimage));
    }

    return ret;
}


exportstream_xml::exportstream_xml()
{
    mess = new xml_message(BACKUPEXPORT_METAINFO);
}


exportstream_xml::exportstream_xml(const fileref& data)
{
    mess = new xml_message(data, true);
}


exportstream_xml::exportstream_xml(const ustring name)
{
    mess = new xml_message(name);
}




exportstream_xml::~exportstream_xml()
{
}


xml_messagep exportstream_xml::to_xmlp() const
{
    return mess;
}



void exportstream_xml::add_section(section::type sect, xml_messagep sectinfop)
{
    
    const ustring sectionname(section(sect).image());
    if(!sectinfop.isnull() && sectinfop->getcommand() != sectionname) {
        Out->msg(WARN, "Export metadata section %s has a name of '%s'", *sectionname, *sectinfop->getcommand());
        DB->msg("exportstream_xml::add_section(%s) adding '%s'", *sectionname, *sectinfop->simage());
    }

    

    if(!sectinfop.isnull() && sectinfop->valid() && valid() && !mess.isnull()) {
        mess->children.push_back(sectinfop);
    }
}



bool exportstream_xml::get_label(rhlLabel &rhllabel) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        const ustring attrname(attr2ustr(attr::labelattr));
        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            const ustring labelstr(backupsectp->getstring(attrname));

            
            
            ustring backuptag;
            char backuptag_hashvalue(0);
            const ustring attrtaghashname(attr2ustr(attr::labelattr_taghash));
            if(backupsectp->defined(attrtaghashname)) {
                backuptag_hashvalue = static_cast<char>(backupsectp->getint(attrtaghashname));
            } else if(!imported_backuptag_value.isempty()) {
                backuptag = imported_backuptag_value;
            }

            char aux1(0), aux2(0);
            const ustring attraux1name(attr2ustr(attr::labelattr_aux1));
            if(backupsectp->defined(attraux1name)) {
                aux1 = static_cast<char>(backupsectp->getint(attraux1name));
            }
            const ustring attraux2name(attr2ustr(attr::labelattr_aux2));
            if(backupsectp->defined(attraux2name)) {
                aux2 = static_cast<char>(backupsectp->getint(attraux2name));
            }

            rhllabel = rhlLabel(*labelstr, backuptag.isempty() ? 0 : *backuptag, aux1, aux2);
            if(backuptag_hashvalue != 0) {
                rhllabel.set_taghash(backuptag_hashvalue);
            }

            ret = true;
        }
    }

    return ret;
}




bool exportstream_xml::get_status(int& status) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        const ustring attrname(attr2ustr(attr::partial));
        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            const int is_partial(backupsectp->getint(attrname));

            
            status = is_partial?RHL_UPDATE_BEGIN:RHL_UPDATE_ONETIME;   
            ret = true;
        }
    }

    return ret;
}



bool exportstream_xml::get_totalsize(double& totalsize) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        const ustring attrname(attr2ustr(attr::totalbytes));
        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            totalsize = backupsectp->getdouble(attrname);
            ret = true;
        }
    }

    return ret;
}



bool exportstream_xml::get_roothashflags(roothashflags& rflags) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        if(!backupsectp.isnull()) {
            
            roothashflags tmp(rflags);

            
            const ustring newformatattr(attr2ustr(attr::newformat));
            if(backupsectp->defined(newformatattr)) {
                tmp.newformat = (backupsectp->getdouble(newformatattr) != 0.0);
            }

            const ustring ispresentattr(attr2ustr(attr::ispresentbytes));
            if(backupsectp->defined(ispresentattr)) {
                tmp.ispresent = float(backupsectp->getdouble(ispresentattr));
            }

            const ustring pidattr(attr2ustr(attr::pid));
            if(backupsectp->defined(pidattr)) {
                tmp.plugin_num = backupsectp->getint(pidattr);
            }

            const ustring percentnewattr(attr2ustr(attr::percentnew));
            if(backupsectp->defined(percentnewattr)) {
                tmp.percentnew = backupsectp->getint(percentnewattr);
            }

            const ustring isencryptedattr(attr2ustr(attr::isencrypted));
            if(backupsectp->defined(isencryptedattr)) {
                tmp.isencrypted = backupsectp->getbool(isencryptedattr);
            }

            const ustring retentiontypeattr(attr2ustr(attr::retentiontype));
            if(backupsectp->defined(retentiontypeattr)) {
                const ustring retentiontypestr(backupsectp->getstring(retentiontypeattr));
            }

            
            const ustring backuptypeattr(attr2ustr(attr::backuptype_internal));
            if(backupsectp->defined(backuptypeattr)) {
                const ustring backuptypestr(backupsectp->getstring(backuptypeattr));
                const tbackuptype backuptype(backuptypestr);
                const ustring errstr(backuptype.get_errors());

                if(!errstr.isempty()) {
                    Out->msg(WARN, "<12499>Received '%s' attempting to retrieve exported backuptype", *errstr);
                } else {
                    tmp.backuptype = backuptype;
                }
            }

            const ustring ddrindexattr(attr2ustr(attr::ddrindex));
            if(backupsectp->defined(ddrindexattr)) {
                tmp.ddrindex = backupsectp->getint(ddrindexattr);
            }

            rflags = tmp;

            ret = true;
        }
    }

    return ret;
}



pidtype exportstream_xml::get_pid() const
{
    roothashflags rflags;

    rflags.plugin_num = -1;
    if(get_roothashflags(rflags) && rflags.plugin_num > 0) {
        return pidtype(rflags.plugin_num);
    }

    return pidtype::none;
}



const bool exportstream_xml::get_backup_version_and_ddrindex(ustring& version, int& ddrindex) const
{
    roothashflags rflags;

    ddrindex = rflags.ddrindex = 0;
    if(get_roothashflags(rflags) && rflags.plugin_num > 0) {
        ddrindex = rflags.ddrindex;

        const xml_messagep archive_infop(find_section(section::archive_info));
        if(!archive_infop.isnull()) {
            const xml_messagev cv(archive_infop->children);

            for(size_t i = 0; i < cv.size(); i++) {
                const xml_messagep childp(cv[i]);

                if(!childp.isnull() && childp->getstring("name") == APPVERSION) {
                    version = childp->getstring("value");
                    return true;
                }
            }
        }
    }

    return false;
}



bool exportstream_xml::get_snapup_timestamp(ubigint64& timestamp) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        const ustring attrname(attr2ustr(attr::created_prectime));
        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            const ustring hexstr(backupsectp->getstring(attrname));
            const prectime pt(prectime::evalInputTime(hexstr));

            timestamp = +pt;
            ret = true;
        }
    }

    return ret;
}



bool exportstream_xml::get_expires_time(ubigint64& expirestime) const
{
    bool ret(false);

    if(valid() && !mess.isnull()) {
        
        const xml_messagep backupsectp(find_section(section::backup));
        const ustring attrname(attr2ustr(attr::expires_prectime));
        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            const ustring hexstr(backupsectp->getstring(attrname));
            const prectime pt(prectime::evalInputTime(hexstr));

            expirestime = +pt;
            ret = true;
        }
    }

    return ret;
}


const bool exportstream_xml::has_section(const section::type sect) const
{
    return !find_section(sect).isnull();
}


const xml_messagep exportstream_xml::find_section(const section::type sect) const
{
    xml_messagep sectionp;

    if(valid() && !mess.isnull()) {
        const xml_messagev& children(mess->children);
        const ustring sectionname(section(sect).image());
        for(size_t i = 0; i < children.size(); i++) {
            if(!children[i].isnull() && children[i]->getcommand() == sectionname) {
                sectionp = children[i];
                break;
            }
        }
    }

    return sectionp;
}


const ustring exportstream_xml::attr2ustr(const attr::type attrtype)
{
    const attr attrobj(attrtype);
    return attrobj.image();
}


xml_messagep exportstream_xml::get_xmlp(const ddrfilesxml_search from) const
{
    xml_messagep xmlp;

    if((from == ddrfilesxml_from_gsan_then_ddr) || (from == ddrfilesxml_from_gsan)) {
        xmlp = find_section(section::ddr_files_xml_gsan);
    }

    if(xmlp.isnull()) {
        xmlp = find_section(section::ddr_files_xml_ddr);
    }

    return xmlp;
}


ddrfiles_xmlp exportstream_xml::get_ddrfiles_xmlp(const ddrfilesxml_search from) const
{
    xml_messagep xmlp(get_xmlp(from));

    ddrfiles_xmlp ret;
    if(!xmlp.isnull() && xmlp->children.size() > 0 && !xmlp->children[0].isnull()) {
        
        ret = new ddrfiles_xml();

        
        if(!ret->loadXmlBackupFileList(xmlp->children[0]->fimage())) {
            ret = 0;
        }
    }

    return ret;
}




emd_elementp exportstream_xml::get_containerid_emdp(const ddrfilesxml_search from, const location::tcontainerid containerid) 
{
    emd_elementp retemdp;

    ddrfiles_xmlp ddrfilesxmlp(get_ddrfiles_xmlp(from));
    if(!ddrfilesxmlp.isnull()) {
        retemdp = ddrfilesxmlp->queryEmd(containerid);
    }

    return retemdp;
}





#define HERMOSA_RELEASE  "7.0.100"
#define BUILD_SUPPORTED  HERMOSA_RELEASE "-336"
#define BUILDONE "-1"


const bool exportstream_xml::is_backup_supported() const
{
    
    ustring versionstr;
    int ddrindex;
    if(get_backup_version_and_ddrindex(versionstr, ddrindex)) {
        ustring release;
        ustring rest;
        versionstr.split(release, rest, true, '-');

        
        const tversion relversion(release + ustring(BUILDONE));
        const tversion hermosa_release(ustring(HERMOSA_RELEASE BUILDONE));
        if(relversion.isvalid() && hermosa_release.isvalid() && relversion == hermosa_release) {
            const tversion version(versionstr);
            
            const bool ret(((ddrindex <= 0) || !version.isvalid() || (tversion(BUILD_SUPPORTED) < version)));

            if(!ret) {
                Out->msg(WARN, "Reference to backup created with Avamar version '%s'", *version.image());
            }

            return ret;
        }
    }

    
    return true;
}


const bool exportstream_xml::is_backup_indio_or_greater() const
{
    
    ustring versionstr;
    int ddrindex;
    if(get_backup_version_and_ddrindex(versionstr, ddrindex)) {
        const tversion version(versionstr);
        return version.isvalid() && tversion(tversion::release_verstr(tversion::indio_client))< version;
    }

    return false;
}


const bool exportstream_xml::is_backup_equal_or_newer_to(const tversion::release_ver rel_version) const
{
    bool ret(false);

    if(valid()) {
        xml_messagep backupsectp(find_section(section::archive_info));
        const ustring attrname(attr2ustr(attr::appversion));
        
        if(backupsectp.isnull() || !backupsectp->defined(attrname)) {
            
            backupsectp = find_section(section::backup);
        }

        if(!backupsectp.isnull() && backupsectp->defined(attrname)) {
            const ustring versionstr(backupsectp->getstring(attrname));
            DB->msg("exportstream_xml::is_backup_equal_or_newer_to() - backup was created by client version %s", *versionstr);
            const tversion version(versionstr);
            if(!version.isvalid()) {
                Out->msg(WARN, "Backup created by Avamar version \"%s\"is invalid.", *versionstr);
                return false;
            }
            const tversion release_base(tversion::release_verstr(rel_version));
            ret = release_base < version;
            if(!ret) {
                Out->msg(WARN, "Backup created with Avamar version '%s' is older than %s", *version.image(), *release_base.image());
            }
        }
    }

    return ret;
}






















#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backisilontardir.h"
#include "parsestream_base.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "isilontar_history.h"
#include "dirrec_pack.h"
#include "filenames.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "ndmp_volume_entification.h"
#include "isilontarstream.h"
#include "backdirstreamslice.h"
#include "utar_ctl_sup.h"

#include <algorithm>





#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define verbosealternative ((xflag[1]&16384)!=0) 








backisilontardir::backisilontardir(BackCycle* parent_, workelem* info_,
                                   parsestream_base* parser_, int traverse_depth_,
                                   inode_table& inodetab_,
                                   int mount_point_numelems_,
                                   isilontar_history* hist,
                                   MetadataIntf_sp parent_metadataIntfp_)
    : backndmptardir_base(parent_, info_, parser_, traverse_depth_,
                          inodetab_, mount_point_numelems_, parent_metadataIntfp_),
                          histlist(NULL), 
                          histsrv(hist)
{
    if(msg1) DB->msg("backisilontardir::backisilontardir (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    inode_is_64_bits = true;

    
    if (traverse_depth == 0) {
        if (!flags.ndmp_history_pipe_name.isempty()) {
            
            assert(histsrv == 0);
            histsrv = new isilontar_history(parent->main, upath(flags.ndmp_history_pipe_name),
                                            upath(flags.save_ndmp_history));
            DB->msg("backisilontardir::backisilontardir() started isilontar_history");
            DB->msg("backisilontardir::backisilontardir() ndmp_history_pipe_name=%s, save_ndmp_history=%s",
                    *flags.ndmp_history_pipe_name, *flags.save_ndmp_history);
        }

        if (info->use_container) {
            
            determine_volume_offset();
        }
    }

    
    
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);

    
    
    if (info->use_container && info->direlemp->is_directory()) {
        
        
        
        add_directory_to_container();
    }

    
    
    
    
    if (catalog_enabled && info->direlemp->is_directory()) {
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'", *info->direlemp->fullpath().image());
            return;
        }
    }

    if (info->direlemp->is_directory()) {
        process_dir_data(info->direlemp);
    }
}

backisilontardir::~backisilontardir()
{
    if(msg1) DB->msg("backisilontardir::~backisilontardir "
                           "(parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    subtract_from_direlem_commitment(cycle_direlem_commitment);

    if (traverse_depth == 0 && histsrv != NULL) {
        
        delete histsrv;
    }
}







void backisilontardir::init()
{
    if (!flags.incremental && throttle_child_spawning()) {
        
        
        
        
        insert_self(info->direlemp);
        return;
    }

    static int count = 0;
    ++count;
    if(msg1 || (count%1000) == 0)
         DB->msg("backisilontardir::init cnt=%d (parent:%p) (this:%p), depth=%d info->direlemp:%s",
                 count, parent, this, traverse_depth, *info->direlemp->fullpath().image());

    if (phase != phase_init) {
        
        

        if (info->use_container && !save_obj_direlem->is_directory()) {
            
            
            

            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->endfile(save_obj_direlem.getimpl(), 0)) != ucontainer::pce__success) {
                Out->Abort("backisilontardir::init: Problem calling endfile for %s (%s)",
                        *save_obj_direlem->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            } else if (flags.incremental) {
                location loc(save_obj_direlem->get_location());

                
                
                
                
                
                
                if (cur_synthlist_coversize == 0) {
                    cur_synthlist_offset = loc.get_abs_offset_in_container();
                    if (msg2) DB->msg("backisilontardir::init: Reset cur_synthlist_offset to abs_offset_in_container (offset:%"LL"d)",
                                      cur_synthlist_offset.value());
                }

                
                
                
                
                if ((save_obj_direlem->hard_links() > 1) && !save_obj_direlem->is_tar_hardlink()) {
                    
                    
                    add_files_to_synth_list(&cur_synthlist);
                    
                    

                    
                    cur_synthlist.add_hardlink_data((ubigint64)save_obj_direlem->inode_number64());
                    assert ((cur_synthlist_coversize == 0) && (cur_synthlist_checksum == 0));  
                }

                
                
                
                
                
                cur_synthlist_coversize += loc.get_coverage_size();
                cur_synthlist_checksum ^= loc.get_checksum().value;  
                if (msg2) DB->msg("backisilontardir::init: cur_synthlist (offset:%"LL"d coversize:%"LL"d checksum:%u)",
                                  cur_synthlist_offset.value(), cur_synthlist_coversize.value(), cur_synthlist_checksum);
            }
        }
    }

    if (!get_next_header(save_obj_direlem, save_altdata, save_stubdata)) {
        
        
        

        
        
        
        
        if (info->use_container && (inodetab.current_container_location.get_containerid() == 0)) {
            save_location_template(info->direlemp->get_location(), false );
        }

        if (info->use_container && info->direlemp->is_directory() && !reserved_hiddendir) {
            
            
            

            if (flags.incremental) {
                
                add_files_to_synth_list(&cur_synthlist);
                
                
            }

            
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                Out->Abort("backisilontardir::init: Problem calling enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }

            if (msg2) DB->msg("DDR: backisilontardir::init DIR LOCATION %s is %s",
                           *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());

            if (flags.incremental) {
                
                
                
                
                
                
                
                
                
                
                if (!dir_header_added) {
                    
                    add_dir_header_to_synth_list(&cur_synthlist);
                    
                    
                }

                
                inode_table::data_block synth_item;
                
                location loc(info->direlemp->get_location());
                
                
                synth_item.block_begin = (ubigint64)(loc.get_abs_offset_in_container() + loc.get_coverage_size() - loc.get_footer_size()).value();
                synth_item.block_size = (bigint64)loc.get_footer_size().value();
                synth_item.block_checksum = loc.get_checksum().footer_value;
                cur_synthlist.add_item(synth_item);
                if (msg2) DB->msg("backisilontardir::init Added entry (footer for '%s') to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                                  *info->direlemp->name(), synth_item.block_begin, synth_item.block_size, (ubigint64)cur_synthlist.list_size());
            }
        }  
        return;
    }

    set_phase(phase_read_data);
    process_direlem(save_obj_direlem, save_altdata, save_stubdata);

    
    
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);
}




bool backisilontardir::get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata)
{
    
    altdata  = fileref::empty;
    stubdata = fileref::empty;

    bool pushed_entry = parser->has_pushed_entry();
    bool get_entry_ret = parser->getentry(obj_direlem, altdata, stubdata);

    
    
    if (!get_entry_ret && !max_changed_date_msg_sent) {
        send_max_changed_date();
    }

    if (!get_entry_ret || obj_direlem.isnull()) {
        DB->msg("backisilontardir::get_next_header encountered end of stream inc?%d phase:%d empty_stream:%d, direlem.isnull():%d",
                flags.incremental, phase, parser->is_empty_stream(), obj_direlem.isnull());

        if (flags.incremental && phase == phase_init) {
            
            if (parser->is_empty_stream()) {
                const upath parent_path("");
                DB->msg("backisilontardir::get_next_header empty stream reading previous backup path for parent '%s'", *parent_path.image());
                
                location prev_loc(inodetab.base_container_location);
                prev_loc.set_abs_offset_in_container(0);

                
                
                
                
                
                
                
                prev_loc.set_containerid(0);
                prev_loc.set_enclosing_container(NULL);  

                cycle *child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, prev_loc, prevlist);
                child->noop();
                nforked++;
                forked_prev_restore = true;
            }
        }

        set_phase(phase_wait_for_history); 
        childdone(NULL);

        if ((NULL != histsrv) && (traverse_depth == 0))
            
            
            histsrv->data_stream_done(); 

        return false;
    }

    if (!set_new_direlem_path(obj_direlem, pushed_entry)) return false;

    const upath curpath(info->direlemp->fullpath());
    const int cur_path_elems(curpath.numelems()); 
    const upath newpath(obj_direlem->fullpath());
    const int new_path_elems(newpath.numelems());    

    if(msg2)
        DB->msg("backisilontardir::get_next_header cur_path_elems:%d(%s)[0]='%s' "
                      "new_path_elems:%d(%s)[0]='%s' curroffset:%s",
                cur_path_elems, *curpath.image(), *curpath.get(0),
                new_path_elems, *newpath.image(), *newpath.get(0),
                *parser->get_headeroffset().image());

    if (new_path_elems <= cur_path_elems) {
        
        
        if (msg2)DB->msg("backisilontardir::get_next_header exiting2 because path is in parent (%d <= %d) '%s'",
                         new_path_elems, cur_path_elems, *obj_direlem->fullpath().image());

        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_wait_for_history); 
        childdone(NULL);
        return false;
    }

    
    
    
    
    
    if (new_path_elems > cur_path_elems+1) {
        
        
        
        
        if (msg1)
        {
            DB->msg("backisilontardir::get_next_header big step '%s' vs '%s' new_path_elems:%d cur_path_elems+1:%d",
                        *curpath.image(), *newpath.image(), new_path_elems, cur_path_elems+1);
        }

        assert(obj_direlem->is_directory()); 

        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        

        
        altdata = fileref::empty;
        assert(stubdata.isnull());

        
        obj_direlem->set_security(fileref::empty);

        
        obj_direlem->set_fullpath(newpath.slice(0, cur_path_elems));
        obj_direlem->set_name(obj_direlem->fullpath().stripdir());
        obj_direlem->set_is_root();  
        if (msg1)DB->msg("backisilontardir::get_next_header big step new path '%s' name '%s'",
                         *obj_direlem->fullpath().image(), *obj_direlem->name());
    }

    if (msg2)DB->msg("backisilontardir::get_next_header returns obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                     *obj_direlem->fullpath().image(), *obj_direlem->file_size().image(), *altdata.size64().image(),
                     *stubdata.size64().image());

    return true;
}



bool backisilontardir::set_new_direlem_path(DIRELEMp& obj_direlem, bool pushed_entry)
{
    
    
    if (!flags.ndmp_prefix.isempty() &&
        !pushed_entry) 
    {
        upath collapsed_path;
        upath ndmp_prefix_path(flags.ndmp_prefix);

        if (traverse_depth == 0)
        {
            
            
            
            
            mount_point_numelems = obj_direlem->fullpath().numelems();

            DB->msg("Mount-point (top-level) directory is: %s", *obj_direlem->fullpath().image());
            collapsed_path = ndmp_prefix_path;
            dirrec_pack::ndmp_volume vpath(obj_direlem.getimpl());
            vpath.set(ndmp_unentify_volume(flags.ndmp_prefix));
        }
        else
        {
            upath current_path(obj_direlem->fullpath());
            if (current_path.numelems() < mount_point_numelems)
            {
                
                Out->msg(FATAL, "<9978>Path %s goes below mount point, exiting.", *current_path.image());
                uapp::staging().startTermination(EXIT_MISC, "path goes below mount point (in set_new_direlem_path)");
                set_phase(phase_wait_for_history);
                childdone(NULL);
                return false;
            }

            
            
            collapsed_path = ndmp_prefix_path / current_path;
            if (msg2) DB->msg("backisilontardir::get_next_header: traverse_depth=%d, mount_point_numelems=%d, collapsed_path='%s'",
                              traverse_depth, mount_point_numelems, collapsed_path.image().tostr());
        }

        if (msg2) DB->msg("Collapsing path %s -> %s", *obj_direlem->fullpath().image(), collapsed_path.image().tostr());
        obj_direlem->set_fullpath(collapsed_path);
        obj_direlem->set_name(collapsed_path.stripdir());
    }
    return true;
}

void backisilontardir::process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata) {

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                *obj_direlem->name(), obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                 *obj_direlem->name(), obj_direlem->file_size().dvalue());

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)
        DB->msg("backisilontardir::process_direlem obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                *stubdata.size64().image());

    fileoffset patchoffset = 1;  

    
    
    if (flags.incremental) {
        bool added = curlist.split_enter_if_undef(obj_direlem->inode_number64(), obj_direlem->name(), obj_direlem);
        if (!added) {
            Out->msg(ERR, "While processing %s (inode %lu) found a second entry with inode '%lu' and name '%s'",
                     *info->direlemp->fullpath().image(), info->direlemp->inode_number64(),
                     obj_direlem->inode_number64(), *obj_direlem->name());
        }
    }

    
    ordered_curlist.push_back(obj_direlem);

    if(msg2)
        DB->msg("backisilontardir::process_direlem: Added to ordered_curlist('%s', '%s')",
                *obj_direlem->name(), *obj_direlem->fullpath().image());

    
    
    if (info->use_container && !dir_header_added && flags.incremental && info->direlemp->is_directory()) {
        
        
        
        add_dir_header_to_synth_list(&cur_synthlist);
        
        
    }

    
    
    if (info->use_container && !obj_direlem->is_directory()) {
        
        

        ucontainer::errortype errcode;

        if ((errcode = info->container->beginfile(obj_direlem.getimpl(), datasize, 1 )) != ucontainer::pce__success) {
            Out->Abort("backisilontardir::process_direlem: Problem calling beginfile for %s (%s)",
                    *obj_direlem->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        } else {
            if (msg2) DB->msg("DDR: backisilontardir::process_direlem: abs_offset_in_container: %"LL"d beginfile for file %s",
                              obj_direlem->get_location().get_abs_offset_in_container().value(),
                              *obj_direlem->fullpath().image());
        }
    }

    if(obj_direlem->is_directory()) {
        
        child_dir_count++;
        
        

        
        
        if (info->use_container && flags.incremental) {
            
            add_files_to_synth_list(&cur_synthlist);
            
            

            
            if (msg2) DB->msg("backisilontardir::process_direlem: Adding directory '%s' to cur_synthlist within '%s'",
                              *obj_direlem->name(), *info->direlemp->name());
            cur_synthlist.add_dir((ubigint64)obj_direlem->inode_number64());
        }

        
        
        if (msg2) DB->msg("backisilontardir::process_direlem subdir for %s", *obj_direlem->fullpath().image());
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        backisilontardir *subdir = new backisilontardir(this, w, parser, traverse_depth+1,
                                                        inodetab, mount_point_numelems, histsrv,
                                                        my_metadataIntfp);
        subdir->noop();
        nforked++;

    } else if (obj_direlem->is_symlink() && datasize == 0) {
        
        
        fileref link = parser->get_symlink_data();
        assert(!link.isnull());
        datasize = link.size();
        obj_direlem->set_file_size(datasize);

        if (msg2)DB->msg("Handling inline symlink, size=%d", datasize.ivalue());
        workelem *w = new workelem( info, link );
        cycle *linkchild = new nbackdata(this, w, patchoffset, false , 0, info->use_container );
        linkchild->noop();
        nforked++;

    } else { 
        
        obj_direlem->set_stdin();       

        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        if (obj_direlem->is_tar_hardlink()) {
            if (msg2)
                DB->msg("backisilontardir::process_direlem this:%p obj_direlem:%s is_tar_hardlink:1",
                        this, *obj_direlem->fullpath().image());
            
            
            
            
            
            w->hold_data = true;
        }

        nbackdata *cycle_chunk = new nbackdata( this, w, patchoffset, false, parser, info->use_container );
        cycle_chunk->noop();
        nforked++;
        size += datasize;
    }

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    if(msg2)DB->msg("backisilontardir::process_direlem DONE obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                    *stubdata.size64().image());
}


void backisilontardir::process_dir_data(DIRELEMp obj_direlem)
{
    isilontarstream::parser *ets_parser = dynamic_cast<isilontarstream::parser*>(parser);

    workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem, filestatsref());
    cycle *child = new backdirstreamslice(this, w, obj_direlem, ets_parser, info->use_container);
    child->noop();
    nforked++;
}


void backisilontardir::childdone(cycle* child)
{
    if(msg1) DB->msg("backisilontardir::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d",
                     parent, this, child, nforked, ncollected);

    if (child) {
        ncollected++;

        switch (phase) {
        case phase_init:
            return;

        case phase_read_data:
        case phase_wait_for_history:
            
            
        case phase_wait_for_children:
            
            
        case phase_forksdone:
            
            
            
            if (child == data_hasher_child) {
                
                main->safesetactivelimit(TODO_MAX, "return from prevlist", true);
                break; 
            }
            
        case phase_do_hidden: {
            
            
            
            
            
            backisilontardir *dc_dir = dynamic_cast<backisilontardir *>(child);
            if (dc_dir != NULL) {
                
                

                
                child_dir_count--;
                
                

                DIRELEMp de(dc_dir->getInfo()->direlemp);
                if (info->use_container) {
                    
                    
                    ubigint64 child_inode(de->inode_number64());

                    
                    
                    childlist.add_child(child_inode);
                    if (msg2) DB->msg("backisilontardir::childdone: Added inode %"LL"d to child_dir_list. List size=%"LL"d",
                                      child_inode, (ubigint64)childlist.list_size());

                    if (flags.incremental) {
                        
                        
                        merged_coverage_size += dc_dir->merged_coverage_size;
                        if (msg2) DB->msg("backisilontardir::childdone  Updated merged_coverage_size for %s to:%"LL"d (added %"LL"d from child dir)",
                                          *info->direlemp->name(), (bigint64)merged_coverage_size.value(), (bigint64)dc_dir->merged_coverage_size.value());

                        
                        
                        merged_checksum ^= dc_dir->merged_checksum;
                        if (msg2) DB->msg("backisilontardir::childdone  Updated merged_checksum for %s to:%u (included %u from previous backup)",
                                          *info->direlemp->name(), merged_checksum, dc_dir->merged_checksum);
                    }
                } else {
                    
                }

                
                
                if (catalog_enabled) {
                    MetadataIntf_sp metadatap = dc_dir->my_metadataIntfp;
                    direlemp2metadatap.insert(std::make_pair(de.getimpl(), metadatap));
                    if (msg2) DB->msg("backemctardir7::childdone: Added child dir '%s' to metadata map (de.getimpl=%p, metadatap=%p, map_size=%d)",
                                      *de->name(), de.getimpl(), metadatap.get(), (int)direlemp2metadatap.size());
                }
            }

            
            
            nbackdata *dc_file = dynamic_cast<nbackdata *>(child);
            if (dc_file && dc_file->get_depkind() == none) {
                DIRELEMp de(dc_file->getInfo()->direlemp);
                remember_hardlinked_info(de);
            }
            break;
        }
        case phase_done: {
            commit_directory_metadata();
            notifyparent();
            
            
            return;
        }
        default:
            assert(false);
        }
    }

    if(msg1) DB->msg("backisilontardir::childdone this:%p phase:%d forked_prev_restore:%d nforked=%d ncollected=%d",
                     this, phase, forked_prev_restore, nforked, ncollected);

    if ((phase == phase_wait_for_history) || (phase == phase_wait_for_children)) {
        process_wait_phases(histlist ? static_cast<const int> (histlist->size()) : 0);
    } 

    if ((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)) {
        if (flags.incremental) {
            
            
            
            process_forksdone_phase_part1(&cur_synthlist, &prev_synthlist);
        }

        
        
        
        
        if (catalog_enabled) {
            
            
            
            if (!add_children_to_metastore()) {
                Out->Abort("Problem adding children to the Metadata store for directory '%s'", *info->direlemp->fullpath().image());
                return;
            }
        }

        
        
        
        
        
        process_forksdone_phase_part2(child, &cur_synthlist, &prev_synthlist);
    } 

    
    if ((phase == phase_do_hidden) && (ncollected == nforked)) {
        process_do_hidden_phase();
    }
}







void backisilontardir::remember_hardlinked_info(DIRELEMp &de)
{
    if (msg2)
        DB->msg("backisilontardir::remember_hardlinked_info for %s", *info->direlemp->fullpath().image());

    if (de->is_directory() || (de->hard_links()<2) || de->is_tar_hardlink()) {
        if (msg2) DB->msg("backisilontardir::remember_hardlinked_info ignoring dir:%d nlink:%u hl:%d inode:%lu %s",
                          de->is_directory(), de->hard_links(), de->is_tar_hardlink(), de->inode_number64(), *de->fullpath().image());
        return;
    }

    
    
    if (msg2)
        DB->msg("backisilontardir::remember_hardlinked_info inode:%lu nlink:%d %s",
                de->inode_number64(), de->hard_links(), *de->fullpath().image());

    
    
    
    
    const MetadataId metadataid(de->file_hash());
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false,
                           de->get_location().get_abs_offset_in_container().value());

        
        childlist.add_child(de->inode_number64());
        if (msg2) DB->msg("backisilontardir::remember_hardlinked_info: Added inode %"LL"d to child_dir_list. List size=%"LL"d",
                          de->inode_number64(), (ubigint64)childlist.list_size());
        
        
    } else {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false);
    }
}









void backisilontardir::request_prevlist()
{
    forked_prev_restore = true; 

    if (!flags.incremental)
        return;

    if (flags.noinodetable)
        return;

    ndmp_inode64_t de_inode = info->direlemp->inode_number64();
    MetadataId metadataid;
    fileoffset size;
    bool wasdir = false;
    ubigint64 dir_offset;
    upath path("");

    if (!inodetab.find_entry(de_inode, metadataid, size, wasdir, dir_offset)) {
        if (msg2)
            DB->msg("backisilontardir::request_prevlist for '%s' no entry in inode_table for inode:%"LL"u",
                    *info->direlemp->fullpath().image(), de_inode);

        upath topdirpath = upath(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), true);

        if (topdirpath.image() == flags.ndmp_prefix) {
            
            
            
            wasdir = true;
            metadataid = main->prev_backup.getRootLocation().getMetadataId();
            if (msg2) DB->msg("backemctardir7::request_prevlist: Retrieved MetadataId '%s' for previous backup", *metadataid.partialimage());
            dir_offset = 0;
            path = topdirpath;
        } else {
            if (msg1)
                DB->msg("backisilontardir::request_prevlist for '%s' inodetab.find_entry(%"LL"u) returned false",
                              *info->direlemp->fullpath().image(), de_inode);
            return;
        }
    }

    if (!wasdir) {
        if (msg1) DB->msg("backisilontardir::request_prevlist entry in inode_table for inode:%"LL"u was not a directory", de_inode);
        return;
    }

    if(msg1)
        DB->msg("backisilontardir::request_prevlist for '%s' starting restdirlist using MetadataId:%s diroffset:%"LL"u path:%s",
                *info->direlemp->fullpath().image(), *metadataid.partialimage(), dir_offset, *path.image());

    
    location prev_loc(inodetab.base_container_location);
    prev_loc.set_abs_offset_in_container(dir_offset);

    
    
    
    
    
    
    
    if (reserved_hiddendir) {
        prev_loc.set_containerid(0);
        prev_loc.set_enclosing_container(NULL);  
    }

    const location dirloc(main->prev_backup.getMedialoc(), metadataid);
    cycle *child = new restdirlist(this, dirloc, path, prev_loc, prevlist);
    child->noop();
    nforked++;
    forked_prev_restore = true;
}




void backisilontardir::response(message& outargs)
{
    if(msg2)
        DB->msg("backisilontardir::response (parent:%p) (this:%p)", parent, this);
    ncollected++;
    msgpack_c::getndmphistlist64 thl(outargs);
    bool existed;
    ubigint64 histlistptr;
    thl.res(UNPACK, existed, histlistptr);
    if (msg2) DB->msg("backisilontardir::response unpacked result: existed:%d histlistptr:%p",
                      existed, (void*)histlistptr);

    if (existed) {
        
        histlist = (histvector_t *)histlistptr;
        foundhistory = true;
        if (msg2) {
            DB->msg("backisilontardir::response DEBUG DUMP histlist:%p with %"Z"u entries",
                    histlist, histlist->size());
            for (histvector_t::const_iterator i = histlist->begin(); i!=histlist->end(); i++) {
                DB->msg("    name:'%s' inode:%lu", *((*i).key_string), (*i).key_number);
            }
        }
    } else {
        histlist = NULL;
        foundhistory = false;
        DB->msg("backisilontardir::response unable to find history for inode '%s'", *tostr(info->direlemp->inode_number64()));
    }
    childdone(NULL);  
}



bool backisilontardir::merge_lists()
{
    if (msg1) {
        DB->msg("backisilontardir::merge_lists directory %s (inode %s), prevlist.size():%u curlist.size():%u histlist.size():%"Z"u",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
                prevlist.size(), curlist.size(), (foundhistory ? histlist->size() : 0));
    }

    
    
    removesnapviewvolumes(flags.ndmp_prefix);

    if (parser->is_empty_stream()) {
        copy_previous_backup(&prev_synthlist, &childlist);
        return true;
    }

    
    if (!foundhistory) return false;

    
    if (msg2) {
        DB->msg("backisilontardir::merge_lists for directory %s inode:%s",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()));
        debug_print_direlemp_list(curlist, "curlist", msg2);
        debug_print_direlemp_list(prevlist, "prevlist", msg2);
    }

    
    
    
    histvector_t::const_iterator hi;
    for (hi = histlist->begin(); hi != histlist->end(); hi++) {
        csustring name((*hi).key_string);
        uint64_t inum((*hi).key_number);

        
        
        
        if ((name == ".") || (name == ".."))
            continue;

        if (msg2) DB->msg("backisilontardir::merge_lists processing histlist item '%s' -> %"LL"u",
                          *name, inum);

        DIRELEMp curDE;
        DIRELEMp prevDE;

        if (curlist.lookup(*hi, curDE)) {
            
            assert(name.equal(curDE->name()));
            update_stats_counts(curDE);

        } else if (prevlist.lookup(*hi, prevDE)) {
            
            assert(name.equal(prevDE->name()));

        } else if (flags.ignore_isilon_case_errors && prevlist.lookup(*hi, prevDE, false)) {
            
            assert((ustring)name == prevDE->name());
            
            
            
            
            Out->msg(WARN, "While processing %s (inode %s), NDMP file history messages "
                     "indicate the presence of a directory entry (inode:%s name:%s) that "
                     "doesn't appear in the data stream or in our previous backup of this directory.",
                     *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
                     *tostr(inum), *name);

        } else {
            
            Out->msg(ERR, "<9982>While processing %s (inode %s), NDMP file history messages "
                     "indicate the presence of a directory entry (inode:%s name:%s) that "
                     "doesn't appear in the data stream or in our previous backup of this directory.",
                     *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
                     *tostr(inum), *name);
            continue;
        }

        if (!prevDE.isnull()) {
            
            
            main->getstatsobj(context::backupstats)->mergeprogress(prevDE);

            
            
            if (info->use_container) {
                
                
                
                add_to_prev_synth_list(prevDE, &prev_synthlist, &childlist);
            }

            
            ordered_prevlist.push_back(prevDE);
        }
    }

    delete histlist;
    histlist = NULL;

    return true;
}


void backisilontardir::request_history()
{
    
    
    if (!histsrv) return; 

    assert(phase == phase_wait_for_history);

    
    if (historyrequests++) {
        DB->warn("backisilontardir::request_history %p request count %d, not requesting again!", this, historyrequests);
        return;
    }

    message m;
    msgpack_c::getndmphistlist64 thl(m);
    assert(info->direlemp->inode_number64() != 0);
    ndmp_inode64_t inode_arg = info->direlemp->inode_number64();
    thl.arg(PACK, inode_arg);
    nforked++;
    if(msg1)
        DB->msg("backisilontardir::request_history_new requesting history (GETNDMPISILONHISTLIST) for inode:'%s'(%s) nforked:%d ncollected:%d phase:%d forked_prev_restore:%d",
                *tostr(info->direlemp->inode_number64()), *info->direlemp->fullpath().image(), nforked, ncollected, phase, forked_prev_restore);
    histsrv->send(this, m);
}

void backisilontardir::finish_top_level_directory(cycle *child)
{
    
    
    
    
    if (info->use_container && info->direlemp->is_directory() && reserved_hiddendir) {
        if (!flags.incremental) {
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                Out->Abort("Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }
        } else {
            
            
            
            
            

            
            
            
            
            
            fileoffset system_info_dir_size;
            DIRELEMp tmpde(curlist.split_lookup(0, UNDOO_DIRECTORY_NAME));
            if (tmpde.isnull()) {
                Out->msg(ERR,"Could not find .system_info in curlist.");
            } else {
                
                system_info_dir_size = tmpde->get_location().get_coverage_size();
                if (msg2) DB->msg("backisilontardir::finish_top_level_directory  Coverage size for .system_info directory is %"LL"d",
                                  (ubigint64)system_info_dir_size.value());
            }

            
            
            ubigint64 inode_number = 0;
            ubigint64 dir_header_size = 0;
            if (msg2) DB->msg("backisilontardir::finish_top_level_directory    Synth footer from current container (Offset:%"LL"d  Size:%"LL"d  Checksum:%u)",
                              top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum);
            synth_block(top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum, inode_number, dir_header_size, false );

            
            
            
            
            
            location loc(info->direlemp->get_location());
            loc.set_coverage_size(loc.get_coverage_size() + (merged_coverage_size + system_info_dir_size));
            info->direlemp->set_location(loc);
            if (msg2) DB->msg("backisilontardir::finish_top_level_directory  Coverage size for %s increased by (%"LL"d+%"LL"d) (now %"LL"d)",
                              *info->direlemp->name(), (ubigint64)merged_coverage_size.value(),
                               (ubigint64)system_info_dir_size.value(),(bigint64)loc.get_coverage_size().value());
        }
    }

    
    
    
    
    
    if (copy_entire_previous_backup) {
        
        
        assert(!info->direlemp->is_directory());  
        assert(cur_synthlist.list_size() == 0);

        
        
        synth_volume_data(child, &cur_synthlist, &prev_synthlist);
    }

    if (info && info->use_container && !info->container.isnull()) {
        bool write_ddrfile = parser->is_empty_stream();
        main->finalizeucontainer(info->container, write_ddrfile);
    }
}

void backisilontardir::commit_directory_metadata()
{
    assert(ncollected == nforked);
    
    
    info->direlemp->set_hash(hash);

    
    
    
    
    check_dirlisting_limit(flags);
    static const fileoffset dirsizelimit(flags.dirlisting_limit);
    if ((dirsizelimit > 0) && (consumed_size > dirsizelimit)) {
        double avgsize = (dirlistcount > 0) ? (consumed_size.dvalue() / double(dirlistcount)) : 0;
        Out->msg(INFO, "<10675>Directory data consumes %s bytes for %"Z"d entries, average storage used per directory entry is %lf bytes",
                 *consumed_size.image(), dirlistcount, avgsize);
        Out->msg(INFO, "<10676>Please reduce the size of this directory to allow future incremental backups.  See Avamar NDMP documentation for further details.");
    }

    
    const ubigint64 de_inode(info->direlemp->inode_number64());
    
    
    
    
    const MetadataId metadataid(hash);
    
    
    
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory(),
                           (info->direlemp->get_location().get_abs_offset_in_container() + info->direlemp->get_location().get_header_size()).value(),
                           &childlist, &cur_synthlist, &prev_synthlist);
    } else {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory());
    }

    
    
    
    if (!info->direlemp->is_dirrec_present(KIND_EXTRA_DIR_SIZES) && info->direlemp->is_directory()) {
        if (msg1) DB->msg("backisilontardir::commit_directory_metadata  Creating EXTRA_DIR_SIZES dirrec for empty directory '%s'", *info->direlemp->name());
        info->direlemp->increment_dirsizes(0, 0, 0);
    }

    
    
    
    if (info->use_container && flags.incremental && info->direlemp->is_directory()) {
        location loc(info->direlemp->get_location());
        loc.set_checksum_value(loc.get_checksum().value ^ merged_checksum);
        info->direlemp->set_location(loc);
        if (msg2) DB->msg("backisilontardir::commit_directory_metadata  Checksum for %s modified to %u (included %u from previous backup)",
                          *info->direlemp->name(), loc.get_checksum().value, merged_checksum);
    }
}

#if !defined(UTAR_COMMANDS_H_INCLUDED)
#define UTAR_COMMANDS_H_INCLUDED















#include "context.h"
#include "synccall.h"
#include "blktraj.h"
#include "authid.h"
#include "hashcode.h"
#include "ustring.h"
#include "roothashlist.h"
#include "infofile_info.h"
#include "dpnobject.h"
#include "direlem.h"
#include "hfs_info_struct.h"
#include "utar_flags_enums.h"
#include "ddrfiles_xml.h" 
#include "ucontainer_base.h"
#include "list_archive.h"

class    fileoffset;
class    xml_mesasgep;
class    utar_flags_info;
class    restroot;



class utar_commands;
class BackupRootInfo;
class BackupRootInfoList;


class path2direlemp_table {
public:
    path2direlemp_table() {}
    ~path2direlemp_table() {}

    
    const bool add_table_entry(const upath& path, const DIRELEMp &dep);

    
    inline const size_t table_size() const { return path_table.size(); }

    
    
    
    const bool lookup(const upath &lookup_path, DIRELEMp &dep) const;

    
    
    
    
    
    const bool convert_path_to_key(const upath &lookup_path, upath &key_path) const;

    
    
    
    
    struct subpath_comp {
        bool operator() (const upath& p1, const upath& p2) const
        {
            int n1 = p1.numelems();
            int n2 = p2.numelems();
            ustring str1, str2;
            int num = (n1 < n2) ? n1 : n2;
            int i = 0;
            for (; i < num; i++) {
                str1 = p1.get(i);
                str2 = p2.get(i);
                if (!str1.equal(str2)) break;
            }

            
            
            if ((i == num) && (n1 < n2)) return true;
            return str1 < str2;
        }
    };

private:
    
    
    
    #if SYSTEM_WINDOWS
      typedef std::map<upath, DIRELEMp, subpath_comp > path2direlemp_table_t;
    #else
      typedef std::map<upath, DIRELEMp, subpath_comp, stlsafepoolallocator<std::pair<upath const, DIRELEMp > > > path2direlemp_table_t;
    #endif
    typedef path2direlemp_table_t::const_iterator const_path2direlemp_table_itr;
    typedef path2direlemp_table_t::iterator path2direlemp_table_itr;

    path2direlemp_table(const path2direlemp_table&);

    path2direlemp_table_t path_table;
};

#define MAXLEVS 10

class utar_commands {
 public:
    SAFEALLOC(utar_commands);
    friend class client_commands;
    friend class list_archive;
    friend class list_archive::outputsink;
    friend class list_archive::xmloutputsink;
    friend class list_archive::stdoutputsink;
    friend class list_archive::cacherebuildsink;
    friend class nbackroot;
    friend class backupboost::backupboostutils;

    utar_commands(utar_flags_info& flags, hfs_info_struct& hfs_info_,
                  utar_flags_info& dstflags);

      
    utar_commands(utar_flags_info& flags, hfs_info_struct& hfs_info_,
                  utar_flags_info& dstflags,
                  ctl_messagep requestp, ctl_queuep responseq);

    virtual ~utar_commands() {};

      
    virtual exitcodes_t do_command();

      
    virtual exitcodes_t do_restore();

      
    virtual exitcodes_t do_archives(bool query_only = false, bool output_list = true);

      
    virtual exitcodes_t do_delete();

      
    virtual exitcodes_t do_history();

      
    static exitcodes_t do_browse(utar_flags_info& flags);

      
    static exitcodes_t do_backupboost_browse(utar_flags_info& flags);

    static exitcodes_t do_backupboost_journal_cleanup(utar_flags_info& flags, context* main);

      
      
    bool pick_backup(BackupRootInfo& chosenBackup, bool get_oldest = false, BackupRootInfoList* listp = NULL) const;


    
    
    xml_messagep backuprootinfo_to_xml(const BackupRootInfo& backupInfo, const bool for_exportstream = false);

    
    
    void display_snapup_info(const BackupRootInfo& backupInfo, bool check_info);

    
    
    
    void display_snapup_version_info(const BackupRootInfo& backupInfo) const;

    static bool mkdir_full(const utar_flags_info& flags, ustring path); 

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    static bool get_direlem(const hfs_info_struct& hfs_info, const utar_flags_info& flags,
                             const location& search_start_loc, const upath& lookfor, DIRELEM& searchresult, ustring& errdesc,
                             const upath& assign_fullpath=upath(""), const bool ignorecase=false, const bool force_gsan_metaloc=false);

    
    
    
    
    
    
    bool get_direlem(const location& search_start_loc, const upath& lookfor, DIRELEM& searchresult, ustring& errdesc,
                      const upath& assign_fullpath=upath(""), const bool ignorecase=false, const bool force_gsan_metaloc=false) const;

    
    
    
    
    
    
    
    
    
    static DIRELEM::iterator get_direlem(DIRELEM::iterator searchiter, const upath& lookfor, upath& found_fullpath,
                                          ustring& errdesc, const utar_flags_info& flags, bool ignorecase=false, const DIRELEM& parentDE = DIRELEM());

    
    
    
    
    
    DIRELEM::iterator get_direlem(DIRELEM::iterator iter, const upath& lookfor, upath& found_fullpath,
                                   ustring& errdesc, bool ignorecase=false) const;

    
    bool list_hash_entries(const location& fromLoc, std::vector<ustring> &entries, ustring &errdesc) const;

    
    bool set_celerrai18n(const BackupRootInfo& prevBackup) { return get_infofile(prevBackup); }

    
    const bool get_ddrfiles_xml(const BackupRootInfo& backupInfo, const ustring& filename, fileref& data) const;

    
    hfs_info_struct& getHfsInfoStruct() { return(hfs_info); }

    
    bool restore_file(fileref& res, const DIRELEM* direlem, const fileoffset startoff=fileoffset(0), const fileoffset endoff=fileoffset(0), ucontainer::basep containerp = NULL) const;
    
    
    
    
    bool mkdirpath_checkwrite(const utar_flags_info& flags, ustring& path) const;

    static int check_write(const ustring& path);

    
    bool get_infofile(const BackupRootInfo& backupInfo);

    bool get_infofile_obj(const DIRELEM& de, infofile_info& infofile) const;

    
    bool get_work_results(const BackupRootInfo& backupInfo, backupboost::target_work_results& work_results);

    
    bool get_frompath(ustring& frompath);

    userid* get_uids() { return uids; }
    groupid* get_gids() { return gids; }
    pidtype get_currpid() { return currpid; }

    restroot* get_dirRestRoot(context* main = NULL);

    double get_infofile_size(){ return infofile.dsize; }

    bool get_starting_location(const upath &inode_search_path, location &starting_loc, DIRELEMp &dep, const hashcode &roothash) const;

    class dirlist {
    public:
      dirlist(DIRELEM &_de, dirlist* _prev) : preexisting(true) { de = _de; link = _prev; }
      DIRELEM de;
      bool preexisting;       
      dirlist *link;
      SAFEALLOC(dirlist);
    };
    typedef dirlist* dirlistp;

    
    bool finishRestore(const bool priorSuccess, dirlist* topdirs, const ustring& frompath) const;

    
    bool is_inode_dumpformat(const hashcode& roothash, const pidtype& pid);

    
    bool find_entified_name (const hashcode& roothash, const ustring& orig_path, ustring& ent_path, bool return_top=0);

    
    static bool gethashdata(fileref& data, const hashcode& hash_, chunktype& kind, const hfs_info_struct &hfs_info, ustring& errdesc);

    static path2direlemp_table netapp_direlemp_cache;

    
    
    static void set_netapp_browse(const bool netapp_browse_ = true) { netapp_browse = netapp_browse_; }
    static bool is_netapp_browse() { return netapp_browse; }

    
    static fileref migrateinfo_fr;
    static fileref workresults_fr;

    
    static int sysinfo_off;
    static double sysinfo_chunksize;

protected:
    utar_flags_info& flags;
    hfs_info_struct hfs_info;
    utar_flags_info& dstflags;

    
    ctl_messagep requestp;
    ctl_queuep responseq;

    bool outputxml;

    fileoffset totalsize; 

    userid *uids;
    groupid *gids;

    
    virtual exitcodes_t do_restore_work(const bool do_progress, backstate& state);

    exitcodes_t init_ddr();

    ADEMgrX* getAdeMgr() { return m_adeMgr; }


private:
    infofile_info  infofile;
    int  curentries; 

    restroot* dirRestRoot;

    ADEMgrX* m_adeMgr;

    
    
    static bool netapp_browse;

    static mtex sysinfo_file_mutex;

    static bool lookup_gsan_path(hashcode search_start_hash, const upath& lookfor, DIRELEM& searchresult,
                                 ustring& errdesc, const upath& assign_fullpath, const hfs_info_struct& hfs_info);

      
    bool get_file(const BackupRootInfo& backupInfo, fileref& data, const upath& path) const;

 public:
    
    bool get_sysinfo_file(const BackupRootInfo& backupInfo, fileref& data, const upath& path) const;

 private:
      
    bool get_hbeprofilepath(const BackupRootInfo& backupInfo, ustring& profile_path) const;

    
    
    
    bool get_view_override(client_config_flags::view_type vt, const BackupRootInfo& backupInfo, fileref& data) const;

      
    const fileref get_encodingsfile(const BackupRootInfo& backupInfo) const;

      
    const ustring get_backuptag(const BackupRootInfo& backupInfo) const;

      
    bool backuptag_match(const ustring& backuptag, const char aux1, const BackupRootInfo& backupInfo) const;

      
    bool get_backuplist(BackupRootInfoList& lst, bool include_partials, const int flags_count, const bool metadata_only = false) const;

    
    
    
    bool filter_backuplist(const BackupRootInfoList& inlist, BackupRootInfoList& outlist) const;

    
    bool filter_backuplist(const BackupRootInfoList& inlist, const ustring& label, const ustring& backuptag, const int labelnum, const SavesetId& savesetId, BackupRootInfoList& outlist) const;

      
      
    bool display_list(BackupRootInfoList& list);

    bool preload_ddrfiles_from_gsan(const BackupRootInfo& backupInfo);

      
      
    bool display_history(BackupRootInfoList& list);


      
    bool read_id_list(const ustring& filename, associd *list, const BackupRootInfo& backupInfo) const;

    
    bool get_inode_table(const BackupRootInfo& backupInfo);

      
    bool get_ids(const BackupRootInfo& backupInfo) const;

#if 0
      
    bool get_snapview_user_group_maps(const hashcode &roothash,
                                      tassoc<ustring, associd *> &uids_map, tassoc<ustring, associd *> &gids_map);
#endif

    static bool safemkdir(const upath& path, const bool inherit_permissions); 

    
    void display_snapup_info(const BackupRootInfo& backupInfo, const infofile_info& infofile, pidtype& pid_of_backup);

    
    void dpnobj_ls( dpnobj& obj, const ustring& fullpath, bool recurse = false, int indent = 0);
    ustring readlink(const dpnobj& obj, ubigint64 size);

    
    bool login_to_ddr(const BackupRootInfo& backupInfo, const tddrindex ddrIndexFromBackup, const location::tbackupid backupid);

    pidtype currpid;  

    ddrfiles_xmlp load_ddr_files(fileref ddrfilesxml);

    
    
    
    
    
    
    
    
    
    
    
    const ustring get_sysinfo_path(const ustring& called_from, const BackupRootInfo& backupInfo, const bool volume_specific_sysinfo = false, ustring prefix = "") const;

    
    
    const bool set_ndmp_prefix_for_catalog_backup(const ustring& called_from, const BackupRootInfo& backupInfo) const;

    
    
    bool get_metadata_backup(BackupRootInfo& metadata_rec) const;

    
    
    void verify_metadata_backups(BackupRootInfoList& lst) const;

};




#endif




















#include "common.h"
#include "debug.h"
#include "restdata.h"
#include "todoelem.h"
#include "context.h"
#include "chunktype.h"
#include "restcomp.h"
#include "msgpack_c.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "output.h"
#include "timer.h"
#include "runstage.h"
#include "tnodeid.h"
#include "tunivchunktype.h"
#include "restdir.h"
#include "chunker.h"
#ifdef USEADE
#include "ade_mgrx.h"
#endif
#include "backappend.h"
#include "compelem.h"
#include "MetadataStore.h"

#define msg1 ((xflag[1]&0x10)!=0) 
#define msg2 ((xflag[1]&0x20)!=0) 
#define cdsf_msg ((xflag[2]&1)!=0) 
#define msg3 ((xflag[11]&4)!=0)   
#define chgblkmsg      ((xflag[19]&4096)!=0)

#define use_comphints_x ((xflag[10]&262144)!=0) 



restdata::is_ourdata_sp restdata::default_is_ourdata_sp = is_ourdata_sp(new is_regdata());





restdata::restdata(cycle *parent,
                   const hashcode& hash_,
                   chunktype *ctypep,           
                   const bool expectatomic_,
                   const restelem& restinfo,
                   const fileoffset offset_,
                   const fileoffset size_,
                   cycle *starter,
                   const bigint64 prior_,
                   const fileref& comparedata_,
                   const int conn_,
                   backappend *root_file_cycle_, 
                   const bool use_container_,    
                   const is_ourdata_sp ourdata_sp_) 

  : cycle(parent),
    info(restinfo),  
    comparedata(comparedata_),
    expectatomic(expectatomic_),          
    fromcache(false),
    redocount(0),
    conn(conn_),
    prior(prior_),
    ctypep_to_return(ctypep),
    root_file_cycle( root_file_cycle_ ),
    use_container(use_container_),
    rest_chunker( NULL ),
    ourdata_sp(ourdata_sp_)
{
    contructorHelper (hash_, offset_, size_, starter);
}



restdata::restdata(cycle *parent,
                   const hashcode& hash_,
                   chunktype *ctypep,           
                   const bool expectatomic_,
                   const restelem& restinfo,
                   const bool use_container_,   
                   const is_ourdata_sp ourdata_sp_) 

  : cycle(parent),
    info(restinfo),  
    comparedata(fileref::empty),
    expectatomic(expectatomic_),          
    fromcache(false),
    redocount(0),
    conn(restinfo.dpninx),
    prior(0),
    ctypep_to_return(ctypep),
    root_file_cycle( NULL ),
    use_container(use_container_),
    rest_chunker( NULL ),
    ourdata_sp(ourdata_sp_)
{
    contructorHelper (hash_, fileoffset(0), fileoffset(-1), NULL);
}


void restdata::contructorHelper (const hashcode& hash_,
                                 const fileoffset offset_,
                                 const fileoffset size_,
                                 cycle *starter )
{
    

    this->hash = hash_;
    this->offset = offset_;
    this->size = size_;
    this->use_comphints = (main->getdpnmaxmessage(info.dpninx) >= GETHASHDATAHINTS
                           && (use_comphints_x));  

    if (msg1) DB->msg("restdata::constructorHelper location:%s", *info.direlem.get_location().image());

    if(starter)
        starter->setnext(TODO_CHUNK, this, prior);      
    else
        this->todoEnqueueInsert(TODO_CHUNK, this, prior);
}



bool restdata::checkcompressedhash(const fileref& data, const hashcode& hash) {
    if(! flags.compress)
        return false;
    fileref cdata = data;
    
    bool met_maxpercent;
    if(! cdata.compress(flags.cpercent, fileref::compressionlevels(flags.clevel), fileref::compmodes(flags.compress), fileref::encmode_none, met_maxpercent))
        return false;
    hashcode chash;
    cdata.binhash(chash);
    
    return chash == hash;
}

void restdata::send_get_data(hashcode &hash)
{
    message m;
    if(!use_comphints) {
        msgpack_c::gethashdata ghd(m);
        int userid = 0;  
        time_t prefetchtime = 0;  
        ghd.arg(PACK, hash, userid, prefetchtime);
    } else {
        msgpack_c::gethashdatahints ghdh(m);
        ghdh.arg(PACK, hash);
    }
    if(msg1) DB->msg("restdata:send_get_data off:%s prior:%"LL"d server %d hash:%s",
                              *offset.image(), prior, (int)info.dpninx, *hash.partialimage());

        main->remotecall(this, m, conn);    

}

void restdata::show_data(fileref &data, const ustring &msg, hashcode &computed_hash)
{
    if (DB->messages_on) {
        DB->msg("%s (requested %s, actual %s, %d bytes)", *msg, *hash.partialimage(), *computed_hash.partialimage(), data.size());
        data.hexdump(true);
        DB->msg(" ");
    }
}






bool restdata::incremental_match()
{
    if(msg1)DB->msg("Doing checking incremental restore size=%s offset=%s datasize=%s, expectatomic=%d",
                     *size.image(), *offset.image(), *info.data.size64().image(), expectatomic);

    if(!flags.to_stdout &&
       
       
       (flags.streamformat_out != utar_flags_enums::streamformat_tar) &&
       size != fileoffset(-1) &&       
       expectatomic &&                 
       offset + size <= info.data.size64()) 
    {

       if(msg1) DB->msg("Doing incremental restore");

        
        
        fileref slice;
        unsigned int small_size = size.ivalue();
        slice.initslice64(info.data, offset, small_size);
        hashcode slicehash;
        slice.binhash(slicehash);

        if(slicehash == hash || checkcompressedhash(slice, hash)) {
            if(msg1) DB->msg("slice unchanged offset=%s size=%s", *offset.image(), *size.image());
            if(!info.ignoreStats && !fromcache) {
                if (msg1) DB->msg("restdata::incremental_match adding bytes %s", *tostr(size.dvalue()));
                main->addfilebytes(context::restorestats, size.dvalue());
                main->addprogbytes(context::restorestats, size.dvalue());
                main->getstatsobj(context::restorestats)->update(stats::ispresent, size.dvalue(), chunktype::atomic, main->handling_system_info());
            }
            
            
            fileref nulldata;
            nulldata.initnull(small_size);
            
            info.data.setslice64(offset, nulldata, false);
            return true;
        }
    }
    return false;
}


void restdata::init() {
    const location loc(info.direlem.get_location());
    const bool isddrdata(loc.getMedia() == location::media::ddr);
    if(msg1)DB->msg("restdata::init this:%p nforked:%d ncollected:%d isddrdata:%d use_container:%d %s",
                    this, nforked, ncollected, isddrdata, use_container, *info.direlem.fullpath().image());

    
    if (use_container) {
        const location::tformat::type format(info.direlem.get_location().get_format());
        ucontainer::errortype result;
        if(format == location::tformat::raw) {
            result = read_data_from_raw_container(&info.direlem, info.container);
        } else {
            
            
            
            
            
            
            
            
            
            
            
            bool only_read_requested_size(false);
            if ((flags.streamformat_out == utar_flags_enums::streamformat_emctar) ||
                (flags.streamformat_out == utar_flags_enums::streamformat_isilon) ||
                (flags.streamformat_out == utar_flags_enums::streamformat_zfs)) {
                only_read_requested_size = true;
            }

            
            assert(ourdata_sp);
            
            result = read_data_from_ucontainer(main, info, flags.validate, flags.media_in_size, only_read_requested_size, ourdata_sp);
        }
        if(result != ucontainer::pce__success) {
            ustring errstr = ustring::sprintf(LOCTXT("Unable to %s data for file '%s' (code:%s)."),
                                              flags.validate ? "validate" : "restore",
                                              *info.direlem.fullpath().image(), *ucontainer::error_description(result));
            set_error(true, errstr);
            Out->msg(ERR, "%s", *errstr);
        }
        childdone(NULL);
        return;
    }

    if (loc.isFromCatalog()){
        if(msg1) DB->msg("Restdata::init data on the Catalog");
        if (!read_data_from_catalog()) {
            const ustring errstr = ustring::sprintf(LOCTXT("Unable to %s data for file '%s'"),
                                flags.validate ? "validate" : "restore",
                                *info.direlem.fullpath().image());
            set_error(true, errstr);
            Out->msg(ERR, "%s", *errstr);
        }
        childdone(NULL);
        return;
    }

    if(memcmp(&hash, &hashcode::empty, sizeof(hashcode))==0) {
        
        if(msg1) DB->msg("restdata::init empty hash %s == %s, path='%s'", *hash.partialimage(), *hashcode::empty.partialimage(), *info.path.image());
        message null;
        response(null);
        return;
    }

    if (hash == hashcode::zero) {
        
        
        
        if (flags.destination_data != client_config_flags::same_destination)
            DB->msg("Restoring '%s' (hashcode is zero) without data", *info.path.image());
        else
            Out->msg(ERR, "<9909> Unable to restore %s, cannot find data", *info.path.image());
        message null;
        response(null);
        return;
    }

    if(msg1) DB->msg("Restdata: %s, path='%s', prior=%"LL"d", *hash.partialimage(), *info.path.image(), prior);

    if(flags.incremental && incremental_match()) {
        message null;
        response(null);
        return;
    }

    message cachemsg;
    if(main->restorecache_lookup(hash, cachemsg)) {
        assert(cachemsg.requestcode() == GET_HASH_DATA || cachemsg.requestcode() == GETHASHDATAHINTS);
      
        fromcache = true;
        response(cachemsg);
        return;
    }
    send_get_data(hash);
}





restdata* restdata::find_restdata_parent( cycle *myparent ) {
    backappend *my_root_file_cycle = root_file_cycle;
    while( myparent != NULL && myparent != my_root_file_cycle ) { 
        restdata *restdata_parent = dynamic_cast<restdata *>(myparent);
        if( restdata_parent )
            return restdata_parent;
        myparent = myparent->parent;
    }
    return NULL;
}


void restdata::response(message& outargs) {
    if(outargs.isnull()) {
        
        info.data.free();
        notifyparent();
        return;
    }

    fileref outdata;
    fileref hintdata;
    chunktype ckind;
    int cachelevel = CACHELEVEL_NONE;
    if(outargs.requestcode()!=GETHASHDATAHINTS) {  
        msgpack_c::gethashdata ghd(outargs);
        ghd.res(UNPACK, ckind, outdata, cachelevel);
        if(msg2) DB->msg("got ckind of %s from hash %s", *ckind.image(), *hash.partialimage());
    } else {
        unsigned int datasize;
        fileref combineddata;
        tunivchunktype ctype;
        msgpack_c::gethashdatahints ghdh(outargs);
        ghdh.res(UNPACK, ctype, datasize, combineddata);
        ckind = ctype.oldkind();
        

        if(ctype.hascompositehints()) {
            assert(datasize < (unsigned)combineddata.size());

            fileref d;
            d.initslice(combineddata, 0, datasize);

            if (use_comphints) {
                hintdata.initslice(combineddata, datasize, combineddata.size() - datasize);

                if(false  && !hintdata.isnull()) {
                    nodevector nodes(hintdata);
                    for(unsigned int i = 0; i < nodes.size(); i++) {
                        DB->msg("restdata::response i=%u of %u nodeid=%s", i, (unsigned)nodes.size(), *nodes[i].image());
                    }
                }
            }

            outdata = d;
        }
        else {
            outdata = combineddata;
        }
    }

    if(msg2) DB->msg("restdata::response: this=%p, h=%s, err=%s msg=(%s) fromcache:%c ckind:%s size:%d",
                     this, *hash.partialimage(), *outargs.found_image(), *outargs.ximage(), fromcache ? 'T':'F', *ckind.image(), outdata.size());

    if(outargs.iserrorresponse()) {
      
      if (outargs.responsecode() == MSG_ERR_ENTER_INCOMPLETE) {
          Out->msg(FATAL, "<5679>The CAT server does not support this operation.");
          uapp::staging().startTermination(EXIT_MISC, "CAT server does not support this operation");
          return;
      }
      if(hash != hashcode::zero) { 
           set_error(true,
             ustring::sprintf("missing response in restdata.response %s err=%s msg=(%s) datalen=%d",
                             *hash.partialimage(), *outargs.found_image(), *outargs.ximage(), outdata.size()));
           Out->msg(ERR, "<5517>\"%s\" Server error %s occurred restoring chunk %s",    
                             *info.path.image(), *outargs.found_image(), *hash.partialimage());
        }
        info.data.free();
        notifyparent();
        return;
    }
    
    if( info.data.iserror(filebase::ERRCODE_ERR) ) {
        info.data.free();
        notifyparent(); 
        
        
        return; 
    }

    int sentsize = outdata.size();

    
    

    
    
    
    
    if(outargs.isflagset(MSGFLAG_NODATACRC) &&
        !flags.nohashrestdata && !ckind.is_dir_atomic() && !fromcache) {

        
        
        
        

        hashcode reshash;
        outdata.binhash(reshash);
        if(reshash != hash || redocount) {
            DB->msg("GET_HASH_DATA: redo:%d kind:%s size:%d  computed %s, requested %s, msg.hash %s",
                    redocount, *ckind.image(), outdata.size(), *reshash.partialimage(), *hash.partialimage(), *outargs.body().hash.partialimage());

            if(reshash != hash) {
                Out->msg(WARN, "<6429>Retrieved incorrect data from server: redo:%d kind:%s size:%d  computed %s, requested %s, msg.hash %s",
                        redocount, *ckind.image(), outdata.size(), *reshash.partialimage(), *hash.partialimage(), *outargs.body().hash.partialimage());
                show_data(outdata, "Incorrect data", reshash);
                if (++redocount <= REDOLIMIT) {
                    send_get_data(hash);                                
                    return;
                }
                set_error(true, ustring::sprintf("bad response in restdata.response redo:%d kind:%s %s != %s (%s)",
                                                 redocount, *ckind.image(), *hash.partialimage(), *reshash.partialimage(), *outargs.found_image()));
                Out->msg(ERR, "<5518>\"%s\" Server data error restoring chunk %s (%s)",
                              *info.path.image(), *hash.partialimage(), *outargs.found_image());  

                DB->msg("restdata::response outargs.found_image(%s) %s \n         hash:%s\noutargs.hash:%s\n\n",
                        *outargs.found_image(), *outargs.ximage(), *hash.partialimage(), *outargs.body().hash.partialimage());

                info.data.free();
                notifyparent();
                return;
            }
            show_data(outdata, "Correct data", reshash);
        }
    }

    
    bool wascompressed = false;
    if(ckind.is_extatomic()) {
        if(msg3) {
            DB->msg("restdata::response: ckind=%s, hash %s raw compressed data, %d bytes", *ckind.image(), *hash.partialimage(), outdata.size());
            outdata.hexdump(false);
        }

        int csize = outdata.size();
     

        
        bool res = outdata.uncompress(main->get_enckey());

        if(!res) Out->msg(ERR, "<7692>\"%s\": INTERNAL uncompress/decrypt failure, data not restored correctly", *info.path.image());
        main->getstatsobj(context::restorestats)->add_compress(0 , csize, outdata.size());

        if(outdata.size() > csize) {   
            if(!info.ignoreStats && !fromcache)
                main->getstatsobj(context::restorestats)->update(stats::reduced, outdata.size() - csize, ckind, main->handling_system_info());       
        } else {
        
            sentsize += outdata.size() - csize;         
        }

        if(msg3) {
            DB->msg("restdata::response: hash %s uncompressed data, %d bytes", *hash.partialimage(), outdata.size());
            outdata.hexdump(false);
        }
        wascompressed = true;
        ckind = chunktype::atomic;
    }

    if(! fromcache && main->restorecache_enabled() && (main->restorecache_cache_atomics() || !ckind.is_atomic()) ) {
        
        
        
        if (wascompressed && outargs.requestcode() == GET_HASH_DATA) {
            msgpack_c::gethashdata ghd(outargs);
            ghd.res(PACK, ckind, outdata, cachelevel);
        }

        main->restorecache_enter(hash, outargs);
    }

    if((!flags.replicate) && (!info.ignoreStats) && !fromcache) {
        main->getstatsobj(context::restorestats)->update(stats::sent, sentsize, ckind, main->handling_system_info());

        if(ckind.is_data_atomic())  { 
            
            
            
            
            
            if (msg1) DB->msg("restdata::response: updating restore stats %s, sent %d", *tostr(outdata.size()), sentsize);
            main->addprogbytes(context::restorestats, outdata.size());
        }
        else if (msg1) DB->msg("restdata::response: skipping restore stats %s, sent %d", *tostr(outdata.size()), sentsize);
    }
    else if (msg1) DB->msg("restdata::response: skipping sent stats %d", sentsize);

    
    
    
    if (fromcache && ckind.is_data_atomic()) {
        
        main->getstatsobj(context::restorestats)->byteprogress(stats::hashcache, outdata.size(), filestatsref(), chunktype::atomic, main->handling_system_info());
    }

    if(! comparedata.isnull()) {
        
        if(! ckind.is_data_atomic())
            Out->msg(ERR, "<5252>randchunk data not atomic");
        if(outdata != comparedata)
            Out->msg(ERR, "<5253>randchunk validate mismatch %s outdata.size=%d comparedata.size=%d",
                     *hash.partialimage(), outdata.size(), comparedata.size());
    }

    if(ckind.is_atomic() || info.rawmode) {     
        if( root_file_cycle ) {
            rest_chunker = root_file_cycle->get_chunker();
            if( rest_chunker ) {
                if( chgblkmsg) DB->msg( "CHGBLK not building chunker kind = %s(Atomic) because we have one", *ckind.image() );
            } else {
                if( chgblkmsg) DB->msg( "CHGBLK build that chunker kind = %s(Atomic)", *ckind.image() );
                fileoffset maxsize;
                fileref mapbuffer;
                rest_chunker = chunker::pick_atomic(flags, root_file_cycle->getInfo(), ckind, root_file_cycle, maxsize, mapbuffer);
                rest_chunker->set_chunker_name( "restore atomic chunker" );
                
                root_file_cycle->set_chunk(rest_chunker);
                if( chgblkmsg) DB->msg( "CHGBLK restdata::response parent=%p", parent );
                restdata *restdata_parent = find_restdata_parent( parent );
                if( chgblkmsg) DB->msg( "CHGBLK restdata::response restdata_parent=%p", restdata_parent );
                chunker *parent_chunker = NULL;
                if( restdata_parent )
                    parent_chunker = restdata_parent->rest_chunker;
                if( parent_chunker )
                    parent_chunker->child = rest_chunker;
                else root_file_cycle->set_chunk_top( rest_chunker );
                if( chgblkmsg) DB->msg( "CHGBLK ++rest_chunker->set_chunker_parent( %p )", parent_chunker );
                rest_chunker->set_chunker_parent( parent_chunker );
                if( chgblkmsg) DB->msg( "CHGBLK --rest_chunker->set_chunker_parent( %p )", parent_chunker );
            }

            if( chgblkmsg) DB->msg( "CHGBLK restdata::response atomic_chunker=%p", rest_chunker );
            if( chgblkmsg) DB->msg( "CHGBLK ++Calling chunker::pre_restore_into_chunker" );

            
            fileref pre_data;
            fileref post_data;

            
            if( info.startbyte >= offset &&
                info.startbyte <= offset+size ) {
                
                assert( info.startbyte-offset <= outdata.size() );
                
                pre_data.initslice6464( outdata, 0, info.ischangeblockappend ? outdata.size() : info.startbyte-offset );
                if( chgblkmsg && info.ischangeblockappend) DB->msg( "CHGBLK ischangeblockappend");
                if( chgblkmsg) DB->msg( "CHGBLK Setting Atomic predata.size()=%d", pre_data.size() );
                if( chgblkmsg && flags.verbose >=2) DB->msg( "CHGBLK Setting Atomic predata=%s", *ustring(pre_data) );
                rest_chunker->pre_restore_into_chunker( pre_data );
            }
            if( info.endbyte >= offset &&
                info.endbyte < offset+size ) {
                
                fileoffset len = offset + outdata.size64() - info.endbyte -1;
                post_data.initslice6464( outdata, info.endbyte-offset+1, len );         
                if( chgblkmsg) DB->msg( "CHGBLK Setting Atomic post_data.size()=%d", post_data.size() );
                if( chgblkmsg && flags.verbose >=2) DB->msg( "CHGBLK Setting Atomic postdata=%s", *ustring(post_data) );
                rest_chunker->set_post_restore_data( post_data );
            }

            if( pre_data.size() == 0 && post_data.size() == 0 ) {
                if( chgblkmsg) DB->msg( "CHGBLK We should not be here, we should only be restoring data on the edges %s..%s", *offset.image(), *fileoffset(offset+size).image() );
            }

            if( chgblkmsg) DB->msg( "CHGBLK outdata.size()=%d pre_data.size=%d post_data.size=%d", outdata.size(), pre_data.size(), post_data.size() );

            if( chgblkmsg) DB->msg( "CHGBLK --Calling chunker::pre_restore_into_chunker" );
        } else {
            if(! outdata.isnull()) {

                
                

                bool validate = (flags.validate && ckind.is_data_atomic() && !main->handling_system_info());
                if(! validate) {
                    

                    fileoffset restoffset(offset - info.startbyte);  
                    if(info.checkrange && !ckind.is_dir() ) {
                        fileoffset start(0);  
                        fileoffset size(outdata.size64());
                        if (info.startbyte > offset)    { start = info.startbyte - offset; size = size-start; restoffset = fileoffset(0); }
                        if (info.endbyte < offset+outdata.size64()) size = (info.endbyte-offset) - start + fileoffset(1);
                        if (start < fileoffset(0) || size < fileoffset(0)) {
                            
                            notifyparent();
                            return;
                        }
                        

                        outdata = outdata.makeslice64(start, size);
                        
                    }

                    
                    if(info.data.isnull() && ckind.is_dir() && info.restdircycle) {
                        restdir *rdc = info.restdircycle;
                        
                        
                        
                        info.data.initmem(outdata);
                        rdc->info.data = info.data;
                        if(msg1)DB->msg("restdata::response making block (size=%d)", info.data.size());
                    }
                    else {
                        
                        
                        
                        
                        
                        info.exportdata(restoffset, outdata); 
                    }

                    if( info.data.iserror(filebase::ERRCODE_ERR) ) {
                        
                        
                        set_error( true, ustring("") ); 
                    }
                }
            }


            if (ctypep_to_return) *ctypep_to_return = ckind;
            if(info.data.getrefcount() > 1) {  
                info.data.free();
            }
        }
        notifyparent();
    } else {
        cycle *child;
        if( root_file_cycle ) {
            if( chgblkmsg ) DB->msg( "CHGBLK build that chunker kind = %s(Composite)", *ckind.image() );
            if( chgblkmsg ) DB->msg( "CHGBLK Calling chunker::expand_composite" );
            chunker::expand_composite( outdata, ckind );
            ckind = chunktype::recipe8;
            restdata *restdata_parent = find_restdata_parent( parent );
            
            if( restdata_parent )
                rest_chunker = restdata_parent->rest_chunker->child;
            else rest_chunker = root_file_cycle->get_top_chunker();

            if( rest_chunker ) {
                if( chgblkmsg) DB->msg( "CHGBLK not building chunker kind = %s(Composite) because we have one", *ckind.image() );
            } else {
                rest_chunker = new composite_chunker(flags, root_file_cycle->getInfo(), chunktype::recipe8, root_file_cycle);
                rest_chunker->set_chunker_name( "rest composite chunker" );
                if( chgblkmsg ) DB->msg( "CHGBLK restdata::response restdata_parent=%p", restdata_parent );
                if( restdata_parent ) {
                    chunker *parent_chunker = restdata_parent->rest_chunker;
                    if( chgblkmsg ) DB->msg( "CHGBLK ++rest_chunker->set_chunker_parent( %p )", parent_chunker );
                    rest_chunker->set_chunker_parent( parent_chunker );
                    if( chgblkmsg ) DB->msg( "CHGBLK --rest_chunker->set_chunker_parent( %p )", parent_chunker );
                    rest_chunker->fixup_depth(); 
                    if( parent_chunker )
                        parent_chunker->child = rest_chunker;
                    else root_file_cycle->set_chunk_top( rest_chunker );
                }
            }

            if( chgblkmsg ) DB->msg( "CHGBLK restdata::response composite_chunker=%p", rest_chunker );

            
            fileoffset abs_endoff = chunker::get_last_endoff( outdata, chunktype::recipe8 )+offset;

            if( restdata_parent == NULL )
                root_file_cycle->set_max_offset( chunker::get_last_endoff( outdata, chunktype::recipe8 ) ); 

            if( chgblkmsg ) DB->msg( "CHGBLK Composite spans %s..%s", *offset.image(), *abs_endoff.image() );

            

            fileref pre_data;
            fileref post_data;

            if( info.startbyte >= offset &&
                info.startbyte <= abs_endoff ) {
                
                int off = 0;
                int old_off = 0;
                fileoffset local_endoff;
                while( off < outdata.size() ) {
                    compelem elem( chunktype::recipe8 );
                    elem.init( outdata, off );
                    local_endoff = elem.getendoff()+offset;
                    if( local_endoff > info.startbyte ) {
                        off = old_off;
                        break;
                    }
                    old_off = off;
                }

                pre_data.initslice6464( outdata, 0, off );
                if( chgblkmsg ) DB->msg( "CHGBLK Setting Composite predata size=%d", pre_data.size() );
                if( chgblkmsg ) chunker::list_composite( pre_data, ckind );
                rest_chunker->pre_restore_into_chunker( pre_data );
            }

            if( info.endbyte >= offset &&
                info.endbyte < abs_endoff ) { 
                
                if( chgblkmsg ) DB->msg( "CHGBLK finding post_data edge info.endbyte=%s", *info.endbyte.image() );
                int off = 0;
                int old_off = 0;
                fileoffset lower = offset;
                fileoffset upper;
                while( off < outdata.size() ) {
                    compelem elem( chunktype::recipe8 );
                    elem.init( outdata, off );
                    upper = elem.getendoff()+offset;
                    
                    if( chgblkmsg ) DB->msg( "CHGBLK composite =%s..%s", *lower.image(), *upper.image() );
                    if( lower > info.endbyte ) {
                        if( chgblkmsg ) DB->msg( "CHGBLK found edge off=%d old_off=%d", off, old_off );
                        off = old_off;
                        break;
                    }
                    old_off = off;
                    lower = upper;
                }

                if( chgblkmsg ) DB->msg( "CHGBLK converting composite" );
                
                fileoffset prev_offset = 0;
                fileoffset size;
                int index = 0;
                post_data.initcat( outdata.size() /28);

                while( index < outdata.size() ) {
                    compelem elem( chunktype::recipe8 );
                    if( chgblkmsg ) DB->msg( "CHGBLK elem.init index=%d", index );
                    elem.init( outdata, index );
                    if( chgblkmsg ) DB->msg( "CHGBLK elem.getendoffset prev_offset=%s", *prev_offset.image() );
                    size = elem.getendoff()-prev_offset;
                    if( chgblkmsg ) DB->msg( "CHGBLK size = %s", *size.image() );
                    prev_offset = elem.getendoff();
                    if( index > off ) {
                        compelem outelem( chunktype::recipe8 );
                        outelem.sethash( elem.gethash() );
                        outelem.setendoff( size, true );
                        post_data.append( outelem.getdata() );
                    }
                }

                if( chgblkmsg ) DB->msg( "CHGBLK Setting Composite postdata size=%d", post_data.size() );
                if( chgblkmsg ) chunker::list_composite( post_data, ckind );
                rest_chunker->set_post_restore_data( post_data );
            }

            if( pre_data.size() == 0 && post_data.size() == 0 ) {
                if( chgblkmsg ) DB->msg( "CHGBLK We should not be here, we should only be restoring data on the edges %s..%s", *offset.image(), *abs_endoff.image() );
                if( chgblkmsg ) DB->msg( "CHGBLK info.startbyte info.endbyte %s..%s", *info.startbyte.image(), *info.endbyte.image() );
            }

            if( chgblkmsg ) DB->msg( "CHGBLK pre_data.size=%d post_data.size=%d", pre_data.size(), post_data.size() );
        };

        child = new restcomp(this, info, outdata, hintdata, ckind, prior+offset.value(), offset, root_file_cycle );
        if (ctypep_to_return) *ctypep_to_return = ckind;
    }
}

void restdata::childdone(cycle *child) {
    if(info.data.getrefcount() > 1)  
        info.data.free();
    
    notifyparent();
}

restdata::~restdata() {
    
}




bool restdata::read_data_from_catalog() {
    if (main != NULL && main->getAdeMgr() != NULL) {
        const hfs_info_struct hfsInfo = main->getAdeMgr()->getHfsInfo(dpn0);
        if (!hfsInfo.metaStore) {
            if (msg1)DB->msg("restdata::read_data_from_catalog() failing because somehow we got a backup from the catalog but this platform does not support the catalog. How did we get here???");
                return false;
        }
        MetadataIntf_sp resMi;
        const MetadataId mid = info.direlem.get_metadataLocation()->getMetadataId();
        if(hfsInfo.metaStore->getMetadata(mid, resMi) == storeSuccess) {
            fileref outdata;
            if (resMi->getGenericData(FILE_DATA, outdata)) {
                if(!flags.validate)info.exportdata(offset, outdata); 
                main->getstatsobj(context::restorestats)->update(stats::sent, outdata.size(), chunktype::atomic, main->handling_system_info());
                main->addprogbytes(context::restorestats, outdata.size());
                return true;
            }
            else {
                if (msg1)DB->msg("restdata::read_data_from_catalog() failing because the catalog reports no Generic Data(FILE_DATA) with the metadataId (%s)", *mid.image());
                return false;
            }
        }
        else {
            if (msg1)DB->msg("restdata::read_data_from_catalog() failing because the catalog cannot find the requested metadataId (%s) in the catalog", *mid.image());
            return false;
        }
    }
    else {
        if (main == NULL) {
            if (msg1)DB->msg("restdata::read_data_from_catalog() failing because we have no context. How did we get here?");
            return false;
        }
        else {
            if (msg1)DB->msg("restdata::read_data_from_catalog() failing because we have no AdeMgr (required to get hfsInfo)");
            return false;
        }
    }
    return false;
}














ucontainer::errortype restdata::read_data_from_ucontainer(context* main, restelem& info, const bool validate, const int media_in_size, const bool only_read_requested_size , const is_ourdata_sp ourdatap ) {
    const DIRELEM* de = &info.direlem;
    
    if(info.container.isnull()) { assert(!info.container.isnull()); return ucontainer::pce__ucontainer_object_not_existant; }

    const ustring filename(de->fullpath().image()); 
    const location loc(de->get_location());
    const fileoffset absoffset(loc.get_abs_offset_in_container());
    if (cdsf_msg) DB->msg("restdata::read_data_from_ucontainer: name '%s' direlem absoffset = %s, loc:%s", *filename, *absoffset.image(), *loc.image());

    
    assert(info.container->is_seekable() || absoffset==0);
    ucontainer::errortype retval;
    retval = info.container->seek(absoffset, SEEK_SET);
    if (retval != ucontainer::pce__success) {
        DB->msg("restdata::read_data_from_ucontainer bad response from seek call %s", *ucontainer::error_description(retval));
        return retval;
    }

    
    udirelemp de_from_container(NULL);
    fileoffset obj_size;  
    retval = info.container->getobj(de_from_container, obj_size);

    
    if (retval != ucontainer::pce__success) {
        DB->msg("restdata::read_data_from_ucontainer: processing ucontainer, problem calling getobj: %s ", *ucontainer::error_description(retval));
        return retval;
    }

    
    assert(ourdatap);
    
    const is_ourdata_sp looking_for_metadata(undoo::dynamic_pointer_cast<is_metadata>(ourdatap));
    if(de_from_container.isnull()
       || (!de_from_container->is_descend_obj()) 
       || (de_from_container->is_directory() && !looking_for_metadata) 
    ) {
        const bool denull(de_from_container.isnull());
        const ustring isdescend(denull? "N/A" : de_from_container->is_descend_obj()? "true" : "false"),
                      isdir    (denull? "N/A" : de_from_container->is_directory()? "true" : "false"),
                      ismetadata(looking_for_metadata? "true" : "false");
        DB->msg("restdata::read_data_from_ucontainer: processing ucontainer, "
                "de_from_container isnull():%s is_descend_obj():%s is_directory():%s is_metadata:%s "
                "getobj failed: %s", denull?"true":"false", isdescend.tostr(), isdir.tostr(), ismetadata.tostr(), *ucontainer::error_description(retval));
            return retval;
    }

    
    
    if (validate) {
        

        
        if (!de_from_container->name().equal(de->name())) {
            Out->msg(ERR, "Name mismatch detected, path \"%s\" does not match the path \"%s\" from container.",
                     *de->print(upath(de->name()), true, NULL, NULL, false, true),
                     *de_from_container->print(upath(de_from_container->name()), true));
            return ucontainer::pce__unknown;
        }
    }

    
    
    
    if(info.checkrange && info.container->is_seekable()) {
            if (cdsf_msg) DB->msg("restdata::read_data_from_ucontainer seek to offset %s", info.startbyte.image().tostr());
            ucontainer::errortype result = info.container->seek_in_object(info.startbyte, SEEK_SET);
        if(result != ucontainer::pce__success) {
                DB->msg("restdata::read_data_from_ucontainer seek failed with '%s'", ucontainer::error_description(result).tostr());
                
                if(result != ucontainer::pce__unimplemented_feature)
            return result;
        }
    }

    fileoffset export_offset; 
    
    while(uapp::staging().canRun()) {
        
        
        
        const bool restore_objdata((*ourdatap)(info, de_from_container));

        if (cdsf_msg) DB->msg("restdata::read_data_from_ucontainer name:%s ascend?%d descend?%d continue?%d meta?%d restore_objdata?%d",
                              *de_from_container->name(), de_from_container->is_ascend_obj(), de_from_container->is_descend_obj(),
                              de_from_container->is_continuefile(), de_from_container->is_meta(), restore_objdata);

        
        
        if(de_from_container->is_ascend_obj() && (restore_objdata || !de_from_container->is_meta())) break;

        
        ucontainer::errortype result;
        result = container_getdata(main, info, media_in_size, (restore_objdata && !validate), export_offset, only_read_requested_size);  
        if(info.checkrange && result == ucontainer::pce__success) { 
            return ucontainer::pce__success;
        } else if(result != ucontainer::pce__end_of_file) { 
            DB->msg("restdata::read_data_from_ucontainer returned unexpected value %s", *ucontainer::error_description(result));
            return result;
        }
        assert(result == ucontainer::pce__end_of_file);

        
        de_from_container = NULL;  
        retval =  info.container->getobj(de_from_container, obj_size);
        if (retval != ucontainer::pce__success || de_from_container.isnull()) {
            DB->msg("restdata::read_data_from_ucontainer processing ucontainer, getobj failed: %s", *ucontainer::error_description(retval));
            return retval;
        }
    }
    
    return ucontainer::pce__success;  
}































ucontainer::errortype restdata::container_getdata(context* main, restelem& info, const int media_in_size, const bool doexport, fileoffset& export_cur, const bool only_read_requested_size)
{
    
    if(info.container.isnull()) { assert(!info.container.isnull()); return ucontainer::pce__ucontainer_object_not_existant; }

    ucontainer::errortype result(ucontainer::pce__success);
    if(cdsf_msg)DB->msg("restdata::container_getdata doexport:%d export_cur:%s checkrange?%d [%s-%s]",
                         doexport, *export_cur.image(), info.checkrange, *info.startbyte.image(), *info.endbyte.image());

    
    while (uapp::staging().canRun()) {
        fileref dataread;  
        fileoffset dataread_start(fileoffset::unknown);  

        fileoffset data_request_size(media_in_size);
        
        
        if (only_read_requested_size || (doexport && info.checkrange)) {
            
            
            fileoffset remaining_size_to_read = (info.endbyte - info.startbyte + 1) - export_cur;
            if (remaining_size_to_read < media_in_size) {
                data_request_size = remaining_size_to_read;
            }
        }

        if(cdsf_msg)DB->msg("restdata::container_getdata doexport:%d Calling getdata data_request_size:%s", doexport, *data_request_size.image());
        result = info.container->getdata(data_request_size, dataread, dataread_start);

        
        if ((result != ucontainer::pce__success) && (result != ucontainer::pce__end_of_file)) {
            DB->msg("restdata::container_getdata getdata failed with '%s' dataread_start:%s export_cur:%s",
                    *ucontainer::error_description(result), *dataread_start.image(), *export_cur.image());
            return result;
        }

        
        if (result == ucontainer::pce__end_of_file || dataread.size64() == fileoffset(0)) {
            assert(dataread.size64() == fileoffset(0)); 
            if(cdsf_msg) DB->msg("restdata::container_getdata: getdata() returned \"pce__end_of_file\" or size of zero (%s)", *dataread.size64().image());
            return result;
        }

        
        if(doexport) {
            const fileoffset dataread_end(dataread_start + dataread.size64() - 1);
            if(cdsf_msg) DB->msg("restdata::container_getdata exporting data read:%s, export_cur:%s dataread_start:%s dataread_end:%s",
                                 *dataread.size64().image(), *export_cur.image(), *dataread_start.image(), *dataread_end.image());
            if(info.checkrange) {
                
                if(dataread_start <= info.endbyte && dataread_end >= info.startbyte) {
                    
                    const fileoffset export_start(dataread_start < info.startbyte ? info.startbyte - dataread_start : 0);
                    const fileoffset export_size(std::min(dataread_end, info.endbyte) - (dataread_start+export_start) + 1);
                    if(cdsf_msg)DB->msg("restdata::container_getdata exporting range export_cur:%s export_start:%s export_size:%s", *export_cur.image(), *export_start.image(), *export_size.image());
                    fileref trimmed_data(dataread.makeslice64(export_start, export_size));
                    info.exportdata(export_cur, trimmed_data);
                    export_cur += export_size;

                    
                    if(main)main->addprogbytes(context::restorestats, export_size.dvalue());

                    
                    if (msg1) DB->msg("restdata::container_getdata: updating ddsent stats %s", *tostr(export_size.dvalue()));
                    if(main)main->getstatsobj(context::restorestats)->update(stats::ddsent, export_size.dvalue(), chunktype::atomic, main->handling_system_info());

                    
                    
                    
                    
                    if(dataread_end >= info.endbyte) { 
                        if(cdsf_msg)DB->msg("restdata::container_getdata read all of the requested data %s >= %s", *dataread_end.image(), *info.endbyte.image());
                        return ucontainer::pce__success;  
                    }

                } else if(dataread_start > info.endbyte) { 
                    if(cdsf_msg)DB->msg("restdata::container_getdata read past the end of requested data %s > %s", *dataread_start.image(), *info.endbyte.image());
                    return ucontainer::pce__success;  
                }

            } else {
                info.exportdata(export_cur, dataread);
                export_cur += dataread.size64();

                
                if(main)main->addprogbytes(context::restorestats, dataread.size64().dvalue());

                
                if (msg1) DB->msg("restdata::container_getdata: updating ddsent stats %s", *tostr(dataread.size64().dvalue()));
                if(main)main->getstatsobj(context::restorestats)->update(stats::ddsent, dataread.size64().dvalue(), chunktype::atomic, main->handling_system_info());
            }
        }
    }
    return result; 
}



ucontainer::errortype restdata::read_data_from_raw_container(const DIRELEM* de, ucontainer::basep container) {
    
    if(container.isnull()) { assert(!container.isnull()); return ucontainer::pce__ucontainer_object_not_existant; }

    const ustring    filename(de->fullpath().image()); 
    const location   loc(de->get_location());
    const fileoffset absoffset(loc.get_abs_offset_in_container());

    
    
    
    
    fileoffset needbytes(loc.get_coverage_size());

    if(info.checkrange) {
    
    
    
    
    
    
    
    
    
        assert(info.startbyte <= info.endbyte);
        needbytes = info.endbyte - info.startbyte + 1;
    }

    if (cdsf_msg) DB->msg("restdata::read_data_from_raw_container: filename:'%s' absoffset:%s needbytes:%s ", *filename, *absoffset.image(), *needbytes.image());

    assert(container->is_seekable() || absoffset == 0);

    
    ucontainer::errortype retval = container->seek(absoffset+(info.checkrange? info.startbyte : 0), SEEK_SET);
    if (retval != ucontainer::pce__success) {
        DB->msg("restdata::read_data_from_raw_container: processing ucontainer, seek failed: %s", *ucontainer::error_description(retval));
        return retval;
    }

    fileoffset sizeleft(needbytes);  
    fileoffset restoffset(0);         
    while (sizeleft > 0 && uapp::staging().canRun()) {

        fileref fr;
        fileoffset byteoffset_in_file(-1);
        const ucontainer::errortype retval = container->getdata(sizeleft, fr, byteoffset_in_file);
        fileoffset size_returned(fr.size64());
        if(cdsf_msg) DB->msg("restdata::read_data_from_raw_container: getdata of %s returned '%s' %s", *sizeleft.image(), *error_description(retval), *size_returned.image());

        if (retval != ucontainer::pce__success || size_returned == fileoffset(0)) {

            if (retval == ucontainer::pce__end_of_file || size_returned == fileoffset(0)) {
                if(cdsf_msg) DB->msg("restdata::read_data_from_raw_container: getdata() returned \"pce__end_of_file\" or size of zero (%s)", *size_returned.image());
                break;

            } else {
                
                DB->msg("restdata::read_data_from_raw_container: processing ucontainer, getdata failed: %s", *ucontainer::error_description(retval));
                Out->msg(FATAL, "Failed to restore file \"%s\", unable to retrieve data.", *filename);
                return retval;
            }
        }
        if(cdsf_msg) DB->msg("restdata::read_data_from_raw_container: getdata() returned data size:%s, offset:%s",
                             *size_returned.image(), *byteoffset_in_file.image());


        
        
        
        
        if(size_returned <= sizeleft) {
            sizeleft -= size_returned;
        } else {
            assert(false); return ucontainer::pce__error_parsing_stream;
        }
        
        if(cdsf_msg) DB->msg("restdata::read_data_from_raw_container: Adding bytes to output. size:%s, offset:%s", *size_returned.image(), *restoffset.image());
        if(!flags.validate) info.exportdata(restoffset, fr);

        
        
        restoffset += size_returned;

        
        main->addprogbytes(context::restorestats, size_returned.dvalue());

        
        if (msg1) DB->msg("restdata::read_data_from_raw_container: updating ddsent stats %s", *tostr(size_returned.dvalue()));
        main->getstatsobj(context::restorestats)->update(stats::ddsent, size_returned.dvalue(), chunktype::atomic, main->handling_system_info());
    }
    if(sizeleft != 0 || needbytes != restoffset) {
        assert(sizeleft == 0);
        assert(needbytes == restoffset);
        DB->msg("restdata::read_data_from_raw_container sizeleft:%s needbytes:%s restoffset:%s", *sizeleft.image(), *needbytes.image(), *restoffset.image());

    }

    return ucontainer::pce__success;
}











#include "common.h"
#include "debug.h"
#include "cycle.h"
#include "output.h"
#include "backstate.h"
#include "nbackroot.h"
#include "workelem.h"
#include "ade_mgrx.h"
#include "restelem.h"
#include "restdata.h"
#include "ctl_message.h"

static int nextid;

#define MSG 0
#define deb  (((xflag[11]&8388608)!=0)||((xflag[2]&8)!=0))
#define cdsf_msg ((xflag[2]&1)!=0) 




cycle *EMPTYCYCLE = (cycle *)(4);

cycle::cycle(cycle *parent_, context *main_)
 :  parent(parent_),
    main(main_ == NULL ? parent->main : main_),
    flags(main->get_flags()),
    cb(NULL),
    nforked(0), ncollected(0), cyincluded(0),
    cyisatomic(false),
    
    forksdone(false), collectdone(false),
    cydeleted(false), cyisdirectory(false), cyexcluded(false), 
    autodelete(true),
    
    next_cycle(NULL), next_priority(0), next_kind(0),
    error(false),
    
    depth(parent_ == NULL ? 0 : parent_->depth+1),
    rootinfo(parent_ == NULL ? NULL : parent_->rootinfo),
    threadloopnum(parent_ == NULL ? -1 : parent_->threadloopnum)
{
    if(MSG)DB->msg("cycle::cycle constructor (parent:%p) (this:%p)", parent, this);
    assert(main != NULL);
    offset  = fileoffset(0);
    size    = fileoffset(0);

    ident = ++nextid;
    
}

int cycle::id() {
    return this == NULL ? 0 : ident;
}

void cycle::setparentandroot(cycle *parent_) {
    if(parent_ != NULL) {
        cycle::parent = parent_;
        multivolumeroot* rootinfo_ = parent_->getrootinfo();
        if(rootinfo_ != NULL) {
            cycle::rootinfo = rootinfo_;
        }
        threadloopnum = parent_->getThreadNbr();
    }
}

SAFEBODY(cycle);

void cycle::init() {
}

void cycle::response(message& outargs) {
}

void cycle::notifyparent() {
    if(parent) {
        if(error) {
            
            parent->error = true;
        }

        
        parent->hash = hash;
        parent->childdone(this);
    }
    if (next_cycle) {
        if (next_priority != 0)     
            todoEnqueueInsert(next_kind, next_cycle, next_priority);
        else
            todoEnqueue(next_kind, next_cycle);
    }

    
    if(autodelete)
        deleteself();
}

void cycle::setautodelete(bool b) {
    autodelete = b;
}

void cycle::deleteself() {
    if( cydeleted ) {
        DB->msg( "Cycle Already deleted %p", this);
    }
    cydeleted = true;
    if(MSG)
        DB->msg( "cycle::deleteself (this:%p)", this);
    delete this;
}

void cycle::childdone(cycle *child) {
    notifyparent();
}

void cycle::noop() {
}

void cycle::setnext(todo_kind kind, cycle *next, const bigint64 priority ) {
    this->next_kind  = kind;
    this->next_cycle = next;
    this->next_priority = priority;
}

ustring cycle::image() const {
    ustring img;
    img = "cycle ";
    img += ustring::sprintf( "kind=%X ", next_kind);
    img += ustring::sprintf( "offset=%s ", *offset.image());
    img += ustring::sprintf( "hash=%s ", *hash.partialimage());
    img += ustring::sprintf( "parent=%p ", parent);
    img += ustring::sprintf( "error=%X ", error);
    img += ustring::sprintf( "cb=%p", cb);
    return img;
}

void cycle::bt_msg(const ustring &msg) const {
    DB->msg("cycle::bt_msg '%s', cycles chain from child to parent:", *msg);
    const cycle *p = this;
    while (p) {
        
        const BackCycle *cbp = dynamic_cast<const BackCycle*>(p);
        BackCycle *bp = const_cast<BackCycle*>(cbp);
        workelem* w = (bp ? bp->getInfo() : NULL);

        if (w && !w->direlemp.isnull()) {
            DB->msg("    %p is_a %s: workelem(%s, use_cont:%d cont:%p): %s",
                    p, typeid(*p).name(), *w->direlemp->fullpath().image(), w->use_container, w->container.getimpl(), *p->image());
        } else {
            DB->msg("    %p is_a %s: %s", p, typeid(*p).name(), *p->image());
        }
        if (p == p->parent) break; 
        p = p->parent;
    }
}


ustring todoelem::image(const todo_kind kind)
{
    ustring ret("unknown");

    switch( kind ) {
    case TODO_RESPONSE:
        ret = "response";
        break;
    case TODO_CHUNK:
        ret = "chunk";
        break;
    case TODO_FILE:
        ret = "file";
        break;
    case TODO_FILE_CACHE:
        ret = "file_cache";
        break;
    case TODO_HARD_LINK:
        ret = "hard_link";
        break;
    case TODO_DIR:
        ret = "dir";
        break;
    case TODO_DONE_SYNC:
        ret = "done_sync";
        break;
    case TODO_DONE:
        ret = "done";
        break;
    default:
        ret = ustring::sprintf( "unknown(%d)", kind );
    }
    return ret;
}

ustring todoelem::image() {
    return image(kind);
}

ustring todoelem::ximage() {
    ustring img = ustring::sprintf("todoelem (kind:%d (%s)", kind, *image());
    img += ustring::sprintf(" todo_error:%d", todo_error);
    if (cy == NULL)
        img += ustring(" cy:(nil) )");
    else
        img += ustring::sprintf(" cy:%p (%s) )", cy, *cy->image());

    return img;
}

cycle::~cycle() {
    
    
    if(MSG)
        DB->msg( "cycle::~cycle (this:%p) ident %d", this, ident );
}

void cycle::set_error(bool error_, ustring msg) {
    if( error_ && !msg.isempty() ) {
       Out->msg(ERR, "<5445>INTERNAL CYCLE ERROR: %s", *msg);
    }
    error = error_;
}





ADEMgrX* cycle::getAdeMgr()
{
    
    
    
    

    return main ? main->getAdeMgr() : 0;
}




void cycle::sendRemoteCall(cycle *cy, message& inargs)
{
    
    cycle::main->getAdeMgr()->remoteAsyncCall(inargs, cy, dpn0);
}




void cycle::enqueueResponse(cycle *cy, message& outargs, bool error)
{
    if(rootinfo != NULL) {
        rootinfo->enqueueResponseRC(cy, outargs, error);
    }
    else { 
        main->add(TODO_RESPONSE, cy, outargs, error);
    }
}




void cycle::todoEnqueue(todo_kind kind, cycle *cy)
{
    if(rootinfo != NULL) {
        rootinfo->enqueueRequestRC(kind, cy, getThreadNbr(), error);
    }
    else {  
        main->add(kind, cy, error);
    }
}





void cycle::todoEnqueueInsert( todo_kind kind, cycle *cy, bigint64 next_priority)
{
    if(rootinfo != NULL) {
        rootinfo->enqueueRequestRC(kind, cy, next_priority, getThreadNbr(), error);
    }
    else {  
        main->add_insert(kind, cy, next_priority, error);
    }
}

cycle *cycle::restore_range(const hashcode &h, const fileoffset &startbyte, const fileoffset &endbyte,
                            const bool expectatomic, fileref &outslice, ustring &errmsg, DIRELEM &direlem,
                            ucontainer::basep &rest_container, bool use_container )
{
    errmsg = "";

    if (startbyte >= endbyte) {
        errmsg = ustring::sprintf("startbyte %s >= endbyte %s", *startbyte.image(), *endbyte.image());
        return NULL;
    }

    if (outslice.isnull()) {
        outslice.initmem((size_t)(endbyte - startbyte).value());
    } else {
        if (outslice.size64() != (endbyte - startbyte)) {
            errmsg = ustring::sprintf("restore_range given pre-allocated fileref of %s bytes, but (endbyte:%s - startbyte:%s) == %s",
                                      *outslice.size64().image(), *endbyte.image(), *startbyte.image(), *(endbyte - startbyte).image());
            return NULL;
        }
    }

    
    
    
    
    
    
    
    
    
    
    location loc(direlem.get_location());
    if ((h == hashcode::zero && loc.get_format() > location::tformat::raw) ||
        (direlem.is_directory() && loc.isFromDDR())) {
        use_container = true;
    }
    filestatsref fstats;
    restelem cinfo(direlem.fullpath(), direlem, fstats, outslice);

    
    
    
    if (use_container && (loc.getMedia() > location::media::gsan)) {
        if (rest_container.isdefined()) {
            cinfo.container = rest_container;
        } else {
            cinfo.container = main->open_container_for_read(loc);
        }
    }
    
    
    cinfo.prep_restore_of_slice(h, startbyte, endbyte);

    restdata::is_ourdata_sp restore_data_type;
    if (use_container && direlem.is_directory()) {
        
        
        
        udirelem::meta dir_meta(udirelem::meta::pmt_directory_streamslice);
        restore_data_type = undoo::make_shared<restdata::is_metadata>(dir_meta);
        if (cdsf_msg) DB->msg("cycle::restore_range: Calling restdata to retrieve directory meta");
    } else {
        
        restore_data_type = restdata::default_is_ourdata_sp;
    }

    cycle *rcycle = new restdata(this, h, NULL, expectatomic, cinfo, use_container, restore_data_type);
    nforked += (rcycle != NULL) ? 1 : 0;

    return rcycle;
}







bool cycle::isNewStreamThreadOK(int currentThread, const upath& fulldirpath) const
{
    if (main == NULL) {
        DB->msg("cycle::isNewStreamThreadOK: no main context in cycle, can't multithread.");
        return false;
    }
    if (rootinfo == NULL) {
        DB->msg("cycle::isNewStreamThreadOK: missing multithreading root information, can't multithread.");
        return false;
    }
    utar_flags_info& flags = main->get_flags();
    if (deb) DB->msg("cycle::isNewStreamThreadOK(%d, %s) main %p rootinfo %p parallel type %d", currentThread, *fulldirpath.image(), main, rootinfo, flags.parallel_type);

    bool ret(false);

    
    
    

    if (currentThread != -1) {
        
        
        
        
        
        ustring matched_volname;
        if ((flags.parallel_type == utar_flags_enums::parallel_by_volume) &&
             (!use_new_pool_mechanics || allow_sub_track) &&
             main->state->targets.volumematch(fulldirpath, matched_volname))
        {
            
            if (deb) DB->msg("cycle::isNewStreamThreadOK: Path %s has mounted point path %s.", *fulldirpath.image(), *matched_volname);
            ustring current_mount = rootinfo->getThreadStartingPath(currentThread);
            current_mount = current_mount.strip(ustring::STRIP_TRAILING, DIRSEP);
            if (deb) DB->msg("cycle::isNewStreamThreadOK: Current thread has mount point path %s.", *current_mount);
            if(!main->state->targets.pathequal(matched_volname, current_mount))
                ret = true;
        }
    } else if (rootinfo->isQueuePoolEnabled()) {        
        if (flags.parallel_type == utar_flags_enums::parallel_by_volume) {
            ret = main->state->targets.volumematch(fulldirpath);
        } else if (flags.parallel_type == utar_flags_enums::parallel_by_target) {
            ret = main->state->targets.exact(fulldirpath);
        }
    }
    if (deb) DB->msg("cycle:isNewStreamThreadOK returning %s", ret ? "true" : "false");
    return ret;
}




void BackCycle::notifyparent() {
    if(parent) { 
        if(error) {  
            parent->set_error(true, "");
        }
        if (!info || info->setParentHash) {
            parent->hash = hash;
        } else {
            if (MSG) DB->msg("BackCycle::notifyparent NOT resetting parent->hash(%s) = hash(%s)",
                             *parent->hash.partialimage(), *hash.partialimage());
        }
        parent->childdone(this);
    }
    if(next_cycle) {
        if(next_priority != 0)    
            todoEnqueueInsert(next_kind, (BackCycle*)next_cycle, next_priority);
        else
            todoEnqueue(next_kind, (BackCycle*)next_cycle);
    }
    
    if(autodelete) {
        deleteself();
    }
}

void BackCycle::report_target_done(const bool isdir, const bool success) const {

    if(!flags.report_targets_done)
        return;

    if(!info) {
        DB->msg("BackCycle::report_target_done info is NULL");
        return;
    }

    if(!main->state->targets.exact(info->path, isdir))
        return;

    if(main->client_ctl_statep.isnull()) {
        DB->msg("BackCycle::report_target_done client_ctl_statep is null");
        return;
    }

    typedef ctl_message::ctl_event ctlevent;
    const ctlevent target_done_event(flags, 
                                     ctlevent::target_completed, 
                                     info->path.image(), 
                                     success? "succeeded" : "failed"); 

    if(deb) DB->msg("BackCycle::report_target_done (this=%p, class='%s') sending report: %s", this, typeid(*this).name(), target_done_event.image().tostr());

    if(main->client_ctl_statep->enq_send(target_done_event.getmessage()) != ctl_queue::enqueued_ret)
        DB->msg("BackCycle::report_target_done unable to enqueue target completed event");
}

ustring BackCycle::image() const {
    
    
    ustring ci = cycle::image();
    ustring ipath("NULL INFO");
    ustring dpath("NULL DE");

    if (info) {
        ipath = info->path.image();
        if (info->direlemp.isdefined()) {
            dpath = info->direlemp->fullpath().image();
        }
    }
    ustring ret = ustring::sprintf("'%s' at %p; info.path:%s, de.path:%s. cycle data: %s ", typeid(*this).name(), this, *ipath , *dpath, *ci);
    return ret;
}

ucontainer::errortype BackCycle::begin_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc) {
    ustring path = direlemp->fullpath().image();
    
    
    
    
    fileoffset offset = container->get_curroffset();
    if(deb)DB->msg("BackCycle::begin_dir    ucontainer before begindir  '%s' (offset:%s, mysize:%s) %s",
                                *path, *offset.image(), *direlemp->file_size().image(), *desc);
    const ucontainer::errortype errcode1(container->begindir(direlemp.getimpl()));
    if (errcode1 != ucontainer::pce__success) {
        if (uapp::staging().canRun())
            Out->Abort("Problem calling begindir for '%s' (%s) offset=%s",
                       *path, *ucontainer::error_description(errcode1), *offset.image());
        else {  
            
            Out->msg(ERR, "Problem after cancellation calling begindir for '%s' (%s) offset=%s",
                          *path, *ucontainer::error_description(errcode1), *offset.image());
            const ustring errmsg("Fatal error encountered during cancellation");
            uapp::staging().startTermination(EXIT_ABORT, errmsg);
            uapp::staging().setStageFinal(errmsg);
        }

        return errcode1;
    }
    if(deb)DB->msg("BackCycle::begin_dir    ucontainer after  begindir  '%s' loc:%s size:%s",
             *path, *direlemp->get_location().image(), *direlemp->file_size().image());

    if(deb)DB->msg("BackCycle::begin_dir    ucontainer before begindirc '%s'", *path);

    const ucontainer::errortype errcode2(container->begindircontent(direlemp.getimpl()));
    if (errcode2 != ucontainer::pce__success) {
        Out->Abort("Problem calling begindircontent for '%s' (%s) offset=%s",
                    *path, *ucontainer::error_description(errcode2), *offset.image());
        return errcode2;
    }
    if(deb)DB->msg("BackCycle::begin_dir    ucontainer after  begindirc '%s' loc:%s size:%s",
             *path, *direlemp->get_location().image(), *direlemp->file_size().image());

        return ucontainer::pce__success;
}

ucontainer::errortype BackCycle::end_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc, const ustring path) {
    ucontainer::errortype errcode(ucontainer::pce__success);
    
    
    
    
    const fileoffset offset(container->get_curroffset());

    if(deb)DB->msg("BackCycle::end_dir      ucontainer before enddir    '%s' (offset: %s, mysize=%s) %s",
             *path, *offset.image(), *direlemp->file_size().image(), *desc);

    errcode = container->enddir(direlemp.getimpl());
    if (errcode != ucontainer::pce__success) {
        Out->Abort("BackCycle::end_dir Problem calling enddir for '%s' (%s) offset=%s",
                    *path, *ucontainer::error_description(errcode), *offset.image());
    } else {
        if(deb)DB->msg("BackCycle::end_dirr      ucontainer after  enddir    '%s' loc:%s size:%s",
                       *path, *direlemp->get_location().image(), *direlemp->file_size().image());
    }
    return errcode;
}


fileref BackCycle::build_diratomic(direlemp_list_type& de_listing, fileoffset& totalsize,
                                   bool flags_inode, int max_compchunk_size)
{
    fileref listing2;
    listing2.initlist(int(de_listing.size() * DIRELEM_DOLAYOUT_AVERAGE_SIZE));
    for (unsigned int i=0; i<de_listing.size(); i++) {
       if(!de_listing[i]->dolayout(listing2, false, true, flags_inode, max_compchunk_size))
           DB->msg("WARNING: de_listing[%d] chunk larger than %d, discarded security attributes from %s.",
                   i, max_compchunk_size, *de_listing[i]->fullpath().image());
       totalsize += de_listing[i]->file_size();
    }
    return listing2;
}


replcycle::replcycle(replcycle *parent_, context *main_, workelem* info_)
  :   BackCycle(parent_, main_, info_),
      count_atomic_depth(parent_ == NULL ? false : parent_->count_atomic_depth),
      ddrindexfrombackup(parent_ == NULL ? 0 : parent_->ddrindexfrombackup),
      backupinfop(parent_? parent_->backupinfop : NULL),
      migration_sysinfo_write(parent_? parent_->migration_sysinfo_write : NULL),
      atomic_depth(parent_ == NULL ? -1 : parent_->atomic_depth)
{}




bool replcycle::should_use_raw_containers(const tversion& avtar_version_that_created_backup, const pidtype& pid)
{
    
    return ((pid.kind() == pidtype::vcbimage) ||
            
            (avtar_version_that_created_backup != tversion() &&
             (((pid.kind() == pidtype::ostackimage) || (pid.kind() == pidtype::hypervvss)) &&
              (tversion::MIN_LAGUNA_CLIENT_VERSION == avtar_version_that_created_backup || tversion::MIN_LAGUNA_CLIENT_VERSION < avtar_version_that_created_backup))));
}

void replcycle::update_stats(context::statstype st, stats::reason why, chunktype ctype, double sz) {
    if (sz > 0) {
        main->addfilebytes(st, sz);
        main->addprogbytes(st, sz);
        if(why < stats::lastreason)
            main->getstatsobj(st)->update(why, sz, ctype, false);
    }
}


#if !defined(CLIENT_COMMANDS_H_INCLUDED)
#define CLIENT_COMMANDS_H_INCLUDED












class authid;
class blktraj;
class context;
class namelist;
class roothashlist;
class utar_flags_info;
class synccall;
struct hfs_info_struct;
class hfs_info;

class client_commands {
public:
  SAFEALLOC(client_commands);
  static bool getRootHash    (synccall &sync, hashcode &rh, const blktraj &bn, const authid &au, bool include_partials);
  static bool getRootHashList(synccall &sync, roothashlist &rhl, const blktraj &bn, const authid &au, int maxRec, ubigint64 startTime, ubigint64 endTime, bool include_partials);
  static bool getnamelist    (synccall &sync, namelist &names,const blktraj &bn, const authid &au);


  static exitcodes_t  do_pipe(hfs_info_struct& hfs_info, utar_flags_info& flags, context* mycontext);
  static exitcodes_t  do_user(hfs_info_struct& hfs_info, utar_flags_info& flags);
  static exitcodes_t  do_cycletest(hfs_info_struct& hfs_info, utar_flags_info& flags, context* mycontext);

  static void timetest(utar_flags_info& flags);
  static void testagent();
  static void testagentserver(utar_flags_info& flags);
  static void testdataextents(int iterations);
  static void controltest(utar_flags_info& flags);
  static void testpipe(utar_flags_info& flags);
  static int  pingtest(utar_flags_info& flags);

};

#endif
#if !defined(RESTROOT_H_INCLUDED)
#define RESTROOT_H_INCLUDED















#include <vector>

#include "common.h"
#include "cycle.h"
#include "queue.h"
#include "context.h"
#include "ustring.h"
#include "chunktype.h"
#include "ade/ade_multivolume.h"
#include "ucontainer_base.h"

class async_callback;
class DIRELEM;


class restroot : public multivolumeroot, public bicycle {
public:
    
    restroot(const location& _metadataLocation, context& main_, const upath& path, bool ismapi, const DIRELEM *de = NULL, const location parentdataloc = location());

    
    restroot(const hashcode& hash, context& main_, fileref &resdata, chunktype *ctypep,
             bool rawmode, async_callback *cb, fileoffset startoff=fileoffset(0), fileoffset endoff=fileoffset(0)); 

    
    restroot(context* main_, fileref& res, const DIRELEM* direlem,
             const fileoffset startoff=fileoffset(0), const fileoffset endoff=fileoffset(0), ucontainer::basep containerp = NULL);

    
    restroot(context* main_);

    
    void loadDirectoryTargetList(const DIRELEM* targetDirelem);

    
    void pushPriorCloseParams(void* topdirs, const ustring& frompath, const ustring& topath);

    
    inline ubigint64 getListSize() { return( restoreList.size()); }

    
    bool getCloseParameters(ubigint64 i, void** topdirs, ustring& fromPath, ustring& toPath);

    
    virtual void init();

    
    virtual void childdone(cycle *child);

    virtual ~restroot();

    SAFEALLOC(restroot);
protected:
    bool ispipe;
    fileref resdata;

private:
    struct RestoreElement {
        bicycle*        child;          
        bool            resultOK;       
        DIRELEM         direlem;
        void*           topdirs;        
        upath           fromPath;       
        upath           toPath;
    };
    typedef DEFINE_STL_VECTOR_TYPE(RestoreElement) RestoreList;
    RestoreList restoreList;            

    recursive_mutex restrootlock; 

    void start_one_restore(RestoreElement& restoreElement);
};

#endif

#if !defined(RESTCOMPDATA_H_INCLUDED)
#define RESTCOMPDATA_H_INCLUDED



#include "cycle.h"
#include "fileref.h"
#include "restelem.h"
#include "tagduns.h"
#include "vector.h"

class backappend;


class restcompdata : public cycle {
  public:
    restcompdata(
             cycle *parent,                
             restelem& restinfo,           
             fileref& compdata,            
             const fileoffset offset,      
             chunktype compkind,           
             cycle *starter,               
             const bigint64 prior,         
             int hintconn,                 
             backappend *root_file_cycle = NULL 
             );

    virtual void init();
    void response(message& outargs);
    virtual ~restcompdata();

    SAFEPOOLALLOC(restcompdata);

  private:
    restelem info;                              
    fileref compdata;
    chunktype compkind;
    int redocount;
    const int conn;
    const bigint64 prior;
    backappend *root_file_cycle; 
     
    void send();
    int processchunks(message& outargs, chunktype& ckind, const undoo::vector<tagduns>& chunksizes, fileref& outdata);
    bool verifyhash(chunktype ckind, fileref& outdata, const hashcode& hash, message& outargs);
    bool uncompress(chunktype ckind, fileref& outdata, int& sentsize);
    void exportdata(chunktype ckind, fileref& outdata, fileoffset& offset);
    void show_data(fileref &data, const ustring &msg, hashcode &computed_hash);
};

#endif


#if !defined(RESTELEM_H_INCLUDED)
#define RESTELEM_H_INCLUDED

















#include "fileref.h"
#include "direlem.h"
#include "filestats.h"
#include "chunktype.h"
#include "streamtransform.h"
#include "restorestreamstate.h"
#include "volinfo.h"
#include "ucontainer_base.h"
#include "udirelem.h"
#include "ade/interfaceade_flags.h"

class RestoreStreamState;
class restdir;
class pipe_control;


#define enableslicerestore ((xflag[20]&8192)!=0)



class restelem {
public:
    
    restelem(const upath& path_, DIRELEM& direlem_,
             const filestatsref& fstats_ = filestatsref(),
             bool checkrange_ = false,
             const volinfo vinfo_ = volinfo(),
             const fileoffset startbyte_ = fileoffset(0), const fileoffset endbyte_ = fileoffset(0)
             );
    
    restelem(const ustring& matchpath_, const upath& path_, DIRELEM& direlem_,
             const filestatsref& fstats_ = filestatsref(),
             bool checkrange_ = false,
             const volinfo vinfo_ = volinfo(),
             const fileoffset startbyte_ = fileoffset(0), const fileoffset endbyte_ = fileoffset(0)
             );
    
    restelem(const upath& path_, DIRELEM& direlem_,
             const filestatsref& fstats_, fileref& data_,
             const ucontainer::basep containerp_ = NULL);

    
    restelem(fileref& data_ );

    restelem();

    ~restelem();

    SAFEALLOC(restelem);

    
    restelem( const restelem &rhs );

    
    void exportdata(const fileoffset foOffset, fileref& frWriteThis);

    
    
    bool enableSpecialZipProcessing(const bool shrinkofficexml);

    bool enableSpecialCelerraProcessing(const fileref& compressordata);

    bool isSpecialCelerraProcessingEnabled() const { return m_bSpecialCelerraProcessingEngaged; }

    ustring specialCelerraImage() const;

    
    bool querySecondPassRequired(void);

    
    
    bool prep_restore_of_slice(const hashcode& h, const fileoffset &start, const fileoffset &end);
    
    
    
    
    
    bool init_data_regions_primarydata();

    
    
    
    
    static bool is_celerra_streamslice_restore(const DIRELEM& direlem, const pidtype &backup_pid, const pidtype &running_pid);

    ustring image() const;

  
  
  
  
  
    ustring matchpath;
    upath path;
    DIRELEM direlem;
    filestatsref fstats;
    fileref data;

    volinfo vinfo;         
    fileoffset startbyte;  
                           
    fileoffset endbyte;    
                           

    
    
    restdir *restdircycle; 

    ucontainer::basep container;  

    
    pipe_control* ppipe_control;

    dpns dpninx;           
private:
    RestoreStreamState *m_prss;
public:
    
    bool checkrange : 1;
    bool isroot     : 1;  
    bool rawmode    : 1;  
                          
                          
                          
                          
                          
    bool ignoreStats: 1;  
                          
    bool isprefetching:1; 
    
    
    bool ischangeblockappend:1;

private:
    bool m_bSpecialZipProcessingEngaged : 1; 
    bool m_bSpecialCelerraProcessingEngaged : 1;
};

#endif



















#include "common.h"
#include "debug.h"
#include "context.h"
#include "output.h"
#include "workelem.h"
#include "backstream.h"
#include "backstreamdir.h"
#include "backavpaxstream.h"
#include "backemctardir7.h"
#include "backemctardir6.h"
#include "backisilontardir.h"
#include "backzfstardir.h"
#include "utar_parsestream.h"
#include "emctarstream.h"
#include "isilontarstream.h"
#include "zfstarstream.h"
#if !defined(AVOID_NETWORKER_INTERFACE)
    #include "legato_interface/parsesavestream.h"
#endif
#include "parsestream_ucontainer.h"
#include "mediadesc.h"
#include "ddr_interface.h"
#include "utar_flags_enums.h"
#include "utar_flags_info.h"
#include "utar_commands.h"
#include "runstage.h"
#include "filenames.h"

#include "inode_table_checker.h"
#include "backemctarinode2hash.h"
#include "backupboostdir.h"
using namespace backupboost;





#define backstream_msg      ((xflag[2]&8192)!=0)
#define backstream_msg_only ((xflag[2]&16384)!=0)
#define dump_headers        ((xflag[1]&128)!=0)

#define backstreamdir_msg1  ((xflag[2]&2048)!=0)
#define backstreamdir_msg2  ((xflag[2]&4096)!=0)

#define skipinodetabcheck     ((xflag[20]&4) != 0)

mtex backstream::bb_journal_mutex;









backstream::backstream(BackCycle* parent_, context *main, workelem *info_,
                       const ustring fromstream, exportstream_xmlp& infop,
                       const location::tbackupid prev_backupid_,
                       BackupRootInfoList *backup_list_, bool manual_) :
    BackCycle(parent_, info_),
    parser(NULL),
    phase(initial),
    exportstream_infop(infop),
    prev_backupid(prev_backupid_),
    backup_list(backup_list_),
    prev_backup(),
    thread_started(false),
    manual(manual_),
    session_id(0),
    token(NULL)
{
    if(backstream_msg) DB->msg("backstream::backstream constructor parent:%p, this:%p, stream:%s", parent, this, *fromstream);
    assert(parent != NULL);

    
    bool server_supports_altdata(main->getdpnmaxmessage() >= SETLOGSCAN);
    DB->msg("backstream::backstream server_supports_altdata:%d", server_supports_altdata);
    if (flags.streamformat_in == utar_flags_enums::streamformat_emctar
        && !server_supports_altdata
    ) {
      Out->msg(ERR, "<7332>Server version does not support backup of alternate data streams.  This data will not be saved.  Please upgrade server to at least 3.7.1 to save this data");
    }

    
    if (flags.streamformat_in == utar_flags_enums::streamformat_emctar) 
        uapp::staging().skipWrapup();

    if(flags.streamformat_in == utar_flags_enums::streamformat_savestream) {
#if !defined(AVOID_NETWORKER_INTERFACE)
        parser = new parsesavestream(main, flags,
                                     flags.media_in, flags.streamformat_in);
#else
        Out->msg(ERR, "<7525>Savestream format not supported on this platform");
#endif
    } else {
        if (flags.streamformat_in == utar_flags_enums::streamformat_emctar) {
            Out->msg(INFO, "Stream slice parser for streamformat emctar: On");
            parser = new emctarstream::parser(flags.media_in,
                                              flags.streamformat_in, 
                                              flags.stream_blocksize, 
                                              flags.stream_timeoutsecs, 
                                              (flags.tarstream_use_native_upaths ? parsestream::flags_use_native_upaths : 0),
                                              flags.teeinstream,
                                              &flags, flags.isexplicit("celerrai18n"));
        } else if (flags.streamformat_in == utar_flags_enums::streamformat_isilon) {
            parser = new isilontarstream::parser(flags.media_in,
                                              flags.streamformat_in,
                                              flags.stream_blocksize,
                                              flags.stream_timeoutsecs,
                                              (flags.tarstream_use_native_upaths ? parsestream::flags_use_native_upaths : 0),
                                              flags.teeinstream,
                                              &flags, flags.isexplicit("celerrai18n"));
        } else if (flags.streamformat_in == utar_flags_enums::streamformat_zfs) {
            parser = new zfstarstream::parser(flags.media_in,
                                              flags.streamformat_in,
                                              flags.stream_blocksize,
                                              flags.stream_timeoutsecs,
                                              (flags.tarstream_use_native_upaths ? parsestream::flags_use_native_upaths : 0),
                                              flags.teeinstream,
                                              &flags);
        } else if (flags.streamformat_in == utar_flags_enums::streamformat_cdsf) {

            
            if(flags.nemoresurrect) {
                const mediadesc mediad(flags.media_in);

                
                
                const ustring cdsf_stream_path(mediad.getpath());

                if(flags.ddrenabled) {
                    
                    fileref cdsffr;

                    
                    
                    const ustring srclsu(mediad.get_lsu());

                    
                    
                    int ddrHandle = 0;
                    
                    getAdeMgr()->get_ddrhandle(ddrHandle);

                    
                    DataDomainSysInfo ddrSysInfo;
                    getAdeMgr()->getSysInfo(ddrSysInfo);

                    
                    ddr_interface::initddrread(cdsffr, ddrHandle, srclsu, cdsf_stream_path, 0, (unsigned int)-1);

                    parser = new parsestream_ucontainer(cdsffr,
                                                        flags.streamformat_in,
                                                        0,
                                                        cdsf_stream_path,
                                                        flags.teeinstream);
                } else {
                    parser = new parsestream_ucontainer(cdsf_stream_path,
                                                        flags.streamformat_in,
                                                        0,
                                                        ustring(),
                                                        flags.teeinstream);
                }

            } else {
                parser = new parsestream_ucontainer(flags.media_in,
                                                    flags.streamformat_in,
                                                    0,
                                                    ustring(),
                                                    flags.teeinstream);
            }
        } else if (flags.pluginid.kind() == pidtype::backupboost) {
            
            
            
            
            
            
            
            
            

            
            
            uapp* uappp(uapp::getapp());
            vol_flags.set_defaults();
            vol_flags.read_config(uapp::tool_avtar, uappp->argc, uappp->argv, false);  

            
            
            
            
            
            
            vol_flags.ndmp_prefix = ndmp_entify_volume(info->path.image());

            
            
            hardlink_path_tab.set_mount_path_numelems(info->path.numelems());

        } else {
            parser = new utar_parsestream(main, flags,
                                          server_supports_altdata);
        }
    }

    
    if (flags.pluginid.kind() == pidtype::backupboost)
        phase = thread_cycle;

    
    
    
    
    if (!manual)
        todoEnqueue(TODO_DIR, this);
}

backstream::~backstream()
{
    if(backstream_msg)DB->msg("backstream::~backstream (parent:%p) (this:%p) (parser:%p)", parent, this, parser);
    if (parser) {
        DB->msg("backstream::~backstream about to delete parser (closes fd)");
        delete parser;
    }
}

void backstream::init()
{
    if(backstream_msg) DB->msg("backstream::init (parent:%p) (this:%p) (parser:%p)", parent, this, parser);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    if (phase == thread_cycle) {
        ustring target_path = info->path.image();
        if (isNewStreamThreadOK(getThreadNbr(), info->path)) {
            
            todoEnqueue(TODO_RESPONSE, EMPTYCYCLE);
            thread_started = getrootinfo()->enqueueOnNewThreadRC(target_path, TODO_DIR, this, 0, NULL);
            return;
        } else {
            phase = initial;
        }
    }

    
    
    
    
    
    
    
    if ((flags.streamformat_out == utar_flags_enums::streamformat_cdsf) ||
        (flags.streamformat_in == utar_flags_enums::streamformat_cdsf)  ||
        (flags.pluginid.kind() == pidtype::backupboost)) {
        DB->msg("backstream::init Setting inodetab.use_inode_tree = true");
        inodetab.use_inode_tree = true;
    } else {
        DB->msg("backstream::init Setting inodetab.use_inode_tree = false");
        inodetab.use_inode_tree = false;
    }

    inodetab.is_zfs_backup = (flags.streamformat_in==utar_flags_enums::streamformat_zfs) ? true : false;

    if (phase == initial) {
        
        
        bool inode_table_parsed(false);

        
        if ((flags.pluginid.kind() == pidtype::backupboost) &&
            (flags.backupboostmode != utar_flags_enums::bb_force_level0_full)) {

            
            hfs_info_struct& hfsInfo(main->getAdeMgr()->getHfsInfo(dpn0));
            utar_flags_info dstflags;   
            utar_commands uc(vol_flags, hfsInfo, dstflags);

            if (!flags.isexplicit("count")) {
                
                vol_flags.count = 30;
            }

            
            vol_flags.labelnum = flags.labelnum;

            
            
            
            
            
            vol_flags.backupboostmode = flags.backupboostmode;

            
            
            
            
            vol_flags.incremental = (flags.backupboostmode != utar_flags_enums::bb_force_level0_full);

            
            
            
            
            
            
            if (!bbutils.prepare_incremental(vol_flags, uc, *backup_list, prev_backup, prev_result, inodetab, hardlink_path_tab)) {
                
                
                
                Out->Abort("Unable to proceed with incremental backup for mount '%s'\n", *info->path.image());
                notifyparent();
                return;

            } else {
                
                
                
                if (vol_flags.incremental) {
                    
                    
                    
                    inode_table_parsed = true;

                    
                    assert(info->container.isdefined());

                    
                    prev_backupid = location::tbackupid(prev_backup.getBackupTime());
                    info->container->set_previous_backupid(prev_backupid);

                    
                    if (!populate_previous_location(prev_backup, prev_backupid, vol_flags.ndmp_prefix)) {
                        
                        
                        return;
                    }
                }
            }
        }

        
        if(flags.incremental && !flags.noinodetable &&
           (flags.streamformat_in==utar_flags_enums::streamformat_tar   ||
            flags.streamformat_in==utar_flags_enums::streamformat_avpax ||
            flags.streamformat_in==utar_flags_enums::streamformat_pax   ||
            flags.streamformat_in==utar_flags_enums::streamformat_emctar||
            flags.streamformat_in==utar_flags_enums::streamformat_isilon||
            flags.streamformat_in==utar_flags_enums::streamformat_zfs)
           ) {
            if(!flags.basesnapup_inodetable_path.isempty()) {
                if(!inodetab.parse(flags.basesnapup_inodetable_path)) {
                    
                    
                    
                    Out->msg(FATAL, "<7333>Error parsing previous backup inode table");
                    notifyparent();
                    return;
                } else {
                    inode_table_parsed = true;
                }
            } else {
                Out->msg(WARN, "<7334>Base backup node table not specified");
            }
        }

        
        
        if (inode_table_parsed) {
            
            
            
            ustring table_source((flags.pluginid.kind() == pidtype::backupboost) ?
                                     ustring("labelnum ") + tostr(vol_flags.labelnum) + " for " + info->path.image() :
                                     flags.basesnapup_inodetable_path);

            Out->msg(INFO, "<7353>Successfully read and parsed inode table from '%s'", *table_source);

            if(skipinodetabcheck) {
                Out->msg(INFO, "<10812>Should run inode2hash table cleanup, but --x20 bit 4 is set, not checking.");
            } else if (flags.pluginid.kind() == pidtype::backupboost) {
                Out->msg(INFO, "Should run inode2hash table cleanup for '%s', but disabled for BackupBoost backups.", *info->path.image());
            } else {
                
                
                Out->msg(INFO, "<10813>Running inode2hash table cleanup; table contains %s entries", *tostr(inodetab.entry_count(true)));
                phase = inodetabcheck;
                inode_table_checker *checker = new inode_table_checker(this, &inodetab);
                checker->noop();
                
                
                return;
            }
            if(backstreamdir_msg2)
                inodetab.debug_dump();
        }
    }

    
    
    phase = stream;
    startbackstreamdir();
}

void backstream::startbackstreamdir()
{
    if (flags.streamformat_in==utar_flags_enums::streamformat_emctar) {
        if (disable_cmr10_inflation) {
            Out->msg(INFO, "<10814>Disabling Celerra/VNX CMR10 inflation.  Expect low sub-file commonality over time for Celerra/VNX deduped files");
        } else {
            Out->msg(INFO, "<10815>Enabling Celerra/VNX CMR10 inflation if detected.");
        }
    }

    if (flags.regenerate_inode2hash) {
        
        
        
        

        
        workelem* w = info;
        if (phase == avpaxstream) {
            
            
            
            w = new workelem(NULL, info->direlemp);
            w->direlemp->set_hash(hash);
            w->path = upath("");

            phase = stream;
        }

        bool use_ddr = flags.ddrenabled && (flags.destination_data != client_config_flags::ddr_to_gsan);
        const bool is_zfs_backup(flags.streamformat_in == utar_flags_enums::streamformat_zfs);
        Out->msg(INFO, "Regenerating inode2hash: %s",
                 *info->direlemp->file_hash().partialimage());
        backemctarinode2hash *regen_i2h = new backemctarinode2hash(this, w, prev_backupid, use_ddr, false , 0 , is_zfs_backup);
        regen_i2h->noop();
        return;
    }

    if (flags.celerra_vnx_avamar_enhancements) {
        
        Out->msg(INFO, "<10817>Backstream creating root backemctardir7 object");
        
        
        
        backemctardir7 *emctardir = new backemctardir7(this, info, parser, 0, inodetab);
        emctardir->noop();

    }  else if (flags.streamformat_in==utar_flags_enums::streamformat_emctar) {
        
        Out->msg(INFO, "Backstream creating root backemctardir6 object");
        backemctardir6 *emctardir = new backemctardir6(this, info, parser, 0, inodetab);
        emctardir->noop();

    }  else if (flags.streamformat_in==utar_flags_enums::streamformat_avpax ||
                flags.streamformat_in==utar_flags_enums::streamformat_cdsf) {
        Out->msg(INFO, "<12565>Backstream creating root backavpaxstream object");
        
        
        workelem *w = new workelem(info, info->direlemp->fullpath(), info->direlemp);
        backavpaxstream *paxstream = new backavpaxstream(this, main, w, parser, 0, exportstream_infop,
                                                         undoo::make_shared<direlemp_list_type>(),
                                                         backavpaxstream::flag_should_output_listing);

        
        
        phase = avpaxstream;

        
        todoEnqueueInsert(TODO_DIR, paxstream, 1);

        paxstream->noop();

    } else if (flags.streamformat_in==utar_flags_enums::streamformat_isilon) {






#if !SYSTEM_UNIX_HPUX_ITANIUM
        Out->msg(INFO, "Backstream creating root backisilontardir object");
        backisilontardir *isilontardir = new backisilontardir(this, info, parser, 0, inodetab);
        isilontardir->noop();
#else
        Out->msg(ERR, "Isilon NDMP backup/restore is not supported on HP11i platform.");
        assert(false);
#endif

    } else if (flags.streamformat_in==utar_flags_enums::streamformat_zfs) {
        Out->msg(INFO, "Backstream creating root backzfstardir object");
        backzfstardir *zfstardir = new backzfstardir(this, info, parser, 0, inodetab);
        zfstardir->noop();

    } else if (flags.pluginid.kind() == pidtype::backupboost) {
        
        bool proceed_with_backup(true);
        backupboost_interface bb_int;

        if (!bb_int.initialize()) {
            Out->msg(ERR, "BackupBoost begin %s failed to load shared library",
                          (vol_flags.incremental) ? "incremental" : "full");
            proceed_with_backup = false;
        }   

        
        
        if (vol_flags.incremental) {
            long session_switch_time(0);
            int format_version(0);
            vol_flags.media_in = flags.vardir/ustring("clientlogs")/ustring(vol_flags.ndmp_prefix + "-listing.txt");
            
            
            bb_journal_mutex.lock();
            freopen(vol_flags.media_in.tostr(), "w", stdout);
            int err_code = bb_int.begin_incremental_backup(info->path.image(), prev_result.session_id, true,
                                                           session_id, session_switch_time, format_version, token);
            fclose(stdout);
            bb_journal_mutex.unlock();
            if (err_code != LFS_SUCCESS) {
                
                
                
                
                ustring result_code(bb_int.err_code_to_desc(err_code));

                
                if (vol_flags.backupboostmode == utar_flags_enums::bb_synthetic_full_only) {
                    
                    Out->msg(ERR, "BackupBoost begin incremental backup failed for '%s' : returned '%s' (return code:%d)",
                             *info->path.image(), *result_code, err_code);
                    proceed_with_backup = false;

                } else {
                    
                    
                    Out->msg(INFO, "BackupBoost begin incremental for '%s' returned '%s' (return code:%d).  Performing a full backup instead",
                             *info->path.image(), *result_code, err_code);
                    vol_flags.incremental = false;  
                }

            } else {
                
                Out->msg(INFO, "Beginning incremental backup for '%s' (current session_id: '%s', previous session_id: '%s')",
                        *info->path.image(), *tostr(session_id), *tostr(prev_result.session_id));

                
                DB->msg("backstream::startbackstreamdir: Pre-process events for '%s' from '%s'", *info->path.image(), *vol_flags.media_in);
                if (!bbutils.preprocess(inodetab, hardlink_path_tab, bbeventlist, &vol_flags)) {
                    Out->msg(ERR, "BackupBoost unable to pre-process journal events for '%s'", *info->path.image());
                    proceed_with_backup = false;
                } else {
                    if (backstreamdir_msg2) {
                        DB->msg("\n"); DB->msg("backstream::startbackstreamdir: Main event list after adding extra events"); bbeventlist.dump();
                    }
                }
            }
        }

        
        if (!vol_flags.incremental) {
            int err_code = bb_int.begin_full_backup(info->path.image(), session_id, token);
            if (err_code != LFS_SUCCESS) {
                Out->msg(ERR, "BackupBoost begin full backup failed for '%s' : returned '%s' (return code:%d)",
                         *info->path.image(), *bb_int.err_code_to_desc(err_code), err_code);
                proceed_with_backup = false;

            } else {
                
                Out->msg(INFO, "Beginning full backup for '%s' (current session_id: '%s')",
                        *info->path.image(), *tostr(session_id));
            }
        }

        if (proceed_with_backup) {
            backupboostdir *backupboostcycle = new backupboostdir(this, parent, info, 0, session_id, token, inodetab, hardlink_path_tab, bbeventlist, &vol_flags, prev_backup);
            backupboostcycle->noop();

        } else {
            
            
            Out->Abort("Unable to proceed with backup for mount '%s'\n", *info->path.image());
            notifyparent();
            return;
        }

    } else {
        Out->msg(INFO, "<10818>Backstream creating root backstreamdir object");
        backstreamdir *streamdir = new backstreamdir(this, main, info, parser, 0, info->use_container);
        streamdir->noop();
    }
}

void backstream::childdone(cycle *child)
{
    if(backstream_msg) DB->msg("backstream::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d", parent, this, child, nforked, ncollected);

    switch (phase) {
    case initial:
        assert(false); 
        break;
    case inodetabcheck:
        Out->msg(INFO, "<10819>Finished inode2hash table cleanup; table now contains %"Z"d entries", inodetab.entry_count(true));
        phase = stream;
        startbackstreamdir();
        break;
    case avpaxstream:
        DB->msg("backstream::childdone in phase 'avpaxstream' checking for AER import of Celerra or Isilon NDMP backup");
        
        
        if(flags.streamformat_in==utar_flags_enums::streamformat_avpax &&
           flags.dtoexportstream && !exportstream_infop.isnull() &&
           ((exportstream_infop->get_pid() == pidtype(pidtype::os_celerra + pidtype::ndmp)) ||
            (exportstream_infop->get_pid() == pidtype(pidtype::os_isilon + pidtype::ndmp )))) {
            Out->msg(INFO, "Performing inode table regeneration for AER import of NDMP backup");

            
            
            flags.regenerate_inode2hash = true;
            startbackstreamdir();

            break;
        }
        
    case stream:
        
        
        DB->msg("backstream::childdone in phase 'stream' about to notify parent");
        if(thread_started) {
            thread_started = false;
            todoEnqueue(TODO_DONE, NULL);           
            setThreadNbr(parent->getThreadNbr());   

            
            
            if (info->use_container && !info->container.isnull()) {
                main->finalizeucontainer(info->container);
            }
        }
        if (flags.pluginid.kind() == pidtype::backupboost) {
            backupboost_interface bb_int;

            if (!bb_int.initialize()) {
                Out->msg(ERR, "Failed to load BackupBoost shared library");
            }   

            if (!vol_flags.incremental) {
                
                int err_code = bb_int.end_full_backup(token, session_id);
                if (err_code != LFS_SUCCESS) {
                    Out->msg(ERR, "BackupBoost end full backup failed for %s : '%s' (return code:%d)",
                             *info->path.image(), *bb_int.err_code_to_desc(err_code), err_code);
                }

                size = child->size;

            } else {
                
                int err_code = bb_int.end_incremental_backup(session_id, token);
                if (err_code != LFS_SUCCESS)
                    Out->msg(ERR, "BackupBoost end incremental backup failed for %s : '%s' (return code:%d)",
                             *info->path.image(), *bb_int.err_code_to_desc(err_code), err_code);
            }
        }
        notifyparent();
        break;
    default:
        assert(false); 
    }
}



void backstream::response(message& outargs)
{
  if(backstream_msg)DB->msg("backstream::response (parent:%p) (this:%p)", parent, this);
  assert(false);
}




bool backstream::populate_previous_location(const BackupRootInfo &prev_backup,
                                            const location::tbackupid &backupid,
                                            const ustring &prefix) {

    const hfs_info_struct& hfsInfo = main->getAdeMgr()->getHfsInfo(dpn0);
    DIRELEM de;
    ustring errdesc;
    const upath vol_path = upath(prefix);
    upath target;
    location de_loc(de.get_location());

    
    de_loc.set_backupid(backupid);
    de.set_location(de_loc);
    DB->msg("backstream::populate_previous_location(): looking up volume:%s", *prefix);
    if (!utar_commands::get_direlem(hfsInfo, vol_flags, prev_backup.getRootLocation(),
                                    vol_path, de, errdesc, target)) {
        
        Out->Abort("Failed to find volume %s in previous (base) backup", *prefix);
        return false;
    } else {
        
        
        const location parent_loc; 
        main->set_location_info("backstream::populate_previous_ndmp_location()", parent_loc, de);

        
        info->direlemp->set_location(de.get_location());
    }
    return true;
}
#if !defined(EMCTARPIPE_H_INCLUDED)
#define EMCTARPIPE_H_INCLUDED












#include "pipe_control.h"
#include "fileref.h"
#include "direlem.h"
#include "ustring.h"
#include "userid.h"
#include "paxndmp.h"



class emctarpipe : public pipe_control {
public:
    
    
    emctarpipe(fileref& data_, const userid *uidmap_, const groupid *gidmap_,
               const ustring &pathprefix_, const bool i18n, const bool rewrite_i18n, const ustring ndmp_prefix);

    ustring get_path_prefix() const { return pathprefix; }

    ustring convert_path_to_hardlink_path(const ustring& direlemfullpath) const;

    static bool islnk(const DIRELEM &de);
    static bool isfifo(const DIRELEM &de);
    static bool ischr(const DIRELEM &de);
    static bool isblk(const DIRELEM &de);

    SAFEALLOC(emctarpipe);

protected:
    void fillemcheader(struct HD_EMC &head, const DIRELEM &de, const ustring &fullpath, int extattrsize, 
                       bool is_hardlink, const ustring &linkcontent);
    
    
    
    
    
    
    virtual bool fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                            const DIRELEM& elem,  const ustring& path,
                            const filetype ftype, const ustring& linkname,
                            const fileoffset startoff=fileoffset(0));
private:
    bool check_streamslices(fileoffset &filesize, fileoffset &altdatasize, fileoffset &stubdatasize, const DIRELEM &elem) const;

    
    
    
    bool checkemctardedup(const DIRELEM& elem, fileoffset& reservesize);

    const userid *uidmap;
    const groupid *gidmap;
    ustring pathprefix;
    const bool i18n;
    const bool rewrite_i18n;
    ustring ndmp_prefix;

    
    

    void fillmyblock(fileref &fref);
};


#endif




#if !defined(REPLFILE_H_INCLUDED)
#define REPLFILE_H_INCLUDED












#include "cycle.h"
#include "hashcode.h"
#include "fileref.h"
#include "chunktype.h"
#include "restelem.h"
#include "direlem.h"
#include "filepipe.h"
#include "backappend.h"

class workelem;


class replfile : public replcycle {
public:
    replfile(replcycle *parent, const hashcode& hash, const int sliceoff,
             const ustring& name,
             chunktype ctype, const int traverse_depth, workelem* info, cycle *starter);
    virtual void init();
    void response(message& outargs);
    void childdone(cycle *child);
    virtual ~replfile();
    SAFEPOOLALLOC(replfile);

private:
    
    class repldumper : public filepipedump_base {
    public:
        
        repldumper(replfile* repl_, workelem* info);

        
        ~repldumper();

        
        virtual int dump(const fileref& data);

    private:
        replfile *repl;
        workelem *info;
    };
    
    class replfetcher : public threadbase {
    public:
        replfetcher(replfile *repl,
                    restelem& restinfo,
                    workelem* info,
                    bool validate,
                    int media_in_size);
        virtual void body();
        SAFEALLOC(replfetcher);
    private:
        replfile *repl;
        restelem& restinfo;
        workelem* info;
        bool validate;
        int media_in_size;
    };


    friend class replfile::repldumper;    
    friend class replfile::replfetcher;

    hashcode rhash;
    const ustring name;
    chunktype ctype;
    DIRELEM dir;
    const int traverse_depth;
    int phase;
    restelem restinfo;
    bool use_raw_container;

    
    bool container_cachehit(DIRELEMp direlem, location loc);

    
    void update_progress(double sz);
};

#endif

#if !defined(RESTFILEUSINGEXTENTS_H_INCLUDED)
#define RESTFILEUSINGEXTENTS_H_INCLUDED












#include "cycle.h"
#include "ade_restore.h"
#include "restelem.h"
#include "volinfo.h"
#include "ucontainer_base.h"
#include "resource_identifier.h"

class DIRELEM;
class pipe_control;

class restfileusingextents : public bicycle, nsAdeLib::ADERestore {
public:
    SAFEPOOLALLOC(restfileusingextents);

    restfileusingextents(bicycle*          parent,
                         DIRELEM&          direlem,
                         const restelem&   restinfo,
                         const hashcode&   extentshash_,
                         ucontainer::basep container = NULL,
                         cycle*            starter = NULL,
                         const volinfo     vinfo = volinfo());

    virtual void init();

    virtual void childdone(cycle *child);

    virtual ~restfileusingextents();

private:
    restelem info;

    const hashcode extentshash;

    
    enum {
        phase_construction        = 0,
        phase_restoring_extents   = 1,
        phase_restoring_data      = 2,
        phase_done                = 3,
    };
    int phase; 

    
    fileref extentsdata;

    
    resource_identifier resourceid;

    
    pipe_control* ppipe_control;
};



#endif






















#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backemctardir7.h"
#include "parsestream_base.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "emctar_history.h"
#include "dirrec_pack.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "streambuffer.h"               
#include "streamtransformemctardedup.h" 

#include "ndmp_volume_entification.h"
#include "emctarstream.h"
#include "backdirstreamslice.h"
#include "utar_ctl_sup.h"

#include <algorithm>





#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define verbosealternative ((xflag[1]&16384)!=0) 








backemctardir7::backemctardir7(BackCycle* parent_, workelem *info_,
                               parsestream_base *parser_, int traverse_depth_,
                               inode_table &inodetab_,
                               int mount_point_numelems_ ,
                               emctar_history *hist ,
                               MetadataIntf_sp parent_metadataIntfp_)
    : backndmptardir_base(parent_, info_, parser_, traverse_depth_,
                          inodetab_, mount_point_numelems_, parent_metadataIntfp_),
                          histlist(NULL), 
                          histsrv(hist)
{
    if(msg1) DB->msg("backemctardir7::backemctardir7 constructor (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    inode_is_64_bits = true;

    
    if (traverse_depth == 0) {
        if (!flags.ndmp_history_pipe_name.isempty()) {
            
            assert(histsrv == 0);
            histsrv = new emctar_history(parent->main, upath(flags.ndmp_history_pipe_name),
                                         upath(flags.save_ndmp_history));
            DB->msg("backemctardir7::backemctardir7() started emctar_history");
        }

        if (info->use_container) {
            
            determine_volume_offset();
        }
    }

    todoEnqueueInsert(TODO_DIR, this, -traverse_depth); 

    
    
    if (info->use_container && info->direlemp->is_directory()) {
        
        
        
        add_directory_to_container();
    }

    
    
    
    
    if (catalog_enabled && info->direlemp->is_directory()) {
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'", *info->direlemp->fullpath().image());
            return;
        }
    }

    if (info->direlemp->is_directory()) {
        process_dir_data(info->direlemp);
    }
}

backemctardir7::~backemctardir7()
{
    if(msg1) DB->msg("backemctardir7::~backemctardir7 destructor "
                           "(parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    subtract_from_direlem_commitment(cycle_direlem_commitment);

    if (traverse_depth == 0 && histsrv != NULL) {
        
        delete histsrv;
    }
}







void backemctardir7::init()
{
    if (!flags.incremental && throttle_child_spawning()) {
        
        
        
        
        insert_self(info->direlemp);
        return;
    }

    static int count;
    ++count;
    if(msg1 || (count%1000) == 0)
        DB->msg("backemctardir7::init cnt=%d (parent:%p) (this:%p), depth=%d info->direlemp:%s",
                count, parent, this, traverse_depth, *info->direlemp->fullpath().image());

    if (phase != phase_init) {
        
        

        if (info->use_container && !save_obj_direlem->is_directory()) {
            
            
            

            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->endfile(save_obj_direlem.getimpl(), 0)) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->msg(ERR,"Problem creating container endfile for %s (%s)",
                        *save_obj_direlem->fullpath().image(), *errdesc);
            } else if (flags.incremental) {
                location loc(save_obj_direlem->get_location());

                
                
                
                
                
                
                if (cur_synthlist_coversize == 0) {
                    cur_synthlist_offset = loc.get_abs_offset_in_container();
                    if (msg2) DB->msg("backemctardir7::init: Reset cur_synthlist_offset to abs_offset_in_container (offset:%"LL"d)",
                                      cur_synthlist_offset.value());
                }

                
                
                
                
                if ((save_obj_direlem->hard_links() > 1) && !save_obj_direlem->is_tar_hardlink()) {
                    
                    
                    add_files_to_synth_list(&cur_synthlist);
                    
                    

                    
                    cur_synthlist.add_hardlink_data((ubigint64)save_obj_direlem->inode_number64());
                    assert ((cur_synthlist_coversize == 0) && (cur_synthlist_checksum == 0));  
                }

                
                
                
                
                
                cur_synthlist_coversize += loc.get_coverage_size();
                cur_synthlist_checksum ^= loc.get_checksum().value;  
                if (msg2) DB->msg("backemctardir7::init: cur_synthlist (offset:%"LL"d coversize:%"LL"d checksum:%u)",
                                  cur_synthlist_offset.value(), cur_synthlist_coversize.value(), cur_synthlist_checksum);
            }
        }
    }

    if(!get_next_header(save_obj_direlem, save_altdata, save_stubdata)) {
        
        
        

        
        
        
        
        if (info->use_container && (inodetab.current_container_location.get_containerid() == 0)) {
            save_location_template(info->direlemp->get_location(), false );
        }

        if (info->use_container && info->direlemp->is_directory() && !reserved_hiddendir) {
            
            
            

            if (flags.incremental) {
                
                add_files_to_synth_list(&cur_synthlist);
                
                
            }

            
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->msg(ERR,"Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *errdesc);
            }

            if (msg2) DB->msg("DDR: backemctardir7::init DIR LOCATION %s is %s",
                              *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());

            if (flags.incremental) {
                
                
                
                
                
                
                
                
                
                
                if (!dir_header_added) {
                    
                    add_dir_header_to_synth_list(&cur_synthlist);
                    
                    
                }

                
                inode_table::data_block synth_item;
                
                location loc(info->direlemp->get_location());
                
                
                synth_item.block_begin = (ubigint64)(loc.get_abs_offset_in_container() + loc.get_coverage_size() - loc.get_footer_size()).value();
                synth_item.block_size = (bigint64)loc.get_footer_size().value();
                synth_item.block_checksum = loc.get_checksum().footer_value;
                cur_synthlist.add_item(synth_item);
                if (msg2) DB->msg("backemctardir7::init Added entry (footer for '%s') to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                                  *info->direlemp->name(), synth_item.block_begin, synth_item.block_size, (ubigint64)cur_synthlist.list_size());
            }
        }  
        return;
    }

    set_phase(phase_read_data);
    process_direlem(save_obj_direlem, save_altdata, save_stubdata);
    insert_self(save_obj_direlem);
}




bool backemctardir7::get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata)
{
    

    
    
    altdata  = fileref::empty;
    stubdata = fileref::empty;

    bool pushed_entry = parser->has_pushed_entry();

    bool get_entry_ret = parser->getentry(obj_direlem, altdata, stubdata);

    
    
    if (!get_entry_ret && !max_changed_date_msg_sent) {
        send_max_changed_date();
    }

    if(!get_entry_ret || obj_direlem.isnull()) {
        
        
        

        if (flags.incremental && phase==phase_init) {
            
            if(parser->is_empty_stream()) {
                const upath parent_path("");
                DB->msg("backemctardir7::get_next_header empty stream reading previous backup path for parent '%s'",
                        *parent_path.image());
                
                location prev_loc(inodetab.base_container_location);
                prev_loc.get_abs_offset_in_container() = 0;

                
                
                
                
                
                
                
                prev_loc.set_containerid(0);
                prev_loc.set_enclosing_container(NULL);  

                cycle *child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, prev_loc, prevlist);
                child->noop();
                nforked++;
                forked_prev_restore = true;
            }
        }

        set_phase(phase_wait_for_history); 
        childdone(NULL);

        if ((NULL != histsrv) && (traverse_depth == 0))
            
            
            histsrv->data_stream_done(); 

        return false;
    }

    if (!set_new_direlem_path(obj_direlem, pushed_entry)) return false;

    if(obj_direlem->name().isempty()) {   
        
        
        Out->msg(ERR, "<7397>Illegal tar record found, name field is empty at streamoffset:%s.",
                 *parser->get_headeroffset().image());
        
        
        insert_self(obj_direlem);
        return false;
    }

    const upath curpath(info->direlemp->fullpath());
    const int   cur_path_elems(curpath.numelems()); 
    const upath newpath(obj_direlem->fullpath());
    const int   new_path_elems(newpath.numelems());    

    if(msg2)
        DB->msg("backemctardir7::get_next_header cur_path_elems:%d(%s)[0]='%s' "
                      "new_path_elems:%d(%s)[0]='%s' curroffset:%s",
                cur_path_elems, *curpath.image(), *curpath.get(0),
                new_path_elems, *newpath.image(), *newpath.get(0),
                *parser->get_headeroffset().image());

    if (new_path_elems <= cur_path_elems) {
        
        
        if(msg2)DB->msg("backemctardir7::get_next_header exiting2 because path is in parent (%d <= %d) '%s'",
                        new_path_elems, cur_path_elems, *obj_direlem->fullpath().image());
        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_wait_for_history); 
        childdone(NULL);
        return false;
    }

    
    
    
    
    
    if (new_path_elems > cur_path_elems+1) {
        
        
        
        
        if(msg1)DB->msg("backemctardir7::get_next_header big step '%s' vs "
                              "'%s' new_path_elems:%d cur_path_elems+1:%d",
                        *curpath.image(), *newpath.image(), new_path_elems, cur_path_elems+1);

        assert(obj_direlem->is_directory()); 

        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        

        
        altdata = fileref::empty;
        assert(stubdata.isnull());

        
        obj_direlem->set_security(fileref::empty);

        
        obj_direlem->set_fullpath(newpath.slice(0, cur_path_elems));
        obj_direlem->set_name(obj_direlem->fullpath().stripdir());
        obj_direlem->set_is_root();  
        if(msg1)DB->msg("backemctardir7::get_next_header big step new path '%s' name '%s'",
                        *obj_direlem->fullpath().image(), *obj_direlem->name());
    }

    if(msg2)DB->msg("backemctardir7::get_next_header returns obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *obj_direlem->file_size().image(), *altdata.size64().image(),
                    *stubdata.size64().image());
    return true;
}


void backemctardir7::process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata) {

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                *obj_direlem->name(), obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                 *obj_direlem->name(), obj_direlem->file_size().dvalue());

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)
        DB->msg("backemctardir7::process_direlem obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                *stubdata.size64().image());

    fileoffset patchoffset = 1;  

    
    
    if (flags.incremental) {
        bool added = curlist.split_enter_if_undef(obj_direlem->inode_number64(), obj_direlem->name(), obj_direlem);
        if (!added) {
            Out->msg(ERR, "While processing %s (inode %s) found a second entry with inode '%s' and name '%s'",
                     *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
					 *tostr(obj_direlem->inode_number64()), *obj_direlem->name());
        }
    }

    
    ordered_curlist.push_back(obj_direlem);

    if(msg2)
        DB->msg("backemctardir7::process_direlem: Added to ordered_curlist('%s', '%s')",
                *obj_direlem->name(), *obj_direlem->fullpath().image());

    
    
    if (info->use_container && !dir_header_added && flags.incremental && info->direlemp->is_directory()) {
        
        
        
        add_dir_header_to_synth_list(&cur_synthlist);
        
        
    }

    
    
    if (info->use_container && !obj_direlem->is_directory()) {
        
        

        ucontainer::errortype errcode;

        if ((errcode = info->container->beginfile(obj_direlem.getimpl(), datasize, 1 )) != ucontainer::pce__success) {
            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
            Out->msg(ERR,"Problem creating container beginfile for %s (%s)",
                    *obj_direlem->fullpath().image(), *errdesc);
        } else {
            if (msg2) DB->msg("DDR: backemctardir7::process_direlem: abs_offset_in_container: %"LL"d beginfile for file %s",
                              obj_direlem->get_location().get_abs_offset_in_container().value(),
                              *obj_direlem->fullpath().image());
        }
    }

    if(obj_direlem->is_directory()) {
        
        child_dir_count++;
        
        

        
        
        if (info->use_container && flags.incremental) {
            
            add_files_to_synth_list(&cur_synthlist);
            
            

            
            if (msg2) DB->msg("backemctardir7::process_direlem: Adding directory '%s' to cur_synthlist within '%s'",
                              *obj_direlem->name(), *info->direlemp->name());
            cur_synthlist.add_dir((ubigint64)obj_direlem->inode_number64());
        }

        
        
        if(msg2) DB->msg("backemctardir7::process_direlem subdir for %s", *obj_direlem->fullpath().image());
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        backemctardir7 *subdir = new backemctardir7(this, w, parser, traverse_depth+1,
                                                    inodetab, mount_point_numelems, histsrv,
                                                    my_metadataIntfp);
        subdir->noop();
        nforked++;

    } else if(obj_direlem->is_symlink() && datasize == 0) {
        
        
        fileref link = parser->get_symlink_data();
        assert(!link.isnull());
        datasize = link.size();
        obj_direlem->set_file_size(datasize);

        if(msg2)DB->msg("Handling inline symlink, size=%d", datasize.ivalue());
        workelem *w = new workelem( info, link );
        cycle *linkchild = new nbackdata(this, w, patchoffset, false , 0, info->use_container);
        linkchild->noop();
        nforked++;

    } else { 
        if(msg2) DB->msg("Streamslice mode file, size=%"LL"d", datasize.value());

        
        obj_direlem->set_stdin();       
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        if (obj_direlem->is_tar_hardlink()) {
            if (msg2)
                DB->msg("backemctardir7::process_direlem this:%p obj_direlem:%s is_tar_hardlink:1",
                        this, *obj_direlem->fullpath().image());
            
            
            
            
            
            w->hold_data = true;
        }
#if CELERRA_CMR10
        bool emctardedup = false;
        if (!stubdata.isnull() || stubdata.size() > 0) {
            emctardedup = isstubemctardedup(stubdata);
        }

        if (emctardedup && !disable_cmr10_inflation) {
            if (msg2)
                DB->msg("backemctardir7::process_direlem obj_direlem:%s is cmr10 dedup compressed, "
                        "setting StreamtransformEmctarDedup in workelem",
                        *obj_direlem->fullpath().image());
            w->st = new StreamtransformEmctarDedup();
            w->sb = new Streambuffer();
        }
#endif
        nbackdata *cycle_chunk = new nbackdata( this, w, patchoffset, false, parser, info->use_container );
        cycle_chunk->noop();
        nforked++;
        size += datasize;
    }

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    if(msg2)DB->msg("backemctardir7::process_direlem DONE obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                    *stubdata.size64().image());
}


void backemctardir7::childdone(cycle *child)
{
    if(msg1) DB->msg("backemctardir7::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d",
                     parent, this, child, nforked, ncollected);

    if (child) {
        ncollected++;

        switch (phase) {
        case phase_init:
            return;

        case phase_read_data:
        case phase_wait_for_history:
            
            
        case phase_wait_for_children:
            
            
        case phase_forksdone:
            
            
            
            if(child == data_hasher_child)  {
                
                main->safesetactivelimit(TODO_MAX, "return from prevlist", true);
                break; 
            }
            
        case phase_do_hidden: {
            
            
            
            
            
            backemctardir7 *dc_dir = dynamic_cast<backemctardir7 *>(child);
            if (dc_dir != NULL) {
                
                

                
                child_dir_count--;
                
                

                DIRELEMp de(dc_dir->getInfo()->direlemp);
                if (info->use_container) {
                    
                    
                    ubigint64 child_inode(de->inode_number64());

                    
                    
                    childlist.add_child(child_inode);
                    if (msg2) DB->msg("backemctardir7::childdone: Added inode %s to child_dir_list. List size=%"LL"d",
                    		*tostr(child_inode), (ubigint64)childlist.list_size());

                    if (flags.incremental) {
                        
                        
                        merged_coverage_size += dc_dir->merged_coverage_size;
                        if (msg2) DB->msg("backemctardir7::childdone  Updated merged_coverage_size for %s to:%"LL"d (added %"LL"d from child dir)",
                                          *info->direlemp->name(), (bigint64)merged_coverage_size.value(), (bigint64)dc_dir->merged_coverage_size.value());

                        
                        
                        merged_checksum ^= dc_dir->merged_checksum;
                        if (msg2) DB->msg("backemctardir7::childdone  Updated merged_checksum for %s to:%u (included %u from previous backup)",
                                          *info->direlemp->name(), merged_checksum, dc_dir->merged_checksum);
                    }
                }

                
                
                if (catalog_enabled) {
                    MetadataIntf_sp metadatap = dc_dir->my_metadataIntfp;
                    direlemp2metadatap.insert(std::make_pair(de.getimpl(), metadatap));
                    if (msg2) DB->msg("backemctardir7::childdone: Added child dir '%s' to metadata map (de.getimpl=%p, metadatap=%p, map_size=%d)",
                                      *de->name(), de.getimpl(), metadatap.get(), (int)direlemp2metadatap.size());
                }
            }

            
            
            nbackdata *dc_file = dynamic_cast<nbackdata *>(child);
            if (dc_file && dc_file->get_depkind() == none) {
                DIRELEMp de(dc_file->getInfo()->direlemp);
                remember_hardlinked_info(de);
            }
            break;
        }
        case phase_done: {
            commit_directory_metadata();
            notifyparent();
            
            
            return;
        }
        default:
            assert(false);
        }
    }

    if(msg1) DB->msg("backemctardir7::childdone this:%p phase:%d forked_prev_restore:%d nforked=%d ncollected=%d",
                     this, phase, forked_prev_restore, nforked, ncollected);

    if ((phase == phase_wait_for_history) || (phase == phase_wait_for_children)) {
        process_wait_phases(histlist ? static_cast<int> (histlist->size()) : 0);
    } 

    if ((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)) {
        if (flags.incremental) {
            
            
            
            process_forksdone_phase_part1(&cur_synthlist, &prev_synthlist);
        }

        
        
        
        
        if (catalog_enabled) {
            
            
            
            if (!add_children_to_metastore()) {
                Out->Abort("Problem adding children to the Metadata store for directory '%s'", *info->direlemp->fullpath().image());
                return;
            }
        }

        
        
        
        
        
        process_forksdone_phase_part2(child, &cur_synthlist, &prev_synthlist);
    } 

    
    if ((phase == phase_do_hidden) && (ncollected == nforked)) {
        process_do_hidden_phase();
    }
}







void backemctardir7::remember_hardlinked_info(DIRELEMp &de)
{
    if (msg2)
        DB->msg("backemctardir7::remember_hardlinked_info for %s", *info->direlemp->fullpath().image());

    if (de->is_directory() || (de->hard_links()<2) || de->is_tar_hardlink()) {
        if (msg2) DB->msg("backemctardir7::remember_hardlinked_info ignoring dir:%d nlink:%u hl:%d inode:%s %s",
                          de->is_directory(), de->hard_links(), de->is_tar_hardlink(), *tostr(de->inode_number64()), *de->fullpath().image());
        return;
    }

    
    
    if (msg2)
        DB->msg("backemctardir7::remember_hardlinked_info inode:%s nlink:%d %s",
        		*tostr(de->inode_number64()), de->hard_links(), *de->fullpath().image());

    
    
    
    
    const MetadataId metadataid(de->file_hash());
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false,
                           de->get_location().get_abs_offset_in_container().value());

        
        childlist.add_child(de->inode_number64());
        if (msg2) DB->msg("backemctardir7::remember_hardlinked_info: Added inode %s to child_dir_list. List size=%"LL"d",
        		     *tostr(de->inode_number64()), (ubigint64)childlist.list_size());
        
        
    } else {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false);
    }
}









void backemctardir7::request_prevlist()
{
    forked_prev_restore = true; 

    if(!flags.incremental)
        return;

    if(flags.noinodetable) {
        
        return;
    }

    ubigint64 de_inode = info->direlemp->inode_number64();
    MetadataId metadataid;
    fileoffset size;
    bool wasdir = false;
    ubigint64 dir_offset;
    upath path("");

    
    if(!inodetab.find_entry(de_inode, metadataid, size, wasdir, dir_offset)) {
        if (msg2)
            DB->msg("backemctardir7::request_prevlist for '%s' no entry in inode_table for inode:%s", *info->direlemp->fullpath().image(), *tostr(de_inode));
        if (de_inode == 2) {
            
            
            
            wasdir = true;
            metadataid = main->prev_backup.getRootLocation().getMetadataId();
            if (msg2) DB->msg("backemctardir7::request_prevlist: Retrieved MetadataId '%s' for previous backup", *metadataid.partialimage());
            path = upath(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), true);
            dir_offset = 0; 
        } else {
            if (msg1)
                DB->msg("backemctardir7::request_prevlist for '%s' inodetab.find_entry(%s) returned false",
                        *info->direlemp->fullpath().image(), *tostr(de_inode));
            return;
        }
    }

    if (!wasdir) {
        if (msg1) DB->msg("backemctardir7::request_prevlist entry in inode_table for inode:%s was not a directory", *tostr(de_inode));
        return;
    }

    if(msg1)
        DB->msg("backemctardir7::request_prevlist for '%s' starting restdirlist using MetadataId:%s diroffset:%"LL"u path:%s",
                *info->direlemp->fullpath().image(), *metadataid.partialimage(), dir_offset, *path.image());

    
    location prev_loc(inodetab.base_container_location);
    prev_loc.set_abs_offset_in_container(dir_offset);

    
    
    
    
    
    
    
    if (reserved_hiddendir) {
        prev_loc.set_containerid(0);
        prev_loc.set_enclosing_container(NULL);  
    }

    const location dirloc(main->prev_backup.getMedialoc(), metadataid);
    cycle *child = new restdirlist(this, dirloc, path, prev_loc, prevlist);
    child->noop();
    nforked++;
    forked_prev_restore = true;
}




void backemctardir7::response(message& outargs)
{
    if(msg2)
        DB->msg("backemctardir7::response (parent:%p) (this:%p)", parent, this);
    ncollected++;
    
    msgpack_c::getndmphistlist64 thl(outargs);
    bool existed;
    ubigint64 histlistptr;
    thl.res(UNPACK, existed, histlistptr);
#if (POINTER64)  
    if (msg2) DB->msg("backemctardir7::response unpacked result: existed:%d histlistptr:%p",
                      existed, (void*)histlistptr);
#endif

    if (existed) {
        
#if (POINTER64)  
        histlist = (histvector_t *)histlistptr;
#endif
        
        foundhistory=true;
        if (msg2) {
            DB->msg("backemctardir7::response DEBUG DUMP histlist:%p with %"Z"u entries",
                    histlist, histlist->size());
            for (histvector_t::const_iterator i = histlist->begin(); i!=histlist->end(); i++) {
                DB->msg("    name:'%s' inode:%s", *((*i).key_string),*tostr((*i).key_number));
            }
        }
    } else {
        histlist = NULL;
        foundhistory = false;
        DB->msg("backemctardir7::response unable to find history for inode %s", *tostr(info->direlemp->inode_number64()));
    }
    childdone(NULL);  
}



bool
backemctardir7::merge_lists()
{
    if(msg1) {
        DB->msg("backemctardir7::merge_lists directory %s (inode %s), prevlist.size():%u curlist.size():%u histlist.size():%"Z"u",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()), prevlist.size(), curlist.size(), (foundhistory ? histlist->size() : 0));
    }

    
    
    removesnapviewvolumes(flags.ndmp_prefix);

    if (parser->is_empty_stream()) {
        copy_previous_backup(&prev_synthlist, &childlist);
        return true;
    }

    
    if (!foundhistory) return false;

    
    if (msg2) {
        DB->msg("backemctardir7::merge_lists for directory %s inode:%s",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()));
        debug_print_direlemp_list(curlist, "curlist", msg2);
        debug_print_direlemp_list(prevlist, "prevlist", msg2);
    }

    
    
    
    histvector_t::const_iterator hi;
    for (hi = histlist->begin(); hi != histlist->end(); hi++) {
        csustring name((*hi).key_string);
        ubigint64 inum((*hi).key_number);

        
        
        
        if ((name == ".") || (name == "..")) {
            continue;
        }

        if (msg2) DB->msg("backemctardir7::merge_lists processing histlist item '%s' -> %s",
                           *name, *tostr(inum));

        DIRELEMp curDE;
        DIRELEMp prevDE;

        if (curlist.lookup(*hi, curDE)) {
            
            assert(name.equal(curDE->name()));
            update_stats_counts(curDE);
        } else if (prevlist.lookup(*hi, prevDE)) {
            
            assert(name.equal(prevDE->name()));
            main->getstatsobj(context::backupstats)->mergeprogress(prevDE);

            
            
            if (info->use_container) {
                
                
                
                add_to_prev_synth_list(prevDE, &prev_synthlist, &childlist);
            }

            
            ordered_prevlist.push_back(prevDE);

        } else {
            
            Out->msg(ERR, "<9982>While processing %s (inode %s), NDMP file history messages indicate the presence of a directory entry (inode:%s name:%s) that doesn't appear in the data stream or in our previous backup of this directory.",
                     *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
					 *tostr(inum), *name);
            continue;
        }
    }

    delete histlist;
    histlist = NULL;

    return true;
}


void
backemctardir7::request_history()
{
    
    
    if(!histsrv)  return; 

    assert(phase == phase_wait_for_history);

    
    if (historyrequests++) {
        DB->warn("backemctardir7::request_history %p request count %d, not requesting again!", this, historyrequests);
        return;
    }

    message m;
    msgpack_c::getndmphistlist64 thl(m);
    assert(info->direlemp->inode_number64() != 0);
    ubigint64  inode_arg = info->direlemp->inode_number64();
    thl.arg(PACK, inode_arg);
    nforked++;
    if(msg1)
        DB->msg("backemctardir7::request_history_new requesting history (GETNDMPHISTLIST64) for inode:%s(%s) nforked:%d ncollected:%d phase:%d forked_prev_restore:%d",
        		*tostr(info->direlemp->inode_number64()), *info->direlemp->fullpath().image(), nforked, ncollected, phase, forked_prev_restore);
    
    histsrv->send(this, m);
    
    
}

void backemctardir7::finish_top_level_directory(cycle *child)
{
    

    
    
    
    
    if (info->use_container && info->direlemp->is_directory() && reserved_hiddendir) {
        if (!flags.incremental) {
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->msg(ERR,"Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *errdesc);
            }

        } else {
            
            
            
            
            

            
            
            
            
            
            fileoffset system_info_dir_size;
            DIRELEMp tmpde(curlist.split_lookup(0, UNDOO_DIRECTORY_NAME));
            if (tmpde.isnull()) {
                Out->msg(ERR,"Could not find .system_info directory to determine its coverage size");
            } else {
                
                system_info_dir_size = tmpde->get_location().get_coverage_size();
                if (msg2) DB->msg("backemctardir7::finish_top_level_directory  Coverage size for .system_info directory is %"LL"d",
                                  (ubigint64)system_info_dir_size.value());
            }

            
            
            ubigint64 inode_number = 0;
            ubigint64 dir_header_size = 0;
            if (msg2) DB->msg("backemctardir7::finish_top_level_directory    Synth footer from current container (Offset:%"LL"d  Size:%"LL"d  Checksum:%u)",
                              top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum);
            synth_block(top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum, inode_number, dir_header_size, false );

            
            
            
            
            
            location loc(info->direlemp->get_location());
            loc.set_coverage_size(loc.get_coverage_size() + (merged_coverage_size + system_info_dir_size));
            info->direlemp->set_location(loc);
            if (msg2) DB->msg("backemctardir7::finish_top_level_directory  Coverage size for %s increased by (%"LL"d+%"LL"d) (now %"LL"d)",
                              *info->direlemp->name(), (ubigint64)merged_coverage_size.value(),
                               (ubigint64)system_info_dir_size.value(),(bigint64)loc.get_coverage_size().value());
        }
    }

    
    
    
    
    
    if (copy_entire_previous_backup) {
        
        
        assert(!info->direlemp->is_directory());  
        assert(cur_synthlist.list_size() == 0);

        
        
        synth_volume_data(child, &cur_synthlist, &prev_synthlist);
    }

    if (info && info->use_container && !info->container.isnull()) {
        bool write_ddrfile = parser->is_empty_stream();
        main->finalizeucontainer(info->container, write_ddrfile);
    }
}

void backemctardir7::commit_directory_metadata()
{
    assert(ncollected == nforked);

    
    
    info->direlemp->set_hash(hash);

    
    
    
    
    check_dirlisting_limit(flags);
    static const fileoffset dirsizelimit(flags.dirlisting_limit);
    if ((dirsizelimit > 0) && (consumed_size > dirsizelimit)) {
        double avgsize = (dirlistcount > 0) ? (consumed_size.dvalue() / double(dirlistcount)) : 0;
        Out->msg(INFO, "<10675>Directory data consumes %s bytes for %"Z"d entries, average storage used per directory entry is %lf bytes",
                 *consumed_size.image(), dirlistcount, avgsize);
        Out->msg(INFO, "<10676>Please reduce the size of this directory to allow future incremental backups.  See Avamar NDMP documentation for further details.");
    }

    
    const ubigint64 de_inode(info->direlemp->inode_number64());
    
    
    
    
    const MetadataId metadataid(hash);
    
    
    
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory(),
                           (info->direlemp->get_location().get_abs_offset_in_container() + info->direlemp->get_location().get_header_size()).value(),
                           &childlist, &cur_synthlist, &prev_synthlist);
    } else {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory());
    }

    
    
    
    if (!info->direlemp->is_dirrec_present(KIND_EXTRA_DIR_SIZES) && info->direlemp->is_directory()) {
        if (msg1) DB->msg("backemctardir7::commit_directory_metadata  Creating EXTRA_DIR_SIZES dirrec for empty directory '%s'", *info->direlemp->name());
        info->direlemp->increment_dirsizes(0, 0, 0);
    }

    
    
    
    if (info->use_container && flags.incremental && info->direlemp->is_directory()) {
        location loc(info->direlemp->get_location());
        loc.set_checksum_value(loc.get_checksum().value ^ merged_checksum);
        info->direlemp->set_location(loc);
        if (msg2) DB->msg("backemctardir7::commit_directory_metadata  Checksum for %s modified to %u (included %u from previous backup)",
                          *info->direlemp->name(), loc.get_checksum().value, merged_checksum);
    }
}



#if !defined(backisilontardir_H_INCLUDED)
#define backisilontardir_H_INCLUDED












#include "isilontar_history.h"
#include "backndmptardir_base.h"


class backisilontardir : public backndmptardir_base
{
public:
  SAFEALLOC(backisilontardir);

  
  
  
  
  backisilontardir(BackCycle* parent_,
                   workelem* info_,
                   parsestream_base* parser,
                   int traverse_depth,
                   inode_table& inodetab_,
                   int mount_point_numelems = 0,
                   isilontar_history* hist = 0,
                   MetadataIntf_sp parent_metadataIntfp_ = MetadataIntf_sp());

  virtual ~backisilontardir();

  virtual void init();
  virtual void response(message& outargs);  
  virtual void childdone(cycle* child);

  virtual void responseReceived(DataHasher* dataHasher) { childdone(dataHasher); }

private:
  backisilontardir(); 

  
  bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata);
  void process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata);

  
  bool set_new_direlem_path(DIRELEMp& obj_direlem, bool pushed_entry);

  void process_dir_data(DIRELEMp obj_direlem);

  
  
  
  void remember_hardlinked_info(DIRELEMp& de);

  void request_prevlist();     
  void request_history();      
  bool merge_lists();          

  void finish_top_level_directory(cycle *child);
  void commit_directory_metadata();

  histvector_t* histlist;           

  isilontar_history* histsrv;         
};

#endif
























#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backndmptardir_base.h"
#include "parsestream_base.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "emctar_history.h"
#include "dirrec_pack.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "streambuffer.h"               
#include "streamtransformemctardedup.h" 

#include "ndmp_volume_entification.h"
#include "emctarstream.h"
#include "backdirstreamslice.h"
#include "utar_ctl_sup.h"

#include <algorithm>
#include "filemap.h"





#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define dowfs             ((xflag[15]&2)==0)      

#define inject_ddr_checksum_error ((xflag[26]&4)!=0) 


bool backndmptardir_base::ddr_checksums_enabled((xflag[29]&16384)==0);


int backndmptardir_base::total_direlem_commitment = 0;


bool backndmptardir_base::max_changed_date_msg_sent(FALSE);









backndmptardir_base::backndmptardir_base(BackCycle* parent_, workelem *info_,
                               parsestream_base *parser_, int traverse_depth_,
                               inode_table &inodetab_,
                               int mount_point_numelems_ ,
                               MetadataIntf_sp parent_metadataIntfp_)
  : BackCycle(parent_, info_),
    ADEBackup(parent->main),
    parser(parser_),
    traverse_depth(traverse_depth_),
    reserved_hiddendir(false),
    mount_point_numelems(mount_point_numelems_),
    phase(-1),
    forked_prev_restore(!flags.incremental),
    foundhistory(false),
    emctarstreamoffset(traverse_depth == 0 ? 0 : parser_->get_headeroffset()),
    historyrequests(0),
    inodetab(inodetab_),
    data_hasher_child(NULL), 
    dataHasher(parent->main),
    inode_is_64_bits(false),
    dir_header_added(false),
    copy_entire_previous_backup(false)
{
    if(msg1) DB->msg("backndmptardir_base::backndmptardir_base constructor "
                           "(parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);
    assert(parent != NULL);
    assert(info != NULL);
    if (info->use_container) {
        assert(!info->container.isnull());
    }

    
    ordered_curlist_index = 0;
    ordered_prevlist_index = 0;

    
    dirlistcount = 0;
    cycle_direlem_commitment = 0;
    child_dir_count = 0;
    child_spawning_paused = false;

    
    merged_coverage_size = fileoffset::unknown;
    merged_checksum = 0;
    cur_synthlist_checksum = 0;
    top_level_footer.block_begin = 0;
    top_level_footer.block_size = 0;
    top_level_footer.block_checksum = 0;

    
    if ((!flags.ndmp_prefix.isempty() && traverse_depth == 1) ||
        (flags.ndmp_prefix.isempty() && traverse_depth == 0)) {
        DIRELEMp hiddendir(new DIRELEM);
        const epoch_t now((epoch_t)timer::now());
        hiddendir->initialize( hashcode::zero, now, now, now, fileoffset(0),
                               ATTR_DIRECTORY|ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);

        curlist.split_enter(0 , UNDOO_DIRECTORY_NAME, hiddendir);
        reserved_hiddendir = true;

        
        total_direlem_commitment = 0;
    }

    
    const hfs_info_struct& hfsInfo(main->getAdeMgr()->getHfsInfo(dpn0));
    catalog_enabled = (hfsInfo.metaStore != NULL);

    if (catalog_enabled) {
        
        metadatastorep = hfsInfo.metaStore;

        if (reserved_hiddendir) {
            
            
            
            SavesetIntf_sp saveset_interfacep;
            storeResultCodes store_errcode(storeSuccess);
            if ((metadatastorep == NULL) || (store_errcode = metadatastorep->getOpenBackup(saveset_interfacep, parent_metadataIntfp)) != storeSuccess) {
                Out->Abort("Problem calling getOpenBackup() for %s (result code=%d)",
                        *info->direlemp->fullpath().image(), store_errcode);
                return;
            } else {
                if (msg2) DB->msg("backndmptardir_base::backndmptardir_base: getOpenBackup() successful for dir %s (parent_metadataIntfp.count=%ld)",
                                  *info->direlemp->fullpath().image(), parent_metadataIntfp.use_count());
            }
        } else {
            
            
            parent_metadataIntfp = parent_metadataIntfp_;
        }
    }

    set_phase(phase_init);

}


backndmptardir_base::~backndmptardir_base()
{
    if(msg1) DB->msg("backndmptardir_base::~backndmptardir_base destructor "
                           "(parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);
    delete info;
}



void backndmptardir_base::send_max_changed_date()
{
    
    if (!max_changed_date_msg_sent) {
        
        if (main && main->tomato) {
            ctl_messagep max_changed_date_msg(new ctl_message(ctl_message::type::send_max_changed_date));
            max_changed_date_msg->set_max_changed_date(parser->get_max_changed_date(flags.incremental));
            main->tomato->post_to_parent(max_changed_date_msg, NULL);
            max_changed_date_msg_sent = TRUE;
        }
    }
}




void backndmptardir_base::determine_volume_offset()
{
    assert (info->use_container);

    if (!flags.incremental) {
        
        inodetab.volume_offset = 0;

    } else {
        
        
        
        location prev_loc(info->direlemp->get_location());
        inodetab.volume_offset = (ubigint64)prev_loc.get_abs_offset_in_container().value();
        DB->msg("backndmptardir_base::determine_volume_offset Saved offset (%"LL"d) for volume:%s",
                inodetab.volume_offset, *flags.ndmp_prefix);

        
        save_location_template(prev_loc, true );
    }
}



void backndmptardir_base::add_directory_to_container()
{
    ucontainer::errortype errcode;
    if ((errcode = info->container->begindir(info->direlemp.getimpl())) != ucontainer::pce__success)
    {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem creating container begindir for %s (%s)",
                *info->direlemp->fullpath().image(), *errdesc);
        return;
    } else {
        if (msg2) DB->msg("DDR: backndmptardir_base::backndmptardir_base: abs_offset_in_container:%"LL"d begindir for dir %s",
                          info->direlemp->get_location().get_abs_offset_in_container().value(),
                          *info->direlemp->fullpath().image());

        
        
        cur_synthlist_offset = info->direlemp->get_location().get_abs_offset_in_container();
        cur_synthlist_coversize = 0;
        cur_synthlist_checksum = 0;
        
        

        
        
        merged_coverage_size = 0;
        merged_checksum = 0;
    }
}




bool backndmptardir_base::open_metastore_directory_entry()
{
    assert(metadatastorep != NULL);

    
    storeResultCodes store_errcode(storeSuccess);
    if (!parent_metadataIntfp || (store_errcode = parent_metadataIntfp->openDir(*(info->direlemp), my_metadataIntfp)) != storeSuccess) {
        Out->msg(ERR, "Problem calling openDir() for %s (result code=%d)",
                *info->direlemp->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backndmptardir_base::open_metastore_directory_entry: openDir() successful for dir %s",
                          *info->direlemp->fullpath().image());
    }
    return true;
}



bool backndmptardir_base::add_directory_to_metastore(DIRELEMp obj_direlem)
{
    if (!obj_direlem.isdefined()) {
        Out->msg(ERR, "Attempted to add non-existent directory to metadata store.");
        return false;
    }

    assert(metadatastorep != NULL);

    
    direlemp2metadatap_iterator map_entry = direlemp2metadatap.find(obj_direlem.getimpl());
    if (map_entry == direlemp2metadatap.end()) {
        Out->msg(ERR, "Cannot close directory '%s' because it does not appear to have been opened.", *obj_direlem->fullpath().image());
        return false;
    }

    MetadataIntf_sp metadatap = map_entry->second;
    
    
    storeResultCodes store_errcode(storeSuccess);
    if (!metadatap || (store_errcode = metadatap->closeDir(*obj_direlem)) != storeSuccess) {
        Out->msg(ERR, "Problem calling closeDir() for %s (result code=%d)",
                *obj_direlem->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backndmptardir_base::add_directory_to_metastore: closeDir() successful for dir %s",
                          *obj_direlem->fullpath().image());
    }
    return true;
}






bool backndmptardir_base::add_item_to_metastore(DIRELEMp obj_direlem)
{
    if (!obj_direlem.isdefined()) {
        Out->msg(ERR, "Attempted to add non-existent object to metadata store.");
        return false;
    }

    assert(metadatastorep != NULL);
    storeResultCodes store_errcode(storeSuccess);
    if (!my_metadataIntfp || (store_errcode = my_metadataIntfp->add(*obj_direlem)) != storeSuccess) {
        Out->msg(ERR, "Problem calling add() for %s (result code=%d)",
                *obj_direlem->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backndmptardir_base::add_item_to_metastore: add() successful for %s",
                          *obj_direlem->fullpath().image());
    }
    return true;
}






bool backndmptardir_base::add_children_to_metastore()
{
    assert(metadatastorep != NULL);
    std::vector<DIRELEMp>::iterator ordered_curlist_it(ordered_curlist.begin());
    std::vector<DIRELEMp>::iterator ordered_prevlist_it(ordered_prevlist.begin());

    if ((ordered_curlist_it == ordered_curlist.end()) &&
        (ordered_prevlist_it == ordered_prevlist.end())) {
        return true;  
    }

    DIRELEMp de;

    
    
    
    bool working_on_curlist(true);
    while ((ordered_curlist_it != ordered_curlist.end()) ||
           (ordered_prevlist_it != ordered_prevlist.end())) {
        
        
        

        if (ordered_curlist_it != ordered_curlist.end()) {
            
            
            de = *ordered_curlist_it;
            ordered_curlist_it++;
        } else {
            
            de = *ordered_prevlist_it;
            ordered_prevlist_it++;
            working_on_curlist = false;
        }

        assert(de.isdefined());

        if (de->is_directory() && working_on_curlist) {
            
            if (!add_directory_to_metastore(de)) {
                Out->msg(ERR, "Problem adding directory '%s' to '%s' in Metadata store.",
                           *de->name(), *info->direlemp->fullpath().image());
                return false;
            } else {
                
                
                
                
                
                if (!inodetab.update_metadataid(de->inode_number64(), de->get_metadataLocation()->getMetadataId())) {
                    Out->msg(ERR, "Failed to update Metadata ID for inode '%"LL"d' (name:'%s') in directory '%s'.",
                             de->inode_number64(), *de->name(), *info->direlemp->fullpath().image());
                    return false;
                }
            }

        } else {
            
            
            if (!add_item_to_metastore(de)) {
                Out->msg(ERR, "Problem adding item '%s' to '%s' in Metadata store.",
                           *de->name(), *info->direlemp->fullpath().image());
                return false;
            } else {
                
                
                
                if ((de->hard_links() > 1) && !de->is_tar_hardlink()) {
                    if (!inodetab.update_metadataid(de->inode_number64(), de->get_metadataLocation()->getMetadataId())) {
                        Out->msg(ERR, "Failed to update Metadata ID for inode '%"LL"d' (name:'%s') in directory '%s'.",
                                 de->inode_number64(), *de->name(), *info->direlemp->fullpath().image());
                        return false;
                    }
                }
            }
        }
    }

    
    
    

    return true;
}





void backndmptardir_base::insert_self(DIRELEMp obj_direlem)
{
    ustring name(obj_direlem.isnull() ? ustring("NULL") : obj_direlem->fullpath().image());
    if(msg1)DB->msg("backndmptardir_base::insert_self (%p)  name:%s depth:%d",
                    this, *name, -traverse_depth);
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);         
}


bool backndmptardir_base::set_new_direlem_path(DIRELEMp &obj_direlem, bool pushed_entry)
{
    
    
    
    if (!flags.ndmp_prefix.isempty() && !pushed_entry) {
        
        upath collapsed_path;
        upath ndmp_prefix_path(flags.ndmp_prefix);

        if (traverse_depth == 0) {
            
            
            
            
            mount_point_numelems = obj_direlem->fullpath().numelems();

            DB->msg("Mount-point (top-level) directory is: %s", *obj_direlem->fullpath().image());
            collapsed_path = ndmp_prefix_path;
            dirrec_pack::ndmp_volume vpath(obj_direlem.getimpl());
            vpath.set(ndmp_unentify_volume(flags.ndmp_prefix));

        } else {
            upath current_path(obj_direlem->fullpath());
            if (current_path.numelems() <= mount_point_numelems) {
                
                Out->msg(FATAL, "<9978>Path %s goes below mount point, exiting.", *current_path.image());
                uapp::staging().startTermination(EXIT_MISC, "path goes below mount point (in set_new_direlem_path)");
                set_phase(phase_wait_for_history);
                childdone(NULL);
                return false;
            }

            upath sliced_path(current_path.slice(mount_point_numelems, current_path.numelems()));
            
            collapsed_path = ndmp_prefix_path / sliced_path.to_relative();
        }

        if (msg2) DB->msg("Collapsing path %s -> %s", *obj_direlem->fullpath().image(), collapsed_path.image().tostr());
        obj_direlem->set_fullpath(collapsed_path);
        obj_direlem->set_name(collapsed_path.stripdir());
    }
    return true;
}


#if CELERRA_CMR10
bool backndmptardir_base::isstubemctardedup(const fileref& stubdata)
{
    
    
    
    if(stubdata.size() < 161+8) {
        DB->warn("isstubemctardedup stubdata.size():%s does not contain enough data to be a valid @emctar-offattrs stub",
                 stubdata.size64().image().tostr());
        return false;
    }
    const unsigned long namesize(parsestream_base::extractulong(stubdata, 155, 6, 8));
    const unsigned long extsize(parsestream_base::extractulong(stubdata, 161, 12, 8));
    
    offattrsdata di;
    if((unsigned long)stubdata.size64().value() < 512+namesize+extsize+sizeof(di)) {
        DB->warn("isstubemctardedup stubdata.size():%s does not contain enough data to be a valid @emctar-offattrs stub with namesize:%lu extsize:%lu",
                 *stubdata.size64().image(), namesize, extsize);
        return false;
    }
    stubdata.getslice(512+namesize+extsize, sizeof(di), &di);
    
    if (di.ctype == 4 && di.connectionId == 1023)
        return true;
    return false;
}
#endif


void
backndmptardir_base::process_dir_data(DIRELEMp obj_direlem)
{
    static bool errored(false);

    emctarstream::parser *ets_parser = dynamic_cast<emctarstream::parser*>(parser);
    if (NULL == ets_parser) {
        if (!errored) {
            Out->msg(ERR, LOCTXT("Celerra/VNX backup in progress with --celerra-vnx-streamslices=true, but stream parsing object types (%s) does not support streamslices.  Processing %s."),
                     typeid(*parser).name(), *obj_direlem->fullpath().image());
            errored = true;
        }
        return;
    }

    
    
    

    workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem, filestatsref());
    cycle *child = new backdirstreamslice(this, w, obj_direlem, ets_parser, info->use_container);
    child->noop();
    nforked++;
}


void
backndmptardir_base::process_wait_phases(const int hist_count)
{
    if ((phase == phase_wait_for_history) && (!historyrequests || foundhistory)) {
        
        
        
        

        
        
        if (foundhistory) add_to_direlem_commitment(hist_count);
        if (flags.incremental && traverse_depth > 0 && throttle_prevlist_requests()) {
            
            
            
            
            set_phase(phase_wait_for_children);
        } else {
            set_phase(phase_forksdone);
        }
    } 

    if ((phase == phase_wait_for_children) && (ncollected  == nforked)) {
        
        
        
        
        set_phase(phase_forksdone);
    }
}






void
backndmptardir_base::process_forksdone_phase_part1(inode_table::synth_list_cur* cur_listp,
                                                   inode_table::synth_list_prev* prev_listp)
{
    assert((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)  && (flags.incremental));
    

    
    
    if (cycle_direlem_commitment > 0) {
        if (msg2) {
            axion_procinfo proc;
            int estimated_prevlist_mbytes((total_direlem_commitment - cycle_direlem_commitment) * bytes_per_direlem / (1024 * 1024));
            DB->msg("backndmptardir_base::process_forksdone_phase_part1 subtract %d from total_direlem_commitment (%dMB + %dMB) inode:%"LL"d traverse_depth:%d",
                    cycle_direlem_commitment, proc.vmsize_mb, estimated_prevlist_mbytes, info->direlemp->inode_number64(), traverse_depth);
        }
        subtract_from_direlem_commitment(cycle_direlem_commitment);
    }

    if (reserved_hiddendir) {
        
        
        prev_sysinfo = prevlist.split_lookup(0, UNDOO_DIRECTORY_NAME);
    }

    if (info->use_container) {
        
        add_files_to_synth_list(cur_listp);
        
        
    }

    merge_lists();

    if (info->use_container && !reserved_hiddendir) {
        
        
        
        
        
        location loc(info->direlemp->get_location());
        loc.set_coverage_size(loc.get_coverage_size() + merged_coverage_size);
        info->direlemp->set_location(loc);
        if (msg2) DB->msg("backndmptardir_base::process_forksdone_phase_part1  Coverage size for %s increased by %"LL"d (now %"LL"d)",
                          *info->direlemp->name(), (ubigint64)merged_coverage_size.value(), (bigint64)loc.get_coverage_size().value());
    }

    
    
    
    
    
    
    
    if (info->use_container && !dir_header_added && info->direlemp->is_directory()) {
        
        add_dir_header_to_synth_list(cur_listp);
        if (msg2) DB->msg("backndmptardir_base::process_forksdone_phase_part1: cur_synthlist (offset:%"LL"d coversize:%"LL"d)",
                          cur_synthlist_offset.value(), cur_synthlist_coversize.value());
    }

    
    if (msg2 && info->use_container) {
        dump_synth_lists(cur_listp, prev_listp);
    }
}







void
backndmptardir_base::process_forksdone_phase_part2(cycle *child_cycle,
                                                   inode_table::synth_list_cur* cur_listp,
                                                   inode_table::synth_list_prev* prev_listp)
{
    assert((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked));

    
    if (reserved_hiddendir) {
        
        
        
        
        DIRELEMp tmpde(curlist.split_lookup(0, UNDOO_DIRECTORY_NAME));
        if (tmpde.isnull()) {
            if (msg2) DB->msg("backndmptardir_base::process_forksdone_phase_part2: Could not find .system_info in curlist.");
        } else {
            
            
            
            ordered_prevlist.push_back(tmpde);
        }

        
        if (info->use_container && flags.incremental) {
            
            
            
            
            
            

            
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->Abort("Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *errdesc);
                return;
            } else {
                
                location loc(info->direlemp->get_location());
                
                
                top_level_footer.block_begin = (ubigint64)(loc.get_abs_offset_in_container() + loc.get_coverage_size() - loc.get_footer_size()).value();
                top_level_footer.block_size = (bigint64)loc.get_footer_size().value();
                top_level_footer.block_checksum = loc.get_checksum().footer_value;
                if (msg2) DB->msg("backndmptardir_base::process_forksdone_phase_part2 Saved footer info for '%s' (block_begin:%"LL"d block_size:%"LL"d block_checksum:%u)",
                                  *info->direlemp->name(), top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum);
            }

            
            
            
            synth_volume_data(child_cycle, cur_listp, prev_listp);
        }

        
        
        
        finish_top_level_directory(child_cycle);

        
        final_childdone();
    }

    set_phase(phase_do_hidden);
}




void
backndmptardir_base::process_do_hidden_phase()
{
    assert((phase == phase_do_hidden) && (ncollected == nforked));

    if (!uapp::staging().canRun()) {
        Out->msg(ERR, "<16420>backndmptardir_base::process_do_hidden_phase error merging history stream data during phase_do_hidden while processing directory '%s'",
                  *info->direlemp->fullpath().image());
    }

    workelem *w = new workelem(NULL, fileref());
    cycle *datachild = new backdataconsumer(this, w, this, true);
    datachild->noop();

    nforked++;
    
    if (parser->is_empty_stream())
        finish_top_level_directory(datachild);
    set_phase(phase_done);
}


void
backndmptardir_base::final_childdone()
{
    
    
    

    if(!flags.noinodetable) {
        
        fileref inode_info;
        ustring inode_filename = ustring::sprintf("inode2hashtable_%d_", getpid()) + flags.ndmp_prefix;
#ifdef NAME_MAX
        if (inode_filename.bytelength() > NAME_MAX)
            inode_filename = inode_filename.substr(0, NAME_MAX);
#endif
        const ustring inode_filepath = flags.vardir / inode_filename;
        inode_info.initdisk(inode_filepath, 0, filemap::write, false, true, true);
        
        Out->msg(INFO, "<9981>Writing inode table");
        if(inodetab.image(inode_info, inodetab.currentversion(), true)) {
            
            main->sysinfo_files_and_data.enter(INODE2HASH_TABLE_FILENAME, inode_info);
            DB->msg("backndmptardir_base::final_childdone save inode2hash to disk : %s", *inode_filepath);
            if(msg2) {
                DB->msg("backndmptardir_base::final_childdone wrote inode table into .system_info");
                inodetab.debug_dump();
            }
        } else {
            
            
            
            
            Out->msg(INFO, "<7355>Unable to write inode table.");
        }
    }

    if(msg1) DB->msg("backndmptardir_base::final_childdone calling backhidden nforked:%d ncollected:%d",
                     nforked, ncollected);

    
    
    
    xflag[5] |= (2|8|32|64|1024); 
    flags.nomachinedesc = true;

    
    
    DIRELEMp de;
    de = curlist.split_lookup(0, UNDOO_DIRECTORY_NAME);
    workelem *w = new workelem(info, de);
    w->use_container = false; 
    bool write_ddrfile = !parser->is_empty_stream();
    
    
    backhidden *hidden = new backhidden(this, w, fileoffset(0), 0, false, write_ddrfile);

    if (flags.incremental)
    {
        assert(prev_sysinfo != 0);
        hidden->save_last_sysinfo(prev_sysinfo);
    }

    hidden->noop();
    nforked++;
}



void backndmptardir_base::notifyparent()
{
    if (msg1) DB->msg("backndmptardir_base::notifyparent All done, parent=%p this=%p", parent, this);
    if (has_error()) {
        parent->set_error(true, "backndmptardir_base failed");
    }

    cycle::notifyparent();
    
}



void backndmptardir_base::set_phase(int phasenum, bool force_history_request )
{
    if (phasenum <= phase) return; 

    if(msg1)DB->msg("backndmptardir_base::set_phase setting phase to %d for directory '%s'", phasenum, *info->direlemp->name());

    phase = phasenum;

    if ((phase == phase_wait_for_history) || (phase == phase_forksdone)) {
        
        
        
        
        
        
        bool hasfakeparent = info->direlemp->is_root();

        
        
        
        
        

        if (hasfakeparent) {
            ubigint64 directory_inode(inode_is_64_bits ?
                                      info->direlemp->inode_number64() :
                                      info->direlemp->inode_number());
            DB->msg("backndmptardir_base::set_phase phasenum:%d not requesting history for fakeparent:%d '%s' inode:%"LL"d",
                    phasenum, hasfakeparent, *info->direlemp->fullpath().image(), directory_inode);
            
            
            
            
            
            
            forked_prev_restore = true;
        } else {
            
            
            
            if (flags.incremental || force_history_request) {
                
                
                
                
                
                if (phase == phase_wait_for_history) {
                    request_history();
                } else {
                    
                    request_prevlist();
                }
            }
        }
    }
}


void
backndmptardir_base::check_delta_size(const DIRELEMp cur, const fileref& listing, fileoffset &prev_size)
{
    
    
    

    const int delta_size = (listing.size64()-prev_size).lopart();
    int max_comp_size = main->getmaxdpncompchunksize(dpn0); 
    
    if(delta_size > max_comp_size) {
        DB->error("INTERNAL WARNING: DIRELEM > %d bytes: listing.size=%d delta=%d name=%s",
                  max_comp_size, listing.size(), delta_size, *cur->fullpath().image() );
    }
    prev_size = listing.size();
}


void
backndmptardir_base::update_stats_counts(const DIRELEMp &de) const
{
    
    

    if (de->is_internal()) return;

    
    
    if (de->is_directory()) {
        main->getstatsobj(context::backupstats)->add_dircount(1);
    } else {
        main->getstatsobj(context::backupstats)->add_filecount(1);
    }
}




bool
backndmptardir_base::throttle_prevlist_requests()
{
    axion_procinfo proc;
    
    
    
    
    
    int estimated_prevlist_mbytes(total_direlem_commitment * bytes_per_direlem / (1024 * 1024));
    if ((flags.ndmpmemthrottlethresh > 0) && ((proc.vmsize_mb + estimated_prevlist_mbytes) > flags.ndmpmemthrottlethresh)) {
        if (msg2) DB->msg("backndmptardir_base::throttle_prevlist_requests returning 'TRUE' (%dMB + %dMB) inode:%d traverse_depth:%d",
                          proc.vmsize_mb, estimated_prevlist_mbytes, info->direlemp->inode_number(), traverse_depth);
        return true;
    }
    if (msg2) DB->msg("backndmptardir_base::throttle_prevlist_requests returning 'FALSE' (%dMB + %dMB) inode:%d traverse_depth:%d",
                      proc.vmsize_mb, estimated_prevlist_mbytes, info->direlemp->inode_number(), traverse_depth);
    return false;
}




bool
backndmptardir_base::throttle_child_spawning()
{
    
    
    
    
    
    
    

    
    
    if (child_dir_count > 0) {
        axion_procinfo proc;
        
        
        if ((flags.ndmpmemthrottlethresh > 0) && (proc.vmsize_mb > flags.ndmpmemthrottlethresh)) {
            if (!child_spawning_paused) {
                
                if (msg2) DB->msg("backndmptardir_base::throttle_child_spawning returning 'TRUE' (%dMB) child_dir_count:%d inode:%d traverse_depth:%d",
                                  proc.vmsize_mb, child_dir_count, info->direlemp->inode_number(), traverse_depth);
                child_spawning_paused = true;
            }
            return true;
        }
    }
    if (child_spawning_paused) {
        
        axion_procinfo proc;
        if (msg2) DB->msg("backndmptardir_base::throttle_child_spawning returning 'FALSE' (%dMB) child_dir_count:%d inode:%d traverse_depth:%d",
                          proc.vmsize_mb, child_dir_count, info->direlemp->inode_number(), traverse_depth);
        child_spawning_paused = false;
    }
    return false;
}









fileref backndmptardir_base::nextdatablock(bool &suppress_requeue)
{
    suppress_requeue = false;
    fileref nextbuf;

    
    
    
    if (((ordered_curlist.size()-ordered_curlist_index) == 0) &&
        ((ordered_prevlist.size()-ordered_prevlist_index) == 0)) {
        return nextbuf;                 
    }

    unsigned direlem_count = (unsigned)((ordered_curlist.size()-ordered_curlist_index) + (ordered_prevlist.size()-ordered_prevlist_index));
    nextbuf.initlist(std::min(unsigned(1000), direlem_count) * DIRELEM_DOLAYOUT_AVERAGE_SIZE);
    DIRELEMp cur;
    fileoffset totalsize = 0;

    
    while ((ordered_curlist_index < ordered_curlist.size()) ||
           (ordered_prevlist_index < ordered_prevlist.size())) {
        
        
        if (ordered_curlist_index < ordered_curlist.size()) {
            
            
            cur = ordered_curlist[ordered_curlist_index];
            ordered_curlist_index++;
        } else {
            
            cur = ordered_prevlist[ordered_prevlist_index];
            ordered_prevlist_index++;
        }

        dirlistcount++;

        
        main->layout_direlem(*cur, nextbuf, false, true, true);

        
        if (!cur->is_internal()) {
            totalsize += cur->file_size();
            info->direlemp->increment_dirsizes(*cur);
        }

        
        
        
        if (!flags.incremental && info->direlemp->is_directory()) {
            update_stats_counts(cur);
        }

        
        
        if (nextbuf.size64() > 1024*1024)
            break;
    }

    
    
    
    
    
    
    info->direlemp->increment_dirsizes(nextbuf.size64(), 0, 0); 
    info->direlemp->set_file_size(info->direlemp->file_size()+totalsize);

    return nextbuf;
}


void backndmptardir_base::removesnapviewvolumes(const ustring ndmp_prefix)
{
    if (traverse_depth == 0 && !flags.ndmp_prefix.isempty()) {
        
        
        
        DIRELEMp volume;
        if (msg1) {
            undoo::vector<composite_key> keys;
            prevlist.keys(keys);
            for (size_t i = 0; i < keys.size(); i++)
                DB->msg("backndmptardir_base::removesnapviewvolumes found top-level entry %s", *(keys[i].image()));
        }

        ubigint64 inode(0);
        composite_key pkey;
        while (prevlist.pop_front(pkey, volume)) {
            if ((pkey.key_string).equal(ndmp_prefix)) {
                
                inode = pkey.key_number;
                break;
            }
        }

        if (msg1) DB->msg("backndmptardir_base::removesnapviewvolumes volume %s %sfound",
                          *ndmp_prefix, volume.isnull() ? "not " : "");
        prevlist.clear();
        if (!volume.isnull()) {
            
            prevlist.split_enter(inode, ndmp_prefix, volume);
        }
    }
}


void
backndmptardir_base::copy_previous_backup(inode_table::synth_list_prev* prev_synthlistp,
                                          inode_table::child_dir_list* childlistp)
{
    
    DIRELEMp prevDE;
    composite_key pkey;
    while (prevlist.pop_front(pkey, prevDE)) {
        main->getstatsobj(context::backupstats)->mergeprogress(prevDE);

        
        
        
        
        
        if (prevDE->is_directory()) {
            main->getstatsobj(context::backupstats)->add_dircount(-1);
        }

        
        ordered_prevlist.push_back(prevDE);

        
        
        if (info->use_container) {
            copy_entire_previous_backup = true;
            
            
            
            add_to_prev_synth_list(prevDE, prev_synthlistp, childlistp);
        }
    }
}


void
backndmptardir_base::debug_print_direlemp_list(composite_to_direlemp_table &list, const ustring &msg, bool shoulddump)
{
    if (!shoulddump) return;

    undoo::vector<composite_key> inode64names(list.keys());
    DB->msg("backndmptardir_base composite_to_direlemp_table DEBUG DUMP %s, %"Z"d keys", *msg, inode64names.size());
    for (undoo::vector<composite_key>::const_iterator n = inode64names.begin(); n != inode64names.end(); n++) {
        const DIRELEMp de(list.lookup(*n));
        ubigint64 de_inode(inode_is_64_bits ?
                           de->inode_number64() :
                           de->inode_number());
        DB->msg("    '%s' -> '%s' inum:%"LL"d loc.cid:%d loc.absoff:%s",
                *((*n).image()), *de->name(), de_inode, de->get_location().get_containerid(), *de->get_location().get_abs_offset_in_container().image());
    }
}




void
backndmptardir_base::add_to_prev_synth_list(const DIRELEMp &prevDE,
                                            inode_table::synth_list_prev* prev_synthlistp,
                                            inode_table::child_dir_list* childlistp)
{
    
    
    
    
    
    if (!copy_entire_previous_backup &&
        (prevDE->is_directory() || ((prevDE->hard_links() > 1) && !prevDE->is_tar_hardlink()))) {
        
        
        
        
        childlistp->add_child(prevDE->inode_number64());
        if (msg2) DB->msg("backndmptardir_base::add_to_prev_synth_list: Added inode %"LL"d to child_dir_list. List size=%"LL"d",
                          prevDE->inode_number64(), (ubigint64)childlistp->list_size());

        
        if (prevDE->is_directory()) {
            
            

            
            prev_synthlistp->add_dir((ubigint64)prevDE->inode_number64());
            
            prev_synthlistp->add_dir_header_size((ubigint64)prevDE->get_location().get_header_size().value());
        } else {
            
            prev_synthlistp->add_hardlink_data((ubigint64)prevDE->inode_number64());
        }
    }

    
    
    inode_table::data_block synth_item;
    location loc(prevDE->get_location());
    synth_item.block_begin = (ubigint64)loc.get_abs_offset_in_container().value();
    synth_item.block_size = (bigint64)loc.get_coverage_size().value();
    synth_item.block_checksum = loc.get_checksum().value;
    prev_synthlistp->add_item(synth_item);
    if (msg2) DB->msg("backndmptardir_base::add_to_prev_synth_list Added entry '%s' to prev_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                      *prevDE->name(), synth_item.block_begin, synth_item.block_size, (ubigint64)prev_synthlistp->list_size());

    
    merged_coverage_size += synth_item.block_size;
    if (msg2) DB->msg("backndmptardir_base::add_to_prev_synth_list  Updated merged_coverage_size for %s to:%"LL"d (added %"LL"d from previous backup)",
                      *info->direlemp->name(), (bigint64)merged_coverage_size.value(), synth_item.block_size);

    
    merged_checksum ^= synth_item.block_checksum;
    if (msg2) DB->msg("backndmptardir_base::add_to_prev_synth_list  Updated merged_checksum for %s to:%u (included %u from previous backup)",
                      *info->direlemp->name(), merged_checksum, synth_item.block_checksum);
}






















void
backndmptardir_base::merge_synth_lists(const inode_table::synth_list_cur* cur_listp,
                                       const inode_table::synth_list_prev* prev_listp,
                                       const bool footer_present,
                                       const ubigint64 inode_being_processed,
                                       const ubigint64 top_level_inode)
{
    if (msg2) DB->msg("backndmptardir_base::merge_synth_lists Begin processing items in cur_synthlist for inode:%"LL"d (list size:%"LL"d footer_present:%d)",
                      inode_being_processed, (ubigint64)cur_listp->list_size(), footer_present);

    
    
    
    
    
    
    
    ubigint64 loop_start(0);
    if (footer_present) {
        loop_start = 1;
    }

    
    inode_table::synth_list_cur::cur_list_iterator_const citer(cur_listp->list_begin());
    for(ubigint64 i = loop_start; i < cur_listp->list_size(); i++) {
        inode_table::data_block list_item(*citer);
        ubigint64 inode_number = 0;
        ubigint64 dir_header_size = 0;

        
        
        
        
        if ((i == loop_start) && (inode_being_processed != top_level_inode)) {
            inode_number = inode_being_processed;
            dir_header_size = list_item.block_size;
        }

        if (cur_listp->is_dir(&list_item)) {
            
            
            
            inode_number = list_item.block_begin;

            
            inode_table::synth_list_cur* sub_cur_synthlistp(NULL);
            inode_table::synth_list_prev* sub_prev_synthlistp(NULL);
            if (!inodetab.find_lists(inode_number, sub_cur_synthlistp, sub_prev_synthlistp)) {
                Out->msg(ERR, "While merging synth lists for inode %"LL"d, no entry was found in the table for that inode", inode_number);
            } else {
                
                if (msg2) DB->msg("backndmptardir_base::merge_synth_lists  Descending into directory for inode %"LL"d.  List sizes (cur:%"LL"d prev:%"LL"d)",
                                  inode_number, (ubigint64)sub_cur_synthlistp->list_size(), (ubigint64)sub_prev_synthlistp->list_size());
                merge_synth_lists(sub_cur_synthlistp, sub_prev_synthlistp, true , inode_number, top_level_inode);
                if (msg2) DB->msg("backndmptardir_base::merge_synth_lists  Ascending from directory for inode %"LL"d", inode_number);
            }

        } else {
            
            
            

            if (cur_listp->is_hardlink_data(&list_item)) {
                
                
                
                inode_number = list_item.block_begin;

                
                
                citer++;
                list_item = *citer;
                
                
                i++;
            }

            
            
            
            synth_block(list_item.block_begin, list_item.block_size, list_item.block_checksum, inode_number, dir_header_size, false );
        }

        citer++;  
    }

    
    
    if (msg2) DB->msg("backndmptardir_base::merge_synth_lists Begin processing items in prev_synthlist for inode:%"LL"d (list size:%"LL"d)",
                      inode_being_processed, (ubigint64)prev_listp->list_size());

    for(inode_table::synth_list_prev::prev_list_iterator_const piter(prev_listp->list_begin());
                                                 piter != prev_listp->list_end();
                                                 piter++) {
        inode_table::data_block list_item(*piter);
        ubigint64 inode_number = 0;
        ubigint64 dir_header_size = 0;

        if (prev_listp->is_dir(&list_item) || prev_listp->is_hardlink_data(&list_item)) {
            
            
            
            
            
            
            
            inode_number = list_item.block_begin;

            
            if (prev_listp->is_dir(&list_item)) {
                piter++;
                list_item = *piter;
                
                assert (prev_listp->is_dir_header_size(&list_item));
                dir_header_size = list_item.block_begin;
            }
            piter++;
            list_item = *piter;
        }

        synth_block(list_item.block_begin, list_item.block_size, list_item.block_checksum, inode_number, dir_header_size, true );
    }

    
    if (citer != cur_listp->list_end()) {
        inode_table::data_block list_item(*citer);
        ubigint64 inode_number = 0;
        ubigint64 dir_header_size = 0;
        if (msg2) DB->msg("backndmptardir_base::merge_synth_lists Process footer in cur_synthlist for inode:%"LL"d", inode_being_processed);
        synth_block(list_item.block_begin, list_item.block_size, list_item.block_checksum, inode_number, dir_header_size, false );
    }
    if (msg2) DB->msg("backndmptardir_base::merge_synth_lists Finished processing synthlists for inode:%"LL"d", inode_being_processed);
}








void
backndmptardir_base::synth_block(const ubigint64 &block_begin,
                           const bigint64 &block_size,
                           const tchecksum::tchecksumval &block_checksum,
                           const ubigint64 &inode_number,
                           const ubigint64 &dir_header_size,
                           const bool base_container)
{
    if (msg2) DB->msg("backndmptardir_base::synth_block: Synth from %s container (Offset:%"LL"d  Size:%"LL"d  inode:%"LL"d  header size:%"LL"d)",
                      (base_container ? "previous" : "current"), block_begin, block_size, inode_number, dir_header_size);

    
    
    DIRELEMp srcDE(new DIRELEM);
    location src_loc;
    ustring absolute_path("");
    if (base_container) {
        
        src_loc = inodetab.base_container_location;
    } else {
        
        src_loc = inodetab.current_container_location;
        absolute_path = path_to_temp_container;
    }

    src_loc.set_abs_offset_in_container(block_begin);
    src_loc.set_coverage_size(block_size);

    
    
    if (inject_ddr_checksum_error) {
        src_loc.set_checksum_value(+block_begin & 0xFFFFFFFF); 
        
    } else {
        src_loc.set_checksum_value(block_checksum);
    }
    src_loc.set_checksum_type(ddr_checksums_enabled? 1 : 0);
    srcDE->set_location(src_loc, false);
    srcDE->set_name("block");  

    ucontainer::errortype errcode;
    udirelemp destUDE;
    
    if ((errcode = info->container->synthobj(srcDE.getimpl(), destUDE, absolute_path, false)) != ucontainer::pce__success) {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem synthesizing data in container; error: (%s)", *errdesc);
        return;
    } else {
        DIRELEMp destDE(destUDE.getDIRELEMp());  
        const fileoffset abs_dir_offset(destDE->get_location().get_abs_offset_in_container());
        

        
        
        if (inode_number > 0) {
            
            
            
            
            ubigint64 new_dir_offset(dir_header_size + abs_dir_offset.value());

            
            if (msg2) DB->msg("backndmptardir_base::synth_block: Calling update_dir_offset with inode:%"LL"d new_dir_offset:%"LL"d",
                             inode_number, new_dir_offset);

            bool update_children = false;
            if (base_container) {
                
                
                
                
                update_children = true;

                
                
                inode_table::data_block synth_src;
                synth_src.block_begin = block_begin;
                synth_src.block_size = block_size;
                inodetab.update_dir_offset(inode_number, new_dir_offset, update_children, false, false, &synth_src);
            } else
                inodetab.update_dir_offset(inode_number, new_dir_offset, update_children);
        }
    }
}


void
backndmptardir_base::add_dir_header_to_synth_list(inode_table::synth_list_cur* cur_synthlistp)
{
    inode_table::data_block synth_item;
    location loc(info->direlemp->get_location());
    synth_item.block_begin = (ubigint64)cur_synthlist_offset.value();
    synth_item.block_size = (bigint64)loc.get_header_size().value();
    synth_item.block_checksum = loc.get_checksum().header_value;
    cur_synthlistp->add_item(synth_item);
    if (msg2) DB->msg("backndmptardir_base::add_dir_header_to_synth_list Added header for '%s' to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d block_checksum:%u) list size:%"LL"d",
                      *info->direlemp->name(), synth_item.block_begin, synth_item.block_size, synth_item.block_checksum, (ubigint64)cur_synthlistp->list_size());

    
    cur_synthlist_offset += loc.get_header_size();
    
    cur_synthlist_coversize = 0;
    
    dir_header_added = true;
}


void
backndmptardir_base::add_files_to_synth_list(inode_table::synth_list_cur* cur_synthlistp)
{
    if (cur_synthlist_coversize > 0) {
        
        

        inode_table::data_block synth_item;
        synth_item.block_begin = (ubigint64)cur_synthlist_offset.value();
        synth_item.block_size = (bigint64)cur_synthlist_coversize.value();
        synth_item.block_checksum = cur_synthlist_checksum;
        cur_synthlistp->add_item(synth_item);
        if (msg2) DB->msg("backndmptardir_base::add_files_to_synth_list Added file(s) to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                          synth_item.block_begin, synth_item.block_size, (ubigint64)cur_synthlistp->list_size());

        
        cur_synthlist_offset += cur_synthlist_coversize;
        
        cur_synthlist_coversize = 0;
        cur_synthlist_checksum = 0;
    }
}






void
backndmptardir_base::synth_volume_data(cycle *child,
                                       const inode_table::synth_list_cur* cur_synthlistp,
                                       const inode_table::synth_list_prev* prev_synthlistp)
{
    assert(info->use_container);
    assert(flags.incremental);

    if (msg2) DB->msg("backndmptardir_base::synth_volume_data Calling switchcontainers (parent:%p this:%p child:%p)", parent, this, child);
    
    
    main->switchcontainers(this, child);

    
    ustring staging_path;
    main->getAdeMgr()->getStagingPath(staging_path);
    path_to_temp_container = staging_path + "/" + TEMP_CONTAINER_FILENAME;
    if (msg2) DB->msg("backndmptardir_base::synth_volume_data absolute_path:'%s'", *path_to_temp_container);

    
    
    
    
    
    
    
    
    
    synth_block(0 , 0 , 0 , 0 , 0 , true );

    
    
    
    
    bool footer_present = false;
    ubigint64 top_level_inode(inode_is_64_bits ?
                              info->direlemp->inode_number64() :
                              info->direlemp->inode_number());
    merge_synth_lists(cur_synthlistp, prev_synthlistp, footer_present, top_level_inode, top_level_inode);
}




void
backndmptardir_base::dump_synth_lists(const inode_table::synth_list_cur* cur_synthlistp,
                                      const inode_table::synth_list_prev* prev_synthlistp)
{
    DB->msg("backndmptardir_base::dump_synth_lists  Dump of cur_synthlist for '%s'........:", *info->direlemp->name());
    for(inode_table::synth_list_cur::cur_list_iterator_const citer(cur_synthlistp->list_begin());
                                                 citer != cur_synthlistp->list_end();
                                                 citer++) {
        inode_table::data_block list_item(*citer);
        DB->msg("                            %sOffset:%"LL"d  Size:%"LL"d  Checksum:%u",
                (cur_synthlistp->is_dir(&list_item) ? "[directory inode]  " :
                 cur_synthlistp->is_hardlink_data(&list_item) ? "[hardlink inode]  " :
                 cur_synthlistp->is_dir_placeholder(&list_item) ? "[dir placeholder]  " : ""),
                
                list_item.block_begin, list_item.block_size, list_item.block_checksum);
    }
    DB->msg("backndmptardir_base::dump_synth_lists  Dump of prev_synthlist for '%s'........:", *info->direlemp->name());
    for(inode_table::synth_list_prev::prev_list_iterator_const piter(prev_synthlistp->list_begin());
                                                 piter != prev_synthlistp->list_end();
                                                 piter++) {
        inode_table::data_block list_item(*piter);
        DB->msg("                            %sOffset:%"LL"d  Size:%"LL"d  Checksum:%u",
                (prev_synthlistp->is_dir(&list_item) ? "[directory inode]  " :
                 prev_synthlistp->is_hardlink_data(&list_item) ? "[hardlink inode]  " :
                 prev_synthlistp->is_dir_header_size(&list_item) ? "[dir header size]  " : ""),
                list_item.block_begin, list_item.block_size, list_item.block_checksum);
    }
}







void
backndmptardir_base::save_location_template(const location &prev_loc, const bool base_container)
{
    if (base_container) {
        if (msg2) DB->msg("backndmptardir_base::save_location_template  Saving location information for base backup container");
        inodetab.base_container_location = prev_loc.make_template(true );
        if (msg1) DB->msg("backndmptardir_base::save_location_template  base location:%s", *inodetab.base_container_location.image());
    } else {
        if (msg2) DB->msg("backndmptardir_base::save_location_template  Saving location information for current backup container");
        inodetab.current_container_location = info->direlemp->get_location().make_template(true );
        
        
        inodetab.current_container_location.set_enclosing_container(NULL);
        inodetab.current_container_location.set_emd_relative_path(upath());
        inodetab.current_container_location.set_containerid(1);  
        
        inodetab.current_container_location.set_backupid(location::tbackupid(main->prev_backup.getBackupTime()));
        if (msg1) DB->msg("backndmptardir_base::save_location_template  current location:%s", *inodetab.current_container_location.image());
    }
}


fileoffset backndmptardir_base::emctar_file_hash_size(const DIRELEM &de)
{
    if (!de.is_stream_slice())
        return de.file_size();

    data_regions::endoffsets_t eoff;
    dirrec_pack::regions rr(&de);
    if (!rr.get(eoff)) {
        
        return fileoffset(0);
    }

    if (eoff.size() == 0) {
        
        return fileoffset(0);
    }

    return eoff.rbegin()->second;
}

#if !defined(RESTDATA_H_INCLUDED)
#define RESTDATA_H_INCLUDED












#include "cycle.h"
#include "fileref.h"
#include "restelem.h"

class backappend;
class chunker;


class restdata : public cycle {
public:

    
    
    
    

    
    
    
    class is_ourdata {
    public:
        is_ourdata() {};
        virtual ~is_ourdata() {};

        
        
        
        virtual bool operator()(const restelem& restinfo, const udirelemp& udep) const = 0;

        SAFEPOOLALLOC(restdata::is_ourdata);
    private:
    };

    typedef undoo::shared_ptr<is_ourdata> is_ourdata_sp;

    
    class is_regdata : public is_ourdata {
    public:
        is_regdata() {};
        virtual ~is_regdata() {};

        
        
        
        virtual bool operator()(const restelem& restinfo, const udirelemp& udep) const {
            
            assert(!udep.isnull());
            return !udep->is_meta();
        }

        SAFEPOOLALLOC(restdata::is_regdata);
    };

    
    class is_metadata : public is_ourdata {
    public:
        is_metadata(const udirelem::meta meta_) :
            m_meta(meta_)
            {};

        
        
        
        virtual bool operator()(const restelem& restinfo, const udirelemp& udep) const {
            udirelem::meta mi;
            assert(!udep.isnull());
            const bool udep_ismeta(udep->is_meta(mi));

            return udep_ismeta && mi == m_meta;
        };

        SAFEPOOLALLOC(restdata::is_metadata);
    private:
        const udirelem::meta m_meta;
    };

    
    static is_ourdata_sp default_is_ourdata_sp;

    
    
    

    restdata(cycle *parent,                             
             const hashcode& hash,                      
             chunktype *ctypep,                         
             const bool expectatomic,                   
             const restelem& restinfo,                  
             const fileoffset offset = fileoffset(0),   
             const fileoffset size = fileoffset(-1),    
             cycle *starter = NULL,                     
             const bigint64 prior = 0,                  
             const fileref& comparedata = fileref::empty,    
             const int conn = -1,                       
             backappend *root_file_cycle = NULL,        
             const bool use_container = false,          
             const is_ourdata_sp ourdata_sp = default_is_ourdata_sp); 

    
    restdata(cycle *parent,                             
             const hashcode& hash,                      
             chunktype *ctypep,                         
             const bool expectatomic,                   
             const restelem& restinfo,                  
             const bool use_container,                  
             const is_ourdata_sp ourdata_sp = default_is_ourdata_sp); 

    virtual void init();
    void response(message& outargs);
    virtual void childdone(cycle *child);
    static ucontainer::errortype read_data_from_ucontainer(context* main, restelem& info,
                                                           const bool validation,
                                                           int media_in_size,
                                                           const bool only_read_requested_size = false,
                                                           const is_ourdata_sp ourdatap = default_is_ourdata_sp);
    virtual ~restdata();
    restelem info;                                 

    SAFEPOOLALLOC(restdata);
private:
    
    const fileref comparedata;
    const bool expectatomic;

    bool fromcache;
    int redocount;
    const int conn;
    const bigint64 prior;
    bool use_comphints;
    chunktype *ctypep_to_return;  
    backappend *root_file_cycle;  
    const bool use_container;

    chunker *rest_chunker;

    is_ourdata_sp ourdata_sp;  

    bool checkcompressedhash(const fileref& data, const hashcode& hash);
    bool incremental_match(); 
    void send_get_data(hashcode &hash);
    void show_data(fileref &data, const ustring &msg, hashcode &computed_hash);
    restdata *find_restdata_parent( cycle *parent );
    bool read_data_from_catalog();

    ucontainer::errortype read_data_from_raw_container(const DIRELEM* direlem_ptr, ucontainer::basep container);

    
    
    
    static ucontainer::errortype container_getdata(context* main, restelem& info,
                                                   const int media_in_size,
                                                   const bool doexport,
                                                   fileoffset& export_start,
                                                   const bool only_read_requested_size);

    
    void contructorHelper (const hashcode& hash,
             const fileoffset offset,
             const fileoffset size,
             cycle *starter );

    friend class restdir;
    friend class backappend;
    friend class chunker;
};

#endif













#include "common.h"
#include "restdephash.h"
#include "restfile.h"
#include "restdata.h"
#include "compelem.h"
#include "context.h"
#include "pipe_control.h"
#include "output.h"

#define restdephash_msgs ((xflag[2]&4)!=0)
#define dowfs            ((xflag[15]&2)==0)


restdephash::restdephash(bicycle         *parent,
                         const hashcode&  hash,
                         DIRELEM&         direlem,
                         cycle           *starter 
                         )
    : restnofilter(parent, hash, direlem, NULL, starter)
{
    

    if(restdephash_msgs) {
        DB->msg("restdephash::restdephash name:%s", *this->info.path.image());
    }
}





void restdephash::childdone(cycle *child)
{
    if(restdephash_msgs)DB->msg("restdephash::childdone 1 child:%p nforked:%d ncollected:%d", child, nforked, ncollected);

    if (child) {         
        ncollected++;

        
        
        
        if(ncollected == 1) {
            
            const fileoffset raw_size(calculate_raw_size(ctype, info.data));

            
            if(raw_size != fileoffset::unknown && raw_size >= 0) {
                info.direlem.set_file_size(raw_size);
            }

            
            nforked++;
            restfile* mychild = new restfile(this, info.direlem.file_hash(), info.direlem, NULL, 0, info.vinfo, 0, 0,
                                          restfile::opt_dephash);
            
            mychild->set_info_pipe_control(info.ppipe_control);
            return;
        }
    }

    info.data.free();
    notifyparent();
}


restdephash::~restdephash()
{
    if(restdephash_msgs)DB->msg("restdephash::~restdephash()");
}





















#include "common.h"
#include "debug.h"
#include "restdirlist.h"
#include "restpipe.h"
#include "chunktype.h"
#include "compelem.h"
#include "utar_flags_enums.h"
#include "lowhash.h"







#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   


static upath last_bad_path;     





static name_to_direlemp_table default_nametable;
static composite_to_direlemp_table default_composite_nametable;
static direlemp_list_type default_direlemp_list;
static std::set<ubigint64> default_remove_list;



restdirlist::restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_,
                         const location &parent_data_loc_, composite_to_direlemp_table &table)
    : bicycle(parent),
      parent_metadata_loc(parent_metadata_loc_),
      relativepath(relativepath_),
      nametable(default_nametable),
      composite_nametable(table),
      direlemp_list(default_direlemp_list),
      output_list_type(output_composite_nametable),
      pathindex(0),
      parent_data_loc(parent_data_loc_),
      remove_list(default_remove_list),
      no_error_on_path_not_found(false)
{
    if (parent_data_loc.getMedia() > location::media::gsan && parent_data_loc.get_containerid() == 0) DB->msg("restdirlist::restdirlist for %s given parent_loc with 0 cid", *parent_metadata_loc.image());

    if (msg2) DB->msg("restdirlist::restdirlist %p loc:%s path:%s parent_location:%s",
                      this, *parent_metadata_loc.image(), *relativepath.image(), *parent_data_loc.image());
    composite_nametable.clear();

    const ustring msgid = ustring::sprintf("restdirlist of %dth elem of %s in %s", pathindex, *relativepath.image(), *parent_metadata_loc.image());
    if (cycle *child = new restdirlistproducer(this,
                                              this, 
                                              parent_metadata_loc,
                                              parent_data_loc,
                                              msgid)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
}


restdirlist::restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location &parent_data_loc_, name_to_direlemp_table &table)
    : bicycle(parent),
      parent_metadata_loc(parent_metadata_loc_),
      relativepath(relativepath_),
      nametable(table),
      composite_nametable(default_composite_nametable),
      direlemp_list(default_direlemp_list),
      output_list_type(output_nametable),
      pathindex(0),
      parent_data_loc(parent_data_loc_),
      remove_list(default_remove_list),
      no_error_on_path_not_found(false)
{
    
    
    if (parent_data_loc.getMedia() > location::media::gsan && parent_data_loc.get_containerid() == 0) DB->msg("restdirlist::restdirlist for %s given parent_loc with 0 cid", *parent_metadata_loc.image());

    if (msg2) DB->msg("restdirlist::restdirlist %p loc:%s path:%s parent_location:%s",
                      this, *parent_metadata_loc.image(), *relativepath.image(), *parent_data_loc.image());
    nametable.clear();

    const ustring msgid = ustring::sprintf("restdirlist of %dth elem of %s in %s", pathindex, *relativepath.image(), *parent_metadata_loc.image());
    if(cycle *child = new restdirlistproducer(this,
                                              this, 
                                              parent_metadata_loc,
                                              parent_data_loc,
                                              msgid)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
}


restdirlist::restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location &parent_data_loc_, direlemp_list_type &list, std::set<ubigint64> &remove_list_)
    : bicycle(parent),
      parent_metadata_loc(parent_metadata_loc_),
      relativepath(relativepath_),
      nametable(default_nametable),
      composite_nametable(default_composite_nametable),
      direlemp_list(list),
      output_list_type(output_direlemp_list),
      pathindex(0),
      parent_data_loc(parent_data_loc_),
      remove_list(remove_list_),
      no_error_on_path_not_found(false)
{
    if (parent_data_loc.getMedia() > location::media::gsan && parent_data_loc.get_containerid() == 0) DB->msg("restdirlist::restdirlist for %s given parent_loc with 0 cid", *parent_metadata_loc.image());

    if (msg2) DB->msg("restdirlist::restdirlist %p loc:%s path:%s parent_location:%s",
                      this, *parent_metadata_loc.image(), *relativepath.image(), *parent_data_loc.image());
    nametable.clear();

    const ustring msgid = ustring::sprintf("restdirlist of %dth elem of %s in %s", pathindex, *relativepath.image(), *parent_metadata_loc.image());
    if(cycle *child = new restdirlistproducer(this,
                                              this, 
                                              parent_metadata_loc,
                                              parent_data_loc,
                                              msgid)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
}



restdirlist::restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_,
                         const location& parent_data_loc_, direlemp_list_type_sp entries_, context * main )
    : bicycle(parent, main),
      parent_metadata_loc(parent_metadata_loc_),
      relativepath(relativepath_),
      nametable(default_nametable),
      composite_nametable(default_composite_nametable),
      direlemp_list(default_direlemp_list),
      output_list_type(output_direlemp_list),
      pathindex(0),
      parent_data_loc(parent_data_loc_),
      entries(entries_),
      remove_list(default_remove_list),
      no_error_on_path_not_found(false)
{
    if (msg2) DB->msg("restdirlist::restdirlist %p parent_meta_loc:%s path:%s parent_data_loc:%s ",
                      this, *parent_metadata_loc.image(true), *relativepath.image(), *parent_data_loc.image(true));
    nametable.clear();

    if(cycle *child = new restdirlistproducer(this, this, parent_metadata_loc_,
                                              parent_data_loc_,
                                              ustring::sprintf("restdirlist of %dth elem of %s in %s", pathindex, *relativepath.image(), *parent_metadata_loc_.image(true))))
    {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
}


restdirlist::~restdirlist()
{
    
}




void restdirlist::rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer)
{
    assert(pathindex <= relativepath.numelems());

    
    if (pathindex == relativepath.numelems()) {
        if (msg2) DB->msg("restdirlist::rdlpconsume processing %s direlems of listing data", *::tostr(direlems->size()));
        direlemp_list_type::const_iterator deiter = direlems->begin();
        std::set<ubigint64>::iterator iter(remove_list.end());
        while (deiter != direlems->end()) {
            switch (output_list_type) {
                case output_composite_nametable: {
                    if (flags.streamformat_in == utar_flags_enums::streamformat_isilon ||
                        flags.streamformat_in == utar_flags_enums::streamformat_zfs) {
                        
                        composite_nametable.split_enter((*deiter)->inode_number64(), *(*deiter)->name(), *deiter);
                    } else {
                        
                        composite_nametable.split_enter((*deiter)->emctar_inode_number64(), *(*deiter)->name(), *deiter);
                    }
                    break;
                }
                case output_direlemp_list: {
                    
                    
                    iter = remove_list.find((*deiter)->inode_number64());
                    if (iter == remove_list.end()) {
                        
                        direlemp_list.push_back(*deiter);
                    }
                    break;
                }
                case output_nametable: {
                    
                    nametable.enter((*deiter)->name(), *deiter);
                    break;
                }
                default: {
                    break;
                }
            }
            if (entries) {
                entries->push_back(*deiter);
            }

            deiter++;
        }
        return;
    }

    
    assert(pathindex < relativepath.numelems());
    if (msg2) DB->msg("restdirlist::consume for pathelem %d:'%s' of '%s', searching in %s direlems",
                      pathindex, *relativepath.get(pathindex), *relativepath.image(), *::tostr(direlems->size()));
    direlemp_list_type::const_iterator deiter = direlems->begin();
    while (deiter != direlems->end()) {
        const DIRELEMp dep = *deiter;
        const ustring& target(relativepath.get(pathindex)); 

        if (dep->name().equal(target)) {
            if (msg2) DB->msg("  found target direlem '%s'", *target);
            if (parent_data_loc.get_containerid() > 0) {
                if (msg2) DB->msg("restdirlist::consume found target direlem '%s' while parent.cid:%d, setting child cid",
                                  *target, parent_data_loc.get_containerid());
                location child_loc(dep->get_location());
                child_loc.set_containerid(parent_data_loc.get_containerid());
                dep->set_location(child_loc);
            }
            if (msg2) DB->msg("restdirlist::consume found target direlem '%s' with loc:%s, using as parent for next restdirlistproducer",
                              *target, *dep->get_location().image());

            
            assert(dep->is_directory());

            
            pathindex++;

            
            cycle *child = NULL;
            const ustring rdlpmsg(ustring::sprintf("restdirlist of %dth elem of %s in %s",
                                             pathindex, *relativepath.image(), *hash.partialimage()));

            
            const baselocation_sp fromwhere = dep->get_metadataLocation();
            location nextlocation;
            
            if (!fromwhere || fromwhere->isFromGsan()) {
                nextlocation = location(location::media::gsan, dep->file_hash());
            }
            else {
                nextlocation = location(*fromwhere);
            }

            child = new restdirlistproducer(this, this, nextlocation, dep->get_location(), rdlpmsg, dpn0);

            if (child != NULL) {
                nforked++;
                child->noop();
            } else {
                assert("Could not allocate restdirlistproducer object (from consume)" == 0);
            }

            
            producer->terminate();

            return;
        }
        deiter++;
    }
}

void restdirlist::init()
{
    
    assert(false);
}

void restdirlist::childdone(cycle *child)
{
    if (child) ncollected++;

    if (nforked == ncollected) {
        if (pathindex != relativepath.numelems()) {
            assert(nametable.size() == 0);

            last_bad_path = relativepath.slice(0, pathindex);
            const ustring msg(ustring::sprintf("restdirlist for '%s' in '%s', child finished, but pathindex:%d != relativepath.numelems():%d, setting lastbadpath '%s'",
                                               *relativepath.image(), *parent_metadata_loc.image(), pathindex, relativepath.numelems(), *last_bad_path.image()));
            if(no_error_on_path_not_found) {
                DB->msg("%s", *msg);
            } else {
                set_error(true, msg);
            }
        }

        if (parent == NULL) {
            todoEnqueue(TODO_DONE_SYNC);
        }

        
        notifyparent();

    }
}



#define AGETHRESHOLD 500

static int cache_time_ord;







class hash_direlem_cache {
public:
    hash_direlem_cache() : cachehits(0) { }

    
    class resrec {
    public:
        resrec(const hashcode dirhash, const upath& dirpath, name_to_direlemp_table *_tab, const int _casesense)
          : key(genkey(dirhash, dirpath)), tab(_tab), casesense(_casesense) { refresh_use(); }
        ~resrec() { delete tab; }

        hashcode get_key() const { return key; }
        name_to_direlemp_table* get_entry(int &_casesense) const { _casesense = casesense; return tab; }

        int get_lastuse() const { return use; }
        void refresh_use() { use = cache_time_ord++; }

        
        
        static inline hashcode genkey(const hashcode dirhash, const upath& dirpath) {
            lowhash hasher;
            const ustring path(dirpath.image());
            hasher.update(*path, path.bytelength());
            hasher.update((char *)&dirhash.data, BYTES_IN_HASH);
            hashcode hash_for_key;
            hasher.result(hash_for_key);
            return hash_for_key;
        };

    private:
        const hashcode key;             
        name_to_direlemp_table *tab;    
        const int casesense;            
        int use;                        
    };

    
    resrec *lookup(const hashcode dirhash, const upath& dirpath) {
        scope s(update_mut);
        const hashcode key(resrec::genkey(dirhash, dirpath));
        for(int i=0; i<(int)table.size(); i++) {
            if (table[i] != NULL && table[i]->get_key() == key) {
               table[i]->refresh_use();
               cachehits++;
               if((cachehits % 10000)==0) DB->msg("hash_direlem_cache::lookup: cachehits=%d, tablesize=%d", cachehits, (int)table.size());
               return table[i];
            }
        }
        return NULL;
    }

    
    void enter(resrec *r) {
        scope s(update_mut);
        int slot = -1;
        int lowest_use = -1;
        for(int i=0; i<(int)table.size(); i++) {
            if (table[i] == NULL) {
                slot = i;
                break;
            }

            
            if (lowest_use == -1 || table[i]->get_lastuse() < lowest_use) {
                slot = i;
                lowest_use = table[i]->get_lastuse();
            }

            
            
            if (cache_time_ord - table[i]->get_lastuse() > AGETHRESHOLD*4) {
                delete table[i];
                table[i] = NULL;
            }
        }

        if (slot==-1 || (lowest_use > -1 && cache_time_ord-lowest_use < AGETHRESHOLD)) {
            table.push_back(r);
        } else {
            assert(slot >= 0);
            delete table[slot];
            table[slot] = r;
        }
    }

private:
    mtex update_mut;
    DEFINE_STL_VECTOR_TYPE(resrec *) table;
    int cachehits;
};

hash_direlem_cache hd_cache;





















restdirelem::restdirelem(cycle* parent_, const DIRELEM& parentde_, const upath& fullpath_, int& casing)
    : bicycle(parent_),
        fullpath(fullpath_),
        backupid(parentde_.get_location().get_backupid()),
        parentde(parentde_),
        parent_data_loc(parentde_.get_location()),
      curlevel(0), casesense(casing), namedirtable(NULL)
{
    if (msg1) DB->msg("restdirelem::restdirelem constructor (parent:%p) (this:%p) fullpath:%s parent_loc:%s, sense %d", parent, this, *fullpath.image(), *parent_data_loc.image(), casesense);
    assert(parent != NULL);
    

    const baselocation_sp parentmetaloc(parentde.get_metadataLocation());
    
    if (!parentmetaloc) {
        curloc = location(location::media::gsan, parentde.file_hash());
    }
    
    else if (parentmetaloc->isFromCatalog() || parentmetaloc->isFromGsan()) {
        curloc = location(*parentmetaloc);
    }
    else {
        
        const ustring errmsg = ustring::sprintf("restdirelem::restdirelem called with unrecognized media location(%s)", *parentmetaloc->image());
        set_error(true, errmsg);
    }

    foundsofar = upath("", fullpath.kind(), true);  

    enqueue_self();
}

restdirelem::~restdirelem()
{
    
}




void restdirelem::init() {
    if (msg1) DB->msg("restdirelem::init (parent:%p) (this:%p) fullpath:%s foundsofar:%s parent_loc:%s, sense %d", parent, this, *fullpath.image(), *foundsofar.image(), *parent_data_loc.image(), casesense);

    
    
    const upath findme("", fullpath.kind(), true);  
    if (msg1)DB->msg("restdirelem::init calling restdirlist on '%s' with curloc:%s", *findme.image(), *curloc.image());

    
    
    
    
    if ((xflag[29]&1048576)==0 && curlevel > 0 && curloc.isFromGsan()) {
        hash_direlem_cache::resrec *res = hd_cache.lookup(curloc.getHash(), fullpath.slice(0, curlevel-1));
        if (res != NULL) {

            namedirtable = res->get_entry(casesense);
            assert(namedirtable != NULL);
            childdone(NULL);
            return;
        }
    }

    namedirtable = new name_to_direlemp_table;
    namedirtable->clear();  

    
    cycle* child = new restdirlist(this, curloc, findme, parentde.get_location(), *namedirtable);
    child->noop();
}



void restdirelem::childdone(cycle* child) {
    if (msg1) DB->msg("restdirelem::childdone (parent:%p) (this:%p) fullpath:%s, foundsofar:%s parent_loc:%s, sense %d", parent, this, *fullpath.image(), *foundsofar.image(), *parent_data_loc.image(), casesense);

    if (!uapp::staging().canRun()) { notifyparent(); return; }

    
    ustring name(fullpath.get(curlevel));  
    assert(curlevel <= fullpath.numelems());

    
    
    
    
    
    
    
    
    
    
    
    
    
    if(flags.xmlunentitifydpnpaths) {
        
        const ustring unentitified_name(xml_message::convert_xmlstring(name));
        if(name != unentitified_name) {
            DB->msg("restdirelem::childdone() unentitified name '%s' to '%s'", *name, *unentitified_name);
            name = unentitified_name;
        }
    }

    if (msg2) DB->msg("restdirelem::childdone looking for level:%d name:'%s' in %d, sense %d", curlevel, *name, namedirtable->size(), casesense);

    
    undoo::vector<ustring> keys;
    namedirtable->keys(keys);

    
    if ((xflag[29]&1048576)==0 && child && curlevel > 0 && curloc.isFromGsan()) {
        hash_direlem_cache::resrec *res = hd_cache.lookup(curloc.getHash(), fullpath.slice(0, curlevel-1));
        if (res == NULL) {
              hd_cache.enter(new hash_direlem_cache::resrec(curloc.getHash(), fullpath.slice(0, curlevel-1), namedirtable, casesense));
           
           
        }
    }

    
    DIRELEMp found_de(NULL);
    for (size_t i = 0; i < keys.size(); i++) {
	    if (msg1) DB->msg("restdirelem::childdone: '%s' =?= '%s'? sense %d", *keys[i], *name, casesense);

	    bool foundit(false);
	    
	    
	    
	    
	    
	    
	    
	    
	    
	    
	    
	    if (casesense == CASESENSITIVE)
	        foundit = keys[i].equal(name);
	    else	
	        foundit = keys[i] == name;

        if (foundit) {
	        found_de = namedirtable->lookup(keys[i]);
	        if (casesense == CASEUNDETERMINED) {
		    
		    
		    
		    
		    
		    
		    
		    
		    if (msg1) DB->msg("restdirelem::childdone: casesense was -1; de-get_kind():%d, ignorecase:%s",
                                      found_de->get_kind(), found_de->ignorecase() ? "true" : "false");

                
                
                if (found_de->get_kind() != 0) {
                    if (found_de->ignorecase()) {	
                        casesense = CASEINSENSITIVE;
                        if (msg1)
                            DB->msg("restdirelem::childdone(%s) - casesense = %d", *name, casesense);
                    } else {	
                        casesense = CASESENSITIVE;	
                        if (msg1)
                            DB->msg("restdirelem::childdone(%s) - casesense = %d", *name, casesense);
                        
                        if (!keys[i].equal(name)) {
                            if (msg1) DB->msg("restdirelem::childdone - found '%s' != '%s'", *name, *keys[i]);
                            foundit = false;
                            found_de = NULL;
                            continue;
                        }
                    }
                }
	        }
	        break;
	    }
    }

    
    if (found_de.isnull()) {
        DB->msg("restdirelem::childdone path not found '%s' foundsofar:'%s' ", *fullpath.image(), *foundsofar.image());
        cycle::set_error(true, ""); 
        errdesc = ustring::sprintf("only found '%s' of path '%s'", *foundsofar.image(), *fullpath.image());
        notifyparent();
        return;
    }


    
    location loc(found_de->get_location());

    if (msg1) DB->msg("restdirelem::childdone found child (parent:%p) (this:%p) fullpath:%s foundsofar:%s dataloc:%s",
                 parent, this, *fullpath.image(), *foundsofar.image(), *loc.image());


    loc.set_backupid(backupid);

    found_de->set_location(loc);

    if (msg2)DB->msg("restdirelem::childdone push_back '%s' level:%d direlem:%s loc:%s", *name, curlevel, *found_de->name(), *found_de->get_location().image());
    answers.push_back(found_de);    

    
    if (curloc.isFromGsan()) {
        curloc.setHash(found_de->file_hash());
    }
    else {
        
        curloc = location(*found_de->get_metadataLocation());
    }

    foundsofar.push_back(name);     
    curlevel++;

    parentde = *found_de;
    parent_data_loc = loc;     

    
    
    if (foundsofar.numelems() < fullpath.numelems()) {
        enqueue_self();
    } else {
        assert(int(answers.size()) == fullpath.numelems());
        if(msg1)DB->msg("restdirelem::childdone returns %d elements", (int)answers.size());
        notifyparent();
    }
}


void restdirelem::enqueue_self() {
    if(msg1) DB->msg("restdirelem::enqueue_self (parent:%p) (this:%p) fullpath:%s parent_loc:%s",
                     parent, this, *fullpath.image(), *parent_data_loc.image());
    
    
    main->add_insert(TODO_FILE, this, 0);       
}

#if !defined(CONTEXT_H_INCLUDED)
#define CONTEXT_H_INCLUDED



















#include "todoelem.h"
#include "sock.h"
#include "tassoc.h"
#include "hard_link_id.h"
#include "backstats.h"
#include "sessioninfo.h"
#include "sessioninfo2.h"
#include "mctypes.h"
#include "workcontext.h"
#include "statistic.h"
#include "filestats.h"
#include "utar_flags_info.h"
#include "upath.h"
#include "ctl_state.h"
#include "tnodeid.h"
#include "debug.h"
#include "inode_table.h"
#include "ade/interfaceade_flags.h"
#include "tversion.h"
#include "roothashlistrec.h"
#include "ddrfiles_xml.h" 
#include "ucontainer_base.h"
#include "container_cache.h"
#include "name_to_direlemp.h"
#include "location_types.h"
#include <map>
#include <utility>
#include "BackupRootInfo.h"
#include "resource_identifier.h"
#include "restelem.h"
#include "backupboostutils.h"

#include "location_info_repair.h"

class boolvect;
class backstate;
class watchdog_thread;
class signposts_base;

class dbmsgsender;

class mulqueue;
class message;
class cycle;
class BackCycle;
class msgqueue;
class msgrecv;
class async;
class retry;
class indexmap;
class hashsend;
class roothashlist;
class async_callback;

class pipe_control;
class dumpcontext;
class hashserver;
class ndmp_history;
class backdump;
class backview;
class utar_ctl_sup;
class utar_dto_sup;
class ADEMgrX;

struct hfs_info_struct;
class name_to_direlemp_table;
class location_checker;

#define REDOLIMIT 5



class context {
public:
    context(utar_flags_info&);

    
    hashcode final_resulthash;

    hard_link_to_file_name_t hard_link_to_file_name;
    inode64_to_direlemp_t      emctar_hardlinked_direlems;
    inode_table inodetab; 

    
    inode64_to_linkoffset_t inode64_to_linkoffset;

    
    ctl_statep client_ctl_statep;
    utar_ctl_sup*  tomato;
    utar_dto_sup*  dto_supp;

    
    workcontextref workctx;

    
    backstate *state;

    
    bool dolocalstats;

    
    bool need_rebuild;

    
    
    hashsend *sendthread;

    
    
    msgqueue *recvqueue;

    
    msgqueue *sendqueue;

    
    hashserver *hashsrv;

    
    ndmp_history *histsrv;

    
    safeint files_in_process;

    
    safeint num_open_files;

    
    safeint num_open_dirs;

    
    ustring open_files_list;

    
    safeint rebuilds_in_process;

    
    ustring target_path;

    
    
    
    
    signposts_base *signposts_p;

    
    
    
    
    
    tassoc<ustring, fileref> sysinfo_files_and_data;

    backupboost::target_system_info_data target_sysinfo_files_and_data;

    backupboost::target_work_results work_results;

    backupboost::journal_session_id_time_t session_id_time_table;

    
    fileref morphdata;

    utar_flags_info& get_flags() { return flags; }
    utar_flags_info* get_dstflags() { return dstflags; }
    void add_dstflags(utar_flags_info* dstflagsp);

    
    
    
    bool startsession(sessioninfo2 &sinfo,
                      dpns dpninx, const ustring& appname, const ustring& root, utar_flags_info& flags, cidtype cid, widtype wid,
                      dirstats *dstats, bool isbackup, const ustring& apptype, const ustring& label = "");

    
    
    xml_messagep get_errorsummary_xml(const int exitcode = -1);

    
    virtual void remotecall(cycle *cy, message& inargs, int connection = -1 );




    
    virtual void add(todo_kind kind, cycle *cy, bool error = false);

    
    virtual void add(todo_kind kind, cycle *cy,
                     message& outargs, bool error = false);

    void add_insert(todo_kind kind, cycle *cy, bigint64 ordinal, bool error=false);

    
    
    
    void safesetactivelimit(int n, const ustring& debug_append = "", const bool set_loop_limit = false);

    
    
    
    bool isOutputPipeFull(const bool activelimit_condition = true);

    
    

    


    
    int use_connection(int i); 

    
    virtual bool loop(bool async_mode = false, cycle* target_cycle = NULL);   

    
    virtual bool backup_orphaned_file(const fileref& data, hashcode& hash, bool isdir, fileoffset& size);

    
    virtual bool restore_dir(const location& metadataLocation, const upath& target, const DIRELEM *de = NULL, const location parentloc =location());

    
    
    virtual bool restore_one_file(const hashcode& hash, DIRELEM& direlem,
                                  fileoffset startoff=fileoffset(0), fileoffset endoff=fileoffset(0));

    
    
    virtual bool restore_gsanonly_file(fileref& res, const hashcode& hash, chunktype *ctypep, fileoffset sizehint = fileoffset(0),
                                       fileoffset startoff=fileoffset(0), fileoffset endoff=fileoffset(0));

    
    
    
    
    virtual bool restore_gsanonly_file_cb(fileref& res, const hashcode& hash, chunktype* ctypep,
                                          async_callback *cb, fileoffset sizehint = fileoffset(0),
                                          fileoffset startoff=fileoffset(0), fileoffset endoff=fileoffset(0));

    
    virtual bool restore_chunk(fileref& res, const hashcode& hash, chunktype& ctype);

    
    void record_basefiles(const int ddrhandle, const ustring& clientid, const location::tbackupid backupid,
                          const ddrfiles_xmlp ddrfiles, const int file_count, fileref& ddrwrite) const;

    
    virtual bool restore_tarpipe(const location& theLoc,
                                 const userid  *uidmap,
                                 const groupid *gidmap,
                                 const ustring& filename,
                                 const ustring& target,
                                 const bool isdir);

    
    virtual bool restore_dumppipe(const location& fromloc, const ustring& filename, const stringlist& frompaths,
                                  const bool isdir, DIRELEM& de, const bool is_inode_format);

    
    virtual bool get_hash_info(const hashcode& hash, fileoffset& size, bool& isdir);

    
    virtual bool get_hash_ispresent(const hashcode& hash);

    
    virtual bool get_dir_entry(const hashcode& hash, const ustring& name, DIRELEM& entry);

    
    bool restore_prev_dump(backdump *d);
    bool find_prev_backup(BackupRootInfo& prevBackup);  
    bool restore_a_view(backview *d, int labelnum, ustring acnt);

    bool prepare_emctarstream_incremental(const BackupRootInfo& prevBackup);

    
    
    
    
    
    
    
    
    
    static const int DefaultRestoreCacheSize = 500;
    static const int MaxRestoreCacheSize = 5000;
    void restorecache_enable(int maxmessages = DefaultRestoreCacheSize, bool cache_atomics = true);

    
    bool restorecache_enabled() const;

    
    bool restorecache_cache_atomics() const;

    
    bool restorecache_enter(const hashcode& hash, const message& m);

    
    bool restorecache_lookup(const hashcode& hash, message& m) const;

    
    bool restorecache_defined(const hashcode& hash) const;

    
    void restorecache_stats(int &enters, int &lookups, int &hits) const;

    
    ustring restorecache_image() const;

    void smallfile_prefetcher_stats(fileoffset &totalbytes, fileoffset &runningbytes);

    
    cidtype getclientid() const
        { return my_clientid; }

    void setclientid(cidtype cid)
        { my_clientid = cid; }

    
    void getdispatcherlist(dpns dpninx, sessioninfo::dispatcherlist&) const;

    int get_pending_size();

    void handling_system_info(bool b)
        { system_info_files = b; }

    bool handling_system_info() const
        { return system_info_files; }

    
    bool set_location_info_required(const bool b) {
        const bool ret(get_location_info_required());
        location_info_required = b;
        return ret;
    }

    
    bool get_location_info_required() const
        { return location_info_required; }

    
    bool set_ddr_loc_info_ignored(const bool b) {
        const bool ret(get_ddr_loc_info_ignored());
        ddr_loc_info_ignored = b;
        return ret;
    }

    
    bool get_ddr_loc_info_ignored() const
        { return ddr_loc_info_ignored; }

    
    
    
    void set_ddr_backup_contains_unmapped_data(location_types::tbackupid bid, bool has_unmapped) {
        (void)backups_with_unmapped_data.insert(std::make_pair(bid, has_unmapped));
    }

    
    
    
    
    
    int get_ddr_backup_has_unmapped_data(location_types::tbackupid bid) const {
        const unmapped_data_backup_map::const_iterator found(backups_with_unmapped_data.find(bid));
        return (found == backups_with_unmapped_data.end())? -1 : (found->second? 1 : 0);
    }

    void check_for_raw_format(const location::tbackupid bid, const fileref& ddrfilesdata);
    void check_for_raw_format(const location::tbackupid bid, ddrfiles_xml& ddrfiles);

    
    
    
    

    enum statstype {
        backupstats  = 0,
        restorestats = 1,

        statstypenum = 2, 
    };

    void set_dpn_statstype(dpns dpninx, statstype st);
    statstype get_dpn_statstype(dpns dpninx);

    
    backstats *getstatsobj(statstype st);

    void byteprogress(statstype st, backstats::reason why, double size,
                      const filestatsref &fstats = filestatsref(),
                      chunktype kind = chunktype(0));

    void addfilebytes(statstype st, double size);

    void addprogbytes(statstype st, double size);

    void addfilecount(statstype st, double n);

    void addfilepercentnew(statstype st, double sz, double n);

    
    
    
    
    bool emctar_hardlinked_file (DIRELEM &de, bool &isfirst, ustring &realfullpath, MetadataId &metadataid, fileoffset &sz);
    bool check_emctar_hardlinked_file (const DIRELEM &de, bool &isfirst, DIRELEMp &realde, MetadataId &metadataid, fileoffset &sz, ubigint64 &dir_offset, bool is_emctar = false);
    bool check_zfstar_hardlinked_file (const DIRELEM &de, bool &isfirst, DIRELEMp &realde, MetadataId &metadataid, fileoffset &sz, ubigint64 &dir_offset, data_regions::endoffsets_t &endoffsets);
    bool record_hardlinked_file(const DIRELEM &de);
    
    bool record_one_hardlink_restore(const DIRELEM &de);
    bool hardlinked_file(DIRELEM &direlem, hashcode &de_hash, fileref &altslice, fileref &stubslice );
    void hardlinkable_file_ready( const DIRELEM &direlem );

    
    void print_path(DIRELEM& direlem);

    
    
    void print_path_and_hash(DIRELEM& direlem, hashcode hash);

    
    const int nodeid_to_conn(dpns dpninx, tnodeid nodeid);

    
    pipe_control *getpipe_control(const restelem* re) const;

    dumpcontext *getdumpcontext() const {
        return pdumpcontext;
    }

    backdump *getbackdump() const {
        return pbackdump;
    }

    backview *getbackview() const {
        return pbackview;
    }

    bool isnewdir() const {
        return true;
    }

    bool isatombit() const {
        return true;
    }

    bool dosyslog() const
        { return syslog; }

    
    void setcurtime(epoch_t t) { curtime = t; }

    
    epoch_t getcurtime() { return curtime; }

    
    epoch_t acl_access_time(const DIRELEM& direlem) const;

    
    void set_cur_filename(const upath& filepath, bool isdir = false);

    
    ustring get_cur_filename(int maxlen = 0, bool from_end=false);

    
    
    
    void adjustfileACLstripped(size_t adj = 1) { numfileACLstripped += adj; }
    size_t getfileACLstrippedcount(void) const { return numfileACLstripped; }
    void adjustdirACLstripped(size_t adj = 1)  { numdirACLstripped += adj; }
    size_t getdirACLstrippedcount(void) const { return numdirACLstripped; }

    
    void layout_direlem(DIRELEM& de, fileref& data, bool computedsizeonly, bool newdir, bool inode);

    
    void start_watchdog(int cancel_timer_secs);

    
    void request_rebuild() {}

    

    
    
    
    bool load_and_use_saas_library(const ustring shared_path, const ustring shared_object_name);

    
    fileref::encmodes get_encmode() { return encmode; }
    fileref get_enckey() { return enckey; }

    
    
    
    
    
    
    hashcode get_backupconfighash() const { return backupconfighash; }

    
    hashcode get_encrypthash()      const { return encrypthash; }

    bool is_in_async_mode() const { return in_async_mode; }

    bool open_progresslog();

    utar_flags_info incflags;  

    
    
    encodings character_encodings;

    sessioninfo2 sessinfo[maxdpns];  

    messagecodes getdpnmaxmessage(dpns dpninx=dpn0) const;

    unsigned int getmaxchunksize(dpns dpninx, chunktype ctype) const;

    tmessagesize getmaxdpnmessagedatasize(dpns dpninx) const;

    unsigned int getmaxdpnatomchunksize(dpns dpninx) const;

    unsigned int getmaxdpncompchunksize(dpns dpninx) const;

    tversion getserverversion(dpns dpninx) const;

    unsigned int getmaxdirelemsize(dpns dpninx);

    BackupRootInfo      prev_backup;

    
    
    resource_identifier_list backup_resource_list;

    fileref& getprogresslog() { return(progresslog); }

    ADEMgrX* getAdeMgr() { return(adeMgr); }

    bool init(cidtype clientid);

    bool engageADE(utar_flags_info* dpn1flags = NULL);
    void disengageADE();
    bool enableADEChunker(hfs_info_struct &hfs_info);   
    bool ADEChunkerEnabled();

    bool running_cycles() const { return cycles_running; }

    inline mulqueue* getTodoQueue() { return(todo_queue); }

  
    
    hashcode get_metadata_roothash(const hfs_info_struct& hfs_info) const;
    
    void remove_old_metadata(const hfs_info_struct& hfs_info, const hashcode& metahash);

  
    
    void initializeavtarwork(const int streamindex);

    
    
    ucontainer::basep initnextucontainer(const DIRELEMp& containerobj,
                                         bool honorcontainerpath,
                                         bool add_to_ddrfilesxml = true);

    
    
    
    void finalizeucontainer(ucontainer::basep container, const bool writeddrfilesxml = false);

    void switchcontainers(BackCycle *cy, cycle *child);

    
    
    ucontainer::basep getucontainer_yucky_global();
    void closeucontainer_yucky_global();

    
    
    
    ucontainer::basep open_container_for_read(const location& loc, bool ok_to_use_container_cache = true); 

    
    
    
    ucontainer::basep open_raw_container_for_write(const upath filepath, location::tcontainerid& containerid, const location::tformat::type streamtype = location::tformat::raw);
    bool close_raw_container_for_write(ucontainer::basep containerp);

    
    
    
    
    
    bool copy_whole_container(ucontainer::basep containerp, DIRELEMp de, const upath& newgsanpath, const bool create_cdsf_containerid_name = false);

    
    
    
    
    
    bool copy_all_subcontainers(ucontainer::basep containerp, DIRELEMp de, const upath& newgsanpath);

    void initializeContainerCache();
    void enable_container_object_cache() { use_container_objcache = true; }

    void close_object_in_container(const location& loc);

    void add_ddr_stats(statstype st, const fileref& transport);

    bool is_update_file_cache() const { return update_file_cache; }
    void set_update_file_cache(bool update_file_cache_) { update_file_cache = update_file_cache_; }

    bool is_backupboost_threaded_backup() const { return backupboost_threaded_backup; }
    void set_backupboost_threaded_backup() { backupboost_threaded_backup = true; }

    
    
    
    
    
    
    
    xml_messagep gather_existing_backup_info_xml(const location& theLoc, const BackupRootInfo* brip,
                                                 fileref ddrwrite = fileref());

    SAFEDEF();
    virtual ~context();

protected:
    mulqueue *todo_queue;

    utar_flags_info& flags;
    utar_flags_info* dstflags;

private:
    friend class replicate;

    bool contextopened;
    cidtype my_clientid;
    int numthreads;

    backstats ctx_stats[statstypenum+1]; 
    statstype dpn_stats_type[maxdpns];
    unsigned int maxdirelemsize[maxdpns];

    
    xml_messagep retrieve_existing_backup_info_xml(const location& theLoc, const upath path);

    watchdog_thread *watchdog;
    pipe_control *ppipe_control;
    dumpcontext *pdumpcontext;
    backdump *pbackdump;
    backview *pbackview;

    bool shuttingdown;
    async *asyncthread;
    retry *retrythread;
    safeint nextserial;

    int tunecounter;
    int sendcount;
    int pendcount;
    int outputthrottles;

    int keep_alive_timer;

    
    bool system_info_files;

    
    
    
    bool location_info_required;

    
    
    
    
    
    
    bool ddr_loc_info_ignored;

    debug::basedbmsgsenderref sender;

    mtex filesystem_mutex;

    bool syslog;

    size_t  numfileACLstripped;
    size_t  numdirACLstripped;

    double prefetch_bytes[CACHELEVEL_COUNT];
    int prefetch_count[CACHELEVEL_COUNT];

    epoch_t curtime;
    epoch_t warntime;

    mtex  curfile_mtex;
    upath curfile;
    bool  curisdir;
    bool  in_async_mode;
    bool  cycles_running;

    
    
    mtex ddrfiles_xml_mutex;

    
    fileref progresslog;

    
    bool process_pause_request(debug::pause_t *&pause_request);

    
    void calculate_and_set_activelimit(const bool async_mode);

    
    void get_data_at_rest_encryption_key(const ustring path);

    
    void set_backupconfighash();

    class restorecache;
    undoo::shared_ptr<restorecache> restorecachep;

    double wasted_cpu_throttling_ms;

    tassoc<intobj,int> node_to_conn_cache;

    fileref::encmodes encmode;
    fileref enckey;
    hashcode backupconfighash;
    hashcode encrypthash;

    ADEMgrX* adeMgr;                    
    utar_flags_info  *dpn1flags;        

   
    
    safeint loop_activelimit;

    ucontainer::basep ucontainerp_yucky_global; 
    container_cache containercache;
    bool use_container_cache;
    bool use_container_objcache;

    
    bool update_file_cache;

    bool backupboost_threaded_backup;

    safeint ucontainer_streamindex; 
    const location::tcontainerid allocate_ucontainer_streamindex() {
        return +ucontainer_streamindex++;
    };

    
    const ddrfiles_xmlp get_backup_ddrfiles_xmlp(const location& de) const;

    
    
    const ddrfiles_xml::emd_elementv get_subcontainer_list(const DIRELEMp de) const;

 public:
    bool validate_direlem(const DIRELEM& de); 

    
    const location fill_in_location_clientid_and_backupid(const location& loc) const;

    
    
    
    void setBackupAvtarVersion(const ustring& versionstr, int pidnum);

    bool corruptedBackupFixupCodeEnabled() const { return locRepair; }

    
    
    
    bool handleEsc24121LocMissing(const DIRELEM& parentde, DIRELEM& de);

    
    
    
    
    
    
    
    
    bool handleEsc24121LocAdjustment(const DIRELEM& parentde, const DIRELEM& de, const location& loc, int container_entry_idx, location& newloc);


 private:
    
    
    bool set_location_info_from_upath(const upath& gsanpath, DIRELEM &de) const;

    const ustring create_gsanfullpath(const bool honorobjpath, const ustring& prefix, const ustring& objpath) const;

    void location_checker_summary(); 
    location_checker *checkinfo;     
    typedef DEFINE_STL_MAP_TYPE(location_types::tbackupid, bool) unmapped_data_backup_map;
    unmapped_data_backup_map backups_with_unmapped_data;

    
    tversion backupvers;

    location_info_repair_sp locRepair;

 public:
    
    
    
    tversion get_avtar_version_that_created_backup() const {
        return backupvers;
    }

    bool set_location_info(const ustring& called_from, const location& parentloc, DIRELEM &de) const;

    
    
    
    const emd_elementp get_container_emd(const bool use_containerid_lookup, const DIRELEMp de) const;

    
    
    
    
    
    
    class prep_for_sysinfo {
    public:
        prep_for_sysinfo(context& c)
            : c(c),
              orig_locinfo_required(c.set_location_info_required(false)),
              orig_handling_sysinfo(c.handling_system_info())
        {
            c.handling_system_info(true);
        }
        ~prep_for_sysinfo() {
            c.set_location_info_required(orig_locinfo_required);
            c.handling_system_info(orig_handling_sysinfo);
        }
    private:
        context& c;
        const bool orig_locinfo_required, orig_handling_sysinfo;
    };

    static ustring determineClientID(const hfs_info_struct& hfs_info);

    
    
    
    
    
    
    
    class prep_for_no_ddr_container {
    public:
        prep_for_no_ddr_container(context& c)
            : c(c),
              orig_ddrlocinfo_ignored(c.set_ddr_loc_info_ignored(true))
        { }
        ~prep_for_no_ddr_container() {
            c.set_ddr_loc_info_ignored(orig_ddrlocinfo_ignored);
        }
    private:
        context& c;
        const bool orig_ddrlocinfo_ignored;
    };

 private:
    NOCOPY(context);
};

#endif


#if !defined(ZFSTARPARSESTREAM_H_INCLUDED)
#define ZFSTARPARSESTREAM_H_INCLUDED












#include "parsestream.h"
#include "backdataconsumer.h"
#include "data_regions.h"
#include "tassoc.h"

namespace zfstarstream {

enum pax_field_len {
    NAME_FIELD_LEN       = 100,
    MODE_FIELD_LEN       = 8,
    UID_FIELD_LEN        = 8,
    GID_FIELD_LEN        = 8,
    FILE_SIZE_FIELD_LEN  = 12,
    MTIME_FIELD_LEN      = 12,
    CHKSUM_FIELD_LEN     = 8,
    TYPEFLAG_FIELD_LEN   = 1,
    LINKNAME_FIELD_LEN   = 100,
    MAGIC_FIELD_LEN      = 8,
    UNAME_FIELD_LEN      = 32,
    GNAME_FIELD_LEN      = 32,
    DEVMAJOR_FIELD_LEN   = 8,
    DEVMINOR_FIELD_LEN   = 8,
    HLINK_INO_FIELD_LEN  = 12,
    
    
    PREFIX_FIELD_LEN     = 100,
    TH_PRIMARY_FIELD_LEN = 21,
    TH_VERSION_FIELD_LEN = 1,
    TH_MARKER_FIELD_LEN  = 1,
    TH_INODE_FIELD_LEN   = 21,
    TH_NLINK_FIELD_LEN   = 11,
    PAX_PADDING          = 12
};

enum pax_field_offset {
    NAME_FIELD_OFFSET       = 0,
    MODE_FIELD_OFFSET       = NAME_FIELD_OFFSET + NAME_FIELD_LEN,
    UID_FIELD_OFFSET        = MODE_FIELD_OFFSET + MODE_FIELD_LEN,
    GID_FIELD_OFFSET        = UID_FIELD_OFFSET + UID_FIELD_LEN,
    FILE_SIZE_FIELD_OFFSET  = GID_FIELD_OFFSET + GID_FIELD_LEN,
    MTIME_FIELD_OFFSET      = FILE_SIZE_FIELD_OFFSET + FILE_SIZE_FIELD_LEN,
    CHKSUM_FIELD_OFFSET     = MTIME_FIELD_OFFSET + MTIME_FIELD_LEN,
    TYPEFLAG_OFFSET         = CHKSUM_FIELD_OFFSET + CHKSUM_FIELD_LEN,
    LINKNAME_FIELD_OFFSET   = TYPEFLAG_OFFSET + TYPEFLAG_FIELD_LEN,
    MAGIC_FIELD_OFFSET      = LINKNAME_FIELD_OFFSET + LINKNAME_FIELD_LEN,
    UNAME_FIELD_OFFSET      = MAGIC_FIELD_OFFSET + MAGIC_FIELD_LEN,
    GNAME_FIELD_OFFSET      = UNAME_FIELD_OFFSET + UNAME_FIELD_LEN,
    DEVMAJOR_FIELD_OFFSET   = GNAME_FIELD_OFFSET + GNAME_FIELD_LEN,
    DEVMINOR_FIELD_OFFSET   = DEVMAJOR_FIELD_OFFSET + DEVMAJOR_FIELD_LEN,
    HLINK_INO_FIELD_OFFSET  = DEVMAJOR_FIELD_OFFSET,  
    PREFIX_FIELD_OFFSET     = DEVMINOR_FIELD_OFFSET + DEVMINOR_FIELD_LEN,
    TH_PRIMARY_FIELD_OFFSET = PREFIX_FIELD_OFFSET + PREFIX_FIELD_LEN,
    TH_VERSION_FIELD_OFFSET = TH_PRIMARY_FIELD_OFFSET + TH_PRIMARY_FIELD_LEN,
    TH_MARKER_FIELD_OFFSET  = TH_VERSION_FIELD_OFFSET + TH_VERSION_FIELD_LEN,
    TH_INODE_FIELD_OFFSET   = TH_MARKER_FIELD_OFFSET + TH_MARKER_FIELD_LEN,
    TH_NLINK_FIELD_OFFSET   = TH_INODE_FIELD_OFFSET + TH_INODE_FIELD_LEN
};

struct pax_header {
    char pathname[NAME_FIELD_LEN];
    char mode[MODE_FIELD_LEN];
    char uid[UID_FIELD_LEN];
    char gid[GID_FIELD_LEN];
    char size[FILE_SIZE_FIELD_LEN];
    char mtime[MTIME_FIELD_LEN];
    char chksum[CHKSUM_FIELD_LEN];
    char typeflag;
    char linkpath[LINKNAME_FIELD_LEN];
    char magic[MAGIC_FIELD_LEN];
    char uname[UNAME_FIELD_LEN];
    char gname[GNAME_FIELD_LEN];

    

    union {
        struct {
            char major[DEVMAJOR_FIELD_LEN];
            char minor[DEVMINOR_FIELD_LEN];
        } dev;
        char hlinkino[HLINK_INO_FIELD_LEN]; 
    } u;

    char prefix[PREFIX_FIELD_LEN];
    char thprimary[TH_PRIMARY_FIELD_LEN];
    char thversion;
    char thmarker;
    char thinode[TH_INODE_FIELD_LEN];
    char thnlink[TH_NLINK_FIELD_LEN];
    char paxpadding[PAX_PADDING];
};

enum ustar_ndmp_code {
    LF_NONE,
    LF_NORMAL   = '0',
    LF_LINK     = '1',
    LF_SYMLINK  = '2',
    LF_CHR      = '3',
    LF_BLK      = '4',
    LF_DIR      = '5',
    LF_FIFO     = '6',
    LF_CONTIG   = '7',
    LF_HUMONGUS = 'H',
    LF_LONGLINK = 'K',
    LF_LONGNAME = 'L',
    LF_MULTIVOL = 'M',  
    LF_VOLHDR   = 'V',  
    LF_ACL      = 'A',
    LF_XATTR    = 'E'
};

enum zfstar_state {
    ZFS_TAR_NONE,
    ZFS_TAR_HEADER,
    ZFS_TAR_PRIMARY,
    ZFS_TAR_PADDING,
    ZFS_TAR_HUMONGUS,
    ZFS_TAR_EXTENDED,
    ZFS_TAR_DONE
};

enum th_marker_code {
    TH_NONE = ' ',
    TH_REGULAR = 'f',
    TH_SPECIAL = 's',
    TH_DIRECTORY = 'd',
    TH_ATTRIBUTE = 'a',
    TH_HUGEFILE = 'h'
};

enum hdr_state {
    S_NONE,
    S_READ_HDR,
    S_WRITE_DATA,
    S_READ_EXT_HDR,
    S_WRITE_EXT_DATA,
    S_LONGNAME_HDR,
    S_LONGNAME_DATA,
    S_DONE
};

struct zfstar_ctx {
    zfstar_ctx();
    void clear();
    ustring image() const;
    zfstar_state tarstate;
    hdr_state hdrstate;
    unsigned char typeflag;
    unsigned char thmarker;
    fileoffset filebytesremaining;
    fileoffset hdrbytesremaining;
    fileoffset endoffset;
};

const int BLOCKSIZE = 512;

const ustring LONGNAME_PREFIX = "././_LoNg_NaMe_";
const ustring LONGNAME_LABEL = "././_LoNg_NaMe_qd.fil";

int get_padding(bigint64 datasize, int blocksize = BLOCKSIZE);

class header {
public:
    SAFEALLOC(header);

    header();
    header(const fileref& buf);

    
    void clear();

    
    void initialize(const fileref& buf);

    
    bool iszeroblock() const;

    
    
    bool isgood() const;

    
    ustring image() const;
    void dump() const;

    
    
    ustring stateimage() const;

    
    ustring errormsg() const { return image(); }

    void get_header_buf(fileref& headerbuf);

    unsigned short calculate_checksum(const fileref& buf);

    ubigint64 get_padded_size() const;

    bool is_tar_hardlink() const;

    bool is_special_file() const;

    bool is_long_name() const;

    
    ustring           pathname;
    unsigned int      mode;
    unsigned int      uid;
    unsigned int      gid;
    ubigint64         size;
    unsigned long     mtime;
    unsigned int      chksum;
    unsigned char     typeflag;
    ustring           linkpath;
    ustring           magic;
    ustring           uname;
    ustring           gname;
    ustring           devmajor;
    ustring           devminor;
    unsigned long     hlinkino;
    ustring           prefix;
    ustring           thprimary;
    unsigned char     thversion;
    unsigned char     thmarker;
    ubigint64         thinode;
    unsigned long     thnlink;

 private:
    bool allzerobytes(const char* p, size_t n);

    typedef enum {
        ets_hdr_uninitialized,
        ets_hdr_insufficientdata,
        ets_hdr_badmagic,
        ets_hdr_badversion,
        ets_hdr_badchksum,
        ets_hdr_zeroblock,
        ets_hdr_badvalues,
        ets_hdr_good
    } header_state_t;

    
    header_state_t state;

    
    ustring errmsg;
};




class parser : public parsestream, public backdataconsumer::producer {
public:
    SAFEALLOC(parser);

    
    
    
    parser(const ustring& streamdesc = "",
           const int streamformat = utar_flags_enums::streamformat_zfs,
           const int blocksize = BLOCKSIZE,
           const int stream_timeoutsecs = 30,
           const unsigned objflags_ = 0,
           const ustring& input_tee_streamdesc = "",
           utar_flags_info* flags = NULL);

    virtual ~parser();

    
    
    
    virtual bool getentry(DIRELEMp& de, fileref& altdata, fileref& stubdata);

    virtual fileoffset get_headeroffset() { return tarctx.endoffset; }

    
    
    
    
    
    
    
    
    
    virtual bigint64 readdata(void* bufp, size_t n);

    
    virtual void recordmarks(DIRELEMp& de);

    virtual void non_celerrai18n() const;
    virtual void celerrai18n() const;

    virtual bool is_empty_stream() const;

    

    virtual fileref nextdatablock(bool& suppress_requeue);

    
    
    bigint64 flushtonextheader();

    bool path_changed(const ustring& curpath);

    void set_path(const ustring& pathstr);

    void get_header_image(fileref& buf, bool skipaclhdr = false);

    bool is_humongus_file() const;

    ubigint64 file_size() const;

protected:
    
    
    
    bigint64 peekdata(const bigint64 size, fileref& data, const ustring& desc);
    void mark_end_offset(zfstar_state newstate);
    bool accommodate_peek_size(size_t newsize);
    bool check_eof(bool& founderror);
    bool check_empty_block(bool& founderror);
    bool set_direlem(DIRELEMp& de);
    void set_tar_hardlink(DIRELEMp& de);
    bool get_next_header();
    bool get_metadata_block();
    bool get_acl_header();
    bool get_humongusfile_header();
    bool get_longname_header(bool islink);
    bool is_first_hlink();
    bool check_hardlink_exists();
    bool is_peekbuffer_empty();
    bool outputfromstream(void* bufp, size_t n, fileoffset& bytesremaining);
    bool outputfrombuffer(void* bufp, size_t n);
    void set_primary_end_offsets();
    void parsehumongusfile(void* bufp, size_t n);
    void parse_extattr(void* bufp, size_t n);
    void parse_extattr_hdr(void* bufp, size_t n);
    void parse_extattr_data(void* bufp, size_t n);
    void parse_extattr_exthdr(void* bufp, size_t n);
    void parse_extattr_extdata(void* bufp, size_t n);
    void parse_extattr_longhdr(void* bufp, size_t n);
    void parse_extattr_longdata(void* bufp, size_t n);
    void read_all_zeros();
    void clearmarks();
    void clear();

    
    header pax_hdr;
    header metadata_hdr;
    header acl_hdr;
    header longname_hdr;
    header longlink_hdr;
    header humongus_hdr;
    fileref metadata_blob;
    fileref acl_data;
    fileref longname_data;
    fileref longlink_data;
    fileref humongus_data;
    ustring fullpathstr;
    ustring linkpathstr;

    
    data_regions::endoffsets_t marks;

    
    zfstar_ctx tarctx;

    
    
    
    fileref peekeddata;

    
    fileoffset peekstart;

    
    fileoffset peekend;

    
    
    
    
    typedef scalar<bigint64> inodeobj;
    tassoc<inodeobj, intobj> hardlinkinodes;

    mutable utar_flags_info* flags;

    
    fileref peekbuffer;

    
    bool found_zero_block;

    
    bool empty_stream;

    
    bool eof;

    
    ubigint64 totalfiledatasize;

    
    
    
    bigint64 bytesread;

    
    ustring errormsg;

 private:
    NOCOPY(parser);
};

}

#endif
#if !defined(COLLATOR_H_INCLUDED)
#define COLLATOR_H_INCLUDED
























class chunker;
class hashcode;
class chunktype;
class fileref;
               
class collator {
public:
    collator(chunker *chunk);

    int nextpos();

    void append(hashcode& hash, chunktype& kind, fileref& data, int origsize, int pos);

    void flush();

    void result(hashcode& hash, bool& isatomic);

    void set_chunk( chunker *chunk_ ); 

    SAFEPOOLALLOC(collator);
private:
    int id;
    chunker *chunk;
    int maxpos;
    int curpos;
    hashcode resulthash;
    bool wasatomic;
    class collelem;
    collelem *list;

    void insert(collelem *e);
};

#endif
#if !defined(TARPIPE_H_INCLUDED)
#define TARPIPE_H_INCLUDED












#include "pipe_control.h"
#include "fileref.h"
#include "direlem.h"
#include "ustring.h"
#include "userid.h"
#include "changeblockmap.h"
#include "dataextents.h"



class tarpipe : public pipe_control {
public:
    
    
    tarpipe(fileref data_, const userid *uidmap_, const groupid *gidmap_, const ustring pathprefix_,
            const int streamformat_, const int blocksize_,
            const ustring changeblockmap_filepath = ustring());

    
    
    virtual bool addfile(const DIRELEM& elem,
                         const ustring& path,
                         fileref& dataslice,
                         fileref& altdataslice,   
                         fileref& stubdataslice,  
                         fileref& gsanextentsdata,
                         const filetype ftype = REGTYPE,
                         const ustring& linkname = "",
                         const fileoffset startoff = fileoffset(0)
                         );

    
    virtual bool have_extentsdata() { return extents.size() > 0; }

    
    
    
    
    
    
    
    
    virtual bool getnextextent(extent& e, fileoffset& off, const ustring path);

    SAFEALLOC(tarpipe);

protected:
    
    dataextents extents;

    
    
    
    
    bool fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                    const DIRELEM& elem,  const ustring& path,
                    const filetype ftype, const ustring& linkname,
                    const fileoffset startoff=fileoffset(0));

    
    
    
    
    
    
    
    virtual bool addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                        const fileoffset datasize, fileref& dataslice);

private:
    const userid *uidmap;
    const groupid *gidmap;
    const ustring pathprefix;
    const int blocksize;

    
    const changeblockmap changemap;

    
    ustring     filepath_for_extents;

    
    size_t nextextent;

    
    
    bool dont_output_pax_extended_header;

    void fillmyblock(fileref &fref);

    void addstring(fileref& header, const ustring& s, int max);
    bool addoctal(fileref& header, const ustring& path, const char *fieldname, 
                  ubigint64 n, int max, const char appendvalue = 0);
    bool splitpath(const ustring& path, ustring& prefix, ustring& name);

    
    
    
    bool lowfillheader(fileref& header,
                       const DIRELEM& elem, const ustring& path, const filetype ftype,
                       const fileoffset filesize, const ustring& linkname = ustring(0));

    void addxrec(fileref& header,
                 const ustring& keyword, const ustring& value);

    void addxrec(fileref& header,
                 const ustring& keyword, const ubigint64 value);

    void addxrec(fileref& header,
                 const ustring& keyword, const fileref& value);

    
    
    void pax_extended_header(const filetype ftype,
                             const DIRELEM& elem,
                             const ustring& path,
                             const fileoffset& filesize,
                             const ustring& uname, const ustring& gname,
                             const ustring& linkpath,
                             fileref& data);

    bool combine_extents_intersection(const dataextents& newextents, const upath path);
};



#endif
#if !defined(AVPAXPIPE_H_INCLUDED)
#define AVPAXPIPE_H_INCLUDED












#include "tarpipe.h"
#include "udirelem.h"
#include "exclude.h"
#include "direlem.h"

namespace ucontainer {
    class base;
};



class avpaxpipe : public tarpipe {
public:
    
    
    
    avpaxpipe(fileref data, const int streamformat, const ustring& stream_filename, const unsigned long flags_,
              const int ddrhandle, const ustring clientid, const location::tbackupid backupid,
              fileref ddrwrite,
              const int restorebufmb);

    
    virtual ~avpaxpipe();

    
    
    virtual bool init_fileref(const ustring& streamdesc, const int buffermb, const int stream_timeoutsecs=30, const bool closefilewhendone=false);

    
    
    
    virtual bool output_avamar_archive_info(const xml_messagep xmlp);

    
    
    
    virtual bool addfile(const DIRELEM& elem,
                 const ustring& path,
                 fileref& dataslice,
                 fileref& altdataslice,   
                 fileref& stubdataslice,  
                 fileref& gsanextentsdata,
                 const filetype ftype = REGTYPE,
                 const ustring& linkname = "",
                 const fileoffset startoff = fileoffset(0)
                 );

    
    
    
    
    
    
    
    
    
    
    
    
    virtual bool addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                        const fileoffset datasize, fileref& dataslice);

    
    
    
    virtual bool finobj(const filetype otype, const ustring& path, const DIRELEM& elem);

    
    virtual fileoffset reserved_bytes_pending();

    
    
    virtual bool iserror();

    
    
    virtual void padd_end(fileoffset& size_of_stream);

    
    
    
    
    void match_content_out_of_stream(const ustring& pattern);

    
    
    
    direlemp_list_type retrieve_all_content_out_of_stream() const;

    SAFEALLOC(avpaxpipe);
protected:

private:
    NOCOPY(avpaxpipe);

    
    udirelemp  convertde(const DIRELEM& elem, const bool isroot = false) const;
    DIRELEMp noconvertde(const DIRELEM& elem, const bool isroot = false) const;

    
    udirelemp  convertde_dephash(const DIRELEM& elem, const udirelem::meta meta) const;
    DIRELEMp noconvertde_dephash(const DIRELEM& elem, const udirelem::meta meta) const;

    
    bool has_error;

    
    ucontainer::base *pcp;

    
    fileoffset saved_datasize;

    
    fileoffset saved_metasize;

    
    ustring saved_metaname;

    
    bool need_begindircontent;
    DIRELEM dir_direlem;

    
    
    bool just_processed_out_of_stream_object;

    
    const bool is_streamformat_cdsf;

    
    
    const bool is_media_out_ddr;

    
    exclude outofstream_patterns;

    
    direlemp_list_type out_of_stream_list;
};



#endif


#include "common.h"
#include "debug.h"
#include "restorestreamstate.h"
#include "streamtransformbackupread.h"
#include "streamtransformemctardedup.h"

#define rssmsgs 0


RestoreStreamState::RestoreStreamState(RestoreStreamType type, const fileref compressordata) :
    m_foStartOfNextSegment(0), m_foBytesRetrieved(0)
{
    switch (type) {
    case rst_none:
        m_pst = new StreamtransformData(false, false);
        break;
    case rst_ntfs:
        m_pst = new StreamtransformBackupRead(true, false);
        break;
#if CELERRA_CMR10
    case rst_emctar_dedup:
        m_pst = new StreamtransformEmctarDedup(compressordata);
        break;
#endif
    default:
        DB->error("RestoreStreamState::RestoreStreamState unknown type:%d",
                  type);
        break;
    }
}

RestoreStreamState::~RestoreStreamState(void)
{
    delete m_pst;
}



bool RestoreStreamState::signalEndOfPass(void){
    if( !m_pst->queryStreamProcessingIsComplete() ) {        
        m_pst->signalEndOfStream(m_sb);
    }
    if( m_pst->queryStreamProcessingIsComplete() &&
        m_pst->queryStreamContentIsValid() ) {
        if( !m_pst->querySecondPass() ) {
            DB->msg("Commence second pass of Office 2007 restore");
            m_sb.signalSecondPass();
            m_pst->signalSecondPass();
            m_foStartOfNextSegment = 0;
            return true;
        } 
    }

    
    if( m_pst->queryStreamProcessingIsComplete() &&
        m_pst->queryStreamContentIsValid() ) {
        DB->msg("restdata: BackupRead content is valid");
    } else {
        DB->error("restdata: BackupRead content NOT valid");        
    }
    return false;
}



bool RestoreStreamState::isNextSegmentPresent(void)
{
    bool bRetVal = false;
    QUEUEDSEGMENTS::iterator pos = m_sQueuedSegments.begin();
    if( (pos != m_sQueuedSegments.end()) && 
        (m_foStartOfNextSegment == (*pos).getOffset()) ) { 
        bRetVal = true;
    }
    return bRetVal;
}



bool RestoreStreamState::queueStreamSegment(fileoffset foOffset, fileref& frWriteThis)
{
    assert(foOffset >= m_foStartOfNextSegment);

    for( QUEUEDSEGMENTS::iterator pos = m_sQueuedSegments.begin(); pos != m_sQueuedSegments.end(); ++pos) {
        
        if( foOffset < pos->getOffset() ) {
            if( (foOffset + frWriteThis.size64()) > pos->getOffset() ) {
                DB->error("inserting segment @%f (%f bytes) that overlaps a previously inserted segment @ %f",
                    foOffset.dvalue(), frWriteThis.size64().dvalue(), pos->getOffset().dvalue());
            }
        }
    }

    m_sQueuedSegments.insert(StreamSegment(foOffset, frWriteThis));
    if (rssmsgs) DB->msg("after insert foOffset:%s m_foStartOfNextSegment:%s", *foOffset.image(), *m_foStartOfNextSegment.image());
    if( (foOffset - m_foStartOfNextSegment) > (128 * 1024 * 1024) ) {
        double fQueued = 0.0;
        for( QUEUEDSEGMENTS::iterator pos = m_sQueuedSegments.begin(); pos != m_sQueuedSegments.end(); ++pos) {
            fQueued += pos->getSegment().size64().dvalue();
        }
        double fGap = m_sQueuedSegments.begin()->getOffset().dvalue() - m_foStartOfNextSegment.dvalue();
        double fSpan = m_sQueuedSegments.rbegin()->getOffset().dvalue() + m_sQueuedSegments.rbegin()->getSegment().size64().dvalue() - m_foStartOfNextSegment.dvalue();
        DB->warn("Internal Warning: Very large amount of pending data queued %.0fMB, (%.0fMB span), %fMB processed, %.0f bytes missing", 
            fQueued / (1024*1024),
            fSpan / (1024*1024),
            m_foStartOfNextSegment.dvalue() / (1024*1024),
            fGap);
    }
    return isNextSegmentPresent();
}




fileref RestoreStreamState::retrieveStreamSegment(bool& bNextSegReady)
{
    if( isNextSegmentPresent() ) {
        QUEUEDSEGMENTS::iterator pos = m_sQueuedSegments.begin();
        assert((*pos).getOffset() == m_foStartOfNextSegment);
        fileoffset foSegmentSize = (*pos).getSegment().size64();
        if (rssmsgs) DB->msg("retrieveStreamSegment found next segment at %s with %s bytes",
                             *m_foStartOfNextSegment.image(), *foSegmentSize.image());
        m_foStartOfNextSegment = m_foStartOfNextSegment + foSegmentSize;
        m_pst->appendInput( m_sb, (*pos).getSegment()); 
        m_sQueuedSegments.erase(pos); 
        if( m_sQueuedSegments.begin() != m_sQueuedSegments.end() ) {
            if( m_foStartOfNextSegment > m_sQueuedSegments.begin()->getOffset() ) {
                DB->error( "processed %fByte segment at %f, overlapping following %fByte segment at %f",
                    foSegmentSize.dvalue(), m_foStartOfNextSegment.dvalue() - foSegmentSize.dvalue(),
                    m_sQueuedSegments.begin()->getSegment().size64().dvalue(),
                    m_sQueuedSegments.begin()->getOffset().dvalue());
            }
            assert( m_foStartOfNextSegment <= m_sQueuedSegments.begin()->getOffset() );
        }
        bNextSegReady = isNextSegmentPresent();
        if( m_pst->queryStreamIdentified() ) { 
            m_foBytesRetrieved =  m_foBytesRetrieved + m_sb.getBytesAvailable();
            
            fileref answer = m_pst->extractOutput(m_sb, m_pst->getBytesAvailable(m_sb));
            if (!bNextSegReady && rssmsgs) {
                DB->msg("retrieveStreamSegment returning last fileref (no next segment present)");
                DB->msg("our transform object has: %"LL"u bytes consumed, %"LL"u bytes exported, %d bytes available, and %d internal bytes",
                        m_pst->getBytesConsumed(), 
                        m_pst->getBytesExported(),
                        m_pst->getBytesAvailable(m_sb),
                        m_pst->getBytesInternal(m_sb));
            }
            return answer;
       }
    } else {
        if (rssmsgs) {
            DB->msg("retrieveStreamSegment but no next segment present");
            DB->msg("our transform object has: %"LL"u bytes consumed, %"LL"u bytes exported, %d bytes available, and %d internal bytes",
                    m_pst->getBytesConsumed(), 
                    m_pst->getBytesExported(),
                    m_pst->getBytesAvailable(m_sb),
                    m_pst->getBytesInternal(m_sb));
        }
        bNextSegReady = false;
    }
    return fileref();
}



















#include "common.h"
#include "debug.h"
#include "fileref.h"
#include "context.h"
#include "resource.h"
#include "filestats.h"
#include "workelem.h"
#include "backstate.h"
#include "backstats.h"
#include "utar_flags_info.h"
#include "chunktype.h"
#include "output.h"
#include "backappend.h"
#include "nbackdata.h"
#include "utar_flags_enums.h"
#include "parsestream_base.h"
#include "streambuffer.h"
#include "streamtransformemctardedup.h"

#include "dirrec_pack.h"

#define nbackdata_msg ((xflag[2]&1)!=0)


extern bigint64 curfileord;



nbackdata::nbackdata(BackCycle *parent, workelem *info, fileoffset offset_, const bool isdir_,
                     parsestream_base *parser_ , const bool use_container_  )
    :  BackCycle(parent, info), parser(parser_), inlookup(false), depkind(none), isdir(isdir_), use_container(use_container_)
{
    assert(parent != NULL);
    if (info->use_container) {
        assert(!info->container.isnull());
    }
    cycle::offset = offset_;
    if( nbackdata_msg )
        DB->msg("nbackdata::nbackdata %p %s isdir=%d, parser=%p use_container?%d",
                 this, *info->path.image(), isdir, parser, use_container);
    todoEnqueueInsert(TODO_FILE, this, curfileord++);    
}

nbackdata::nbackdata(BackCycle *parent, workelem *info,
                     nbackdata_depkind depkind_,
                     parsestream_base *parser_,
                     const bool use_container_ )
    : BackCycle(parent, info), parser(parser_), inlookup(false), depkind(depkind_), isdir(false), use_container(use_container_)
{
    assert(parent != NULL);
    if (use_container) assert(info->use_container && !info->container.isnull());
    if( nbackdata_msg )
        DB->msg("nbackdata::nbackdata (this:%p) (parent:%p, %s) %s depkind:%d use_container?%d",
            this, parent, typeid(*parent).name(),*info->path.image(), depkind, use_container);

    cycle::offset = fileoffset::unknown;
    
    
    
    
    if (depkind_ == none) DB->warn("nbackdata::nbackdata constructor called with depkind:none");

    todoEnqueueInsert(TODO_FILE_CACHE, this, curfileord++);    
}

void nbackdata::init()
{
    const upath& path = info->path;

    fileoffset file_size = info->direlemp->file_size();
    info->fstats = filestatsref(flags, path, file_size.dvalue());

    if (!info->ignoreStats && depkind != do_not_set_hash) {
        
        
        if (!info->changeblock)
            main->addfilebytes(context::backupstats, file_size.dvalue());
        else
            main->addfilebytes(context::backupstats, info->streamslice.dvalue());
    }

    if( nbackdata_msg )
        DB->msg("nbackdata::init %p file \"%s\", %s bytes, depkind:%d, dpn = %d",
                this, *path.image(), *file_size.image(), depkind, (int)info->dpninx);
    
    
    if (depkind == emctar_altdata) {
        assert(NULL != parser);
    }

    append_format fmt = af_none;
    if (depkind == emctar_altdata)
        fmt = af_emctar_ads;
    else if (depkind == emctar_dedup)
        fmt = af_emctar_dedup;
    else if (depkind == do_not_set_hash)  
        fmt = af_not_primary;


    backappend *cycle_chunk = new backappend( this,
                                              main,
                                              info,
                                              info->data,
                                              isdir,
                                              info->streamslice,
                                              fmt, 
                                              NULL,
                                              parser);
    assert(cycle_chunk);
    if (use_container) assert(info->use_container && !info->container.isnull());
    cycle_chunk->noop();

    if( nbackdata_msg ) DB->msg("nbackdata::nbackdata %p created backappend %p with use_container:%d info->use_container:%d info->container:%p, leave init (%s)",
                                this, cycle_chunk, use_container, info->use_container, info->container.getimpl(), *path.image());
}

void nbackdata::childdone(cycle *child){
    if(child->cyisatomic)
        cyisatomic = true;  

    

#if CELERRA_CMR10
    
    
    if (info && info->st.isdefined()) {
        if (nforked == 0) {
            
            
            

            
            fileref compressordata; 

            if (nbackdata_msg)
                DB->msg("nbackdata::childdone %s streamtransform set, info->streamslice:%s, info->st->getBytesExported:%"LL"u hash:%s",
                        info->direlemp->fullpath().image().tostr(),
                        info->streamslice.image().tostr(), info->st->getBytesExported(), hash.partialimage().tostr());
            info->direlemp->set_hash(hash);
            info->direlemp->set_file_size(info->streamslice);

            
            dirrec_pack::emctar_dedup epd(info->direlemp.getimpl());
            epd.set(info->streamslice, info->st->getBytesExported());

            if (!info->st->queryStreamProcessingIsComplete()) {
                DB->warn("nbackdata::childdone has Streamtransform but says it's not done");
            }
            if (!info->st->queryStreamContentIsValid()) {
                set_error(true, ustring::sprintf("Error processing space-reduced file '%s'", *info->direlemp->fullpath().image()));
                
                BackCycle::childdone(child);
                return;
            }
            StreamtransformEmctarDedup *st = dynamic_cast<StreamtransformEmctarDedup*>(info->st.getimpl());
            if (st == NULL) {
                DB->error("nbackdata::childdone has Streamtransform but it's not a StreamtransformEmctarDedup");
            } else {
                compressordata = st->getCompressorData();
            }

            
            hashcode cdh;
            compressordata.binhash(cdh);
            if (stmsg) DB->msg("nbackdata compressordata %s %s bytes", *cdh.image(), *compressordata.size64().image());

            workelem *wl = new workelem(info, info->direlemp->fullpath(), info->direlemp, filestatsref(), compressordata);
            wl->use_container = false; 
            wl->setParentHash = false;
            nbackdata *back_compressordata = new nbackdata(this, wl, emctar_dedup, parser);
            back_compressordata->noop();
            nforked++;

            return;
        } else {
            ncollected++;
            if (ncollected < nforked) {
                if (nbackdata_msg)
                    DB->msg("nbackdata::childdone ncollected:%u nforked:%u, still waiting on children",
                            ncollected, nforked);
                return;
            } else {
                if (nbackdata_msg) DB->msg("nbackdata::childdone finished all forked children");
            }
        }
    }
#endif

    
    BackCycle::childdone(child);
}

#define issavestream (flags.streamformat_in == utar_flags_enums::streamformat_savestream)

void nbackdata::notifyparent() {
    if( nbackdata_msg )
        DB->msg( "nbackdata::notifyparent %p info->direlemp->fullpath:%s is_tar_hardlink:%d hash:%s size:%s depkind:%d",
                 this, *info->direlemp->fullpath().image(), info->direlemp->is_tar_hardlink(), hash.partialimage().tostr(),
                 info->direlemp->file_size().image().tostr(), depkind);

    if(parser) {
        
        parser->record_hash(info->direlemp, hash, cyisatomic);

        if(issavestream && flags.xdrctl) {
            
            
            main->safesetactivelimit(TODO_MAX, " got hash", true);
        }
    }

    
    
    
    if (depkind == none) {
        assert (fileoffset::unknown != offset);
        info->direlemp->set_hash(hash);
        if( nbackdata_msg ) DB->msg("nbackdata::notifyparent %s set_hash(%s) = %s",
                                     *info->direlemp->fullpath().image(), *info->direlemp->file_hash().partialimage(), *hash.partialimage());
    } else if (depkind == do_not_set_hash) {
        

        
        


    } else {
        if (nbackdata_msg)
            DB->msg("nbackdata::notifyparent depkind:%d not 'none' hash:%s info->direlemp->fullpath:%s",
                    depkind, *hash.partialimage(), *info->direlemp->fullpath().image());
        int depoffset = info->direlemp->adddephash(hash);
        switch (depkind) {
        case emctar_altdata: {
            dirrec_pack::emctar_altdata ead(info->direlemp.getimpl());
            fileoffset datasize(info->size);
            if (nbackdata_msg)
                DB->msg("nbackdata::notifyparent %p emctar_altdata ead.set(%s, %d)",
                        this, *datasize.image(), depoffset);
            ead.set(datasize, depoffset);
            break;
        }
        case emctar_stubdata: {
            dirrec_pack::emctar_stubdata esd(info->direlemp.getimpl());
            if (nbackdata_msg)
                DB->msg(DBTXT("nbackdata::notifyparent %p emctar_stubdata esd.set(%s, %d)"),
                              this, *info->data.size64().image(), depoffset);
            esd.set(info->data.size(), depoffset);
            break;
        }
        case emctar_dedup: {
            dirrec_pack::emctar_dedup epd(info->direlemp.getimpl());
            if (nbackdata_msg)
                DB->msg(DBTXT("nbackdata::notifyparent %p emctar_dedup_leading epd.set(%s, %d)"),
                        this, *info->data.size64().image(), depoffset);
            epd.reset_compressordata(info->data.size(), depoffset);
            break;
        }
        default:
            DB->error("nbackdata::notifyparent unknown dephash kind %d", depkind);
        }
    }

    
    BackCycle::notifyparent();
    
}

nbackdata::~nbackdata() {
    assert( !info->direlemp->should_skip_this_file() );
    if(! info->isapi)
        delete info;
}
#if !defined(DUMP_DIRELEM_H_INCLUDED)
#define DUMP_DIRELEM_H_INCLUDED












#include "direlem.h"
#include "dumpdirtable.h"
#include "dirrec_pack.h"

struct s_spcl;

#define USE_FULLPATH 0   

class dumpDIRELEM : public DIRELEM {
public:
    dumpDIRELEM()
      : subnodes(NULL), visited(false), found_in_stream(false)
    {}

    dumpDIRELEM(const DIRELEM& direlem)
      : DIRELEM(direlem),
      subnodes(NULL), visited(false), found_in_stream(false)
    {}

    ~dumpDIRELEM() {
        delete subnodes;
    }

    
    
    void initialize(const s_spcl& header, unsigned char attributes); 

    void enter(const ustring& name, int inode) {
        if(subnodes == NULL)
            subnodes = new dumpdirtable(32);  
        subnodes->enter(name, inode);
    }

    void clear() {
      if(subnodes==NULL) return;
      subnodes->clear();
    }

    void keys(undoo::vector<ustring>& res) const {
        if(subnodes == NULL)
            res.clear();
        else
            subnodes->keys(res);
    }

    int lookup(const ustring& name) const {
        if(subnodes == NULL)
            return 0;
        else
            return subnodes->lookup(name);
    }

    void set_fullpath(const ustring& path) {
        #if USE_FULLPATH
            DIRELEM::set_fullpath(path);
        #endif
    }

    const ustring fullpath() const {
        #if USE_FULLPATH
            return DIRELEM::fullpath();
        #else
            return DIRELEM::name();
        #endif
    }

    bool was_visited() const { return visited; }
    void set_visited(const bool yes=true) { visited = yes; }

    bool was_found_in_stream() const { return found_in_stream; }
    void set_found_in_stream(const bool yes=true) { found_in_stream = yes; }

    int num_elems() const { return (subnodes==NULL)?0:subnodes->size(); }
    bool defined(ustring name) const { return (subnodes==NULL)?false:subnodes->defined(name); }

    
    void add_header(const fileref& header_data) {
      dirrec_pack::dump_header hd(this);
      hd.set(header_data);
    }

    
    bool get_header(fileref& header_data)  {
      dirrec_pack::dump_header hd(this);
      return hd.get(header_data);
    }

    void add_acl_ref(const int32_t inode_ref) {
      dirrec_pack::acl_ref ar(this);
      ar.set(inode_ref);
    }

    bool get_acl_ref(int32_t &inode_ref) const {
      dirrec_pack::acl_ref ar(this);
      return ar.get(inode_ref);
    }

    
    int c_spare_26() const;





    SAFEPOOLALLOC(dumpDIRELEM);
private:
    dumpdirtable *subnodes; 
    bool visited;           
    bool found_in_stream;   
};

typedef scalar<unsigned int> uintobj;
typedef tassoc<intobj, DIRELEMp> direlem_assoc_type ;

#endif

#if !defined(NDMPCONTROL_H_INCLUDED)
#define NDMPCONTROL_H_INCLUDED












class ustring;
class DIRELEM;
class fileoffset;
class context;

class ndmpcontrol {
public:
    SAFEALLOC(ndmpcontrol);
    ndmpcontrol(bool enable);
    ~ndmpcontrol();
    void start(int rootinode);
    void senddirelem(int dirinum, const ustring& name, int inum);
    void sendinode(int inum, const DIRELEM& info, const fileoffset& offset);
    void finish();
private:
    bool enabled;
    ustring prefix;
    ustring system;
    FILE *outf;

    char getfilechar(const DIRELEM& info);
};

#endif











#include "common.h"
#include "debug.h"
#include "synccall.h"
#include "todoelem.h"
#include "runstage.h"
#include "dpnobj_types.h"
#include "ade_mgrx.h"

synccall::synccall(context& main_, dpns dpninx_)
  : cycle(NULL, &main_),
    sendcallbase(main_.dosyslog()),
    dpninx(dpninx_)
{
}

bool synccall::isopen() const
{
    return main->getAdeMgr()->getHfsInfo(dpninx).isAvailable;
}

message synccall::call(message& inargs, int connection) {
    
    
    if (main->is_in_async_mode()) {
        this->cb = new synccall_callback();     
        this->autodelete = false;               
    }

    ADEMgrX* adeMgr = main->getAdeMgr();
    if(adeMgr != NULL) {        
        if(inargs.isflagset(MSGFLAG_NOACK))  {  
            adeMgr->remoteAsyncCall(inargs, NULL, dpninx);
        }
        else {  
            adeMgr->remoteAsyncCall(inargs, this, dpninx);
        }
    }
    else {  
        assert(adeMgr);
        inargs.setresponse(MSG_ERR_NOTSTARTED);
        return(inargs);
    }

    if(inargs.isflagset(MSGFLAG_NOACK)) {
        if (!main->is_in_async_mode()) inargs.setresponse(MSG_ERR_NONE);
        else {
            assert(NULL != this->cb);
            delete cb;
            cb = NULL;
        }
        return inargs;
    }

    if (cb != NULL) {
        cb->wait();
        delete cb;
        cb = NULL;
    } else {
        
        
        
        
        if (main->is_backupboost_threaded_backup())
            main->loop(false, this);
        else
            main->loop();
    }




    return this->outargs;
}

void synccall::response(message& outargs) {
    this->outargs = outargs;
    main->add(TODO_DONE_SYNC, this); 
}

synccall::~synccall() {
}
#if !defined(BACKDIRMERGE_H_INCLUDED)
#define BACKDIRMERGE_H_INCLUDED












#include "hashcode.h"
#include "cycle.h"
#include "fileref.h"
#include "context.h"
#include "backdataconsumer.h"
#include "ade_mgr.h"

enum phases {
    phase_start,
    phase_restlistings,
    phase_mergelistings,
    phase_backupmergedlisting,
    phase_hiddendir,
    phase_finishmerge
};



class backdirmerge : public BackCycle, public backdataconsumer::producer {
public:
    SAFEPOOLALLOC(backdirmerge);

    backdirmerge(BackCycle *parent,   
                 workelem *info_,     
                 DIRELEMp &prevdp_,
                 DIRELEMp &currdp_,
                 int traverse_depth_);

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);

    
    virtual fileref nextdatablock(bool& suppress_requeue);

    virtual ~backdirmerge();

protected:
    
    
    void appendde(DIRELEMp de, bool is_curr);

    
    
    void mergesome();

    name_to_direlemp_table prevlisting, currlisting; 
    direlemp_list_type newlisting;              
    DIRELEMp prevdp, currdp;                    
    phases phase;                               
    int traverse_depth;

private:
    
    unsigned int previndex;
    unsigned int currindex;
    unsigned int curindex;      

    
    bool casesensitive;

    
    ustring staging_path;

    
    location curr_loc;

    
    bool merging_roots;

    
    bool final_stage;

    
    
    bool merge_to_ddr;

    
    
    DataDomainSysInfo* ddrSysInfo;

    

    bool namelessthan(ustring &prevname, ustring &currname)
    {
        if (casesensitive)
             return prevname.lessthan(currname);
        return prevname < currname;
    }

    bool nameequals(ustring &prevname, ustring &currname)
    {
        if (casesensitive)
             return prevname.equal(currname);
        return prevname == currname;
    }

};

#endif


#if !defined(SYNCCALL_H_INCLUDED)
#define SYNCCALL_H_INCLUDED












#include "cycle.h"
#include "message.h"
#include "context.h"
#include "dpnobj_types.h"
#include "uevent.h"


class synccall_callback : public async_callback {
public:
    
    synccall_callback(size_t *sizep_ = NULL) : sizep(sizep_), results(0), is_notified(false) { }
        
    virtual ~synccall_callback() { }

    
    
    virtual bool notify(size_t actsize, int resultcode) {
        if(sizep) *sizep = actsize;
        results = resultcode;
        assert(!event.is_set());
        is_notified = true;
        event.set();
        return true;
    }

    
    virtual int wait() {
        event.wait_for_set();
        assert(event.is_set());
        assert(is_notified);
        return results; 
    }

    
    void reset() {
        results = 0; 
        is_notified = false;
        event.reset();
    }

    
    bool notified() { return is_notified;  }

    SAFEALLOC(synccall_callback);

private:
    size_t *sizep;
    int results;

    uevent event;
    bool is_notified;  
};


class synccall : public cycle, public sendcallbase {
public:
    
    synccall(context& main, dpns dpninx = dpn0);   
    virtual ~synccall();

    
    virtual void response(message& outargs);

    
    

    
    virtual message call(message& inargs, int connection = 0);

    virtual bool isopen() const;

    SAFEALLOC(synccall);
private:
    dpns dpninx;
    message outargs;
};

#endif
















#include "common.h"
#include "debug.h"
#include "fileref.h"
#include "filestream.h"
#include "filemap.h"
#include "resource.h"
#include "filestats.h"
#include "workelem.h"
#include "backstate.h"
#include "backstats.h"
#include "filename_cache.h"
#include "hash_cache.h"
#include "utar_flags_info.h"
#include "chunktype.h"
#include "output.h"
#include "backappend.h"
#include "nbackdir.h"   
#include "nbackfile.h"
#include "nbackdata.h"
#include <errno.h>
#include <string.h>
#include "connerror.h"
#include "platerror.h"
#include "runstage.h"
#include "msgpack_c.h"
#include "streamtransformzip.h"
#include "ade_mgrx.h"
#include "reparse_points.h"

#if SYSTEM_WINDOWS
    #include "wss_sis_manager.h"
    #include "volumeinfo.h"
    #include "win_os_version_info.h"
#endif


#define msg1 ((xflag[2]&4)!=0)
#define dbg_reparse_points      (xflag[30]&8)
#define sis_feature_enabled ((xflag[22]&262144)==0)
#define enable_set_office2007_call ((xflag[31]&256)!=0)
#define clear_backup_sparse_attribute_on_windows_dedup_file ((xflag[31]&16384)==0)




#define SKIP_ARCHIVING_STUB_SIZE_CHECK ((xflag[31]&67108864)!=0)

#define inject_ddr_checksum_error ((xflag[26]&4)!=0) 


bigint64 curfileord;

enum phases { phase_init       = 0, 
              phase_checkcache = 1, 
              phase_inlookup   = 2, 
              phase_incache    = 3, 
              phase_backupfile = 4, 
              phase_synthfile  = 5, 
              phase_done       = 6  
};

void HandleShareError(const upath& file, const platerror& errobj);















nbackfile::nbackfile(BackCycle *parent, workelem *info, const fileoffset offset_, cycle * starter , int fd , 
                     const fileref& symlink_target_path_ref_ ) :
    BackCycle(parent, info),
    flag_ddgsan2dd(flags.ddgsan2dd.bytelength() > 0),  
    need_raw_container(false),
    raw_containerid(0),
    phase(phase_init),
    started_thread(false),
    synth_cache_atime(0),
    synth_loc(),
    file_desc(fd),
    
    
    
    file_obj((fd > 0) ? fd : file()),
    symlink_target_path_ref(symlink_target_path_ref_)
{
    BackCycle::offset = offset_;

    assert(!parent->main->ADEChunkerEnabled());
    assert(!info->use_container || !info->container.isnull());

    if(!uapp::staging().canRun(RSTAGE_WRAPUP))  throw EXC_CANCEL;
    if(msg1) DB->msg( "nbackfile::nbackfile (this:%p) info(file).path:'%s' de(gsan).path:'%s' track=%d", this, *info->path.image(), *info->direlemp->fullpath().image(), getThreadNbr());
    myfileord = curfileord++;
    set_phase(phase_checkcache);
    if (!starter) {
        todoEnqueueInsert(TODO_FILE_CACHE, this, myfileord);
    }
    else {
        starter->setnext(TODO_FILE_CACHE, this, 0); 
    }
}

bool nbackfile::nbacklink(workelem * info, hashcode& hash) {
#if SYSTEM_UNIX
    upath path = info->path;
    if (msg1) DB->msg("nbackfile::nbacklink %s", *info->path.image());

    
    
    
    
    
    
    bool is_symlink_target_path_provided = !symlink_target_path_ref.isnull() ? true : false;

    fileref link_ref;

    if (is_symlink_target_path_provided) {
        if (msg1) DB->msg("nbackfile::%s associated target path is already provided (probably symlink path is renamed during LFI backup), backup directly.", __FUNCTION__);
        link_ref = symlink_target_path_ref; 
    } else {
        char buf[4096];
        int n = readlink(*path.image(), buf, sizeof(buf));
        if (n < 0 || n >= (int)sizeof(buf)) {
            platerror errobj;
            Out->msg(ERR, "<7878>Unable to read symbolic link \"%s\", readlink=%d (%s).", *path.image(), n, *errobj.description());
            hash = hashcode::zero;  
            return false;
        } 

        buf[n] = 0;
        link_ref.initmem(buf, n);
        if (msg1) DB->msg("nbackfile::%s symlink '%s' target path '%s'", __FUNCTION__, *path.image(), buf);
    }

    
    workelem *w = new workelem(NULL, link_ref); 
    cycle *datachild;
    datachild = new nbackdata(this, w, fileoffset(0), false , 0, false ); 
    datachild->noop();

    
    return true;
#else
    assert(false);
    return false;
#endif
}

void nbackfile::init()
{
    if(msg1)DB->msg("nbackfile::init() this:%p phase:%s", this, *phase_image(phase));

    DIRELEMp dep = info->direlemp;

    
    
    
    if(phase == phase_synthfile) {
        if(synthfile(dep)) {
            
            
            
            fileoffset ads_size;
            if (flags.nfts_accurate_backup_size && get_ads_size(dep, ads_size))
                advance_progress_bytes_ads_and_finish_cycle(ads_size);
            else
                advance_progress_bytes_and_finish_cycle(dep);
            return;
        } else {
            
            set_phase(phase_backupfile);
        }
    }

    
    
    
    
    if(phase == phase_backupfile){
        backupfile();
        return;
    }

    assert(phase == phase_checkcache);
    
    path = info->path;

    
    stat_file_size = dep->file_size();
    info->fstats = filestatsref(flags, path, stat_file_size.dvalue());

    
    
    
    if(flags.ddrindex > 0 && (flags.streamformat_out == utar_flags_enums::streamformat_raw) &&
       (flag_ddgsan2dd || (stat_file_size >= fileoffset(flags.ddrthreshold * 1024LL * 1024LL)))) {
        need_raw_container = true;
    }

    if(msg1) DB->msg("nbackfile::init (this:%p) path='%s' initialSize=%s", this, *path.image(), *stat_file_size.image());

    
#if SYSTEM_WINDOWS
    bool accessible = true; 
#else
    
    
    bool accessible = dep->is_symlink() || access(*path.image(), R_OK) == 0;
#endif

#if SYSTEM_UNIX

#if SYSTEM_UNIX_SOLARIS || SYSTEM_UNIX_LINUX || SYSTEM_UNIX_AIX
    if((dep->unix_mode() & S_ISGID) && !(dep->unix_mode() & S_IXGRP) &&       
        main->state->fsinfo.is_mandlock_enabled(dep->device_number())) {         
        file solfile;                                                               
        if(solfile.open(info->path.image(), O_RDONLY) && solfile.ismandlocked()) {  
            Out->msg(WARN, "<10507>Skipping file \"%s\" because a mandatory lock has been set by another application.", *path.image());
            main->byteprogress(context::backupstats, stats::skipped, stat_file_size.dvalue(), info->fstats);
            dep->set_internal(true);    
            hash = hashcode::zero;   
            notifyparent();
            return;
        }
    }
#endif

    
    hard_link_id hl( *dep );
    if( dep->hard_links() > 1 )
    {
       if(msg1) DB->msg(("nbackfile::init  hard link file detected (%s)"), *path.image());
       if ( !accessible && !dep->is_symlink() )     
       {
           if(msg1) DB->msg(("nbackfile::init  insufficient privilege (%s)"), *path.image());
           Out->msg(ERR, "<5136>Unable to open \"%s\".   User does not have sufficient privileges to open file.", *path.image());
           hash = hashcode::zero;
           notifyparent();
           return;

       } else {
           if(msg1) DB->msg(("nbackfile::init Hard link file: %s --> %s\n"), *dep->fullpath().image(), *hl.image());
           hashcode_and_isatomic hashatom;
           if( ! main->state->hard_link_to_hash.enter_if_undef(hl,hashcode_and_isatomic(), hashatom) ) {
               
               
               if (need_raw_container || info->use_container) {
                   if(msg1) DB->msg( ("backup file data with ddr for hard link: %s"), *path.image() );

               } else {
                   hash = hashatom.gethash();
                   if( hash != HARDLINK_NULLHASH) {
                       if(msg1) DB->msg(("Skipping file %s hard linked hashcode --> %s isatomic=%d"), *dep->fullpath().image(), *hash.partialimage(), hashatom.getisatomic());
                       cyisatomic = hashatom.getisatomic();
                       main->addfilebytes(context::backupstats, stat_file_size.dvalue());
                       main->byteprogress(context::backupstats, stats::hardlink, stat_file_size.dvalue());  
                       notifyparent();
                       return;
                   }
                   if(msg1) DB->msg( ("TODO_HARD_LINK %s"), *path.image() );
                   recycle(TODO_HARD_LINK);   
                   return;
               }
           }
       }
    }
#endif

    
    if(dep->is_symlink() && flags.dereference) {
        
        if(msg1) DB->msg( ("nbackfile::init follow") );
        dep->convert_symlink(false);
    }

    if (dep->is_reparsePoint()) {
        HandleReparsePoint();
    }

    
    
    if(!dep->is_symlink() && should_create_new_thread(TODO_FILE)) {
        
        
        
        recycle(TODO_FILE);
        assert(started_thread);
    } else {
        
        
        
        main->addfilebytes(context::backupstats, stat_file_size.dvalue());

        
        if(msg1) DB->msg("nbackfile::init calling check_cache for file '%s'", *info->path.image());
        if(accessible && check_cache(dep)) {  
            
            
            
            
            
            
            
            
            return;
        }

        if(msg1) DB->msg("nbackfile::init after check_cache call, file '%s' NOT found in cache", *info->path.image());

        set_phase(phase_backupfile);

        
        
        if(dep->is_symlink()) {
            if (!nbacklink(info, hash)) {
                
                childdone( this ); 
                return;
            }
        } else {
            recycle(TODO_FILE);
        }
    }
}


bool nbackfile::check_cache(DIRELEMp direlem) {

    
    
    
    if( flags.usearchiveattr && direlem->is_archived() ) return false;

    
    if(!direlem->has_accurate_metadata() || !main->state->fcache) return false;

#if SYSTEM_WINDOWS
    if(enable_set_office2007_call && StreamtransformZip::isExtensionSpecialZip( direlem->file_name_extension().tostr()))
        direlem->set_office2007();  
#endif

    
    int          tagword(0);
    bool         cacheisatomic(false);
    unsigned int cache_atime(0);
    location     loc;

    if(msg1)DB->msg("nbackfile::check_cache calling fcache lookup(\"%s\", mtime=%d, size=%u), detect_acl_changes=%d",
                    *path.image(), direlem->mtime(), (int)stat_file_size.value(), flags.detect_acl_changes);

    
    
    

    
    

    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    if (!main->state->fcache->get_file_info(path, direlem->mtime(),
                                            (int)stat_file_size.value(),
                                            direlem->attr(),
                                            direlem->get_kind(),
                                            direlem->filecache_extflags(),
                                            parent->getThreadNbr(),
                                             hash, tagword, cacheisatomic, cache_atime,
                                            loc,
                                             !(info->use_container || flag_ddgsan2dd))) {
        if(msg1) DB->msg("nbackfile::check_cache filename_cache miss %s", *path.image() );
        return false;
    }

    
    
    
    
    
    if(loc.getMedia() == location::media::ddr && !loc.get_checksum().isempty() ) {
        loc.set_checksum_type(1);
    }
    
    else if (loc.getMedia() == location::media::ddr && loc.get_checksum().isempty()) {
        return false;
    }

    if (msg1) DB->msg("nbackfile:check_cache: fcache hit: tagword=%d, cache_atime=%u, cacheisatomic=%d, hash=%s loc:%s",
                      tagword, cache_atime, cacheisatomic, *hash.partialimage(), *loc.image());

    assert( hash != hashcode::zero || loc.getMedia() > location::media::gsan);  
    cyisatomic = cacheisatomic;

    
    
    epoch_t file_atime(0);
    epoch_t ctime(0);
    unsigned int tflag = 0;
    direlem->get_ext_times(ctime, file_atime, tflag);

    
    
    
    
    
    
    
    
    
    
    
    
    if (flags.detect_acl_changes && file_atime != (epoch_t)cache_atime) {
        if (msg1) DB->msg("nbackmain::check_cache detect-acl-changes: Must scan file (file_atime=%u, cache_atime=%u) %s", (unsigned int)file_atime, cache_atime, *path.image());
        return false;
    }

#if SYSTEM_WINDOWS
    
    
    if (wss_sis_manager::sis_manager != NULL
        && direlem->fullpath().image().extension().equal(CS_FILE_EXTENSION)
    ) {
        wss_sis_manager::sis_manager->write_to_hs_file(info->direlemp->fullpath().image(), hash);
    }
#endif

    
    if(tagword == 0 && direlem->is_symlink()){
        return false; 
    }

    
    
    
    if(tagword == 0) { 

        
        
        
        message inargs;
        msgpack_c::hashispresent hip(inargs);
        hip.arg(PACK, hash);
        set_phase(phase_inlookup);
        sendRemoteCall(this, inargs);

    } else {
        
        
        set_hardlink_hash( hash, cyisatomic, *direlem );  

        

        
        if(loc.getMedia() > location::media::gsan) {
            synth_cache_atime = cache_atime;
            synth_loc         = loc;

            set_phase(phase_synthfile);

            recycle(TODO_FILE);
        } else {
            
            
            
            fileoffset ads_size;
            if (flags.nfts_accurate_backup_size && get_ads_size(direlem, ads_size))
                advance_progress_bytes_ads_and_finish_cycle(ads_size);
            else
                advance_progress_bytes_and_finish_cycle(direlem);
        }
    }

    
    
    return true;
}



bool nbackfile::container_cachehit(DIRELEMp direlem, location loc, unsigned int cache_atime) {
    if (msg1) DB->msg("nbackfile::container_cachehit loc:%s", *loc.image());
    hash = hashcode::zero; 

    if (loc.get_backupid() == 0) {
        Out->msg(WARN, "Unable to use filename cache for file '%s', previous data not found in container.  Backing up data.", *direlem->name());
        return false;
    }

    
    
    if (inject_ddr_checksum_error) {
        loc.set_checksum_value(+(ubigint64)loc.get_abs_offset_in_container().value() & 0xFFFFFFFF); 
        
        
    }

    ucontainer::errortype errcode;
    DB->msg("nbackfile::container_cachehit calling synthobj loc:%s", *loc.image());
    direlem->set_location(loc);
    if ((errcode = info->container->synthobj(direlem.getimpl())) != ucontainer::pce__success) {
        Out->msg(WARN, "nbackfile::container_cachehit: Problem calling synthobj for %s (%s)",
                 *direlem->fullpath().image(), *ucontainer::error_description(errcode));
        

        return false;
    }

    
    
    main->state->fcache->put_file_info( path,
                                        (int)stat_file_size.value(),
                                        direlem,
                                        cyisatomic,
                                        cache_atime,
                                        DIRELEM::extflag_nul,
                                        parent->getThreadNbr());

    if (msg1) {
        location newloc(direlem->get_location());
        DB->msg("nbackfile::container_cachehit path=%s synthed from\n    loc:%s to\n    loc:%s",
                *path.image(), *loc.image(), *newloc.image());
    }

    return true;
}


bool nbackfile::is_raw_container_cachehit(DIRELEMp direlem, location loc, unsigned int cache_atime)
{
    
    if((loc.getMedia() == location::media::ddr && loc.get_format() == location::tformat::raw) && need_raw_container) {
        
        
        location::tcontainerid containerid(1);
        bool fastcopy_or_synth_success(false);
        if(flag_ddgsan2dd) {
            
            const hfs_info_struct& hfsInfo = getAdeMgr()->getHfsInfo(dpn0);  

             ustring file(info->path.stripdir());
            if(getAdeMgr()->copyFileForward(hfsInfo.clientidhash.image(), loc.get_backupid().topath(), file, static_cast<ubigint64>(stat_file_size.value())) == EXIT_OK) {
                
                fastcopy_or_synth_success = true;
            }
        } else {
            ucontainer::basep containerp(main->open_raw_container_for_write(info->path, containerid));
            if(!containerp.isnull()) {
                if(containerp->synthdata(loc) == ucontainer::pce__success) {
                    
                    main->close_raw_container_for_write(containerp);
                    containerp = 0;
                    fastcopy_or_synth_success = true;
                }
            } else {
                DB->msg("nbackfile::is_raw_container_cachehit could not allocate raw container for synth, not using file cache");
            }
        }

        
        if(fastcopy_or_synth_success) {
            hash = hashcode::zero; 
            info->direlemp->set_hash(hash);             

            
            loc.set_containerid(containerid);

            
            direlem->set_location(loc);
            main->state->fcache->put_file_info( path,
                                                (int)stat_file_size.value(),
                                                direlem,
                                                cyisatomic,
                                                cache_atime,
                                                DIRELEM::extflag_nul,
                                                parent->getThreadNbr());

            
            return true;
        }
    }

    return false;
}



void nbackfile::response(message& outargs) {
    assert(phase == phase_inlookup);
    if(msg1) DB->msg("nbackfile::response this:%p inlookup", this);

    if(!outargs.isnull() && outargs.isgoodresponse()) { 
        DIRELEM& direlem = *info->direlemp;
        
        
        fileoffset ads_size;
        if (flags.nfts_accurate_backup_size && get_ads_size(info->direlemp, ads_size))
        {
            main->byteprogress(context::backupstats, stats::filecache, ads_size.dvalue(), info->fstats);
        }
        else
        {
            main->byteprogress(context::backupstats, stats::filecache, stat_file_size.dvalue(), info->fstats);
        }
        set_hardlink_hash( hash, cyisatomic, direlem );  

        if( direlem.is_partial() ) {
            DB->msg( ("%s is partial"), *info->path.image() );
        }

        
        if(direlem.has_accurate_metadata() && main->state->fcache && !direlem.is_partial() && uapp::staging().canRun()) {
            
            epoch_t file_atime(0);
            epoch_t ctime(0);
            unsigned int tflag = 0;
            direlem.get_ext_times(ctime, file_atime, tflag);

            main->state->fcache->put_file_info( path, direlem.mtime(), (int)stat_file_size.value(),
                                                     direlem.attr(), direlem.get_kind(), direlem.filecache_extflags(),
                                                     parent->getThreadNbr(), hash, cyisatomic, file_atime );

            
            
            set_phase(phase_incache);
        }

        set_phase(phase_incache);

        childdone( this );
    } else {
        
        if(msg1) DB->msg( ("File %s not found on server"), *path.image() );
        set_phase(phase_backupfile);
        recycle(TODO_FILE);
    }
}




#if 0  

#define PREFETCHMINSIZE (1024*1024)             
#define PREFETCH_MAXTHREADS 32                  

class prefetcher : public threadbase {
public:
    prefetcher(fileref& f, workelem *info, int blocksize);
    virtual void body();
    SAFEALLOC(prefetcher);
private:
    fileref& f;
    workelem *info;
    int blocksize;
};


static safeint prefetchers_running;

prefetcher::prefetcher(fileref& f_, workelem *info_, int blocksize_) :
    f(f_), info(info_), blocksize(blocksize_)
{
    static int pfthreadcnt = 0;
    setdesc(ustring::sprintf("pf%d-%s", ++pfthreadcnt, *info->path.stripdir()));   
}

void prefetcher::body() {                       
    detach();           
    prefetchers_running++;
    DB->msg(("Prefetcher(%d): %s (%.0f bytes)"), +prefetchers_running, *info->path.image(), info->direlemp->file_size().dvalue());
    while( 1 ) {
        fileref buf;
        buf.initmem(blocksize);
        int bytes_read = f.readfilenext(buf.size(), buf.start());
        if( msg1) DB->msg(("Prefetcher:body() read from fileref f. bytes_read = %d"), bytes_read);
        if (bytes_read <= 0) {                  
             info->prefetchqueue->terminate();
             break;
        }
        prefetchbuf *data = new prefetchbuf;
        data->buf.initslice(buf, 0, bytes_read);
        info->prefetchqueue->enqueue(data);     
    }
    prefetchers_running--;
    DB->msg(("Prefetcher:body() exit body()."));
}



bool nbackfile::create_prefetch_thread(fileref& f) {
    DB->msg("nbackfile::create_prefetch_thread flags.maxprefetchkb = (%d)", flags.maxprefetchkb);
    if (!uapp::staging().canRun() || flags.maxprefetchkb <= 0) return false;   
    if (+prefetchers_running > PREFETCH_MAXTHREADS) return false;

    const int blocksize = flags.blocksize;
    const int maxqueuedepth = ((flags.maxprefetchkb*1024)+blocksize-1) / blocksize;
    DB->msg("nbackfile::create_prefetch_thread blocksize = (%d) and maxqueuedepth = (%d)", blocksize, maxqueuedepth);
    info->prefetchqueue = new waitqueue(1, maxqueuedepth);      
    prefetcher* t = new prefetcher(f, info, blocksize);         
    t->start();                                                 
    return true;
}

#endif 

void nbackfile::advance_progress_bytes_and_finish_cycle(const DIRELEMp dep)
{
    
    if(dep->get_reparseType() == REPARSE_SIS) 
        main->byteprogress(context::backupstats, stats::filecache, 0, info->fstats);
    else
    {
        if (flags.calculate_dedup_reparsepoint_size && dep->get_reparseType() == REPARSE_DEDUP && flags.windowsOptimizedBackup)
        {
            upath target;
            fileoffset size(fileoffset::zero);
            ReparsePoints::GetReparsePointInfo(dep->fullpath(), target, NULL, NULL, INVALID_FILE_HANDLE_VALUE, &size);
            DB->msg("dedup'd reparse point %s, size: %f", *dep->fullpath().image(), size.dvalue());
            main->byteprogress(context::backupstats, stats::filecache, size.dvalue(), info->fstats);
        }
        else
            main->byteprogress(context::backupstats, stats::filecache, stat_file_size.dvalue(), info->fstats);
    }
        

    childdone( this );
}


bool nbackfile::synthfile(DIRELEMp dep) {
    const location::media::type media(synth_loc.getMedia());
    if (msg1) DB->msg("nbackfile(%p)::synthfile(%s) media:%s", this, *path.image(), *location::media::image(media));

    bool object_copy_done(false);
    if(media > location::media::gsan) {
        if (info->use_container && !main->state->stream_out_excludes.match(info->path)) {
            object_copy_done = container_cachehit(dep, synth_loc, synth_cache_atime);
        } else {
            
            object_copy_done = is_raw_container_cachehit(dep, synth_loc, synth_cache_atime);
            if(!object_copy_done) {
                
                
                
                DB->msg("nbackfile::synthfile cache points to container but we are not using a container ");
            }
        }
    } else {
        
        object_copy_done = true;
    }

    return object_copy_done;
}





void nbackfile::backupfile() {
    if (msg1) DB->msg("nbackfile(%p)::backupfile(%s)", this, *path.image());

    
    DIRELEM& direlem = *info->direlemp;
    assert( stat_file_size == direlem.file_size() || stat_file_size == fileoffset::unknown); 
    {
        const ustring pathi(path.image());
        
        if(flags.memmap) {
            
            f.initmap( pathi, stat_file_size.ivalue(), filemap::read );
        } else {
            
            if (direlem.is_mapi())
                f.initmapistream( pathi, stat_file_size, direlem );
            else {
                if (file_desc > 0) {
                    
                    
                    
                    
                    f.initfiledesc(file_obj);
                } else {
                    int createFlags = ProcessReparsePointBeforeFileOpen();
#if SYSTEM_WINDOWS
                    
                    
                    
                    if (flags.open_files_in_shared_mode){
                        createFlags |= filestream::ENABLE_FILE_SHARE_WRITE;
                    }
#endif
                    f.initstream( pathi, GetExpectedProcessedSize(), false, direlem.useBackupOps() && (xflag[6]&4096)==0, direlem.is_encrypted(), createFlags);
                }
                
            }
        }
    }
    assert( stat_file_size == direlem.file_size() || stat_file_size == fileoffset::unknown); 

    if( msg1) DB->msg( "nbackfile::backupfile f.refcount=%d %s", f.getrefcount(), *info->path.image() );

    
    if(f.iserror() && flags.check_stdin_path) {
        bool share_error(false);
        #if SYSTEM_WINDOWS
            
            int err = ::GetLastError();
            share_error = (err == ERROR_SHARING_VIOLATION || err == ERROR_LOCK_VIOLATION ||
                (err == ERROR_USER_MAPPED_FILE) || (err == ERROR_DELETE_PENDING) );
        #endif

        
        platerror errobj;
        if(share_error) {
            set_error(true, ustring());
            HandleShareError(path, errobj);
        } else {
#ifdef SYSTEM_UNIX_AIX    
            if(errno == ETXTBSY)
                Out->msg(WARN, "<9983>File is locked with exclusive access and cannot be opened for backup: \"%s\" (%s). File being skipped.",
                         *path.image(), *errobj.description());
            else
#endif
            Out->msg(ERR, "<5137>Unable to open \"%s\" for backup (%s).", *path.image(), *errobj.description());
        }

        main->byteprogress(context::backupstats, stats::skipped, stat_file_size.dvalue(), info->fstats);
        hash = hashcode::zero;   

        #if SYSTEM_UNIX
        if(direlem.hard_links()>1) {
            DB->msg("nbackfile::backupfile unable to open hardlink  (%s)", *path.image());
            
            
            
            
            
            
            set_hardlink_hash( hashcode::empty, false, direlem );
        }
        #endif
        notifyparent();
        return;
    }

    
    main->set_cur_filename(info->path);
    info->fstats->start();

    
    if(main->state->stream_out_excludes.match(info->path)) {
        Out->msg(INFO, "Using raw container for %s", *info->path.image());
        need_raw_container = true;
    }

    
    if(need_raw_container) {
        
        const ucontainer::basep containerp(main->open_raw_container_for_write(info->path, raw_containerid));
        if(!containerp.isnull()) {
            
            info->use_container = true;
            info->container = containerp;
        } else {
            Out->msg(WARN, "Unable to open container for raw format backup of '%s', backing up to gsan", *info->path.image());
        }
    }

    if (info->use_container && uapp::staging().canRun()) {
        const ustring pathstr(direlem.fullpath().image());

        ucontainer::errortype errcode;
        const fileoffset expectedsize(GetExpectedProcessedSize());
        
        
        
        
        
        if (msg1) DB->msg("nbackfile::backupfile ucontainer %d before beginfile '%s' (offset: %s, mysize=%s, expected=%s)",
            info->container->containerid, *pathstr, *info->container->get_curroffset().image(), *direlem.file_size().image(), *expectedsize.image());

        if ((errcode = info->container->beginfile(info->direlemp.getimpl(), expectedsize, true)) != ucontainer::pce__success) {
            Out->Abort("nbackfile::backupfile: Problem calling beginfile for %s (%s) offset=%s",
                     *pathstr, *ucontainer::error_description(errcode), *stat_file_size.image());
            return;
        } else {
            if (msg1) DB->msg("nbackfile::backupfile ucontainer beginfile '%s' (abs_offset_in_container: %s, mysize=%s)",
                              *pathstr,
                              *direlem.get_location().get_abs_offset_in_container().image(),
                              *direlem.file_size().image());
        }
        if (msg1) DB->msg("nbackfile::backupfile ucontainer %d after beginfile loc:%s", info->container->containerid, *info->direlemp->get_location().image());
    }

    if( main->files_in_process.value() > flags.maxparallelfiles + 1 + (flags.parallel ? 200 : 0) )  {
        DB->msg("***********nbackfile::backupfile() filecnt=%d > %d  %s", main->files_in_process.value(), flags.maxparallelfiles, *info->path.image());
    }
    if(msg1) DB->msg("nbackfile::backupfile() chunkit  %s size:%s", *info->path.image(), *f.size64().image());

    if (!main->morphdata.isnull() && info->direlemp->name().extension()==".morph") {    
        assert(flags.morphfactor >= 0);                         
        assert((main->morphdata.size()%65536) == 0);            
        Out->msg(INFO, 3, "<16375>Morphing \"%s\" (%s bytes, morphfactor=0x%02x)", *info->path.image(), *f.size64().image(), flags.morphfactor);
        info->domorph = true;                                   
    }
    if(msg1) DB->msg("nbackfile::backupfile  %s size:%s", *info->path.image(), *f.size64().image());

    
    if (!main->morphdata.isnull() && info->direlemp->name().extension()==".morphtrunc") {    
        Out->msg(INFO, "Morphing \"%s\" by truncation relies on external program to truncate; delay for 1s to allow for timing variations...",
                 *info->path.image());
        threadbase::threadsleep(1000);
        Out->msg(INFO, "done sleeping.");
    }

    backappend *cycle_chunk = new backappend( this, main, info, f, false,0, af_none,NULL,NULL);
    cycle_chunk->noop();

    if(msg1) DB->msg("nbackfile::backupfile  leave  (%s)", *path.image());
}


void nbackfile::childdone(cycle *child) {
    if( msg1 ) {
        DB->msg("nbackfile::childdone (this:%p child=%p) (childclass='%s') phase:%d", this, child, typeid(*child).name(), phase);
        backappend * append = dynamic_cast<backappend *>(child);
        if (append) {
            DB->msg("nbackfile(%p)::childdone() backappend's filename='%s', backappend's filesize=%s", this,
                *append->getInfo()->direlemp->fullpath().image(), *append->getInfo()->direlemp->file_size().image() );
        }
    }

    DIRELEM& direlem = *info->direlemp;

    
    
    
    
    
    
    
    
    

    
    const fileoffset processed_file_size = direlem.file_size();

    
    
    size = processed_file_size;

    if( has_error() ) {
        hash = hashcode::zero;
    } else {
        hash = child->hash;
        if(child->cyisatomic)
            cyisatomic = true;  
    }

    
    location loc(direlem.get_location());
    if( has_error()
        || (hash == hashcode::zero && loc.getMedia() == location::media::gsan)
    ) {
        DB->msg( "nbackfile::childdone child=%p aborting cycle", child );
        set_error( true, ustring("") );
    }
    bool success = (hash != hashcode::zero) || (loc.getMedia() >= location::media::gsan);

    

    
    
    if(!success && main->state->hashes) main->state->hashes->suppress_update();

    hfsassert(processed_file_size == 0 || hfs->hashispresent(hash));

    #if SYSTEM_UNIX
    set_hardlink_hash( hash, cyisatomic, direlem );
    #endif

    if( phase == phase_backupfile ) {
        assert(main->files_in_process.value() >= 0);
        
        if (info->use_container && !direlem.is_symlink() && uapp::staging().canRun()) {   
            if (msg1) DB->msg("nbackfile::childdone  ucontainer %d before endfile   '%s '(offset: %s, mysize=%s)",
                              info->container->containerid, *direlem.fullpath().image(), *info->container->get_curroffset().image(), *direlem.file_size().image());
            fileoffset myoffset = 0;
            ucontainer::errortype errcode = info->container->endfile(info->direlemp.getimpl(), myoffset);
            if (errcode == ucontainer::pce__zeropadded_file) {
                
                
                
                if (!has_error()) {
                    Out->msg(ERR, "Problem backing up file '%s', marked as internal and zero padded in container.",
                             *direlem.fullpath().image());
                }
                direlem.set_internal(); 
            } else if (errcode != ucontainer::pce__success) {
                Out->Abort("nbackfile::childdone Problem calling endfile for %s (%s) offset=%s",
                              *direlem.fullpath().image(), *ucontainer::error_description(errcode), *myoffset.image());
                return;
            } else {
                if (msg1) DB->msg("nbackfile::childdone  ucontainer %d after endfile   '%s '(offset: %s, mysize=%s)",
                                  info->container->containerid, *direlem.fullpath().image(), *info->container->get_curroffset().image(), *direlem.file_size().image());
            }
            if (msg1) DB->msg("nbackfile::childdone  ucontainer %d after endfile   loc:%s", info->container->containerid, *direlem.get_location().image());
        }

        
        if(success && main->state->fcache && info->direlemp->has_accurate_metadata() && uapp::staging().canRun()) {

            
            epoch_t ctime(0);
            epoch_t atime(0);
            unsigned int tflag = 0;
            info->direlemp->get_ext_times(ctime, atime, tflag); 
            info->direlemp->set_hash(hash);             

            
            
            
            
            main->state->fcache->put_file_info( path, (int)processed_file_size.value(), info->direlemp, cyisatomic, atime, DIRELEM::extflag_nul, parent->getThreadNbr() );

            
            
            
            if(msg1) DB->msg("nbackfile::childdone file %s entered in filename_cache", *path.image());
#if SYSTEM_WINDOWS
            
            if (wss_sis_manager::sis_manager != NULL)
               if (info->direlemp->fullpath().image().extension().equal(CS_FILE_EXTENSION)) {
                   wss_sis_manager::sis_manager->write_to_hs_file(info->direlemp->fullpath().image(), hash);
               }
#endif
        }
    }

    
    if( phase == phase_backupfile || phase == phase_incache ) {
        if (info->use_container && !info->container.isnull() && !direlem.is_symlink() && uapp::staging().canRun()) {
            if(need_raw_container) {
                
                if(!main->close_raw_container_for_write(info->container)) {
                    Out->Abort("Unable to close container for raw format backup of '%s'", *info->path.image());
                    return;
                }
                info->use_container = false;
                info->container = 0;

            } else if(started_thread) {
                main->finalizeucontainer(info->container, false);
            }
        }
    }

    
    
    
    
    if( flags.resetarchive ) {
        direlem.reset_archived_attribute(); 
    }

    assert( processed_file_size == direlem.file_size() || 
            processed_file_size==fileoffset(0));   

    
    
    
    

    if(msg1) DB->msg("nbackfile::childdone calling notify parent");

    notifyparent();
}

void nbackfile::set_hardlink_hash( const hashcode &hash, bool isatomic, const DIRELEM& dir ) {
#if SYSTEM_UNIX
    
    if (!info->use_container && dir.hard_links() > 1 ) {
        hard_link_id hl( dir );
        assert( hash != HARDLINK_NULLHASH );                    
        assert( has_error() || need_raw_container || hash != hashcode::zero );        
        assert( has_error() || main->state->hard_link_to_hash.defined(hl) );
        hashcode_and_isatomic hashatom(hash, isatomic);
        main->state->hard_link_to_hash.enter(hl, hashatom);
        if(msg1) DB->msg(("Found file %s with hard link %s, hashcode == %s"),
                *dir.fullpath().image(), *hl.image(), *hash.partialimage());
    }
#endif
}

void nbackfile::notifyparent() {
    if(msg1) DB->msg( "nbackfile::notifyparent %p", this );
    BackCycle::setautodelete(false);        
    BackCycle::notifyparent();

    
    
    
    
    BackCycle::deleteself();
}

void nbackfile::print_listing(context *main, workelem *info, bool backed_up_data, bool showhash, const hashcode& hash) {
    
    
    if( Out->is_enabled(VERBOSE, 3)) {
        if(backed_up_data) {
            
            info->direlemp->set_percentsent(info->fstats.get_percentsent());
        } else {
            
            info->direlemp->set_percentsent(-1.0);
        }
    }
    if(backed_up_data) {
        
        main->addfilepercentnew(context::backupstats, (double)(info->direlemp->file_size().value()), info->fstats.get_percentsent());
    }
    if (showhash) {
        main->print_path_and_hash(*info->direlemp, hash);
    } else {
        main->print_path(*info->direlemp);
    }
}

nbackfile::~nbackfile() {
    assert( !info->direlemp->should_skip_this_file() || main->state->targets.exact(info->direlemp->fullpath()) );  

    const bool no_errors(!has_error() && !f.iserror()),
               backed_up_data(phase == phase_backupfile),
               phase_ok(phase != phase_init);

    if(msg1) DB->msg( "nbackfile::~nbackfile f.refcount=%d %s", f.getrefcount(), *info->path.image() );
    if((Out->is_enabled(VERBOSE, 4) || backed_up_data) && no_errors)
        print_listing(main, info, backed_up_data, flags.showhash, hash);

    if(flags.report_targets_done) {
        report_target_done(false, phase_ok && no_errors);
    }

    
    
    
    main->getstatsobj(context::backupstats)->add_filecount(1);

    if(started_thread) {  
        DB->msg("nbackfile::~nbackfile stopping thread %d for path '%s'", getThreadNbr(), *info->path.image());
        todoEnqueue(TODO_DONE, NULL);   
    }

    delete info;
}


void nbackfile::set_phase(int phasenum) { 
    if(msg1) DB->msg("nbackfile::set_phase from %s to %s", *phase_image(phase), *phase_image(phasenum));
    phase=phasenum;
}

ustring nbackfile::phase_image(int phasenum) {        
    switch(phasenum) {
    case phase_init      :return "phase_init      "; break;
    case phase_checkcache:return "phase_checkcache"; break;
    case phase_inlookup  :return "phase_inlookup  "; break;
    case phase_incache   :return "phase_incache   "; break;
    case phase_backupfile:return "phase_backupfile"; break;
    case phase_synthfile :return "phase_synthfile";  break;
    case phase_done      :return "phase_done      "; break;
    default:              return "unknown         "; break;
    }
}

void nbackfile::HandleReparsePoint() {

    if (msg1 || dbg_reparse_points) DB->msg("nbackfile(%p)::HandleReparsePoint(%s) called", this, *info->path.image());

    
    Reparse_Type repType = info->direlemp->get_reparseType();
    upath target;
    unsigned int targAttrs = 0x00;
    bool dirrecExists = info->direlemp->is_dirrec_present(KIND_REPARSEPOINT);

    
    
    
    if (repType == REPARSE_UNKNOWN || ReparsePoints::IsReparsePointTargetType(repType)) {

        
        if (!dirrecExists || !ReparsePoints::GetReparsePointDataFromDirelem(*info->direlemp, target, repType, &targAttrs)) {
            
            repType = ReparsePoints::GetReparsePointInfo(info->path, target, &targAttrs);

            
            info->direlemp->set_reparseType(repType);
        }
    }

    
    if (dirrecExists && !NeedsReparsePointDirrec(repType)) {
        ReparsePoints::DelReparsePointDataFromDirelem(*info->direlemp);
    }
    
    else if (!dirrecExists && NeedsReparsePointDirrec(repType)) {
        ReparsePoints::SaveReparsePointDataToDirelem(*info->direlemp, target, repType, targAttrs);
    }

    
    
    
    if (REPARSE_DEDUP == repType && !flags.windowsOptimizedBackup) {
        info->direlemp->set_reparsePoint(false);

        
        
        
        
        if (info->direlemp->is_sparseFile() && clear_backup_sparse_attribute_on_windows_dedup_file) {
            info->direlemp->set_is_sparseFile(false);
        }
    }

    
    if (!SKIP_ARCHIVING_STUB_SIZE_CHECK && repType == REPARSE_NON_MSFT) {
        
        
        
        
        fileoffset rpSize;
        upath target;
        (void)ReparsePoints::GetReparsePointInfo(info->direlemp->fullpath(), target, NULL, NULL, NULL, &rpSize);

        stat_file_size = rpSize;
        info->direlemp->set_file_size(rpSize);
    }

    
    
    const bool shouldTraverse = ReparsePoints::ShouldTraverseReparsePoint(info->path, repType, target);
    if (repType == REPARSE_DEDUP || !shouldTraverse) {
        info->direlemp->convert_symlink(false);
    }
}











bool nbackfile::NeedsReparsePointDirrec(const Reparse_Type repType) const {
    bool needsDirrec = true;

    if (repType == REPARSE_NONE || repType == REPARSE_UNKNOWN_MSFT || repType == REPARSE_NON_MSFT || repType == REPARSE_SIS ||
        (repType == REPARSE_DEDUP && !flags.windowsOptimizedBackup)) {
        needsDirrec = false;
    }
    return needsDirrec;
}



int nbackfile::ProcessReparsePointBeforeFileOpen() {
    DIRELEMp direlem = info->direlemp;
    int createFlags = 0x00;

    const Reparse_Type rpType = direlem->get_reparseType();
#if SYSTEM_WINDOWS  
    if ((rpType == REPARSE_DEDUP && !flags.windowsOptimizedBackup) || (rpType == REPARSE_SIS && !sis_feature_enabled)) {
        createFlags |= filestream::DISABLE_OPEN_WITH_REPARSE_FLAG;
        
        direlem->set_reparsePoint(false);
    }
    else
#endif
    if (rpType == REPARSE_USER_SYMLINK_FILE || rpType == REPARSE_NONE) {
        
        
        createFlags |= filestream::DISABLE_OPEN_WITH_REPARSE_FLAG;
    }

    return createFlags;
}













fileoffset nbackfile::GetExpectedProcessedSize() {
    DIRELEMp direlem = info->direlemp;
    fileoffset expected = stat_file_size;

#if SYSTEM_WINDOWS
    Reparse_Type repType = direlem->get_reparseType();
    
    if (repType == REPARSE_USER_SYMLINK_FILE && direlem->file_size() == fileoffset::zero) {
        upath target;
        Reparse_Type ignoredType;
        if (ReparsePoints::GetReparsePointDataFromDirelem(*direlem, target, ignoredType)) {
            fileoffset size = ReparsePoints::GetReparseTargetFileSize(info->path);
            direlem->set_file_size(size);
            expected = size;
            stat_file_size = fileoffset::unknown;       
        }
    }

    
    
    
    
    
    
    
    if ((repType == REPARSE_DEDUP && flags.windowsOptimizedBackup) || repType == REPARSE_NON_MSFT || repType == REPARSE_UNKNOWN_MSFT || repType == REPARSE_SIS
            || direlem->is_sparseFile()) {
        if( msg1 ) DB->msg("nbackfile::GetExpectedProcessedSize() setting file size for '%s' to fileoffset::unknown", *direlem->fullpath().image());
        expected = fileoffset::unknown;
    }

#endif

    return expected;
}



void HandleShareError(const upath& file, const platerror& errobj) {

#if SYSTEM_WINDOWS
    
    
    const upath deepestMtPath = file.getMountPath();

    
    upath walkingMtPath = deepestMtPath;
    while (walkingMtPath.isResolvablePath() && walkingMtPath.numelems()) {
        upath target;
        if (ReparsePoints::GetReparsePointInfo(walkingMtPath, target) != REPARSE_NONE) {
            
            const volinfo vi = VolumeInfo::getVolInfo(walkingMtPath.parentdir());
            if (!vi.isNTFS()) {
                
                
                Out->msg(ERR, "<5139>The file '%s' could not be backed up because it is already open by another application. This is because the path to that file goes through a Reparse Point on a non-NTFS filesystem and the Shadow Copy service is unable to detect the volume. Please add '%s' to your backup dataset to freeze it in future backups.", *file.image(), *deepestMtPath.image());
                return;
            }
        }
        walkingMtPath = walkingMtPath.parentdir().getMountPath();
    }

    
#endif
    Out->msg(ERR, "<5139>File access share error \"%s\" (%s).", *file.image(), *errobj.description());
}



bool nbackfile::should_create_new_thread(const todo_kind kind) const
{
    assert(info != NULL);
    
    return (kind != TODO_HARD_LINK) && info && isNewStreamThreadOK(getThreadNbr(), info->path);
}


void nbackfile::recycle(todo_kind kind) {
    
    if (should_create_new_thread(kind)) {
        
        
        
        ustring path = info->path.image();
        DB->msg("nbackfile::recycle (parent:%p) (this:%p) path:%s changing track", parent, this, *path);
        todoEnqueue(TODO_RESPONSE, EMPTYCYCLE);    
        
        
        
        
        started_thread = getrootinfo()->enqueueOnNewThreadRC(path, kind, this, myfileord);
        DB->msg("nbackfile::recycle switching to another thread kind:%d started_thread:%d ord:%s", kind, started_thread, *tostr(myfileord));

    } else { 
        
        todoEnqueueInsert(kind, this, myfileord);
    }
}

bool nbackfile::get_ads_size(DIRELEMp dep, fileoffset& size)
{
    size = 0;
#if SYSTEM_WINDOWS
    if(!dep->supportsADS() || dep->is_encrypted() || (xflag[5]&262144))
    {
        DB->msg("get_ads_size, file: %s, not support ADS or encrypted or --x05=262144.", *path.image());
        return false;
    }
    
    DIRELEM& direlem = *dep;

    DWORD winrwmode = GENERIC_READ;
    DWORD sharemode = FILE_SHARE_READ;
    bool  isNTorlater = win_os_version_info::is_windows_NT_or_newer();
    if( isNTorlater )
    {
        winrwmode |= READ_CONTROL;
        sharemode |= FILE_SHARE_DELETE;
    }

    int createFlags = ProcessReparsePointBeforeFileOpen();
    const bool use_backup_calls = direlem.useBackupOps() && (xflag[6]&4096)==0 ;
    DWORD   dwFlags = FILE_FLAG_SEQUENTIAL_SCAN;
    
    if(win_os_version_info::is_windows_NT_or_newer() && use_backup_calls)
    {
        const int DISABLE_OPEN_WITH_REPARSE_FLAG = 0x01;
        dwFlags |= (FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_OPEN_NO_RECALL);
        if (createFlags & DISABLE_OPEN_WITH_REPARSE_FLAG)
        {
            dwFlags &= ~FILE_FLAG_OPEN_REPARSE_POINT;
        }
    }

    const upath path = direlem.fullpath();
    const HANDLE altfh = CreateFile(*path.patht("CreateFile"),
                       winrwmode,
                       sharemode,
                       NULL,
                       OPEN_EXISTING,
                       dwFlags,
                       NULL );
    BOOL retcode = (altfh != INVALID_HANDLE_VALUE && altfh != NULL);

    if(!retcode)
    {
        int err_code = (int)GetLastError();
        DB->msg("nbackfile::get_ads_size - Failed open \"%s\", error = %d", *path.image(), err_code);
        return false;
    }

    BYTE				baData[sizeof(WIN32_STREAM_ID) + sizeof(TCHAR)];
    LPWIN32_STREAM_ID	pStrmId;
    const DWORD				dwBytesToRead = sizeof(baData);
    DWORD				dwBytesRead;
    LARGE_INTEGER       liDataSize;
    DWORD				dwLowByteSeeked;
    DWORD				dwHighByteSeeked;
    void* ctx = 0;
    BOOL success = TRUE;
    const BOOL bProcessSecurity(!DIRELEM::ignoreacls);

    while (success && uapp::staging().canRun())
    {
        success = BackupRead(altfh, baData, dwBytesToRead, &dwBytesRead, false, bProcessSecurity, &ctx );
        if(!success || dwBytesRead <= 0)
        {
            break;
        }
        size += dwBytesRead;

        pStrmId = (LPWIN32_STREAM_ID)baData;
        liDataSize = pStrmId->Size;

        if(liDataSize.LowPart != 0 || liDataSize.HighPart != 0)
        {
            dwLowByteSeeked = 0;
            dwHighByteSeeked = 0;
            BackupSeek(altfh, ~0, ~0, &dwLowByteSeeked, &dwHighByteSeeked, &ctx);

            if(dwLowByteSeeked <= 0)
            {
                success = false;
                DB->warn("nbackfile::get_ads_size - BackupSeek alternative data stream at \"%s\" failed, error %d.", *path.image(), (int)GetLastError());
            }
            else
                size += dwLowByteSeeked;
        }
    }

    (void)BackupRead(altfh, NULL, 0, &dwBytesRead, true, bProcessSecurity, &ctx);
    CloseHandle(altfh);

    if(!success)
    {
        DB->msg("nbackfile::get_ads_size - failed at \"%s\".", *path.image());
        return false;
    }

    DB->msg("nbackfile::get_ads_size - BackupRead file \"%s\", size: %f", *path.image(), size.dvalue());
    return true;
#else
    return false;
#endif
}

void nbackfile::advance_progress_bytes_ads_and_finish_cycle(fileoffset& size)
{
	main->byteprogress(context::backupstats, stats::filecache, size.dvalue(), info->fstats);
	childdone( this );
}
















#include "common.h"
#include "debug.h"

#include "restdumpstream.h"

#include "dirrec_pack.h"
#include "runstage.h"
#include "filenames.h"
#include "pipe_control.h"
#include "restdata.h"
#include "restdirlist.h"
#include "filemap.h"
#include "filerefx.h"

#include <algorithm>


#define dbg ((xflag[2]&8192)!=0)
#define umsg ((xflag[2]&134217728)!=0)   

#define do_dir_map     ((xflag[22] & 128) == 0) 
#define do_acl_ref_map ((xflag[22] & 2048) != 0) 
#define do_type_map_dir_repair  ((xflag[22] & 268435456)== 0) 




#define prune_acls ((xflag[29] & 8192) == 0)  

#define disable_final_acl_section ((xflag[29] & 33554432) != 0)  


restdumpstream::restdumpstream(context &_main, const location& _rootmetaloc, const DIRELEM& de, upath subprefix ,
                               const undoo::vector<upath> &subtree ,
                               const ustring& target, const ustring& added_path)
    : cycle(0, &_main)
    , m_phase(phase_do_retrieve)
{
    DB->msg("TOP OF restdumpstream::constructor (cross-platform) ------------------------------------");
        assert(_rootmetaloc.isFromGsan());  
        m_ctx.rootmetaloc  = _rootmetaloc;
        m_ctx.subtree   = subtree;
        m_ctx.subprefix = subprefix;
        m_ctx.mtime     = 0;
        m_ctx.rootnode  = 0;
        m_ctx.flags     = &flags;
        m_ctx.acl_total = 0;
        m_ctx.acl_block = 0;
        m_ctx.acls_calculated_size = 0;
        m_ctx.target    = target;
        m_ctx.xplatform = true;
        m_ctx.added_path = added_path;

        location loc(de.get_location());
        m_ctx.ucontainerp = main->open_container_for_read(loc);

       if (dbg) {
           DB->msg("restdumpstream::ctor: redirected restore target path = '%s'", *m_ctx.target);
           DB->msg("restdumpstream::ctor: hash=%s", *m_ctx.rootmetaloc.image());
           DB->msg("restdumpstream::ctor: de inode=%d filename='%s'", de.inode_number(),  *de.fullpath().image());
           DB->msg("restdumpstream::ctor: location of incoming direlem: %s", *loc.image());
           DB->msg("restdumpstream::ctor: subprefix = '%s' subtree size = %d", *subprefix.image(), (int)subtree.size());
           for (unsigned int ii=0; ii < subtree.size(); ii++) {
               DB->msg("restdumpstream::ctor:        subtree[%d] = '%s'", ii, *subtree[ii].image());
            }
        }
        m_ctx.acl_count = 0;
        main->handling_system_info(true); 
        main->add_insert(TODO_DIR, this, 0);

        
        m_ctx.root_loc = loc.make_template(true );
    }

restdumpstream::restdumpstream(context &_main, const location& _rootmetaloc, const DIRELEM& de, upath subprefix ,
                               const undoo::vector<upath> &subtree  )
    : cycle(0, &_main)
    , m_phase(phase_do_retrieve)
{
    DB->msg("TOP OF restdumpstream::constructor (normal) ------------------------------------");
    assert(_rootmetaloc.isFromGsan());  
    m_ctx.rootmetaloc  = _rootmetaloc;
    m_ctx.subtree   = subtree;
    m_ctx.subprefix = subprefix;
    m_ctx.mtime     = 0;
    m_ctx.rootnode  = 0;
    m_ctx.flags     = &flags;
    m_ctx.acl_total = 0;
    m_ctx.acl_block = 0;
    m_ctx.acls_calculated_size = 0;
    m_ctx.xplatform = 0;
    m_ctx.target = "";
    m_ctx.added_path = "";

    location loc(de.get_location());
    m_ctx.ucontainerp = main->open_container_for_read(loc);

   if (dbg) {
       DB->msg("restdumpstream::ctor: hash=%s", *m_ctx.rootmetaloc.image());
       DB->msg("restdumpstream::ctor: de inode=%d filename='%s'", de.inode_number(),  *de.fullpath().image());
       DB->msg("restdumpstream::ctor: location of incoming direlem: %s", *loc.image());
       DB->msg("restdumpstream::ctor: subprefix = '%s' subtree size = %d", *subprefix.image(), (int)subtree.size());
       for (unsigned int ii=0; ii < subtree.size(); ii++) {
           DB->msg("restdumpstream::ctor:        subtree[%d] = '%s'", ii, *subtree[ii].image());
        }
    }
    m_ctx.acl_count = 0;
    main->handling_system_info(true); 
    main->add_insert(TODO_DIR, this, 0);

    
    m_ctx.root_loc = loc.make_template(true );
}

void restdumpstream::init()
{
    childdone(0);
}

void restdumpstream::childdone(cycle *child)
{

next_phase:
    DB->msg("TOP OF restdumpstream::childdone  m_phase=%d ------------------------------------", (int)m_phase);

    switch (uapp::staging().canRun() ? m_phase : phase_done) {
        case phase_do_retrieve:
            child = new restdumpstreamretrieve(this, m_ctx);
            child->noop();
            m_phase = phase_do_mark;
            break;
        case phase_do_mark:
            m_phase = phase_do_prune;
            if (m_ctx.mtime == 0) 
                goto next_phase;
            child = new restdumpstreammarkfiles(this, m_ctx.toplevel.lookup(TS_FILE_FILENAME), m_ctx);
            child->noop();
            break;
        case phase_do_prune:
        {
            
            fileref zero;
            zero.initzero(m_ctx.typemap.size()/2);
            m_ctx.aclsfound.initlist(0);
            m_ctx.aclsfound.append(zero);

            if (m_ctx.mtime == 0 && m_ctx.subprefix.isempty() && m_ctx.subtree.empty())
                goto next_phase;
            if (m_ctx.xplatform)
                m_phase = phase_crossplatform;
            else
                m_phase = phase_findacls;
            child = new restdumpstreamprune(this, 2, m_ctx.subprefix, ustring(), m_ctx);
            child->noop();
            break;
        }
        case phase_crossplatform:  
        {
            m_ctx.rootnode = 0;
            m_phase = phase_done;  
            ustring tmpstr;
            child = new restdumpcross(this, 2, m_ctx.subprefix, ustring(), m_ctx, tmpstr, m_ctx.target);
            child->noop();
            break;
        }
        case phase_findacls:
        {
            m_phase = phase_do_restore;
            
            if (prune_acls) {
                DIRELEMp de = m_ctx.toplevel.lookup(TS_FILE_FILENAME);
                if (de.isnull()) goto next_phase;
                child = new restdumpstream_markacls(this, 0, de, m_ctx);
                child->noop();
            }
            else goto next_phase;
            break;
        }
        case phase_do_restore:
        {
            
            
            if (prune_acls && (m_ctx.aclsfound.count() > 0)) {
                DIRELEMp de = m_ctx.toplevel.lookup(TS_ACL3_FILENAME);
                if (!de.isnull()) m_ctx.aclsfound.set(5);
            }
            if (dbg && prune_acls) {
                DB->msg("restdumpstreamretrieve: ACLS FOUND IN BACKUP: total size=%d", m_ctx.aclsfound.size());
                int my_count = 0;
                for (int ii=4; ii < m_ctx.aclsfound.max_inode(); ii++) {
                    if (m_ctx.aclsfound.get(ii)) {
                        DB->msg("     acl [%d] = %d", my_count, ii);
                        my_count++;
                    }
                }
            }
            child = new restdumpstreamoutput(this, m_ctx);
            child->noop();
            m_phase = phase_done;
            break;
        }
        case phase_done:
            main->handling_system_info(false); 
            main->add(TODO_DONE, NULL);
            notifyparent();
            break;
        default:
            Out->msg(ERR, "<8718>Unexpected phase number %d", m_phase);
            break;
    }
}



restdumpstream_markacls::restdumpstream_markacls(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum)
    : cycle(parent, 0)
    , m_de(de)
    , m_ctx(ctx)
{
    if (starter) {
        starter->setnext(TODO_DIR, this, inum);
    } else {
        main->add_insert(TODO_DIR, this, inum);
    }
}

void restdumpstream_markacls::init()
{
    
    dumpstream::typemap::inodetype itype, dummy;
    int32_t first = m_ctx.typemap.parse(m_de->fullpath(), itype);
    int32_t last  = m_ctx.typemap.parse(m_de->fullpath() / upath("ffffffff"), dummy) + 1;

    if (first == 0) first = 1;
    if (last == 0) last = m_ctx.typemap.max_inode();
    if (last > m_ctx.typemap.max_inode()) last = m_ctx.typemap.max_inode();

    if (!m_de->is_directory()) first = last; 

    if (dbg) DB->msg("restdumpstream_markacls::init path:%s type:%d first:%08x last:%08x isdir=%d",
                     *m_de->fullpath().image(), itype, first, last, m_de->is_directory());

    
    while ((first < last) && ((m_ctx.typemap.get(first) != itype) || ((m_ctx.sendmap.size() != 0) && !m_ctx.sendmap.get(first)) )) first++;
    if (first >= last) {
        
        if (dbg) DB->msg("restdumpstream_markacls::init. This inode %s has no children.Calling childdone", *m_de->fullpath().image());
        childdone(0);
        return;
    }

    if (dbg) DB->msg("restdumpstream_markacls::init path:%s getting listing", *m_de->fullpath().image());

    
    m_listing.initlist(8192);
    filestatsref fstats;    
    restelem re(m_de->fullpath(), *m_de, fstats, m_listing, m_ctx.ucontainerp);
    cycle *child = new restdata(this, m_de->file_hash(), 0, false, re);
    child->noop();
    nforked++;
}

void restdumpstream_markacls::childdone(cycle *child)
{
    
    if (nforked == 1) {
        child = 0;
        fileoffset coff = m_de->get_location().get_abs_offset_in_container() + m_de->get_location().get_header_size();
        if (dbg) DB->msg("restdumpstream_markacls::childdone: Before loop, path=%s abs offset = %s", *m_de->fullpath().image(), *coff.image() );
        for (int off = 0; off < m_listing.size(); ) {
            DIRELEMp de = new DIRELEM;
            de->populate(m_listing, off, m_de->fullpath(), coff);
            fileoffset tmp_abs = de->get_location().get_abs_offset_in_container();
            if (dbg) DB->msg("restdumpstream_markacls::childdone: PROCESSING FILE/PATH %s offset=%s", *de->fullpath().image(), *tmp_abs.image());
            dumpstream::typemap::inodetype itype;
            int32_t inum = m_ctx.typemap.parse(de->fullpath(), itype);
            if (de->is_directory()) {
                
                if (dbg) DB->msg("restdumpstream_markacls::childdone: calling restdumpstream_markacls for dir '%s'' inode=%d", *de->fullpath().image(), inum);
                child = new restdumpstream_markacls(this, child, de, m_ctx, inum);
                child->noop();
                nforked++;
                continue;
            }

            
            if (m_ctx.sendmap.size() > 0) {
                
                if (!m_ctx.sendmap.get(inum)) {
                    continue;
                }

                
                int32_t aclnum = 0;
                if (dbg) DB->msg("restdumpstream_markacls::childdone: looking for acl for inode %d", de->inode_number());
                dirrec_pack::acl_ref acl(de.getimpl());
                if (acl.get(aclnum) && aclnum != 0 && m_ctx.typemap.get(aclnum) == dumpstream::typemap::acl) {
                    if (dbg) DB->msg("Adding the acl for file inode %d, acl inode = %d", inum, aclnum);
                    m_ctx.aclsfound.set(aclnum);
                }
            }
        }  
        
        m_listing = fileref();
    }
    if (++ncollected >= nforked) {
        if (dbg) DB->msg("restdumpstream_markacls::childdone path:%s notifying parent", *m_de->fullpath().image());
        notifyparent();
    }
}



restdumpstreamretrieve::restdumpstreamretrieve(cycle *parent, restdumpstreamcontext &ctx)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_phase(phase_get_toplevel)
{
    main->add_insert(TODO_DIR, this, 0);
    retrieving_snapview_listing = true;
}

void restdumpstreamretrieve::init()
{
    childdone(0);
}

void restdumpstreamretrieve::childdone(cycle *child)
{
    DIRELEMp de;
    location temp_loc(m_ctx.root_loc);
    location temp_root_loc;

next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {
        case phase_get_toplevel:
            DB->msg("restdumpstreamretrieve::childdone phase_get_toplevel spawning restdirlist for %s with absoff %s",
                    *m_ctx.rootmetaloc.image(), *m_ctx.root_loc.get_abs_offset_in_container().image());

            
            
            temp_root_loc = m_ctx.root_loc;

            
            
            
            
            
            
            
            
            if (retrieving_snapview_listing) {
                
                temp_root_loc.set_containerid(0);
                temp_root_loc.set_enclosing_container(NULL);  
                retrieving_snapview_listing = false;
            }
            {
                const location theloc(location::media::gsan, m_ctx.rootmetaloc.getHash());
                child = new restdirlist(this, theloc, upath(), temp_root_loc, m_ctx.toplevel);
            }
            child->noop();
            m_phase = phase_check_multivolume;
            break;
        case phase_check_multivolume: {
            ustring lookup_str (!flags.ndmp_prefix.isempty() ? flags.ndmp_prefix :
                        !m_ctx.added_path.isempty() ? m_ctx.added_path : "");
            if (!lookup_str.isempty() && !(de = m_ctx.toplevel.lookup(lookup_str)).isnull()) {
                
                
                
                
                
                m_ctx.toplevel.clear();
                m_ctx.rootmetaloc.setHash(de->file_hash());
                m_ctx.root_loc.set_abs_offset_in_container(de->get_location().get_abs_offset_in_container() + de->get_location().get_header_size());
                DB->msg("restdumpstreamretrieve::childdone phase_check_multivolume reset m_ctx with %s at absoffset %s",
                        *m_ctx.rootmetaloc.image(), *m_ctx.root_loc.get_abs_offset_in_container().image());
                m_phase = phase_get_toplevel;
            } else if (!m_ctx.toplevel.defined(TS_DIR_FILENAME)) {
                
                
                Out->msg(FATAL, "<11084>Invalid multi-volume backup volume name (--ndmp-prefix='%s') ",
                         *flags.ndmp_prefix);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid multi-volume backup volume name");
            } else {
                
                m_phase = phase_get_system_info;
            }
            goto next_phase;
            break;
        }
        case phase_get_system_info:
            de = m_ctx.toplevel.lookup(UNDOO_DIRECTORY_NAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", UNDOO_DIRECTORY_NAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "directory not found");
                goto next_phase;
            }
            m_listing.clear();
            if (umsg) DB->msg("restdumpstreamretrieve::childdone phase_get_system_info spawning restdirlist for %s with absoff %s",
                    *de->file_hash().partialimage(), *de->get_location().get_abs_offset_in_container().image());
            
            temp_loc.set_abs_offset_in_container(de->get_location().get_abs_offset_in_container());
            {
                const location theloc(location::media::gsan,  de->file_hash());
                child = new restdirlist(this, theloc, upath(), temp_loc, m_listing);
            }
            child->noop();
            m_phase = phase_get_dirmap;
            break;
        case phase_get_dirmap:
        {
            if (!do_dir_map) { 
                DB->msg("restdumpstreamretrieve::childdone: getting of dirmap disabled.");
                m_phase = phase_get_aclmap;
                goto next_phase;
            }
            de = m_listing.lookup(TS_DIRMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(WARN, "<11085>%s not found - restore may be slow", TS_DIRMAP_FILENAME);
                xflag[22] |= 128;
                goto next_phase;
            }
            m_buffer.initlist(0);
            filestatsref fstats;    
            child = new restdata(this, de->file_hash(), 0, true, restelem(m_buffer));
            child->noop();
            m_phase = phase_get_aclmap;
            break;
        }
        case phase_get_aclmap:
        {
            if (do_dir_map) {
                m_ctx.dirmap.init(m_buffer); 
                if (m_ctx.dirmap.version() < DIRMAP_VERSION) {
                    Out->msg(INFO, "Old version of dirmap found, updating to use version %d.", DIRMAP_VERSION);
                }
            }
            if (!do_acl_ref_map) { 
                DB->msg("restdumpstreamretrieve::childdone: getting of ACLmap disabled.");
                m_phase = phase_get_typemap;
                goto next_phase;
            }
            de = m_listing.lookup(TS_ACLMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(WARN, "<11086>%s not found - continuing", TS_ACLMAP_FILENAME);
                xflag[22] &= ~2048;
                goto next_phase;
            }
            m_buffer.initlist(0);
            filestatsref fstats;    
            child = new restdata(this, de->file_hash(), 0, true, restelem(m_buffer));
            child->noop();
            m_phase = phase_get_typemap;
            break;
        }
        case phase_get_typemap:
        {
            if (do_acl_ref_map) {
                m_ctx.aclmap.init(m_buffer); 
            }

            de = m_listing.lookup(TS_TYPEMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", TS_TYPEMAP_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "typemap file not found");
                goto next_phase;
            }
            m_ctx.typemap.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            child = new restdata(this, de->file_hash(), 0, true, restelem(m_ctx.typemap));
            child->noop();
            m_phase = phase_done;
            break;
        }
        case phase_done:
            notifyparent();
            break;
        default:
            Out->msg(ERR, "<8718>Unexpected phase number %d", m_phase);
            break;
    }
}



restdumpstreammarkfiles::restdumpstreammarkfiles(cycle *parent, DIRELEMp de, restdumpstreamcontext &ctx)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_de(de)
{
    main->add_insert(TODO_DIR, this, -getDepth());
}

void restdumpstreammarkfiles::init()
{
    if (dbg) DB->msg("restdumpstreammarkfiles::init path:%s", *m_de->fullpath().image());

    
    fileref zero;
    zero.initzero(m_ctx.typemap.size()/2);
    m_ctx.timemap.initlist(0);
    m_ctx.timemap.append(zero);

    if (umsg) DB->msg("restdumpstreammarkfiles::init spawning restdirlist with %s and absoff %s",
            *m_de->file_hash().partialimage(), *m_de->get_location().get_abs_offset_in_container().image());

    
    location temp_loc(m_ctx.root_loc);
    temp_loc.set_abs_offset_in_container(m_de->get_location().get_abs_offset_in_container());
    const location theloc(location::media::gsan, m_de->file_hash());
    cycle *child = new restdirlist(this, theloc, upath(), temp_loc, m_child);
    child->noop();
    nforked++;
}

void restdumpstreammarkfiles::childdone(cycle *child)
{
    if (nforked == 1) {
        undoo::vector<ustring> names = m_child.keys();
        for (size_t i = 0; i < names.size(); i++) {
            DIRELEMp de = m_child.lookup(names[i]);
            if (de->mtime() < m_ctx.mtime) {
                
                
                
            } else if (de->is_directory()) {
                
                child = new restdumpstreammarkfiles(this, de, m_ctx);
                child->noop();
                nforked++;
            } else {
                
                m_ctx.timemap.set(de->inode_number());
            }
        }
        m_child.clear(); 
    }
    if (ncollected++ == nforked) {
        if (dbg) DB->msg("restdumpstreammarkfiles::childdone path:%s notifying parent", *m_de->fullpath().image());
        notifyparent();
    }
}









restdumpcross_file::restdumpcross_file(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx, ustring& filename)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_inode(inode)
    , m_path(path)
    , m_phase(phase_get_header)
    , m_filename (filename)
    , m_realsize(0)
    , m_backup_size(0)
    , m_loc_counter(filename)
    , m_backup_loc(0)
    , m_outfile_loc(0)
    , m_bytes_to_process(0)
    , m_hdr_cycle(NULL)
    , m_next_action(crossplatform_ctl::xp_write_next)

{
    assert(inode != 0);
    m_fullpath = upath (path / upath(filename));
    main->add_insert(TODO_DIR, this, -getDepth());
}

void restdumpcross_file::init()
{
    if (dbg) DB->msg("restdumpcross_file::init, inode:%d path:'%s'  filename='%s'", m_inode, *m_path.image(), *m_filename);
    m_phase = phase_get_header;
    restdumpstreamcontext::direlem_cache::iterator found_de = m_ctx.rest_de_cache.find(m_inode);
    if (found_de == m_ctx.rest_de_cache.end()) {
        
        
        
        const location theloc(location::media::gsan, m_ctx.rootmetaloc.getHash());
        cycle *child = new restdirlist(this, theloc, m_ctx.typemap.format(m_inode).parentdir(), m_ctx.root_loc, m_listing);
        child->noop();
        nforked++;
    }
    else {
        
        m_de = found_de->second;
        nforked++;
        childdone(NULL);
    }
}


bool restdumpcross_file::createfile() {
    bool bSecurityRemoved = false;
    bool bFileWasOpen     = false;
    bool bDirPreexisting  = false;
    const bool bSuccess = m_de->createforrestore(flags.permissions, false, true, flags.restoreshortnames, bSecurityRemoved,
          bFileWasOpen, bDirPreexisting, false);
    if (!bSuccess) {
        Out->msg(ERR, "Problem creating file '%s': %s", *m_de->fullpath().image(), strerror(errno));
    }
    return bSuccess;
}

void restdumpcross_file::childdone(cycle *child)
{
    ncollected++;
next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {

    case phase_get_header:
    {
        
        
        if (m_de.isnull()) {
            m_de = m_listing.lookup(m_ctx.typemap.format(m_inode).stripdir());
            ustring name;
            DIRELEMp de;
            
            while (m_listing.pop(name, de)) {
                if (de != m_de && m_ctx.sendmap.get(de->inode_number()) && 
                    m_ctx.rest_de_cache.find(de->inode_number()) == m_ctx.rest_de_cache.end() ) {
                        m_ctx.rest_de_cache[de->inode_number()] = de;
                }
            }
        }
        
        m_loc_counter.set_backup_size(m_de->file_size().value());
        m_listing.clear(); 
        m_hdr_buf = fileref();
        ustring errmsg;
        child = restore_range(m_de->file_hash(), fileoffset(0), fileoffset(TP_BSIZE), true, m_hdr_buf, errmsg, *m_de,
            m_ctx.ucontainerp, m_ctx.ucontainerp.isdefined());
        if (child == NULL) {
            Out->msg(ERR, "Restore of NDMP header 1 failed for file inode=%d file='%s': %s", m_inode, *m_de->fullpath().image(), *errmsg);
            m_phase = phase_done;
            goto next_phase;
        }
        child->noop();
        
        m_phase = phase_init_file;
        break;
    }

    case phase_init_file:
    {
        if (m_hdr_buf.size() == 0) {
            Out->msg(ERR, "Problem restoring header for file '%s'", *m_fullpath.image());
            m_phase = phase_done;
            goto next_phase;
        }
        
        if (!m_loc_counter.parsefileheader (m_hdr_buf, m_inode, m_realsize)) {
            Out->msg(ERR, "Problem parsing header info for inode %d, file='%s'", m_inode, *m_fullpath.image());
            m_phase = phase_done;
            goto next_phase;
        }
        m_hdr_buf = fileref(); 

        
        m_de->set_fullpath(m_fullpath);
        m_de->set_file_size( fileoffset(m_realsize) );

        if (!createfile()) {     
            m_phase = phase_done;
            goto next_phase;
        }

        bool security_lost;
        bool renamed;
        filerefx::initpipestream(m_write_buf, *m_de, false, false, flags.restoreshortnames,
            false, security_lost, flags.openfilerestoreoption, renamed, flags.restore_sparsekb*1024);
        m_phase = phase_get_next_action;
        goto next_phase;
        break;
    }
    case phase_get_next_action:
    {
        if ((nforked == ncollected) && (m_phase == phase_finish_file)) {
            goto next_phase;
        }

        m_next_action = m_loc_counter.get_next_action(m_backup_loc, m_outfile_loc, m_bytes_to_process);
        if (dbg) DB->msg("restdumpcross_file::childdone: get next_action returned %d, m_backup_loc=%ld m_outfile_loc=%ld m_bytes_to_process=%d",
                 m_next_action, m_backup_loc, m_outfile_loc, m_bytes_to_process);
        switch (m_next_action) {
            case crossplatform_ctl::xp_write_next:
                m_phase = phase_write_data;
                break;

            case crossplatform_ctl::xp_get_tsaddr:
                m_phase = phase_get_tsaddr;
                break;

           case crossplatform_ctl::xp_sparse_next:
                m_phase = phase_write_sparse;
                break;

            case crossplatform_ctl::xp_file_done:
                m_phase = phase_finish_file;
                break;
        }
        goto next_phase;
        break;
    }
    case phase_write_data:
    {
        m_read_buf = fileref();
        ustring errmsg;
        fileref local;
        local.initslice6464(m_write_buf, m_outfile_loc, m_bytes_to_process);

        child = restore_range(m_de->file_hash(), fileoffset(m_backup_loc), fileoffset(m_backup_loc + m_bytes_to_process),
            true, local, errmsg, *m_de, m_ctx.ucontainerp, m_ctx.ucontainerp.isdefined());
        if (child == NULL) {
            Out->msg(ERR, "Restore of data block failed for file inode=%d file='%s': %s", m_inode, *m_de->fullpath().image(), *errmsg);
            m_phase = phase_done;
            goto next_phase;
        }
        child->noop();
        
        m_phase = phase_get_next_action;
        goto next_phase;
        break;
    }

    case phase_get_tsaddr:
    {
        
        m_hdr_buf = fileref();  
        ustring errmsg;
        m_hdr_cycle = restore_range(m_de->file_hash(), fileoffset(m_backup_loc), fileoffset(m_backup_loc + m_bytes_to_process),
            true, m_hdr_buf, errmsg, *m_de, m_ctx.ucontainerp, m_ctx.ucontainerp.isdefined());
        if (m_hdr_cycle == NULL) {
            Out->msg(ERR, "Restore of NDMP header 2 failed for file inode=%d file='%s': %s", m_inode, *m_de->fullpath().image(), *errmsg);
            m_phase = phase_done;
            goto next_phase;
        }
        m_hdr_cycle->noop();
        
        m_phase = phase_parse_tsaddr;
        break;
    }
    case phase_parse_tsaddr:
    {
        if (dbg) DB->msg("restdumpcross_file::childdone: phase parse_tsaddr, file='%s' m_backup_loc=%ld, m_outfile_loc=%ld m_bytes_to_process=%d",
                *m_filename, m_backup_loc, m_outfile_loc, m_bytes_to_process);

        
        if (child != m_hdr_cycle) {
            break;
        }
        if (m_hdr_buf.size() == 0) {
            Out->msg(ERR, "Problem restoring TS_ADDR for file '%s'", *m_fullpath.image());
            m_phase = phase_done;
            goto next_phase;
        }
        
        int64_t dummy;  
        if (!m_loc_counter.parsefileheader (m_hdr_buf, m_inode, dummy)) {
            Out->msg(ERR, "Problem parsing header info for inode %d, file='%s'", m_inode, *m_fullpath.image());
            m_phase = phase_done;
            goto next_phase;
        }
        m_phase = phase_get_next_action;
        goto next_phase;
        break;
    }

    case phase_write_sparse: {  
        fileref local;
        local.initzero(m_bytes_to_process);
        m_write_buf.setslice64(fileoffset(m_outfile_loc), local, true);
        m_phase = phase_get_next_action;
        goto next_phase;
        break;
    }
    case phase_finish_file: {  
        if (nforked != ncollected) {
            if (dbg) DB->msg("restdumpcross_file::childdone: phase_finish_file, nforked=%d ncollected=%d", nforked, ncollected);
            break;
        }

        
        backstats *stats = main->getstatsobj(context::restorestats);
        stats->add_filecount(1);
        stats->add_filebytes_primary(m_de->file_size().dvalue());
        stats->add_filebytes_prog(m_de->file_size().dvalue());

        
        
        
        
        
        
        
        
        
        if (child) {
            restdata *dc(dynamic_cast<restdata *>(child));
            if (dc) {
                dc->info.data.free();
            }
        }

        m_write_buf.close();
        m_write_buf.free();

        m_de->set_file_attributes(flags.permissions);
        if (dbg) DB->msg("restdumpcross_file::childdone: COMPLETED RESTORING FILE '%s'", *m_filename);
        m_phase = phase_done;
        goto next_phase;
    }

    case phase_done:
        
        
        m_ctx.rest_de_cache.erase(m_de->inode_number());
        m_ctx.sendmap.set(m_de->inode_number(), false);
        notifyparent();
        break;
    }
}






restdumpcross::restdumpcross(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx, ustring& filename, ustring target_dir)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_inode(inode)
    , m_backup_path(path)
    , m_track(track)
    , m_mtime(0)
    , m_phase(phase_get_listing)
    , m_filename (filename)
    , m_target_dir (target_dir)
    , m_in_restorepath(false)
{
    if (dbg) DB->msg("restdumpcross::restdumpcross, inode=%d path='%s' track='%s', filename='%s' target='%s'", inode, *path.image(), *track, *filename, *target_dir);
    assert(inode != 0);
    main->add_insert(TODO_DIR, this, -getDepth());
}

void restdumpcross::init()
{
    if (dbg) DB->msg("restdumpcross::init track='%s' inode:%d backup_path:'%s' filename='%s' targetdir='%s'", *m_track, m_inode,
         *m_backup_path.image(), *m_filename, *m_target_dir);
    if (m_backup_path.isempty() && m_ctx.rootnode == 0) {
        
        if (dbg) DB->msg("restdumpcross::init subprefix:'%s' rootnode:'%s'",
                *m_ctx.subprefix.image(), *m_ctx.typemap.format(m_inode).image());
        m_ctx.rootnode = m_inode;

        
        if (m_ctx.subtree.empty()) m_ctx.subtree.push_back(upath());
        
        for (size_t i = 0; i < m_ctx.subtree.size(); i++) {
            if (m_ctx.subtree[i].is_absolute()) {
                
                assert(m_ctx.subprefix == m_ctx.subtree[i].slice(0, m_ctx.subprefix.numelems()-1));
                m_ctx.subtree[i] = m_ctx.subtree[i].slice(m_ctx.subprefix.numelems(), m_ctx.subtree[i].numelems()-1);
            }
            if (dbg) DB->msg("restdumpcross::init processing subtree '%s' ", *m_ctx.subtree[i].image());
            ustring tmpstr;
            cycle *child = new restdumpcross(this, m_inode, m_ctx.subtree[i], m_track, m_ctx, tmpstr, m_target_dir);
            child->noop();
            nforked++;
        }
        m_phase = phase_done;
    } else {
        
        if (dbg)  DB->msg("restdumpcross::init track='%s' getting dir contents for inode %d = 0x%x", *m_track, m_inode, m_inode);
        const location theloc(location::media::gsan, m_ctx.rootmetaloc.getHash());
        cycle *child = new restdirlist(this, theloc, m_ctx.typemap.format(m_inode).parentdir(), m_ctx.root_loc, m_listing);
        child->noop();
        m_phase = phase_get_listing;
    }
}

bool restdumpcross::createdirectory() {  
    m_de->set_is_directory(true);
    bool    bSecurityRemoved = false;
    bool    bFileWasOpen = false;
    bool    bDirPreexisting = false;
    const bool bSuccess = m_de->createforrestore(flags.permissions, false, true, flags.restoreshortnames, bSecurityRemoved,
          bFileWasOpen, bDirPreexisting, false);
    if (bSuccess) {
        if (dbg) DB->msg("restdumpcross::createdirectory: success creating '%s'  existing=%d wasopen=%d ", *m_de->fullpath().image(), bDirPreexisting, bFileWasOpen);
    }
    else {
        Out->msg(ERR, "Problem creating directory '%s': %s", *m_de->fullpath().image(), strerror(errno));
    }
    return bSuccess;
}



void restdumpcross::childdone(cycle *child)
{
next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {

        case phase_get_listing: 
        {
            m_de = m_listing.lookup(m_ctx.typemap.format(m_inode).stripdir());
            m_listing.clear(); 
            m_buffer.initlist(m_de->file_size().lopart());
            filestatsref fstats;
            restelem re (m_de->fullpath(), *m_de, fstats, m_buffer, m_ctx.ucontainerp);
            if (dbg) DB->msg("restdumpcross::childdone: calling restdata for dir '%s' file='%s'", *m_de->fullpath().image(), *m_filename);
            child = new restdata(this, m_de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_scan_children;
            break;
        }
        case phase_scan_children: {  
            if (dbg) DB->msg("restdumpcross::childdone, top of scan_children, filename='%s' m_backup_path='%s' m_track='%s'",
                *m_filename, *m_backup_path.image(), *m_track);

            if (m_buffer.size() == 0) {
                Out->msg(ERR, "Error getting directory info for '%s' inode=%d", *m_filename, m_inode);
                m_phase = phase_done;
                goto next_phase;
            }

            ustring subdir, track;
            
            if (m_backup_path.isempty() || m_backup_path.isroot() ) {
                m_in_restorepath = true;  
            }
            else {
                m_in_restorepath = false;
                subdir = m_backup_path.get(0);  
                track = m_track / subdir;
                m_backup_path.pop_front();
                if (m_backup_path.isempty()) m_in_restorepath = true;  
                if (dbg) DB->msg("restdumpcross::childdone searching for child '%s'", *subdir);
            }

            if (m_in_restorepath) {
                upath newpath(m_target_dir);
                m_de->set_fullpath(newpath);
                DB->msg("restdumpcross::childdone:     setting path to '%s'", *newpath.image());
                if (!createdirectory()) {  
                    m_phase = phase_done;
                    goto next_phase;
                }
            }

            
            int32_t acl_inode = 0;
            int32_t ads_inode_unused = 0;
            int32_t dir_inode = dumpstream::parsedumpdir(m_buffer, m_mtime, ads_inode_unused, m_childinode, m_childname, acl_inode);
            if (dbg) DB->msg("restdumpcross::childdone: after parse header, dirinode=%d m_inode=%d filename='%s'", dir_inode, m_inode, *m_filename);

            
            undoo::vector<intobj> ADS_excludes;
            for (unsigned int ii=0; ii < m_childname.size(); ii++) {
                if (dumpstream::decodeNTstreamsdirinode(m_childname[ii]) != 0) {
                    int32_t adsnode = m_childinode[ii];
                    ADS_excludes.push_back(adsnode);
                    if (dbg) DB->msg("restdumpcross::childdone: adding to ADS EXCLUDE LIST %d '%s'", adsnode, *m_childname[ii]);
                }
            }
            m_buffer = fileref(); 

            
            for (size_t i = 2; i < m_childinode.size(); i++) {
                if (ADS_excludes.contains(m_childinode[i])) {  
                    continue;
                }
                if (subdir.bytelength() == 0 || subdir == m_childname[i]) {
                    if (dbg && subdir.bytelength() > 0) DB->msg("restdumpcross::childdone child %u is %d '%s'",
                                                            (uint32_t)i, (int32_t)m_childinode[i], *m_childname[i]);
                    int32_t inode = m_childinode[i];
                    if (m_ctx.typemap.get(inode) == dumpstream::typemap::dir) {
                        upath fullpath(m_target_dir);
                        if (m_in_restorepath) {
                            fullpath.push_back(m_childname[i]);
                        }

                        if (dbg) DB->msg("restdumpcross::childdone: Processing DIR  %d '%s' fullpath='%s'", inode, *m_childname[i], *fullpath.image());
                        child = new restdumpcross(this, inode, m_backup_path, track, m_ctx, m_childname[i], fullpath.image());
                        child->noop();
                        nforked++;
                    }
                    else if (m_ctx.typemap.get(inode) == dumpstream::typemap::file) {
                        upath newpath(m_target_dir);
                        if (dbg) DB->msg("restdumpcross::childdone: Processing file %d '%s'", inode, *m_childname[i]);
                        child = new restdumpcross_file(this, inode, newpath, track, m_ctx, m_childname[i]);
                        child->noop();
                        nforked++;
                    }

                }
            }      
            m_childname.clear(); 
            m_phase = phase_attributes;
            if (nforked > 0) {
                break; 
            }

            
            
            if (!m_in_restorepath) {
                Out->msg(ERR, "<11087>Path not found on backup: %s", *track);
                m_phase = phase_done;
            }
            ncollected = nforked-1; 
            goto next_phase;
        }
        case phase_attributes: 
            if (++ncollected < nforked) break;
            if (m_in_restorepath) {
                if (dbg) DB->msg("restdumpcross: children of dir '%s' complete. Setting attributes", *m_de->fullpath().image());
                m_de->set_file_attributes(flags.permissions);
            }
            m_phase = phase_done;
            goto next_phase;
        case phase_done:
            if (++ncollected < nforked) break;
            m_de = DIRELEMp();  
            if (dbg) DB->msg("restdumpcross::childdone filename='%s' targetdir='%s' notifying parent", *m_filename, *m_target_dir);
            notifyparent();
            break;
        default:
            Out->msg(ERR, "<8718>Unexpected phase number %d", m_phase);
            break;
    }
}



restdumpstreamprune::restdumpstreamprune(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_inode(inode)
    , m_acl_inode(0)
    , m_ntads(0)
    , m_path(path)
    , m_track(track)
    , m_mtime(0)
    , m_phase(phase_get_listing)
{
    assert(inode != 0);
    main->add_insert(TODO_DIR, this, -getDepth());
}


void restdumpstreamprune::init()
{
    if (dbg) DB->msg("restdumpstreamprune::init track='%s' inode:%d path:'%s'", *m_track, m_inode, *m_path.image());
    if (m_path.isempty() && m_ctx.rootnode == 0) {
        
        if (dbg) DB->msg("restdumpstreamprune::init subprefix:'%s' rootnode:'%s'",
                *m_ctx.subprefix.image(), *m_ctx.typemap.format(m_inode).image());
        m_ctx.rootnode = m_inode;
        
        fileref zero;
        zero.initzero(m_ctx.typemap.size()/2);
        m_ctx.sendmap.initlist(0);
        m_ctx.sendmap.append(zero);
        
        if (m_ctx.subtree.empty()) m_ctx.subtree.push_back(upath());
        
        for (size_t i = 0; i < m_ctx.subtree.size(); i++) {
            if (m_ctx.subtree[i].is_absolute()) {
                
                assert(m_ctx.subprefix == m_ctx.subtree[i].slice(0, m_ctx.subprefix.numelems()-1));
                m_ctx.subtree[i] = m_ctx.subtree[i].slice(m_ctx.subprefix.numelems(), m_ctx.subtree[i].numelems()-1);
            }
            DB->msg("restdumpstreamprune::init processing subtree '%s' ", *m_ctx.subtree[i].image());
            cycle *child = new restdumpstreamprune(this, m_inode, m_ctx.subtree[i], m_track, m_ctx);
            child->noop();
            nforked++;
        }
        m_phase = phase_done;
    } else if (!prune_acls && m_path.isempty() && m_inode != m_ctx.rootnode && m_ctx.dirmap.get(m_inode, m_mtime, m_childinode)) {
        
        
        DB->msg("restdumpstreamprune::init track='%s' found dirmap entry %d", *m_track, m_inode);
        m_phase = phase_scan_children;
        childdone(0);
    } else {
        
        
        
        
        
        
        
        
        
        
        if (m_ctx.dirmap.version() >= 2 &&
                m_path.isempty() &&
                m_inode != m_ctx.rootnode &&
                m_ctx.dirmap.get(m_inode, m_mtime, m_acl_inode, m_childinode)) {
            m_phase = phase_scan_children;
            childdone(0);
        } else {
            if (dbg)  DB->msg("restdumpstreamprune::init track='%s' getting dir contents for inode %d", *m_track, m_inode);
            
            
            const location theloc(location::media::gsan, m_ctx.rootmetaloc.getHash());
            cycle *child = new restdirlist(this, theloc, m_ctx.typemap.format(m_inode).parentdir(), m_ctx.root_loc, m_listing);
            child->noop();
            m_phase = phase_get_listing;
        }
    }
}

void restdumpstreamprune::childdone(cycle *child)
{
next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {
        case phase_get_listing:
        {
            m_de = m_listing.lookup(m_ctx.typemap.format(m_inode).stripdir());
            m_listing.clear(); 
            m_buffer.initlist(m_de->file_size().lopart());
            filestatsref fstats;    
            restelem re (m_de->fullpath(), *m_de, fstats, m_buffer, m_ctx.ucontainerp);
            if (dbg) DB->msg("restdumpstreamprune::childdone: calling restdata for dir '%s'", *m_de->fullpath().image());
            child = new restdata(this, m_de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_scan_children;
            break;
        }
        case phase_scan_children: {
            int32_t dir_inode = 0;
            if (m_buffer.size() != 0) {
                
                
                dir_inode = dumpstream::parsedumpdir(m_buffer, m_mtime, m_ntads, m_childinode, m_childname, m_acl_inode);
                if (dbg) DB->msg("restdumpstreamprune::childdone: after parse header, inodes are: dir=%d acl=%d, ads=%d", dir_inode, m_acl_inode, m_ntads);

                if (m_ntads < 0 || m_ntads > m_ctx.typemap.max_inode())
                    m_ntads = 0; 
                else if (!m_ctx.aclmap.has(m_ntads)) {
                    if (do_type_map_dir_repair) {
                        dumpstream::typemap::inodetype itype = m_ctx.typemap.get(m_ntads);
                        if (itype != dumpstream::typemap::dir) {
                            Out->msg(INFO, LOCTXT("Fixed type mismatch for inode %d: found %d but should be %d"),
                                     m_ntads, itype, dumpstream::typemap::dir);
                            m_ctx.typemap.set(m_ntads, dumpstream::typemap::dir);
                        }
                    }
                    if (dbg) DB->msg("restdumpstreamprune::childdone 1 [%s] found ntstreams ref %d <- %d",
                                     *m_track, m_ntads, m_inode);
                    m_ctx.aclmap.add(m_ntads, m_inode);
                }
                m_buffer = fileref(); 
                m_de = DIRELEMp();
                
                for (size_t i = 2; i < m_childinode.size(); i++) {
                    int32_t inode = m_childinode[i];
                    if (do_type_map_dir_repair) {
                        if (m_ctx.aclmap.has(inode)) {
                            continue;
                        }
                    }
                    else
                    {
                        if (m_ctx.typemap.get(inode) != dumpstream::typemap::dir || m_ctx.aclmap.has(inode)) {
                            continue;
                        }
                    }
                    int32_t ref = dumpstream::decodeNTstreamsdirinode(m_childname[i]);
                    if (ref <= 0 || ref > m_ctx.typemap.max_inode()) 
                        continue;
                    bool isvalid = m_ctx.typemap.get(ref) == dumpstream::typemap::file;
                    for (size_t r = 2; r < m_childinode.size() && !isvalid; r++) {
                        
                        
                        isvalid = int32_t(m_childinode[r]) == ref;
                    }
                    if (isvalid) {
                        if (dbg) DB->msg("restdumpstreamprune::childdone 2 [%s] found ntstreams ref %d <- %d",
                                         *m_track, inode, ref);
                        m_ctx.aclmap.add(inode, ref);
                    }
                }  
            }  
            if (dbg) DB->msg("restdumpstreamprune::childdone subtree '%s' inode %d has %u children",
                             *m_track, m_inode, uint32_t(m_childinode.size()-2));
            ustring subdir, track;
            if (!m_path.isempty() && m_path.numelems() > 0) {
                
                subdir = m_path.get(0);
                track = m_track / subdir;
                m_path.pop_front();
                if (dbg) DB->msg("restdumpstreamprune::childdone searching for child '%s'", *subdir);
            }

            
            
            
            
            
            
            
            if ( (subdir.bytelength() == 0 || m_ctx.sendmap.get(dir_inode)) && prune_acls && m_acl_inode != 0) {
                if (dbg) DB->msg("restdumpstreamprune::childdone: for dir inode %d, adding ACL inode %d to acls found map", m_inode, m_acl_inode);
                m_ctx.aclsfound.set(m_acl_inode);
            }

            bool setsendmap = m_ctx.sendmap.size() > 0;
            
            
            
            bool settimemap = setsendmap && m_ctx.timemap.size() > 0 && m_ctx.timemap.get(m_inode);
            
            for (size_t i = 2; i < m_childinode.size(); i++) {
                if (subdir.bytelength() == 0 || subdir.equal(m_childname[i])) {
                    if (dbg && subdir.bytelength() > 0) DB->msg("restdumpstreamprune::childdone child %u is %d '%s'",
                                                            (uint32_t)i, (int32_t)m_childinode[i], *m_childname[i]);
                    int32_t inode = m_childinode[i];
                    
                    if (setsendmap  && !m_ctx.aclmap.has(inode)) m_ctx.sendmap.set(inode);
                    if (settimemap) m_ctx.timemap.set(inode);
                    
                    if (m_ctx.typemap.get(inode) == dumpstream::typemap::dir && !m_ctx.aclmap.has(inode)) {
                        child = new restdumpstreamprune(this, inode, m_path, track, m_ctx);
                        child->noop();
                        nforked++;
                    }
                    if (subdir.bytelength() > 0) { 
                        
                        
                        if (m_ctx.typemap.get(inode) == dumpstream::typemap::file) subdir = "";
                        break;
                    }
                }
            }      
            m_childname.clear(); 
            m_phase = phase_ntstreams;
            if (nforked > 0) {
                break; 
            }
            
            
            if (subdir.bytelength() > 0) {
                Out->msg(ERR, "<11087>Path not found on backup: %s", *track);
                m_phase = phase_done;
            }
            ncollected = nforked-1; 
            goto next_phase;
        }
        case phase_ntstreams:
            if (++ncollected < nforked) break;
            if (m_inode == m_ctx.rootnode && m_ntads != 0) {
                
                
                if (dbg) DB->msg("restdumpstreamprune::childdone '%s' adding root ntstreams inode %d to children",
                                 *m_track, m_ntads);
                m_childinode.push_back(m_ntads);
                m_ntads = 0;
            }
            
            
            
            
            
            for (size_t i = 2; i < m_childinode.size(); i++) {
                int32_t inode = m_childinode[i];
                undoo::vector<intobj> ref;
                if (!m_ctx.aclmap.get(inode, ref))
                    continue;

                bool sendmapset = m_ctx.sendmap.get(inode);
                bool timemapset = m_ctx.timemap.size() > 0 && m_ctx.timemap.get(inode);
                if (dbg) DB->msg("restdumpstreamprune::childdone track='%s' found NT streams dir %d, sendmapset=%d timemapset=%d",
                                 *m_track, inode, sendmapset,timemapset);

                for (size_t j = 0; j < ref.size(); j++) {
                    if (!sendmapset) {
                        
                        
                        
                        if (int32_t(ref[j]) == m_ctx.rootnode || m_ctx.sendmap.get(ref[j])) {
                            m_ctx.sendmap.set(inode);
                            child = new restdumpstreamprune(this, inode, upath(), ustring(), m_ctx);
                            child->noop();
                            nforked++;
                            break;
                        }
                    } else {
                        
                        if (timemapset) m_ctx.timemap.set(ref[j]);
                    }
                }
            }
            if (nforked > ncollected) {
                break; 
            }
            m_phase = phase_done;
            goto next_phase;
        case phase_done:
            if (++ncollected < nforked) break;
            if (m_ctx.timemap.size() > 0 && !m_ctx.timemap.get(m_inode)) {
                
                
                
                bool mtimeflag = m_mtime >= m_ctx.mtime;
                for (size_t i = 0; i < m_childinode.size() && !mtimeflag; i++) {
                    if (m_ctx.sendmap.get(m_childinode[i])) mtimeflag = m_ctx.timemap.get(m_childinode[i]);
                }
                m_ctx.timemap.set(m_inode, mtimeflag);
            }
            if (dbg) DB->msg("restdumpstreamsubtree::childdone track='%s' inode:%d notifying parent", *m_track, m_inode);
            notifyparent();
            break;
        default:
            Out->msg(ERR, "<8718>Unexpected phase number %d", m_phase);
            break;
    }
}



restdumpstreamoutput::restdumpstreamoutput(cycle *parent, restdumpstreamcontext &ctx)
    : cycle(parent, 0)
    , m_ctx(ctx)
    , m_phase(phase_start)
{
    main->add_insert(TODO_DIR, this, 0);
}

void restdumpstreamoutput::init()
{
    if (m_ctx.rootnode == 0)
        m_ctx.rootnode = 2; 
    if (m_ctx.sendmap.size() > 0) {
        
        
        
        
        
        
        
        
        m_ctx.sendmap.set(2);   
        m_ctx.sendmap.clear(3); 
        char *s = m_ctx.sendmap.start();
        char *t = m_ctx.typemap.start();
        for (int32_t i = 0; i < m_ctx.sendmap.size(); i++, s++, t += 2) {
            
            char m = *s | (t[0] & t[1]);
            t[0] &= m;
            t[1] &= m;
        }
        if (m_ctx.timemap.size() > 0) {
            
            m_ctx.timemap.set(2);
            char *s = m_ctx.sendmap.start();
            char *t = m_ctx.timemap.start();
            for (int32_t i = 0; i < m_ctx.sendmap.size(); i++, s++, t++) *s &= *t;
        }
    }
    
    main->getstatsobj(context::restorestats)->add_filecount((double)dumpstream::file_count(m_ctx.dirmap, m_ctx.typemap, m_ctx.sendmap));
    childdone(0);
}

int restdumpstreamoutput::count_acls_in_sendmap() {
    int  sum = 0;
    for (int i = 1; i < m_ctx.typemap.max_inode(); i++) {
        if ((m_ctx.typemap.get(i) == dumpstream::typemap::acl) && (m_ctx.sendmap.get(i)) )
            sum++;
    }
    return sum;
}


















void restdumpstreamoutput::childdone(cycle *child)
{
    DIRELEMp de;
    fileref dataslice;
    dump_header *hdr = 0;
    location temp_loc(m_ctx.root_loc);

next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {
        case phase_start: {
            
            Out->msg(INFO, "<8721>Starting creation of restore stream.");
            de = m_ctx.toplevel.lookup(TS_TAPE_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", TS_TAPE_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "tape file not found");
                goto next_phase;
            }
            m_buffer.initlist((int)(de->file_size().value()));


            
            
            

            filestatsref fstats;    
            restelem re(de->fullpath(), *de, fstats, m_buffer, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_clri;
    }
            break;
        case phase_clri:
        {
            hdr = (dump_header*) m_buffer.start();
            if (!validate_magic(*hdr)) { 
                Out->msg(FATAL, "<11088>Bad TS_START magic number 0x%x", +hdr->c_magic);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "bad TS_START magic number");
                goto next_phase;
            }
            
            if (m_ctx.timemap.size() > 0) {
                hdr->c_shadow.c_level = 1;
                hdr->c_ddate = m_ctx.mtime;
                update_checksum(*hdr);
            }
            
            Out->msg(INFO, "<8723>Restore stream output: producing TS_START");
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), m_buffer.size(), dataslice);
            dataslice.setslice64(0, m_buffer, false);

            
            
            de = m_ctx.toplevel.lookup(TS_CLRI_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", TS_CLRI_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "CLRI file not found");
                goto next_phase;
            }
            m_buffer.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, m_buffer, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_bits;
            }
            break;
        case phase_bits:
    {
            if (m_ctx.sendmap.size() > 0) {
                
                char *c = m_buffer.start()+TP_BSIZE;
                const char *t = m_ctx.typemap.start();
                for (int32_t i = TP_BSIZE; i < m_buffer.size(); i++, c++, t += 2) *c &= t[0] ^ t[1]; 
            }
            
            Out->msg(INFO, "<8724>Restore stream output, producing TS_CLRI");
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), m_buffer.size(), dataslice);
            dataslice.setslice64(0, m_buffer, false);

            
            de = m_ctx.toplevel.lookup(TS_BITS_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", TS_BITS_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "bits file not found");
                goto next_phase;
            }
            m_buffer.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, m_buffer, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_root;
    }
            break;
        case phase_root: {
            if (m_ctx.sendmap.size() > 0) {
                if (prune_acls) {  
                    for (int32_t i = 2; i < m_ctx.sendmap.max_inode(); i++) {
                        if (m_ctx.typemap.get(i) == dumpstream::typemap::acl)
                            m_ctx.sendmap.set(i, m_ctx.aclsfound.get(i));
                    }
                }

                
                char *c = m_buffer.start()+TP_BSIZE;
                char *s = m_ctx.sendmap.start();
                for (int32_t i = TP_BSIZE; i < m_buffer.size(); i++, c++, s++) *c &= *s;
            }
            
            Out->msg(INFO, "<8725>Restore stream output, producing TS_BITS");
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), m_buffer.size(), dataslice);
            dataslice.setslice64(0, m_buffer, false);

            
            upath rootdir = dumpstream::typemap::format(m_ctx.rootnode, dumpstream::typemap::dir);
            const location theloc(location::media::gsan, m_ctx.rootmetaloc.getHash());
            child = new restdirlist(this, theloc, rootdir.parentdir(), m_ctx.root_loc, m_listing);
            child->noop();
            m_phase = phase_inode2;
            break;
        }
        case phase_inode2: {
            
            Out->msg(INFO, "<8726>Restore stream output, adding root node %d -> 2", m_ctx.rootnode);
            upath rootdir = dumpstream::typemap::format(m_ctx.rootnode, dumpstream::typemap::dir);
            de = m_listing.lookup(rootdir.stripdir());

            fileoffset tmp_abs = de->get_location().get_abs_offset_in_container();
            if (umsg) DB->msg("restdumpstreamoutput::childdone: phase inode2, path=%s offset=%s", *de->fullpath().image(), *tmp_abs.image() );

            if (de.isnull()) {
                Out->msg(FATAL, "<8727>root node not found: %s", *m_ctx.typemap.format(m_ctx.rootnode).image());
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "root node not found");
                goto next_phase;
            }
            m_buffer.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, m_buffer, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_dirs;
            break;
        }
    case phase_dirs: {
            hdr = (dump_header*) m_buffer.start();
            if (+hdr->c_inumber != 2) {
                
                hdr->c_inumber = 2;
                update_checksum(*hdr);
            }
            
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), m_buffer.size(), dataslice);
            dataslice.setslice64(0, m_buffer, false);
            if (m_ctx.sendmap.size() != 0) m_ctx.sendmap.clear(2); 

            m_phase = (m_ctx.flags->isexplicit("ontap73acls")
                           ? m_ctx.flags->ontap73acls 
                           : m_ctx.typemap.get(3) != dumpstream::typemap::unused)
                         ? phase_acl3 : phase_files;
            de = m_ctx.toplevel.lookup(TS_DIR_FILENAME);

            fileoffset tmp_abs2 = de->get_location().get_abs_offset_in_container();
            if (umsg) DB->msg("restdumpstreamoutput::childdone: phase inode2, path=%s offset=%s", *de->fullpath().image(), *tmp_abs2.image() );
            if (de.isnull()) {
                
                goto next_phase;
            }
            
            Out->msg(INFO, "<8728>Restore stream output, adding directories");
            child = new restdumpstreamrange(this, 0, de, m_ctx);
            child->noop();
            break;
        }
        case phase_acl3:
            
            de = m_ctx.toplevel.lookup(TS_ACL3_FILENAME);
            if (de.isnull()) {
                m_phase = phase_files;
                if (!m_ctx.toplevel.lookup(TS_ACL_FILENAME).isnull()) {
                    
                    
                    m_phase = phase_inode3_acls_count;
                } else if (m_ctx.typemap.get(3) == dumpstream::typemap::acl) {
                    
                    Out->msg(ERR, "<8729>Missing ACL information from backup.  Unable to restore ACLs.");
                }
                goto next_phase;
            }
            
            temp_loc.set_abs_offset_in_container(de->get_location().get_abs_offset_in_container());
            
            {
                const location theloc(location::media::gsan, de->file_hash());
                child = new restdirlist(this, theloc, upath(""), temp_loc, m_listing);
            }
            child->noop();
            m_phase = phase_inode3;
            break;
        case phase_inode3:
        {
            m_phase = phase_inode3_acls_count;
            
            de = m_listing.lookup("3");
            if (de.isnull()) { 
                DB->msg("restdumpstreamoutput::childdone: No inode 3 header found. Will construct if needed");
                goto next_phase;
            }
            
            DB->msg("restdumpstreamoutput::childdone: getting inode 3 header, size=%ld", de->file_size().value());
            m_ctx.inode3_hdr.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, m_ctx.inode3_hdr, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            break;
        }
        case phase_inode3_acls_count: {
            DB->msg("restdumpstreamoutput::childdone, phase acl_count, sendmap total = %d acls in sendmap = %d", m_ctx.sendmap.count(), count_acls_in_sendmap());
            m_phase = phase_inode3_acls_out;
            de = m_ctx.toplevel.lookup(TS_ACL3_FILENAME);
            
            
            if (de.isnull()) {
                
                de = m_ctx.toplevel.lookup(TS_ACL_FILENAME);
                assert(!de.isnull());
                m_ctx.acl_total = static_cast<uint32_t> (de->file_size().value());
            } else {
               m_ctx.acl_total = static_cast<uint32_t> (de->file_size().value()-TP_BSIZE); 
            }
            DB->msg("restdumpstreamoutput: checking acl sizes");
            m_ctx.acls_calculated_size = 0;        
            restdumpstream_aclsize* aclsize = new restdumpstream_aclsize(this, de, m_ctx);
            aclsize->noop();
            break;
        }
        case phase_inode3_acls_out:
            DB->msg("restdumpstreamoutput: adding acls to acl3 container.");
            if (dbg) DB->msg("restdumpstreamoutput::childdone, phase acls_out, sendmap total = %d acls in sendmap = %d count of acls = %d",
                    m_ctx.sendmap.count(), count_acls_in_sendmap(), m_ctx.acl_count);
            DB->msg("restdumpstreamoutput::childdone: Replacing ACL 3 size %d with calculated size %d", m_ctx.acl_total, m_ctx.acls_calculated_size);
            m_ctx.acl_total = m_ctx.acls_calculated_size;
            de = m_ctx.toplevel.lookup(TS_ACL3_FILENAME);
            
            
            if (de.isnull()) {
                
                DB->msg("restdumpstreamoutput::childdone: Reading ACLs from old backup location");
                de = m_ctx.toplevel.lookup(TS_ACL_FILENAME);
                assert(!de.isnull());
            }
            if (m_ctx.inode3_hdr.size() == 0) {
                
                Out->msg(WARN, "<11089>Missing ACL section's header in backup.  Will attempt to work around.");
                dump_header inode3;
                memset(&inode3, 0, sizeof inode3);
                inode3.c_type = TS_INODE;
                inode3.c_inumber = 3;
                inode3.c_tapea = static_cast<int> (main->getpipe_control(0)->get_curroffset().value() / TP_BSIZE);
                if (m_ctx.timemap.size() > 0) {
                    inode3.c_shadow.c_level = 1;
                    inode3.c_ddate = m_ctx.mtime;
                }
                inode3.c_volume = 1;
                inode3.c_magic = NFS_MAGIC;
                inode3.c_dinode.di_mode = FT_IFREG;
                strcpy(inode3.c_label, "none");
                
                inode3.c_spare[23] = 1094929491; 
                inode3.c_spare[24] = 19541206;
                m_ctx.inode3_hdr.initlist(sizeof inode3);
                m_ctx.inode3_hdr.append(&inode3, sizeof inode3);
            }
            
            hdr = (dump_header*) m_ctx.inode3_hdr.start();
            hdr->c_dinode.di_size = m_ctx.acl_total;
            DB->msg("restdumpstreamoutput::childdone: di_size placed in inode 3 header is %d", m_ctx.acl_total);
            update_checksum(*hdr);
            
            Out->msg(INFO, "<8731>Restore stream output, adding acls");
            child = new restdumpstreamrange(this, 0, de, m_ctx);
            child->noop();
            m_phase = phase_files;
            break;
        case phase_files:
            if (dbg) DB->msg("restdumpstreamoutput::childdone, phase files, sendmap total = %d, acls in sendmap = %d", m_ctx.sendmap.count(), count_acls_in_sendmap());
            m_phase = phase_end1;
            de = m_ctx.toplevel.lookup(TS_FILE_FILENAME);
            if (de.isnull()) {
                
                goto next_phase;
            }
            
            Out->msg(INFO, "<8732>Restore stream output, adding files");
            child = new restdumpstreamrange(this, 0, de, m_ctx);
            child->noop();
            break;
        case phase_end1:
        {
            
            de = m_ctx.toplevel.lookup(TS_END_FILENAME ".1");
            if (de.isnull()) {
                Out->msg(FATAL, "<8733>%s.1 not found", TS_END_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "end file.1 not found");
                goto next_phase;
            }
            
            Out->msg(INFO, "<8734>Restore stream output, producing TS_END");
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), de->file_size(), dataslice);
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, dataslice, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            if (disable_final_acl_section) 
            {
                DB->msg("restdumpstreamoutput::childdone: x29=33554432 has been set, disabling final dumpstream acl section creation.");
                m_phase = phase_done;
            }
            else
            {
                m_phase = phase_eom;
            }
            break;
        }
        case phase_eom:
        {
            
            de = m_ctx.toplevel.lookup(TS_EOM_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<8719>%s not found", TS_EOM_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "eom file not found");
                goto next_phase;
            }
            DB->msg("restdumpstreamoutput::childdone: got TS_EOM, size=%ld", de->file_size().value());
            m_buffer.initlist((int)(de->file_size().value()));
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, m_buffer, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_acls;
            break;
        }
        case phase_acls:
            
            if (m_ctx.sendmap.size() > 0 && uapp::staging().canRun()) {
                Out->msg(INFO, "<8737>Verifying that all selected inodes were found in backup...");
                
                for (int32_t i = 1; i < m_ctx.sendmap.max_inode(); i++) {
                    if (m_ctx.sendmap.get(i))
                        Out->msg(ERR, "<8738>Inode %d was supposed to be restored, but not found in backup", i);
                }
                Out->msg(INFO, "<8739>Verifying that all selected inodes were found in backup...done");
            }

            if (m_ctx.sendmap.size() > 0) {
                DB->msg("restdumpstreamoutput::childdone: handling ACLS for TS_EOM, sendmap size=%d typemap for 3 = %d",
                        m_ctx.sendmap.size(), (int)m_ctx.typemap.get(3));
                
                char *c = m_buffer.start()+TP_BSIZE;
                char *s;
                if (!prune_acls) {
                    s = m_ctx.sendmap.start();
                }
                else {
                    s = m_ctx.aclsfound.start();
                    m_ctx.aclsfound.clear(3);  
                    m_ctx.aclsfound.clear(5);
                }
                
                if (m_ctx.typemap.get(3) == dumpstream::typemap::unused) {
                    
                    
                    
                    DB->msg("restdumpstreamoutput::childdone: no inode 3, clearing ACL bits");
                    for (int32_t i = TP_BSIZE; i < m_buffer.size(); i++, c++, s++) {
                        *c &= *s;
                    }
                } else if (!m_ctx.flags->isexplicit("ontap73acls") && !m_ctx.toplevel.lookup(TS_ACL_FILENAME).isnull()) {
                    
                    
                    
                    
                    DB->msg("restdumpstreamoutput::childdone: Setting sendmap for all ACLs, old style");
                    for (int32_t i = TP_BSIZE; i < m_buffer.size(); i++, c++, s++) *s |= *c;
                    m_ctx.sendmap.clear(3); 
                }
                
                
                
                
                
                
                
                
            }
            
            Out->msg(INFO, "<8735>Restore stream output, producing TS_EOM");
            DB->msg("restdumpstreamoutput::childdone: producing TS_EOM, size=%d", m_buffer.size());
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), m_buffer.size(), dataslice);
            dataslice.setslice64(0, m_buffer, false);

            m_phase = phase_end2;
            if (m_ctx.flags->isexplicit("ontap73acls") && m_ctx.flags->ontap73acls)
                goto next_phase; 
            de = m_ctx.toplevel.lookup(TS_ACL_FILENAME);
            if (de.isnull()) {
                
                
                if (m_ctx.flags->isexplicit("ontap73acls") && !m_ctx.flags->ontap73acls) de = m_ctx.toplevel.lookup(TS_ACL3_FILENAME);
                if (de.isnull()) {
                    DB->msg("restdumpstreamoutput::childdone: no old stype ACLs to output. Going to TS_END");
                    
                    goto next_phase;
                }
                
                
                Out->msg(WARN, "<11090>Restoring OnTap 7.3+ ACLs via old method.  ACLs may be truncated.");
            }
            
            Out->msg(INFO, "<8731>Restore stream output, adding acls");
            child = new restdumpstreamrange(this, 0, de, m_ctx);
            child->noop();
            break;
        case phase_end2:
        {
            
            de = m_ctx.toplevel.lookup(TS_END_FILENAME ".2");
            if (de.isnull()) {
                Out->msg(FATAL, "<8736>%s.2 not found", TS_END_FILENAME);
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "end file.2 not found");
                goto next_phase;
            }
            
            Out->msg(INFO, "<8734>Restore stream output, producing TS_END");
            main->getpipe_control(0)->addobj(pipe_control::REGTYPE, "", DIRELEM(), de->file_size(), dataslice);
            filestatsref fstats;    
            restelem re (de->fullpath(), *de, fstats, dataslice, m_ctx.ucontainerp);
            child = new restdata(this, de->file_hash(), 0, true, re, m_ctx.ucontainerp.isdefined());
            child->noop();
            m_phase = phase_done;
            break;
        }
        case phase_done:
            if (m_ctx.sendmap.size() > 0 && uapp::staging().canRun()) {
                Out->msg(INFO, "<8737>Verifying that all selected inodes were found in backup...");
                
                for (int32_t i = 1; i < m_ctx.sendmap.max_inode(); i++) {
                    if (m_ctx.sendmap.get(i))
                        Out->msg(ERR, "<8738>Inode %d was supposed to be restored, but not found in backup", i);
                }
                Out->msg(INFO, "<8739>Verifying that all selected inodes were found in backup...done");
            }
            notifyparent();
            break;
        default:
            Out->msg(ERR, "<8718>Unexpected phase number %d", m_phase);
            break;
    }
}



restdumpstreamrange::restdumpstreamrange(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum)
    : cycle(parent, 0)
    , m_de(de)
    , m_ctx(ctx)
{
    if (starter) {
        starter->setnext(TODO_DIR, this, inum);
    } else {
        main->add_insert(TODO_DIR, this, inum);
    }
}

void restdumpstreamrange::init()
{
    
    dumpstream::typemap::inodetype itype, dummy;
    int32_t first = m_ctx.typemap.parse(m_de->fullpath(), itype);
    int32_t last  = m_ctx.typemap.parse(m_de->fullpath() / upath("ffffffff"), dummy) + 1;

    if (first == 0) first = 1;
    if (last == 0) last = m_ctx.typemap.max_inode();
    if (last > m_ctx.typemap.max_inode()) last = m_ctx.typemap.max_inode();

    if (!m_de->is_directory()) first = last; 

    if (dbg) DB->msg("restdumpstreamrange::init path:%s type:%d first:%08x last:%08x isdir=%d",
                     *m_de->fullpath().image(), itype, first, last, m_de->is_directory());

    
    while ((first < last) && ((m_ctx.typemap.get(first) != itype) || ((m_ctx.sendmap.size() != 0) && !m_ctx.sendmap.get(first)) )) first++;
    if (first >= last) {
        
        if (dbg) DB->msg("restdumpstreamrange::init. This inode %s has no children.Calling childdone", *m_de->fullpath().image());
        childdone(0);
        return;
    }

    if (dbg) DB->msg("restdumpstreamrange::init path:%s getting listing", *m_de->fullpath().image());

    
    m_listing.initlist(8192);
    filestatsref fstats;    
    restelem re (m_de->fullpath(), *m_de, fstats, m_listing, m_ctx.ucontainerp);
    cycle *child = new restdata(this, m_de->file_hash(), 0, false, re);
    child->noop();
    nforked++;
}

void restdumpstreamrange::childdone(cycle *child)
{
    
    if (nforked == 1) {
        child = 0;
        fileoffset coff = m_de->get_location().get_abs_offset_in_container() + m_de->get_location().get_header_size();
        if (umsg) DB->msg("restdumpstreamrange::childdone: Before loop, path=%s abs offset = %s", *m_de->fullpath().image(), *coff.image() );
        
        for (int off = 0; off < m_listing.size(); ) {
            int oldoffset = off; 
            DIRELEMp de = new DIRELEM;
            de->populate(m_listing, off, m_de->fullpath(), coff);
            fileoffset tmp_abs = de->get_location().get_abs_offset_in_container();
            if (dbg) DB->msg("restdumpstreamrange::childdone: PROCESSING FILE/PATH %s offset=%s", *de->fullpath().image(), *tmp_abs.image());
            dumpstream::typemap::inodetype itype;
            int32_t inum = m_ctx.typemap.parse(de->fullpath(), itype);
            if (inum == 2 || inum == 3) { 
                
                continue;
            }
            if (de->is_directory()) {
                
                if (dbg) DB->msg("restdumpstreamrange::childdone: calling restdumpstreamrange for dir %s", *de->fullpath().image());
                child = new restdumpstreamrange(this, child, de, m_ctx, inum);
                child->noop();
                nforked++;
                continue;
            }

            
            dumpstream::typemap::inodetype ttype = m_ctx.typemap.get(inum); 
            if ((itype == dumpstream::typemap::acl) && (itype != ttype)) {
                if (dbg) DB->msg("restdumpstreamrange::childdone NOT ADDING ACL TO STREAM  path:%s sendmap=%d type=%d",
                                 *de->fullpath().image(), m_ctx.sendmap.get(inum), m_ctx.typemap.get(inum));
                continue;
            }

            if (!prune_acls) {
                
                
                
                if (itype != ttype && itype != dumpstream::typemap::acl) {
                    if (m_ctx.sendmap.size() == 0 || m_ctx.sendmap.get(inum)) {
                        
                        Out->msg(INFO, "<11091>Fixed type mismatch for inode %d: found %d but should be %d",
                             inum, ttype, itype);
                        m_ctx.typemap.set(inum, itype);
                    }
                }
            }

            
            if (m_ctx.sendmap.size() > 0) {
                
                if (!m_ctx.sendmap.get(inum)) {
                    continue;
                }
                
                
                if (itype != ttype) {
                    continue;
                }
                
                m_ctx.sendmap.clear(inum);
                
                if (!m_ctx.flags->ontap73acls && itype != dumpstream::typemap::acl) {
                    
                    int32_t aclnum = 0;
                    dirrec_pack::acl_ref acl(de.getimpl());
                    if (acl.get(aclnum) && aclnum != 0 && m_ctx.typemap.get(aclnum) == dumpstream::typemap::acl) {
                        if (dbg) DB->msg("Adding the acl for inode %d type %d, acl inode = %d", inum, itype, aclnum);
                        m_ctx.sendmap.set(aclnum);
                    }
                }
            }

            if (itype == dumpstream::typemap::file) {
                
                
                backstats *stats = main->getstatsobj(context::restorestats);
                stats->add_filebytes_primary(de->file_size().dvalue());
                stats->add_filebytes_prog(de->file_size().dvalue());
                if (m_ctx.ucontainerp.isdefined()) {
                    stats->update(stats::ddsent, de->file_size().dvalue(), chunktype::atomic, false);
                } else {
                    stats->update(stats::sent, de->file_size().dvalue(), chunktype::atomic, false);
                }
            }

            if (dbg) DB->msg("restdumpstreamrange::childdone adding item path:%s  sendmap=%d type=%d",
                             *de->fullpath().image(), m_ctx.sendmap.get(inum), m_ctx.typemap.get(inum));
            if (itype != dumpstream::typemap::acl) {
                
                fileref dataslice;
                filestatsref fstats;    
                main->getpipe_control(0)->addobj(pipe_control::REGTYPE, de->fullpath().image(), *de, de->file_size(), dataslice);

                fileoffset absoffset  = de->get_location().get_abs_offset_in_container();
                fileoffset cover      = de->get_location().get_coverage_size();
                if (umsg) DB->msg("restdumpstreamrange::childdone calling restdata, inode=%d path=%s  absoffset=%s cover=%s filesize=%s",
                    inum, *de->fullpath().image(), *absoffset.image(), *cover.image(), *de->file_size().image());
                restelem re (de->fullpath(),  *de, fstats, dataslice, m_ctx.ucontainerp);
                child = new restdata(this, de->file_hash(), 0, true, re, fileoffset(0), fileoffset(-1),
                                     
                                     
                                     main->getpipe_control(0)->reserved_bytes_pending() > 128*1024*1024 ? child : 0, inum,
                                     fileref::empty, -1, NULL, m_ctx.ucontainerp.isdefined());

            } else {
                
                
                
                
                
                if (dbg) DB->msg("restdumpstreamrange::childdone: handling ACL with inode %d (%x), oldoffset=%d new=%d size=%d",
                                 inum, inum, oldoffset, off, m_listing.size());
                child = new restdumpstreamacl(this, child, de, m_ctx, inum);
            }
            child->noop();
            nforked++;
        }  
        
        m_listing = fileref();
    }
    if (++ncollected >= nforked) {
        if (dbg) DB->msg("restdumpstreamrange::childdone path:%s notifying parent", *m_de->fullpath().image());
        notifyparent();
    }
}






restdumpstream_aclsize::restdumpstream_aclsize (cycle *parent, DIRELEMp de, restdumpstreamcontext &ctx)
    : cycle(parent, 0),
      m_de(de),
      m_ctx(ctx)
{
    if (dbg) DB->msg("restdumpstream_aclsize::constructor for path %s", *m_de->fullpath().image());
    main->add_insert(TODO_DIR, this, 0);
}


void restdumpstream_aclsize::init() {
    if (dbg) DB->msg("restdumpstream_aclsize::init for path %s", *m_de->fullpath().image());
    
    location temp_loc(m_ctx.root_loc);
    temp_loc.set_abs_offset_in_container(m_de->get_location().get_abs_offset_in_container());
    const location theloc(location::media::gsan, m_de->file_hash());
    cycle *child = new restdirlist(this, theloc, upath(), temp_loc, m_child);
    child->noop();
    nforked++;
}


void restdumpstream_aclsize::childdone(cycle *child) {
    ncollected++;
    if (dbg) DB->msg("restdumpstream_aclsize::childdone: TOP, nforked=%d ncollected=%d", nforked, ncollected);
    if (nforked == 1) {
        undoo::vector<ustring> names = m_child.keys();
        for (size_t i = 0; i < names.size(); i++) {
            DIRELEMp de = m_child.lookup(names[i]);
            if (de->is_directory()) {
                
                if (dbg) DB->msg("restdumpstream_aclsize::childdone: Recursing for path %s", *de->fullpath().image());
                restdumpstream_aclsize *mychild = new restdumpstream_aclsize(this, de, m_ctx);
                mychild->noop();
                nforked++;
            }
            else {
                
                upath mypath = de->fullpath();
                int inode = de->inode_number();
                dumpstream::typemap::inodetype ttype = m_ctx.typemap.get(inode);

                if ( (ttype == dumpstream::typemap::acl) && (inode != 3)) {  
                    if (!prune_acls  || (prune_acls && m_ctx.aclsfound.get(inode))) {
                        fileoffset de_size = de->file_size();
                        m_ctx.sendmap.set(inode);

                        
                        m_ctx.acls_calculated_size = m_ctx.acls_calculated_size + de_size.ivalue();
                        m_ctx.acl_count++;
                        if (dbg) DB->msg("restdumpstream_aclsize::childdone, added ACL inode %d (%s) to count %d, size=%s new total=%d",
                                         inode, *mypath.image(), m_ctx.acl_count, *de_size.image(), m_ctx.acls_calculated_size);
                    }
                }
                else {
                    if (inode != 3) {
                        if (dbg) DB->msg("restdumpstream_aclsize::childdone: inode %d (%s) is not an ACL. type=%d ", inode, *mypath.image(),  (int)ttype );
                    }
                }
            }
        }
    }
    if (nforked == ncollected) {
        notifyparent();
    }
}



restdumpstreamacl::restdumpstreamacl(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum)
    : cycle(parent, 0)
    , m_de(de)
    , m_inum(inum)
    , m_nextheaderoff(ctx.acl_block)
    , m_lastblocksize(0)
    , m_ctx(ctx)
{
    uint32_t numhdrs = 0;
    uint32_t size = de->file_size().ivalue();
    if (ctx.acl_total > 0) {
        
        
        
        while (size >= ctx.acl_block) { 
            size -= ctx.acl_block;
            ctx.acl_total -= ctx.acl_block;
            
            if (ctx.acl_total == 0) { 
                ctx.acl_block = 0;
                break;
            }
            numhdrs++;
            
            m_lastblocksize = ctx.acl_block = std::min(ctx.acl_total, uint32_t(TP_NINDIR*TP_BSIZE));
        }
        
        ctx.acl_block -= size;
        ctx.acl_total -= size;
    }
    if (dbg) DB->msg("restdumpstreamacl::restdumpstreamacl: numhdrs=%d acl_block=%d acl_total=%d size=%d",
                     numhdrs, ctx.acl_block, ctx.acl_total, size);
    
    
    
    
    
    
    
    main->getpipe_control(0)->addobj(pipe_control::REGTYPE, de->fullpath().image(), *de,
                                    de->file_size().ivalue() + numhdrs*sizeof(dump_header), m_slice);
    if (starter) {
        starter->setnext(TODO_DIR, this, inum);
    } else {
        main->add_insert(TODO_DIR, this, inum);
    }
}

void restdumpstreamacl::init()
{
    
    
    m_buffer.initlist(m_de->file_size().ivalue());
    filestatsref fstats;    
    restelem re (m_de->fullpath(), *m_de, fstats, m_buffer, m_ctx.ucontainerp);
    cycle *child = new restdata(this, m_de->file_hash(), 0, false, re, m_ctx.ucontainerp.isdefined());
    child->noop();
    nforked++;
}

void restdumpstreamacl::childdone(cycle *child)
{
    if (nforked == 1) {
        
        
        
        
        
        
        dump_header *hdr = (dump_header*) m_buffer.start();
        
        hdr->c_magic = m_nextheaderoff > 0 || m_lastblocksize > 0 ? ACL_MAGIC : NFS_MAGIC;
        update_checksum(*hdr);
        uint32_t start = 0;
        fileoffset output = 0;
        do {
            if (m_nextheaderoff > 0) {
                
                uint32_t length = std::min(m_buffer.size()-start, m_nextheaderoff);
                if (dbg) DB->msg("Adding inode 3 ACL slice at offset=%s, inum=%d, size=%u, slice start=%u, length=%u",
                                 *(m_slice.absoffset()+output).image(), m_inum, m_buffer.size(), start, length);
                m_slice.setslice64(output, m_buffer.makeslice(start, length), false);
                start += length;
                output += length;
            } else if (m_lastblocksize == 0) {
                
                m_slice.setslice64(0, m_buffer, false);
                break;
            }
            if (m_lastblocksize > 0) {
                
                
                fileref hdrref = m_ctx.inode3_hdr.copyslice(0, sizeof(dump_header));
                
                
                
                
                
                
                
                
                
                

                
                hdr = (dump_header*) hdrref.start();
                
                
                
                
                if (m_nextheaderoff > 0) hdr->c_type = TS_ADDR;
                
                uint32_t length = m_nextheaderoff = TP_NINDIR*TP_BSIZE;
                
                if (m_nextheaderoff > m_buffer.size()-start) {
                    length = m_lastblocksize;
                    DB->msg("restdumpstreamacl::childdone:updating ACL length, hdroff=%d buffsize-start=%d len=%d",
                            m_nextheaderoff, (m_buffer.size()-start), length);
                    m_lastblocksize = 0; 
                }
                if (dbg) DB->msg("restdumpstreamacl::childdone: Adding inode 3 header at offset=%s, length=%u",
                                 *(m_slice.absoffset()+output).image(), length);
                
                
                
                
                
                hdr->c_count = 0;
                memset(hdr->c_data.s_addrs, 0, sizeof hdr->c_data.s_addrs);
                for (uint32_t size = 0; size < length; size += TP_BSIZE) {
                    hdr->c_data.s_addrs[+hdr->c_count] = 1;
                    hdr->c_count = +hdr->c_count + 1;
                }
                update_checksum(*hdr);
                
                m_slice.setslice64(output, hdrref, false);
                output += hdrref.size();
            }
        } while (start < (uint32_t)m_buffer.size());
    }
    if (++ncollected >= nforked) {
        if (dbg) DB->msg("restdumpstreamacl::childdone path:%s notifying parent", *m_de->fullpath().image());
        notifyparent();
    }
}
















#include "common.h"
#include "backhidden.h"
#include "debug.h"
#include "fileref.h"
#include "backstate.h"
#include "workelem.h"
#include "file_system_info.h"
#include "output.h"
#include "file.h"
#include "utar_flags_info.h"
#include "nbackdir.h"
#include "nbackdata.h"
#include "timer.h"
#include "restdirlist.h"
#include "restdata.h"

#include "filenames.h"  
#include "infofile_info.h"
#include "userid.h"
#include "encodings.h"
#include "alocale.h"

#include "machinedesc.h"
#include "wmi.h"
#include "runstage.h"
#include "utar_flags_enums.h"

#include "location.h"
#include "userinfo.h"

#ifdef USEADE
#include "ade_mgrx.h"
#endif
#if SYSTEM_WINDOWS
    #include "wss_sis_manager.h"
#endif

#include "MetadataStore.h"


const int MAX_COMMAND_LINE_LEN = 100 * 1024;


#define DOIT(n) ((xflag[5]&n)==0)

void hiddendirwriter::add_server(hiddendirfuncs * server) {
    servers.push_back(server);
}

void hiddendirwriter::do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also) {

    for (size_t i = 0; i < servers.size(); i++) {
        hiddendirfuncs * oneserver = servers[i];
        oneserver->do_file(name, attributes, data, use_container_also);
    }
}


void hiddendirwriter::do_file_finish() {
    for (size_t i = 0; i < servers.size(); i++) {
        hiddendirfuncs * oneserver = servers[i];
        oneserver->do_file_finish();
    }

}







class MetadataStoreHandler : public hiddendirfuncs {
    public:
        MetadataStoreHandler(MetadataStore * _ms, BackCycle * _parentCycle);
        virtual ~MetadataStoreHandler() { }

        void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false );

        void do_file_finish();

    private:
        MetadataStoreHandler() : ms(NULL), parentCycle(NULL) { }

        MetadataStore * const ms;
        BackCycle * const parentCycle;
        DIRELEM sysInfoDe;          
        MetadataIntf_sp sysInfoMeta;
};


MetadataStoreHandler::MetadataStoreHandler(MetadataStore * _ms, BackCycle * _parentCycle) : ms(_ms), parentCycle(_parentCycle) {

    if (ms != NULL) {
        MetadataIntf_sp root;
        SavesetIntf_sp openSaveset;
        ms->getOpenBackup(openSaveset, root);
        sysInfoDe.set_name(ustring(UNDOO_DIRECTORY_NAME));
        sysInfoDe.set_is_directory();
        sysInfoDe.set_internal(true);
        const ustring parentname = parentCycle->getInfo()->direlemp->name();
        MetadataIntf_sp parent;
        if (!parentname.isempty() && (root->getMetadata(upath(parentname), parent) == storeSuccess)) {
            DB->msg("Creating .system_info folder in root/%s", *parentname);
            if (parent->openDir(sysInfoDe, sysInfoMeta) != storeSuccess) {
                DB->msg("FAILED to create system info directory");
            }
        }
        else {
            DB->msg("Creating .system_info folder in root");
            if (root->openDir(sysInfoDe, sysInfoMeta) != storeSuccess) {
                DB->msg("FAILED to create system info directory");
            }
        }
    }
}


void MetadataStoreHandler::do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also ) {

    
    if (sysInfoMeta) {
        DIRELEM de;
        de.set_name(name);
        de.set_is_directory(false);
        de.set_mtime((epoch_t)timer::now());
        de.set_internal(true);
        de.set_file_size(data.size64());

        
        location loc;
        loc.setMedia(location::media::catalog);
        de.set_location(loc, false);

        
        GenericDataVector gdv;
        gdv.push_back(GenericDataInfo(FILE_DATA, data));
        sysInfoMeta->add(de, gdv);
    }
}


void MetadataStoreHandler::do_file_finish() {
    if (ms != NULL && sysInfoMeta) {
        sysInfoMeta->closeDir(sysInfoDe);
    }
}

backhidden::backhidden(BackCycle* parent_,
                       workelem *info_,
                       fileoffset patchoffset_,
                       const fileoffset incdumpsize_,
                       const bool use_container_also_ ,
                       const bool write_ddrfiles_xml_ ,
                       const DataDomainSysInfo* ddrSysInfoVp_ )
  : BackCycle(parent_, info_),
    incdumpsize(incdumpsize_),
    use_container_also(use_container_also_),
    write_ddrfiles_xml(write_ddrfiles_xml_),
    ddrSysInfoVp(ddrSysInfoVp_),
    write_target_workresults(true)
{
    DB->msg("backhidden::backhidden constructor2 (parent:%p) (this:%p) container?%d write_ddrfiles_xml?%d ddrinfop %p", parent, this, use_container_also, write_ddrfiles_xml, ddrSysInfoVp);
    if (use_container_also) {
        assert(info->use_container);
        
        if (info->container.isnull()) {
            Out->msg(WARN, "backhidden::backhidden with use_container_also, but info->container is null!");
        }
    }
    this->offset = patchoffset_;  

    proxy = hiddendirwriter_sp(new hiddendirwriter());

    
    
    workelem *w = new workelem(info, info->path, info->direlemp); 
    w->use_container = false; 
    nbackdir * backdir = new nbackdir(this, w, fileoffset(0), 
                         true,  
                         false, 
                         false, 
                         false, 
                         0,     
                         0,     
                         false, 
                         NULL,  
                         false); 

    if (backdir != NULL) {
        proxy->add_server(backdir);
    }

    const hfs_info_struct hfsInfo = main->getAdeMgr()->getHfsInfo(dpn0);
    if (hfsInfo.metaStore != NULL) {
        MetadataStoreHandler * ch = new MetadataStoreHandler(hfsInfo.metaStore, parent_);
        proxy->add_server(ch);
    }

    todoEnqueue(TODO_DIR, this);  
}

void backhidden::init() {
    DB->msg("backhidden::init (parent:%p) (this:%p)", parent, this);
#if SYSTEM_WINDOWS
    
    if (wss_sis_manager::sis_manager != NULL)
        wss_sis_manager::sis_manager->close_hs_file();
#endif
    do_hidden_dir();
}

void backhidden::response(message& outargs ) {
    DB->msg( "backhidden::response" );
    assert(false);
}

void backhidden::childdone(cycle *child) {
    assert(info != NULL);
    DB->msg("backhidden::childdone info %p, info->direlemp %p", info, info->direlemp.isnull() ? NULL : info->direlemp.getimpl());
    if (child == NULL) {
        set_error(true, "hiddendir has no child");
    } else {
        size = child->size;
        DB->msg("backhidden::childdone child->size:%s", *child->size.image());
        info->direlemp->set_file_size(child->size);
    }
    
    info->direlemp->set_hash(hash);
    notifyparent();
}

void backhidden::notifyparent() {
    DB->msg("backhidden::notifyparent");
    main->handling_system_info(false);
    cycle::notifyparent();
}

backhidden::~backhidden() {
    DB->msg("backhidden::~backhidden done");
    if (info != NULL && !info->isapi) delete info;

    
    for (hiddendirwriter::ServersType::iterator it = proxy->servers.begin(); it != proxy->servers.end(); it++) {
        const nbackdir * nbd = dynamic_cast<nbackdir *>(*it);
        if (nbd != NULL) {
            
            continue;
        }
        
        delete *it;
    }
    info = NULL;
}

void backhidden::do_hidden_dir() {
    if(uapp::staging().isExitAbort()) return;
    main->handling_system_info(true);

    DB->msg(DBTXT("creating %s directory"), UNDOO_DIRECTORY_NAME);
    if(uapp::staging().isExitCancel())
        Out->msg(INFO, "<7202>Backup CANCELED, wrapping-up session with Server");
    else
        Out->msg(INFO, "<5163>Backup complete, wrapping-up session with Server");
    main->getstatsobj(context::backupstats)->docount(false); 

    if (info->use_container || use_container_also) {
        
        ucontainer::errortype errcode(info->container->begindir(info->direlemp.getimpl()));
        if (errcode != ucontainer::pce__success) {
            Out->Abort("backhidden::do_hidden_dir Problem calling begindir for %s (%s)",
                     *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        } else {
            DB->msg("backhidden::do_hidden_dir    ucontainer begindir  '%s' (abs_offset_in_container: %"LL"d, mysize=%s)",
                    *info->direlemp->fullpath().image(),
                    info->direlemp->get_location().get_abs_offset_in_container().value(),
                    *info->direlemp->file_size().image());

            
            ucontainer::errortype errcode(main->getucontainer_yucky_global()->begindircontent(info->direlemp.getimpl()));
            if (errcode != ucontainer::pce__success)
            {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                Out->Abort("Problem calling begindircontent for %s (%s)",
                         *info->direlemp->fullpath().image(), *errdesc);
                return;
            } else {
                DB->msg("backhidden::do_hidden_dir: begindircontent called. abs_offset_in_container:%"LL"d header_size:%"LL"d",
                        info->direlemp->get_location().get_abs_offset_in_container().value(),
                        info->direlemp->get_location().get_header_size().value());
            }
            DB->msg("backhidden::do_hidden_dir    ucontainer after begindir  loc:%s", *info->direlemp->get_location().image());
        }
    }


#if SYSTEM_WINDOWS
    if (wss_sis_manager::sis_manager != NULL) {
        if(wss_sis_manager::sis_manager->get_cs_hashes_file_exist())
            do_diskfile(CS_HASHES_FILE, wss_sis_manager::sis_manager->get_sis_hs_path_image(), 1);
    }
#endif
    
    
    if(DOIT(1)) {
        {
            fileref archive_info;
            create_archive_info_file(archive_info, NULL );
            proxy->do_file( ARCHIVE_INFO_FILENAME,  ATTR_INTERNAL, archive_info, use_container_also);
        }

        
        {
            fileref archive_info_xml;
            create_archive_info_file(archive_info_xml, "archive_info" );
            proxy->do_file(ustring(ARCHIVE_INFO_FILENAME) + ustring(".xml"), ATTR_INTERNAL, archive_info_xml, use_container_also);
        }
    }

    
    if(DOIT(2)) {
        proxy->do_file( ARCHIVE_MOUNT_FILENAME, ATTR_INTERNAL, DB->mount_point_info, use_container_also);
        if(main->dolocalstats) {
            main->dolocalstats = false;           
            
            
            proxy->do_file( STATS_FILENAME, ATTR_INTERNAL, DB->localstats, use_container_also);
        }
    }

    if( !flags.nomachinedesc && !flags.mapi) {
#if SYSTEM_WINDOWS
        if(DOIT(2)) {
            WMI wmi;
            
            proxy->do_file( MACHINEDESC_FILENAME, ATTR_INTERNAL, wmi.get_xmlfileref(), use_container_also );

            fileref vollist = machinedesc::get_win_volume_list();
            proxy->do_file( VOLUME_LIST_FILENAME, ATTR_INTERNAL, vollist, use_container_also );
        }

        if(DOIT(8)) {
            fileref winpart = machinedesc::get_win_partitiontables(proxy);
            proxy->do_file( PARTITIONTABLES_FILENAME, ATTR_INTERNAL, winpart, use_container_also );
        }

        proxy->do_file( ENCODINGS_FILENAME, ATTR_INTERNAL,
                        main->character_encodings.state_xml(), use_container_also );
#endif
#if SYSTEM_WINDOWS || SYSTEM_UNIX_MACOSX
        if(DOIT(65536)) {
            fileref userinfoxml = userinfo::userinfo_xml();
#if SYSTEM_UNIX_MACOSX
            
            
            
            
            if (! userinfoxml.isnull())
#endif
                proxy->do_file( USERINFO_FILENAME, ATTR_INTERNAL, userinfoxml, use_container_also);
        }
#endif

        proxy->do_file( LOCALE_FILENAME, ATTR_INTERNAL, alocale::state_xml(), use_container_also );

        
        
        
#if SYSTEM_WINDOWS | SYSTEM_UNIX_LINUX
        
        if(! DOIT(4)) {
            fileref smartdata = machinedesc::get_smartdata();
            proxy->do_file( SMARTDATA_FILENAME, ATTR_INTERNAL, smartdata, use_container_also );
        }
#endif
    }

    if (flags.filestats > 0 && DOIT(32))
        proxy->do_file( FILESTATS_FILENAME, ATTR_INTERNAL, DB->get_topfiles(flags.filestats, flags.filestatmin), use_container_also);

    if (DOIT(64)) {
        proxy->do_file( USERS_ID_FILENAME, ATTR_INTERNAL, userid::instance()->to_file(), use_container_also );
        proxy->do_file( GROUP_ID_FILENAME, ATTR_INTERNAL, groupid::instance()->to_file(), use_container_also );
    }

    
    if(DOIT(524288) && main && !main->backup_resource_list.empty()) {
        DB->msg("backhidden::do_hidden_dir: Adding %s with to .system_info.", BACKUP_RESOURCE_LIST);
        proxy->do_file(BACKUP_RESOURCE_LIST, ATTR_INTERNAL, main->backup_resource_list.to_fileref());
    }

    
    
    
#ifdef USEADE
    ADEMgrX* adeMgr = main->getAdeMgr();
    if(adeMgr != NULL) {
        
        if(adeMgr->isDDRenabled() && ((flags.streamformat_out != utar_flags_enums::streamformat_cdsf) || flags.makeview || write_ddrfiles_xml)) {
            DataDomainSysInfo ddrSysInfo;
            DataDomainSysInfo* ddrSysInfop = (DataDomainSysInfo*)ddrSysInfoVp;
            bool resultOK(true);
            if (ddrSysInfop == NULL) {  
                ddrSysInfop = &ddrSysInfo;
                
                resultOK = adeMgr->write_ddrfilesxml(ddrSysInfop);
            } else if (ddrSysInfop->fileName.isempty() || ddrSysInfop->ddrfilesData.isnull()) {
                DB->msg("backhidden::do_hiddendir: DDR sys info failure, name '%s' fileref isnull %d",
                        *ddrSysInfop->fileName, ddrSysInfop->ddrfilesData.isnull());
                resultOK = false;
            }
            if (resultOK) {
                DB->msg("backhidden::do_hidden_dir: Adding ddr_files.xml to .system_info.");
                proxy->do_file(*ddrSysInfop->fileName, ATTR_INTERNAL, ddrSysInfop->ddrfilesData);
            }
            else {
                Out->msg(ERR, "<9918>Internal Error: Cannot obtain DDR files information from Data Domain -- Backup incomplete");
            }
        } else if ((flags.backupstate == utar_flags_enums::backstate_final) && ddrSysInfoVp && write_ddrfiles_xml) {
            
            
            
            
            
            if (ddrSysInfoVp->ddrfilesData.size() > 0) {
                
                DB->msg("backhidden::do_hidden_dir: Adding ddr_files.xml (from previous partial) to .system_info during final state of cumulative backup.");
                proxy->do_file(*ddrSysInfoVp->fileName, ATTR_INTERNAL, ddrSysInfoVp->ddrfilesData);
            } else {
                
                
                Out->msg(ERR, "DDR files information not available for this backup.  It will not be possible to restore this backup or use it as a base for future incrementals.");
            }
        }
    }
#endif

    
    if (!flags.logfilename.isempty() && DOIT(128))
        do_diskfile(LOG_FILENAME, flags.logfilename, 1);

    
    if (!flags.commentfiles.isempty() && DOIT(256)) {
        do_comment_files(flags.commentfiles);
    }

    
    
    if (main->get_encrypthash() != hashcode::empty) {
        fileref encryptinfo;
        encryptinfo.initmem(main->get_encrypthash().image());
        proxy->do_file( ENCRYPTED_FILENAME, ATTR_INTERNAL, encryptinfo, use_container_also);
    }

    
    if (!flags.backuptag.isempty()) {
        do_backuptag(proxy);
    }

    
    
    
    do_sysinfo_assoc(main->sysinfo_files_and_data);

    do_target_sysinfo_assoc(main->target_sysinfo_files_and_data);

    
    
    if (DOIT(16)) {
        if (!DB->workorder.isnull()) {
            proxy->do_file( WORKORDER_FILENAME, ATTR_INTERNAL, DB->workorder, use_container_also);
        }
        proxy->do_file( ERRORS_FILENAME, ATTR_INTERNAL, main->get_errorsummary_xml()->image(true, ""), use_container_also );
    }

    
    
    main->sysinfo_files_and_data.clear();

    if (info->use_container) {
        ucontainer::errortype errcode(info->container->enddir(info->direlemp.getimpl()));
        if (errcode != ucontainer::pce__success) {
            Out->Abort("backhidden::do_hidden_dir Problem calling enddir for %s (%s)",
                     *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        }
        DB->msg("backhidden::do_hidden_dir   ucontainer after enddir    loc:%s", *info->direlemp->get_location().image());
    }

    proxy->do_file_finish();
    main->getstatsobj(context::backupstats)->docount(true); 
}


bool backhidden::create_archive_info_file(fileref& info_data, const char *xmlname) {
    if( !main->state) { return false; }
    infofile_info infof;

    if (main->getstatsobj(context::backupstats)) {
       infof.dsize = main->getstatsobj(context::backupstats)->get_filebytes_prog(); 
       infof.nfiles = main->getstatsobj(context::backupstats)->get_filecount();
    } else {
       infof.dsize = 0;
       infof.nfiles = 0;
    }

    
    
    if(incdumpsize != fileoffset(0))
        infof.dsize = incdumpsize.dvalue();

    infof.command_line = flags.commandline();
    if (infof.command_line.bytelength() > MAX_COMMAND_LINE_LEN) {
        
        
        
        Out->msg(WARN, "Truncating command line from %d to ~%d bytes for archive info.",
                    infof.command_line.bytelength(), MAX_COMMAND_LINE_LEN);
        const ustring suffix("... [truncated]");
        ustring truncated_line = infof.command_line.safe_substr(0, MAX_COMMAND_LINE_LEN - suffix.bytelength());
        infof.command_line = truncated_line + suffix;
    }
    infof.hostname = flags.hostname;
    infof.label = flags.label;
    infof.elaptime = timer::elapsedstring(timer::elapsed());
    infof.pid    = flags.pluginid.name();
    infof.pidnum = flags.pluginid.number();
#ifdef USEADE
    ADEMgrX* adeMgr = main->getAdeMgr();
    if(adeMgr != NULL) {
        infof.serverid = (double)adeMgr->getHfsCreateTime(dpn0);
    }
    else {
        assert(!"adeMgr == NULL: Cannot get main->cstats[dpn0].hfscreatetime");
      
    }
#else
    assert(!"adeMgr == NULL: Cannot get main->cstats[dpn0].hfscreatetime");

#endif

    if(flags.backupsystem) infof.systemstate = flags.systemstatefile;

    if(flags.streamformat_in==utar_flags_enums::streamformat_emctar)
      infof.celerrai18n = flags.celerrai18n;

    int fatals;
    Out->get_total_counts(infof.warnings, infof.errors, fatals);

#if SYSTEM_UNIX_SOLARIS | SYSTEM_UNIX_HPUX
    char *cwd = getcwd(NULL, PATH_MAX);  
#else
    char *cwd = getcwd(NULL, 0);  
#endif
    if(cwd) {
        infof.working_dir = cwd;
        free(cwd);
    }

    
    if(flags.args.size() <= MAX_TARGETS_LEN)
        infof.files = flags.args;
    else
        for(int i=0; i<MAX_TARGETS_LEN; i++)
            infof.files.push_back(flags.args[i]);

    
    infof.sessionid = tostr(main->state->sessionid);
    infof.print_file(info_data, xmlname);
    return true;
}







void backhidden::do_comment_files(const stringlist& list) {
    int i;
    stringlist names;
    for(i=0; i<list.size(); i++) {
        ustring sysinfoname;
        ustring diskfile;
        list[i].split(sysinfoname, diskfile, false, '=');       
        if(diskfile.isempty()) {                
            diskfile = sysinfoname;             
            sysinfoname = COMMENT_FILENAME;     
        }
        if (names.contains(sysinfoname)) {
            Out->msg(WARN, "<6748>Entry \"%s\" for comment file \"%s\" already exists, this entry ignored.", *sysinfoname, *diskfile);
        } else {
            names.push_back(sysinfoname);
            
            const bool isndmp(flags.streamformat_in!=utar_flags_enums::streamformat_none);
            if (!do_diskfile(sysinfoname, diskfile, isndmp?30:1 ) ) {  
                output::severitycode sev = isndmp?output::SEV_ERR:output::SEV_WARN;
                Out->msg(sev, LOCTXT("Comment entry \"%s\" file \"%s\" not found."), *sysinfoname, *diskfile);
            }
        }
    }
}


void backhidden::do_sysinfo_assoc(const tassoc<ustring, fileref>& sysinfo_files_and_data)
{
    
    const undoo::vector<ustring> filenames(sysinfo_files_and_data.keys());
    const size_t filenames_count(sysinfo_files_and_data.size());

    
    for(size_t i = 0; i < filenames_count; i++) {
        const ustring one_filename(filenames[i]);
        const fileref data(sysinfo_files_and_data.lookup(one_filename));

        DB->msg(DBTXT("backhidden::do_sysinfo_assoc(): Output internal file '%s', size %s"),
            *one_filename, *data.size64().image());

        proxy->do_file(one_filename, ATTR_INTERNAL, data, use_container_also);
    }
}

void backhidden::do_target_sysinfo_assoc(const target_sysinfo_data_map& target_sysinfo_files_and_data)
{
    
    
    
    if (!target_sysinfo_files_and_data.is_empty()) {
        system_info_data_list list;
        target_sysinfo_files_and_data.get(path, list);
        for (system_info_data_list::iterator it = list.begin(); it != list.end(); it++) {
            const ustring file_name(it->first);
            const fileref file_data(it->second);
            proxy->do_file(file_name, ATTR_INTERNAL, file_data, use_container_also);
        }
    }
    
    
    if (write_target_workresults && !main->work_results.is_empty()) {
        fileref work_results_ref;
        work_results_ref.initlist(10 * 1024);
        work_results_ref.append(main->work_results.image());
        proxy->do_file(WORKRESULTS_FILENAME, ATTR_INTERNAL, work_results_ref, use_container_also);
    }
}

#define MAXFILESIZE (16*1024*1024)  


bool backhidden::do_diskfile(const ustring& name, const ustring& diskname, int waitsecs )



{
    int i;
    fileref diskfile;
    Out->msg(INFO, 3, "<7522>Copying \"%s\" to server as %s", *diskname, *name);
    for(i=0; i<30; i++) {
        diskfile.initdisk(diskname, true, true);        
        if(!diskfile.iserror() || !uapp::staging().canRun()) break;
        DB->msg(DBTXT("  Problem reading file (attempt#%d), sleeping %d sec and trying again"), i, waitsecs);
        threadbase::threadsleep(waitsecs * 1000);
    }

    if(diskfile.iserror()) {
        DB->msg(DBTXT("Could not open file '%s' (waited %d secs)"), *diskname, i);
        return false;
    }

    
    fileref diskslice;
    int sz = MAXFILESIZE;
    if(diskfile.size64() <= fileoffset(MAXFILESIZE)) sz = diskfile.size();
    diskslice = diskfile.copyslice(0, sz);
    if(sz == MAXFILESIZE)
        diskslice.append(ustring::sprintf(DBTXT("\n***** FILE TRUNCATED FROM %s TO %d BYTES *****"),
                        *diskfile.size64().image(), sz));
    proxy->do_file( name, ATTR_INTERNAL, diskslice, use_container_also );
    return true;
}













bool backhidden::do_backuptag(hiddendirwriter_sp proxy) {
    if (flags.backuptag.isempty()) return false;

    fileref tag;
    tag.initmem(flags.backuptag);

    bool toobig = tag.size64() > (4*1024);
    Out->msg(INFO, 3, "<5084>Sending %s to server (%d bytes)", BACKUPTAG_FILENAME, tag.size());

    
    for (hiddendirwriter::ServersType::iterator it = proxy->servers.begin(); it != proxy->servers.end(); it++) {
        nbackdir * oneServer = dynamic_cast<nbackdir *>(*it);
        if (oneServer != NULL) {
            if (toobig) {
                Out->msg(WARN, "<7523>Backuptag will only be usable by users with the avamar read privilege due to large size(%s)", *tag.size64().image());
                oneServer->do_file( BACKUPTAG_FILENAME, ATTR_INTERNAL, tag, use_container_also);

            } else {
               
                DIRELEMp de = new DIRELEM;
                de->zero();
                epoch_t now((epoch_t)timer::now());
                de->initialize( hashcode::zero, now, now, now, tag.size64(), ATTR_INTERNAL, BACKUPTAG_FILENAME);

                de->set_backuptag(flags.backuptag);

                fileoffset patchoffset = oneServer->add_direlem(de, true );

                workelem *w = new workelem( info, upath(BACKUPTAG_FILENAME), de, info->fstats, tag);
                cycle *subchild = new nbackdata(oneServer, w, patchoffset, false  );
                subchild->noop();
            }
        }
    }

    return true;
}





void backhidden::save_last_sysinfo(DIRELEMp last_sysinfo_de)
{
    const hfs_info_struct& hfsInfo(main->getAdeMgr()->getHfsInfo(dpn0));
    if (hfsInfo.metaStore != NULL) {  
        DB->msg("backhidden::save_last_sysinfo: No previous .system_info folders are copied (chaining disabled) when using the common catalog");
        return;
    }

    if (main->getucontainer_yucky_global().isdefined()) {
        DB->msg("backhidden::save_last_sysinfo: No previous .system_info folders are copied when writing to a ucontainer");
        return;
    }

    if (main->get_flags().max_sysinfo_chain_length == 0) {
        DB->msg("backhidden::save_last_sysinfo: --max-sysinfo-chain-length flag set to zero.  No previous .system_info folders will be saved");
        return;
    }

    
    for (hiddendirwriter::ServersType::iterator it = proxy->servers.begin(); it != proxy->servers.end(); it++) {
        nbackdir * oneServer = dynamic_cast<nbackdir *>(*it);
        if (oneServer != NULL) {
            DIRELEMp new_prev_de(new DIRELEM());
            const epoch_t now = epoch_t(timer::now());

            
            new_prev_de->initialize(hashcode::zero, now, now, now, fileoffset(0), ATTR_DIRECTORY, PREV_UNDOO_DIRECTORY_NAME);

            
            
            fileoffset offset = oneServer->add_direlem(new_prev_de, true);

            
            cycle *hd = new backhiddendir(oneServer, last_sysinfo_de, new_prev_de, offset);
            hd->noop();
        }
    }
}

void backhidden::set_target_path(const ustring &target_path)
{
    path = target_path;
    
    write_target_workresults = false;
}

backhiddendir::backhiddendir(BackCycle *parent, DIRELEMp last_sysinfo_de, DIRELEMp new_prev_de, fileoffset offset)
    : BackCycle(parent, 0, 0)
    , m_phase(phase_get_last_sysinfo)
    , m_last_sysinfo_de(new DIRELEM(*last_sysinfo_de))
    , m_new_prev_de(new_prev_de)
{

    if (main->get_flags().max_sysinfo_chain_length == 0)
    {
        Out->msg(ERR, "<12461>Don't try and create a 'prev' folder if one is not wanted.");
        assert(0);
        notifyparent();
        return;
    }

    this->cyisdirectory = true;
    this->offset = offset;
    m_prev_fr.initlist(1024);
    todoEnqueue(TODO_DIR, this);
}

void backhiddendir::init()
{
    childdone(0);
}

void backhiddendir::childdone(cycle *child)
{
    cycle *tmp;

    switch (uapp::staging().canRun() ? m_phase : phase_notify_parent) {
    case phase_get_last_sysinfo: {

        
        const location lastSysLoc(location::media::gsan, m_last_sysinfo_de->file_hash());
        tmp = new restdirlist(this, lastSysLoc, upath(), m_last_sysinfo_de->get_location(), m_last_sysinfo_contents);
        tmp->noop();
        m_phase = phase_get_last_prev;
        break;
    }
    case phase_get_last_prev: {
        DIRELEMp last_prev_de = 0;

        
        
        if (m_last_sysinfo_contents.remove(PREV_UNDOO_DIRECTORY_NAME, last_prev_de) ||
            m_last_sysinfo_contents.remove(ustring::sprintf("0:%s",PREV_UNDOO_DIRECTORY_NAME), last_prev_de)) {
            
            m_phase = phase_write_new_sysinfo;
            tmp = new restdata(this, last_prev_de->file_hash(), 0, true, restelem(m_prev_fr));
            tmp->noop();
            break;
        }
        else
        {
            
            m_phase = phase_write_new_prev;
            goto phase_write_new_prev;
        }
    }
    case phase_write_new_sysinfo: {
        direlemp_list_type new_sysinfo_contents;
        ustring name;
        DIRELEMp de;
        fileoffset m_size = 0;

        
        while (m_last_sysinfo_contents.pop(name, de)) new_sysinfo_contents.push_back(de);
        m_new_sysinfo_fr.initlist(1024);
        m_new_sysinfo_fr = build_diratomic(new_sysinfo_contents, m_size, false, main->getmaxdpncompchunksize(dpn0));

        
        m_phase = phase_write_new_prev;
        tmp = new nbackdata(this, new workelem(NULL, m_new_sysinfo_fr), 0, true);
        tmp->noop();

        break;
    }
    phase_write_new_prev:
    case phase_write_new_prev: {

        
        
        if (m_prev_fr.size() > 0) m_last_sysinfo_de->set_hash(child->hash);

        
        m_last_sysinfo_de->set_name(tostr(main->incflags.labelnum));
        m_last_sysinfo_de->dolayout(m_prev_fr, false, true, main->get_flags().inode, main->getmaxdpncompchunksize(dpn0));

        DIRELEM de;
        int count = 0, off = 0;
        fileoffset prevsize = 0;

        
        for (off = 0; de.populate(m_prev_fr, off); count++, prevsize += de.file_size()) {}
        assert(count >= 1);

        
        int max = main->get_flags().max_sysinfo_chain_length;
        if (max >= 0)
        {
            
            for (off = 0; count > max; de.populate(m_prev_fr, off), count--, prevsize -= de.file_size()) {}
            
            if (off > 0) m_prev_fr.initslice(m_prev_fr, off, m_prev_fr.size()-off);
        }

        
        m_new_prev_de->set_file_size(prevsize);

        m_phase = phase_notify_parent;

        
        
        
        tmp = new nbackdata(this, new workelem(NULL, m_prev_fr), 0, true);
        tmp->noop();

        break;
    }
    case phase_notify_parent:
        
        
        
        notifyparent();
        break;
    default:
        Out->msg(ERR, "<12462>Unexpected phase number %d in backhidden", m_phase);
        break;
    }
}









#if !defined(BACKEMCTARDIR6_H_INCLUDED)
#define BACKEMCTARDIR6_H_INCLUDED












#include "backndmptardir_base.h"


typedef DEFINE_STL_MAP_TYPE(csustring, DIRELEMp) csname_to_direlemp_t;       

class backemctardir6 : public backndmptardir_base
{

public:
  SAFEALLOC(backemctardir6);

  
  
  
  
  backemctardir6(BackCycle* parent_,
                 workelem *info_,
                 parsestream_base *parser,
                 int traverse_depth,
                 inode_table &inodetab_,
                 int mount_point_numelems = -1,
                 ndmp_history *hist = 0,
                 MetadataIntf_sp parent_metadataIntfp_ = MetadataIntf_sp());

  virtual ~backemctardir6();

  virtual void init();
  virtual void response(message& outargs);  
  virtual void childdone(cycle *child);

  
  
  
  class prevlist_iterator : public composite_to_direlemp_table::iterator {
  public:
      prevlist_iterator() : cy(NULL) {}
      virtual ~prevlist_iterator() {}

      
      void init_cycle_pointer(backemctardir6 *cy_) { cy = cy_; }

      
      virtual void callback(const composite_key& pkey, const DIRELEMp& prevDE)
      {
          
          
          cy->process_prevlist_item(pkey, prevDE);
      }

  private:
      backemctardir6 *cy;
  };

  
  
  void process_prevlist_item(const composite_key& pkey, const DIRELEMp& prevDE);

protected:

  
  void insert_hardlink_tag(const ubigint64 inode,    
                           const ubigint64 hl_begin, 
                           const bigint64 hl_size);  

  
  backemctardir6 *parent_backemctardir6p;

  
  
  
  
  
  
  
  
  
  
  class offset2lists_entry {
  public:
      offset2lists_entry(const inode_table::child_dir_list* childlist_ = 0,
                         const inode_table::synth_list_cur* cur_synthlist_ = 0,
                         const inode_table::synth_list_prev* prev_synthlist_ = 0 ) :
                         childlist(childlist_),
                         cur_synthlist(cur_synthlist_),
                         prev_synthlist(prev_synthlist_)
                         {}

      void operator=(const offset2lists_entry &other) {
          childlist = other.childlist;
          cur_synthlist = other.cur_synthlist;
          prev_synthlist = other.prev_synthlist;
      }

      
      
      inode_table::child_dir_list childlist;

      
      
      inode_table::synth_list_cur cur_synthlist;

      
      
      inode_table::synth_list_prev prev_synthlist;

      SAFEALLOC(offset2lists_entry);
  };

  
  
  
  
  
  
  typedef DEFINE_STL_MAP_TYPE( fileoffset, offset2lists_entry ) offset2lists_type;
  typedef offset2lists_type::iterator offset2lists_iterator;

  
  offset2lists_type offset2lists;

  
  
  offset2lists_iterator my_offset2lists_entry;

  
  
  
  inode_table::child_dir_list* my_childlistp;
  inode_table::synth_list_cur* my_cur_synthlistp;
  inode_table::synth_list_prev* my_prev_synthlistp;

  
  
  
  fileoffset beginning_dir_offset;

  
  
  
  
  
  unsigned int cur_synthlist_tag_index;

  
  
  
  
  
  
  
  
  
  
  
  typedef DEFINE_STL_MAP_TYPE( ubigint64, tchecksum::tchecksumval ) offset2checksum_type;
  typedef offset2checksum_type::iterator offset2checksum_iterator;

  
  offset2checksum_type offset2checksum;

  bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata);
  void process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata);

  
  
  
  void fix_hardlink_extra_info(DIRELEMp &de);

  ubigint64 parentinode;

  
  
  void request_prevlist();

  ndmp_history *histsrv;  

  int nhistchildren;

  
  
  
  
  
  
  
  typedef scalar<unsigned int> uintobj;
  static tassoc<uintobj, ustring> needhardlinkvalues; 

  
  bool find_hardlinkpath(const ubigint64 inode, const ustring linktext, 
                         const upath &volpath,
                         hfs_info_struct &hfsinfo,
                         const csname_to_direlemp_t &topleveldirelems,
                         DIRELEM &de,
                         ubigint64 &parent_inode) const;

  
  void fix_inodetab_entries();

  undoo::vector<ustring> hardlinknames;          
  histmap historytable;                          
  hlhistmap hlhistorytable;                      
  tassoc<csustring, ustring> name2link;          

  prevlist_iterator prevlist_iter;
  typedef std::multimap<int, DIRELEMp> dropped_multimap;
  typedef std::pair<dropped_multimap::iterator, dropped_multimap::iterator> dropped_multimap_rng;
  dropped_multimap dropped;
  bool merge_success;

  
  
  bigint64 fake_offset;
  bigint64 undefined_offset;

  
  bool merge_lists();

  
  
  
  
  
  void update_current_direlem(DIRELEMp curDE,       
                              const uint32_t inode, 
                              const ustring link);  

  
  
  
  

  
  void request_history();       

  
  
  void copy_inodes_from_history();  

  
  
  
  
  
  
  void update_direlem_unix_special(DIRELEMp de, bigint64 devno_, bigint64 rdev_, bigint64 inode_, bigint64 links_);

  void finish_top_level_directory(cycle *child);
  void commit_directory_metadata();

private:
  
  backemctardir6();
};

#endif
















#include "common.h"
#include "debug.h"
#include "backdumpdir.h"

#include "fileref.h"
#include "workelem.h"
#include "output.h"
#include "nbackdata.h"
#include "connerror.h"  

#include <algorithm>

#define bdmsg1        ((xflag[2]&2048)!=0)
#define bdmsg2        ((xflag[2]&4096)!=0)
#define dowfs         ((xflag[15]&2)==0)   

#define breadth_first ((xflag[10]&2048)!=0)


backdumpdir::backdumpdir(BackCycle *parent, context *main, workelem *info_, dumpDIRELEM* direlemp_,
                         direlem_assoc_type& inodeinfo_, int traverse_depth_
) :
    BackCycle(parent, info_),
    direlemp(direlemp_),
    inodeinfo(inodeinfo_),
    traverse_depth(traverse_depth_)
{
    if(bdmsg1)DB->msg("backdumpdir::backdumpdir (parent:%p) (this:%p)", parent, this);
    assert(direlemp != NULL);
    if(!info)
       DB->bt_error(DBTXT("backdumpdir::backdumpdir ---------------------> INFO is NULL <------------------------"));
    for (int i=0; i<traverse_depth; i++) spaces += "   ";
    if (bdmsg2) DB->msg(DBTXT("%sbackdumpdir::backdumpdir initializer traverse_depth:%d name:%s"), *spaces, traverse_depth, *direlemp->fullpath());



    
    
    
    
    if (breadth_first)
        todoEnqueue(TODO_DIR, this);
    else
        todoEnqueueInsert(TODO_DIR, this, -traverse_depth);

    
}

static bool namecmp(const ustring& lhs, const ustring& rhs) {

#if SYSTEM_UNIX
    return strcmp(*lhs, *rhs) < 0;
#else
    return strcasecmp(*lhs, *rhs) < 0;
#endif
}

void backdumpdir::init()
{
    if (direlemp == NULL) {
      Out->msg(ERR, "<5761>null direlemp in backdumpdir is bad???");
      return;
    }


    main->set_cur_filename(info->path, true);

    if(bdmsg2) DB->msg( "%sbackdumpdir::init %p info->path:%s name:%s", *spaces, this, *info->path.image(), *direlemp->name() );
    Out->msg(VERBOSE, 4, "%s", *(info->path.image() / DIRSEPSTR));

    cyisdirectory = true;
    bool parent_is_internal(direlemp->is_internal());

    
    undoo::vector<ustring> names;
    direlemp->keys(names);
    
    
    std::sort(names.begin(), names.end(), namecmp);
    for(unsigned int i=0; i<names.size(); i++) {
        const ustring elemname(names[i]);
        int inum(direlemp->lookup(elemname));

        if (inum <= 0 || elemname.is_dot_or_dot_dot()) continue;

        dumpDIRELEM *elemp = inodeinfo.lookup(inum).getdd();
        if (elemp == NULL) {
          if (bdmsg1)DB->msg("%sbackdumpdir::init %10d  NULL   %s", *spaces, inum, *elemname);
          continue;
        }
        if((elemname.bytelength()>18)  
           && (elemname.contains("_ntstreams_",elemname.bytelength()-18)>=0)
        ) {
            if(bdmsg2)DB->msg(DBTXT("backdumpdir::init d_namlen:%d name:%s setting internal"), elemname.bytelength(), *elemname);
            elemp->set_internal(true);
        }

        
        
        

        const ustring fullname = elemp->fullpath();  

        if(bdmsg1) DB->msg( "%sbackdumpdir::init %10d         %s     fullname:%s name:%s", *spaces, inum, *elemname, *fullname, *elemp->name() );

        elemp->set_name(elemname);
        if(parent_is_internal)elemp->set_internal(true);

        if(!uapp::staging().canRun()) throw EXC_CANCEL;

  
         de_listing.push_back(elemp);
         if(bdmsg2)DB->msg(DBTXT("%sbackdumpdir::init adding inode:%d to list %p"), *spaces, inum, elemp);



        
        







        if( elemp->is_directory()
            && (!flags.makeview || elemp->num_elems()>0) 
        ) {
            workelem *w = new workelem(info, (upath)fullname, elemp);
            cycle *child;

            if(bdmsg1)DB->msg(DBTXT("%sbackdumpdir::init calling backdumpdir %s"), *spaces, *elemp->fullpath());
            child = new backdumpdir(this, main,                
                                    w,                   
                                    elemp,               
                                    inodeinfo,

                                    traverse_depth + 1); 
            nforked++;
        } else {  
            

            if (elemp->was_visited()) DB->msg(DBTXT("strange direlem visited 2 times %d"), elemp->inode_number());
            elemp->set_visited(true);
            cyincluded++;  
            if (!elemp->was_found_in_stream()) {
              main->byteprogress(context::backupstats, stats::filecache, elemp->file_size().dvalue(), info->fstats);
              main->addfilecount(context::backupstats, 1); 
            }
        }
    }
    if(bdmsg1)DB->msg("%sbackdumpdir::init de_listing.numelems():%"Z"d", *spaces, de_listing.size());
    childdone(NULL);  
}

void backdumpdir::response(message& outargs ) {
    DB->msg( "%sbackdumpdir::response", *spaces );
    assert(false);
}

void backdumpdir::childdone(cycle *child) {
    if( bdmsg1 ) DB->msg( "%sbackdumpdir::childdone %s ncollected=%d nforked=%d collectdone=%d", *spaces, *direlemp->fullpath(), ncollected, nforked, collectdone );
    if(! collectdone) {
        if(child == NULL) {  
            if( bdmsg1 ) DB->msg( DBTXT("%sbackdumpdir::childdone child NULL"), *spaces);
            forksdone = true;
        } else {
            if( bdmsg1 ) DB->msg( DBTXT("%sbackdumpdir::childdone child non-null, child size:%s (included:%d)"), *spaces, *child->size.image(), child->cyincluded);
















            ncollected++;


            direlemp->set_visited(true);
            
        }

        if(forksdone && nforked == ncollected) {
            collectdone = true;
            if( bdmsg1 ) DB->msg( "%sbackdumpdir::childdone %s collectdone:%d size:%"Z"d", *spaces, *direlemp->fullpath(), collectdone, de_listing.size());

            fileoffset dirsize;  
            fileref listing1 = build_dirblock(dirsize);
            direlemp->set_file_size(dirsize);
            BackCycle::size = dirsize;      
            workelem *w = new workelem( NULL, listing1 );
            datachild   = new nbackdata(this, w, fileoffset(0), true  );
                                                
        }
    } else {
        if(bdmsg1) DB->msg( DBTXT("%sbackdumpdir::childdone calling notifyparent this=%p"), *spaces, this );
        assert(direlemp);


        DB->msg(DBTXT("%sbackdumpdir::childdone patching %s, hash:%s cyincluded:%d"),
                *spaces, *direlemp->name(), *child->hash.partialimage(), cyincluded);

        direlemp->set_hash(child->hash);


        
        
        
        
        if (child->hash==hashcode::zero || (cyincluded==0 && flags.makeview))
          direlemp->set_internal(true);
        notifyparent();
    }
}

fileref backdumpdir::build_dirblock(fileoffset& totalsize) {
    fileref listing2;
    listing2.initlist(int(de_listing.size() * DIRELEM_DOLAYOUT_AVERAGE_SIZE));

    for (unsigned int i=0; i<de_listing.size(); i++) {
       main->layout_direlem(*de_listing[i], listing2, false, main->isnewdir(), flags.inode);
       totalsize += de_listing[i]->file_size();  
    }
    return listing2;
}

void backdumpdir::notifyparent() {
    if(bdmsg1) DB->msg("%sbackdumpdir::notifyparent %p %s   (parent:%p)",
                       *spaces, this, *info->path.image(), parent);
    if (cyincluded > 0) parent->cyincluded++; 
    
    BackCycle::notifyparent();
    
}

backdumpdir::~backdumpdir() {
    if(bdmsg1) DB->msg(DBTXT("%sbackdumpdir::~backdumpdir (parent:%p) (this:%p) ""%s"" skip:%d dot:%d name:%s"),
                       *spaces, parent, this, *info->path.image(), info->direlemp->should_skip_this_file(), info->direlemp->is_dot_or_dot_dot(), *info->direlemp->name() );
    
    if(! info->isapi)
        delete info;
}
#if !defined(WORKELEM_H_INCLUDED)
#define WORKELEM_H_INCLUDED















#include "component.h"
#include "fileref.h"
#include "direlem.h"  
#include "msg.h"
#include "filestats.h"
#include "hashcode.h"
#include "upath.h"
#include "waitqueue.h"
#include "./ade/interfaceade_flags.h"



#include "refcounter.h"
#include "streambuffer.h"
#include "streamtransform.h"
#include "ucontainer_base.h"


class prefetchbuf : public component {
public:
    fileref buf;
};



class workelem : public component {
public:
    workelem(const workelem &srcelem); 

    
    workelem(const workelem *parentelem, const upath& path, DIRELEMp direlem, const filestatsref& fstats);

    
    workelem(const workelem* parentelem, const upath& path, DIRELEMp direlem);

    
    workelem(const workelem *parentelem,
             const upath& path, DIRELEMp direlem,
             const filestatsref& fstats, const fileref& data);

    
    
    workelem(const workelem *parentelem, const fileref& data);

    
    workelem(const workelem *parentelem, const upath& path);
    workelem(const workelem *parentelem, const DIRELEMp direlemp);
	
	workelem(bool rechunk_, DIRELEMp direlem_, ucontainer::basep ucontainer_);

    ~workelem();

    upath path;                 
    DIRELEMp direlemp;          
    filestatsref fstats;        
    fileref data;               
    fileoffset streamslice;     
    fileoffset size;            
    fileoffset changeblockoff;  
    waitqueue *prefetchqueue;   
    hashcode resulthash;        
    dpns dpninx;                
    bool usechunkcache:1;       
    bool isapi:1;               
    bool isdir:1;               
    bool hold_data:1;           
    bool changeblock:1;         

    bool cb_append:1;           
                                
                                
    bool setParentHash:1;       
    bool ignoreStats:1;         
    bool domorph:1;             

    bool use_container:1;       
	bool rechunk:1;
    ucontainer::basep container; 

    pStreamtransform st;        
    pStreambuffer sb;
    DEFINE_STL_MAP_TYPE(location::tcontainerid, fileoffset) running_coverage_size; 

    SAFEPOOLALLOC(workelem);

private:
    void set_defaults();
};

#endif


















#include <algorithm>

#include "common.h"
#include "debug.h"
#include "utar_commands.h"
#include "output.h"
#include "nbackmain.h"
#include "list_archive.h"
#include "runstage.h"
#include "filename_cache.h"
#include "hash_cache.h"
#include "mctypes.h"
#include "backstate.h"
#include "dpnobject.h"
#include "uwrapper.h"
#include "compelem.h"
#include "timer.h"
#include "smartbrowse.h"
#include "fsmount/dpnobj_defines.h"
#include "alocale.h"
#include "encodings.h"
#include "cdsf_container.h"
#include "filerefx.h"
#include "ddr_interface.h"
#include "ddrfiles_xml.h" 
#include "location.h"
#include "runstage.h"
#include "swap.h"
#include "dumpstreamutils.h" 
#include "filenames.h"

#include "dump_layout.h"
#include "dumpstreamutils.h"
#include "BackupRootInfo.h"

#include "ndmp_volume_entification.h"

#include "MetadataStore.h"




#include "ade_restore.h"
#include "context.h"
#include "direlem_iter.h"
#include "shared_ptr.h"
#include "hashcode.h"
#include <stdexcept>
#if ((SYSTEM_UNIX_SOLARIS) && (SYSTEM_VERSION<=59)) || SYSTEM_UNIX_SCO || SYSTEM_UNIX_UNIXWARE
    #include <climits>
    #define MAX_BACKUPS INT_MAX
#else
    #include <limits>
    
    #define MAX_BACKUPS (std::numeric_limits<int>::max)()
#endif

#define dmsg                 ((xflag[11]&1)!=0)
#define trynewparsing        ((xflag[22]&256)==0)
#define do_browse_override   ((xflag[27]&32)==0)
#define skip_system_info     ((xflag[27]&32768)!= 0)
#define skip_listing_hack    ((xflag[29]&512)!=0)
#define verify_gsan_filesize ((xflag[21]&16384)!=0)
#define cdsf_msg             ((xflag[2]&1)!=0) 

using undoo::shared_ptr;
using undoo::make_shared;
using briutils::get_toplevel_de;
typedef context::prep_for_sysinfo prep_for_sysinfo;






class list_archive::outputsink {
public:
    SAFEPOOLALLOC(outputsink);
    virtual ~outputsink() {}

    
    
    
    
    
    
    
    
    virtual bool process(const DIRELEM::iterator& de_iter);

    
    
    
    
    virtual void add_to_listing(const DIRELEM::iterator& de_iter) {}

    
    
    
    
    
    virtual void done() {}

    
    
    virtual shared_ptr<outputsink> subdir() const = 0;

    
    bool traverse() const { return traverse_cur; }

    
    void set_single_file() { single_file = true; }

    
    bool listing_limit_exceeded() const { return uc.flags.maxentries > 0 && uc.curentries > uc.flags.maxentries; }

protected:
    utar_commands& uc;
    upath curde_fullpath; 
                          
    bool exclude_cur; 
    bool traverse_cur; 
                       
    bool single_file; 

    outputsink(utar_commands& uc, const upath& list_path, bool in_excluded_dir = false);
    bool skip_internal(const DIRELEM& de) const;
    bool is_traversable(const DIRELEM& de) const;
    void set_curde_fullpath(DIRELEM& de);
private:
    bool should_exclude(const upath& fullpath) const;

    
    
    upath full_dir_path;

    
    
    bool in_excluded_dir;
};



class list_archive::xmloutputsink : public list_archive::outputsink {
public:
    
    xmloutputsink(utar_commands& uc, const BackupRootInfo& backupInfo, const upath& list_path);
    
    xmloutputsink(const xmloutputsink& other);
    
    void add_to_listing(const DIRELEM::iterator& de_iter);
    void done();
    shared_ptr<outputsink> subdir() const;
private:
    xml_messagep mess;
};


class list_archive::stdoutputsink : public list_archive::outputsink {
public:
    
    stdoutputsink(utar_commands& uc, const upath& list_path) : outputsink(uc, list_path), top_level_listing(true) {}
    
    stdoutputsink(const stdoutputsink& other);
    ~stdoutputsink();
    
    void add_to_listing(const DIRELEM::iterator& de_iter);
    shared_ptr<outputsink> subdir() const;
    void done() { assert(top_level_listing); }
private:
    bool top_level_listing; 
                            
                            
                            
};






class list_archive::cacherebuildsink : public list_archive::outputsink {
public:
    
    cacherebuildsink(utar_commands& uc, const upath& list_path) : outputsink(uc, list_path) {}
    
    cacherebuildsink(const cacherebuildsink& other);

    void operator()(const hashcode& hash) const; 

    
    bool process(const DIRELEM::iterator& de_iter); 
    shared_ptr<outputsink> subdir() const;
};

list_archive::outputsink::outputsink(utar_commands& uc, const upath& list_path, const bool in_excluded_dir)
    : uc(uc),
      exclude_cur(in_excluded_dir),
      traverse_cur(false),
      single_file(false),
      full_dir_path(list_path),
      in_excluded_dir(in_excluded_dir)
{}

bool list_archive::outputsink::skip_internal(const DIRELEM& de) const {
    return !uc.flags.internal && de.is_internal();
}

bool list_archive::outputsink::should_exclude(const upath& fullpath) const {
    if(in_excluded_dir || uc.hfs_info.main->state->excludes.match(fullpath))
        return !uc.hfs_info.main->state->includes.match(fullpath);
    return false;
}

bool list_archive::outputsink::is_traversable(const DIRELEM& de) const {
    return de.is_directory() && !de.is_symlink() && !uc.flags.no_recursion;
}

void list_archive::outputsink::set_curde_fullpath(DIRELEM& de) {
    
    if(single_file) {
        assert(!de.is_directory());
        curde_fullpath = full_dir_path;
        de.set_fullpath(curde_fullpath);
        return;
    }
    
    
    upath new_fullpath(full_dir_path);
    ustring ndmpvolname;
    if(dirrec_pack::ndmp_volume(&de).get(ndmpvolname)) {
        
        
        de.set_name(ndmpvolname);
        new_fullpath = new_fullpath / upath(ndmpvolname);
    } else if (uc.flags.pluginid.kind() == pidtype::backupboost) {
        
        
        ustring unentified_name(ndmp_unentify_volume(de.name()));
        de.set_name(unentified_name);
        new_fullpath = new_fullpath / upath(unentified_name);
    } else {
        new_fullpath.push_back(de.name(),
                               de.is_unc_root() ? upath::elem_unc_server :
                                                  (new_fullpath.numelems() == 1 && new_fullpath.get_start(upath::elem_unc_server) == 0) ?
                                                  upath::elem_unc_share :
                                                  upath::elem_entry);
    }
    new_fullpath.set_end_dirsep(de.is_directory()); 
    curde_fullpath = new_fullpath;
    de.set_fullpath(new_fullpath);
}

bool list_archive::outputsink::process(const DIRELEM::iterator& de_iter) {
    if(listing_limit_exceeded()) {
        traverse_cur = false;
        return true;
    }
    DIRELEM& de(*de_iter);
    if(skip_internal(de)) {
        exclude_cur = true;
        traverse_cur = false;
        return true;
    }
    set_curde_fullpath(de);
    traverse_cur = is_traversable(de);
    if((exclude_cur = should_exclude(curde_fullpath))) {
        if(!(traverse_cur = traverse_cur && !uc.hfs_info.main->state->includes.isempty()))
            return true; 
    }else {
        ++uc.curentries;
        if(listing_limit_exceeded()) {
            traverse_cur = false;
            return true; 
        }
    }
    add_to_listing(de_iter);
    const fileoffset filesize(de.file_size());
    const hashcode filehash(de.file_hash());
    const bool isdir(de.is_directory());
    if(!isdir)
        uc.totalsize += filesize;
    const bool verifysize(verify_gsan_filesize           &&
                          !isdir                         &&
                          de.get_location().isFromGsan() &&
                          filesize > 0                   &&
                          filehash != hashcode::empty);
    if(!verifysize)
        return true;
    fileref data;
    chunktype ckind;
    ustring errdesc;
    if(!utar_commands::gethashdata(data, filehash, ckind, uc.hfs_info, errdesc)) {
        Out->msg(ERR, "<11118>INTERNAL SIZE ERROR: Cannot get roothash for file \"%s\" err=%s", *curde_fullpath.image(), *errdesc);
        return true;
    }
    if(ckind.is_anycomposit()) {
        int off = 0;
        compelem elem(ckind);
        fileoffset compsize(0);
        while(off < data.size()) {
            elem.init(data, off);                
            assert(elem.getendoff() > compsize); 
            compsize = elem.getendoff();
        }
        DB->msg("Comparing composite %s < %s for \"%s\"", *compsize.image(), *filesize.image(), *curde_fullpath.image());
        if(compsize < filesize)
            Out->msg(ERR, "<11114>INTERNAL SIZE ERROR: \"%s\": Server composite size %s < %s bytes",
                     *curde_fullpath.image(), *compsize.image(), *filesize.image());
    }else if(ckind.is_atomic()) {
         DB->msg("Comparing atomic %s < %s for \"%s\"", *data.size64().image(), *filesize.image(), *curde_fullpath.image());
         if(data.size64() < filesize)
             Out->msg(ERR, "<11115>INTERNAL SIZE ERROR: \"%s\": Server atomic size %s < %s bytes",
                      *curde_fullpath.image(), *data.size64().image(), *filesize.image());
    }else if(ckind.is_extatomic()) {
         if(!data.uncompress(uc.hfs_info.main->get_enckey()))
             assert(!"data.uncompress failed");
         DB->msg("Comparing extatomic %s < %s for \"%s\"", *data.size64().image(), *filesize.image(), *curde_fullpath.image());
         if(data.size64() < filesize)
             Out->msg(ERR, "<11116>INTERNAL SIZE ERROR: \"%s\": Server extatomic size %s < %s bytes",
                      *curde_fullpath.image(), *data.size64().image(), *filesize.image());
    }else
        Out->msg(ERR, "<11117>INTERNAL SIZE ERROR: Unexpected chunk kind=%s for \"%s\"", *ckind.image(), *curde_fullpath.image());
    return true;

}

list_archive::stdoutputsink::stdoutputsink(const list_archive::stdoutputsink& other)
    : outputsink(other.uc, other.curde_fullpath, other.exclude_cur), top_level_listing(false)
{}

list_archive::stdoutputsink::~stdoutputsink() {
    if(!top_level_listing && uc.flags.search_format)
        Out->msg(STD, "record:EOD\n\n");
}

void list_archive::stdoutputsink::add_to_listing(const DIRELEM::iterator& de_iter) {
    if(exclude_cur || listing_limit_exceeded())
        return;
    if(uc.flags.format=="view") {
        if(!de_iter->is_directory())
            Out->msg(STD, "<file acnt=\"%s\" labelnum=\"%d\" fullname=\"%s\" />", *uc.flags.path, uc.flags.labelnum, *curde_fullpath.image());
    }else {
        ustring record = de_iter->print(curde_fullpath, uc.flags.verbose != 0, uc.uids, uc.gids, uc.flags.web_format,
                                        (xflag[19]&2)>0 || uc.flags.inode, de_iter.get_listing_size()); 
        if(uc.flags.web_format && uc.flags.maxentries > 0 && uc.curentries == uc.flags.maxentries) {
           
           
           
           record = record.replace("protection:","truncated:true\nprotection:");
        }
        Out->msg(STD, "%s", record.tostr());
    }
}

shared_ptr<list_archive::outputsink> list_archive::stdoutputsink::subdir() const {
    assert(traverse_cur);
    return make_shared<stdoutputsink>(*this);
}

list_archive::xmloutputsink::xmloutputsink(utar_commands& uc, const BackupRootInfo& backupInfo, const upath& list_path)
    : outputsink(uc, list_path), mess(new xml_message("browse"))
{
    mess->enter("path", list_path.image());
    
    if(!uc.flags.envlangoverride.isempty()) 
        mess->enter(ENV_LOCALE_CS, encodings::env_locale_cs());
    else {
        const prep_for_sysinfo context_is_prepped(*uc.hfs_info.main);
        fileref floc;
        if(uc.get_file(backupInfo, floc, upath(ustring::sprintf("%s%s%s", UNDOO_DIRECTORY_NAME, DIRSEPSTR, LOCALE_FILENAME)))) {
            const ustring lang(alocale(floc).get_locale_cs());
            if(!lang.isempty())
                mess->enter(ENV_LOCALE_CS, lang);
        }
    }
}

list_archive::xmloutputsink::xmloutputsink(const list_archive::xmloutputsink& other)
    : outputsink(other.uc, other.curde_fullpath, other.exclude_cur), mess(other.mess->children.back())
{}

shared_ptr<list_archive::outputsink> list_archive::xmloutputsink::subdir() const {
    assert(traverse_cur);
    return make_shared<xmloutputsink>(*this);
}

void list_archive::xmloutputsink::add_to_listing(const DIRELEM::iterator& de_iter) {
    assert(mess.isdefined());
    if(mess.isnull() || listing_limit_exceeded())
        return;
    if(exclude_cur)
        assert(traverse_cur);
    const xml_messagep entry = de_iter->xml("", uc.flags.verbose != 0, uc.uids, uc.gids);
    if(uc.flags.maxentries && uc.curentries == uc.flags.maxentries)
        entry->enter("truncated", ustring("true")); 
    mess->children.push_back(entry);
}

namespace {
    
    
    
    
    void prepend_path_to_listing(xml_messagep listing) {
        if(skip_listing_hack) {
            DB->msg("prepend_path_to_listing skipping due to xflag");
            return;
        }
        if(listing.isnull() || !listing->valid()) { 
            Out->msg(ERR, "Failed to parse xml browse response");
            return;
        }
        ustring pathval;
        const ustring command(listing->getcommand());
        if(command == "browse_contents" || command == "browse") {
            DB->msg("prepend_path_to_listing no redirect view, performing correction");
            pathval = listing->getstring("path");
        }else if(command == "dir" || command == "file") {
            pathval = listing->getstring("name");
        }else
            return; 
        for(xml_messagev::iterator i = listing->children.begin(); i != listing->children.end(); ++i) {
            if(i->isnull())
                continue;
            if((*i)->getcommand() == "file" || (*i)->getcommand() == "dir") {
                const ustring name((*i)->getstring("name"));
                if(!pathval.isempty() && name.substr(0, pathval.bytelength()) != pathval)
                    (*i)->enter("name", upath(pathval / (*i)->getstring("name")).image());
                prepend_path_to_listing(*i);
            }
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    void replace_negative_pidnum_in_browse_response(const int flagspidnum, ustring& listing)
    {
        if(flagspidnum > 0) {
            const ustring attrname("pidnum");
            xml_messagep tmpmessp(new xml_message(listing, true));
            if(tmpmessp->defined(attrname) && tmpmessp->getint(attrname) == -1) {
                tmpmessp->enter(attrname, flagspidnum);

                listing = tmpmessp->simage();
            }
        }
    }
}

void list_archive::xmloutputsink::done() {
    if(uc.flags.dataview == client_config_flags::view_redirect && !skip_listing_hack) {
        if(single_file) {
            
            assert(mess->children.size() == 1);
            if(!mess->children[0].isnull()) {
                const ustring pname(mess->getstring("path")), kname(mess->children[0]->getstring("name"));
                const int knamelen(kname.bytelength());
                if(pname.substr(pname.bytelength() - knamelen, knamelen) != kname) {
                    Out->msg(WARN, "Filename mismatch while performing listing for requested path");
                }else
                    mess->children[0]->enter("name", mess->getstring("path"));
            }else
                Out->msg(ERR, "Error generating XML listing for requested path");
        }else
            prepend_path_to_listing(mess);
    }
    if(!uc.requestp.isnull() && !uc.responseq.isnull()) {
        
        uc.requestp->set_res_list_snapup_contents(mess->children);
        const ctl_queue::rettype success(uc.responseq->enqueue(uc.requestp));
        if(success != ctl_queue::enqueued_ret)
            DB->msg("xmloutputsink::done unable to queue list %s", *ctl_queue::rettype_image(success));
    }else
        Out->msg(STD, "%s", mess->simage().tostr());
}

list_archive::cacherebuildsink::cacherebuildsink(const cacherebuildsink& other)
    : outputsink(other.uc, other.curde_fullpath, other.exclude_cur)
{}

undoo::shared_ptr<list_archive::outputsink> list_archive::cacherebuildsink::subdir() const {
    assert(traverse_cur);
    return make_shared<cacherebuildsink>(*this);
}

void list_archive::cacherebuildsink::operator()(const hashcode& hash) const {
    if(uc.hfs_info.main->get_flags().rebuildcache && uc.hfs_info.main->state->hashes)
        uc.hfs_info.main->state->hashes->enter(hash, cache::SINGLE_STREAM);
}

bool list_archive::cacherebuildsink::process(const DIRELEM::iterator& de_iter) {
    DIRELEM& de(*de_iter);
    if((exclude_cur = skip_internal(de))) {
        traverse_cur = false;
        return true;
    }
    traverse_cur = is_traversable(de);
    set_curde_fullpath(de);
    if(!uc.hfs_info.main->state->fcache || !de.has_accurate_metadata())
        return true;
    if(de.get_location().isFromGsan()) {
        
        
        
        uc.hfs_info.main->state->fcache->put_file_info(curde_fullpath,
                                                       de.mtime(),
                                                       static_cast<int>(de.file_size().value()),
                                                       de.attr(),
                                                       de.get_kind(),
                                                       de.filecache_extflags(),
                                                       cache::SINGLE_STREAM,
                                                       de.file_hash(),
                                                       de.is_atomic(),
                                                       uc.hfs_info.main->acl_access_time(de));
    }else {
        const DIRELEMp dep(new DIRELEM(de));
        const bool isdir(de.is_directory());
        
        uc.hfs_info.main->state->fcache->put_file_info(curde_fullpath,
                                                       static_cast<int>(de.file_size().value()),
                                                       dep,
                                                       de.is_atomic(),
                                                       uc.hfs_info.main->acl_access_time(de),
                                                       isdir ? DIRELEM::extflag_begindir : DIRELEM::extflag_nul,
                                                       cache::SINGLE_STREAM);

        if(isdir) {
            
            uc.hfs_info.main->state->fcache->put_file_info(curde_fullpath,
                                                           static_cast<int>(de.file_size().value()),
                                                           dep,
                                                           de.is_atomic(),
                                                           uc.hfs_info.main->acl_access_time(de),
                                                           DIRELEM::extflag_enddir,
                                                           cache::SINGLE_STREAM);
        }
    }
    return true;
}

list_archive::list_archive(utar_commands& uc_) : uc(uc_) {
    delta_error_count = 0;
    m_container = NULL;
}

exitcodes_t list_archive::do_list_archive() {
    if(uc.flags.format=="xml")
        uc.outputxml = true;

    
    backstate state(uc.flags.args, false, uc.flags.parallel_type);
    if(!state.is_valid()) {
        DB->msg("list_archive::do_list_archive: No valid targets exist, exiting");
        return EXIT_TARGETLIST;
    }

    uc.hfs_info.main->state = &state;
    state.enter_exclude_include_lists(uc.flags, true);

    BackupRootInfoList list;
    if(!uc.get_backuplist(list, uc.flags.incpartials, uc.flags.count)) 
        return EXIT_NO_ARCHIVES;

    if(list.empty()) { 
        if(uc.flags.label.isempty() && uc.flags.labelnum==0) 
            Out->msg(INFO, "<5200>No matching backups found.");
        else
            Out->msg(ERR, "<5184>No matching backups found.");
        return EXIT_NO_ARCHIVES;
    }

    
    if(uc.flags.labelnum > 0)
        list.sort(BackupRootInfoList::SortNewToOld);

    
    
    BackupRootInfoList filteredlist;
    
    if(!uc.filter_backuplist(list, filteredlist))
        return EXIT_NO_ARCHIVES;

    
    
    if(uc.flags.labelnum_delta != 0) {
        if(uc.flags.labelnum == uc.flags.labelnum_delta) {
            Out->msg(INFO, "<7322>Both label numbers (%d) are identical for difference listing; nothing to compare", uc.flags.labelnum);
            return EXIT_OK;
        }
        const ustring tmp("");
        if(!uc.filter_backuplist(list, tmp, tmp, uc.flags.labelnum_delta, SavesetId(uc.flags.savesetId), list))
            return EXIT_NO_ARCHIVES;
        uc.flags.dpnobj = true;
    }

    
    
	int nbackups(((uc.flags.restore_after.isempty() || uc.flags.restore_before.isempty()) && (0==uc.flags.restore_within_days) && uc.flags.count < 1) ? 1 : uc.flags.count);
    if(nbackups < 1) 
        nbackups = MAX_BACKUPS;
    const bool pick_oldest(!(uc.flags.restore_after.isempty()&&(0==uc.flags.restore_within_days)));
    return pick_oldest? list_within_backups(filteredlist.rbegin(), filteredlist.rend(), nbackups) :
                        list_within_backups(filteredlist.begin(), filteredlist.end(), nbackups);
}



bool list_archive::load_ddrfiles_from_ddr(const BackupRootInfo& one_backup, ddrfiles_xmlp& ddrfiles) const {
    uc.flags.ddrenabled = true;
    ADEMgrX* const adeMgr = uc.hfs_info.main->getAdeMgr();
    if (adeMgr != NULL) {
        const exitcodes_t result = adeMgr->loginDDRWithIndex(uc.flags.path, one_backup.getDDRIndex(), true, false);
        if (result != EXIT_OK) {
            DB->msg("list_archive::load_ddrfiles_from_ddr unable to log into ddr: %d", result);
            return false;
        }
        if (adeMgr->isDDRenabled()) {
            
            
            int ddrHandle = -1;
            adeMgr->get_ddrhandle(ddrHandle);
            ddrfiles = ddr_interface::get_ddr_files(ddrHandle, adeMgr->getHfsInfo(dpn0).clientidhash.image(),
                                                    location::tbackupid(+one_backup.getBackupTime()));
            if (ddrfiles.isnull()) {
                DB->msg("list_archive::load_ddrfiles_from_ddr xmlp:%p, handle=%d", ddrfiles.getimpl(), ddrHandle);
                return false;
            }
            return true;
        } else
            DB->msg("list_archive::load_ddrfiles_from_ddr DDR disabled???");
    } else
        DB->msg("list_archive::load_ddrfiles_from_ddr NULL adeMgr");
    return false;
}

template<typename Iter>
exitcodes_t list_archive::list_within_backups(Iter cur, Iter end, int nbackups) {
    assert(nbackups > 0);
    exitcodes_t retval(EXIT_OK);
    for (int i(0); i < nbackups && cur != end; ++i, ++cur) {
        const BackupRootInfo& one_backup(*cur);
        pid = one_backup.getPluginType();
        DB->msg("list_archive::list_within_backups Plugin OS:%s Kind:%s Number:%d",
                *pidtype::image(pid.os()), *pidtype::image(pid.kind()), pid.number());
        

        
        if (!uc.outputxml)
        {
            
            
            
            if (!uc.get_infofile(one_backup))
                Out->msg(WARN, "<5190>Info not found for this backup.");
            uc.display_snapup_info(one_backup, uc.infofile, pid);
        }

        
        if (!uc.infofile.appversion.isempty())
            Out->msg(INFO, "Backup #%s created by avtar version %s", *one_backup.getSavesetId().image(), *uc.infofile.appversion);
        else
            Out->msg(INFO, "Avtar version unavailable for backup set #%s", *one_backup.getSavesetId().image());

        if (uc.flags.rebuildcache) {
            exitcodes_t result = nbackmain::cache_setup(true, uc.hfs_info.main, uc.flags, *uc.hfs_info.main->state);
            if (result != EXIT_OK)
                return result;
            assert(uc.hfs_info.main->state->hashes != NULL);
            if (one_backup.isFromGsan())
                uc.hfs_info.main->final_resulthash = one_backup.getrootrec().getRoot(); 
        }

        if (uc.flags.dpnobj)
            return do_dpnobj_listing(one_backup);

        uc.preload_ddrfiles_from_gsan(one_backup);

        
        
        
        
        shared_ptr<prep_for_sysinfo> use_to_disable_offset_calculation;
        const location dataloc(get_toplevel_de(one_backup, uc.hfs_info).get_location());
        
        
        const bool needToLogOntoDDR = one_backup.getDDRIndex() > 0;
        if (needToLogOntoDDR) { 
            fileref ddrFilesData;                               
            bool got_ddrfiles(uc.get_ddrfiles_xml(one_backup, DATADOMAINFILES_FILENAME, ddrFilesData));
            if (got_ddrfiles && !ddrFilesData.isnull() && ddrFilesData.size() > 0) {
                assert((+one_backup.getBackupTime()) == dataloc.get_backupid());
                uc.hfs_info.main->check_for_raw_format(dataloc.get_backupid(), ddrFilesData);
            } else {
                DB->msg("list_archive::list_within_backups failed to get "DATADOMAINFILES_FILENAME" from metadata server, trying DDR");
                ddrfiles_xmlp ddrfiles;
                got_ddrfiles = load_ddrfiles_from_ddr(one_backup, ddrfiles);
                if (got_ddrfiles && ddrfiles.isdefined()) {
                    assert((+one_backup.getBackupTime()) == dataloc.get_backupid());
                    uc.hfs_info.main->check_for_raw_format(dataloc.get_backupid(), *ddrfiles);
                } else { 
                    Out->msg(WARN, "Unable to calculate container offsets for backup contents");
                    DB->msg("list_archive::list_within_backups failed to retrieve "DATADOMAINFILES_FILENAME
                            " from DDR (ddrfiles:%p), disabling calculation of offsets", ddrfiles.getimpl());
                    
                    
                    
                    use_to_disable_offset_calculation = shared_ptr<prep_for_sysinfo>(new prep_for_sysinfo(*uc.hfs_info.main));
                }
            }
        }

        if (uc.flags.args.size() == 0) {
            if (!list_path_within_backup(one_backup, upath("")))
                retval = EXIT_MISC;
        } else {
            for (int i = 0; i < uc.flags.args.size(); i++) {  
                
                ustring frompath = uc.flags.args[i]; 
                if (!uc.get_frompath(frompath))
                    return EXIT_BAD_FLAGS;
                DB->msg("list_archive::list_within_backups frompath = %s", *frompath);
                if (!list_path_within_backup(one_backup, (upath) frompath))
                    retval = EXIT_MISC;
            }
        }

        if (uc.flags.rebuildcache) {
            if (uc.hfs_info.main->state->fcache)
                Out->msg(INFO, "<6205>%d entries added to file cache",
                            uc.hfs_info.main->state->fcache->get_items_entered());
            if (uc.hfs_info.main->state->hashes)
                Out->msg(INFO, "<6206>%d entries added to ispresent cache",
                            uc.hfs_info.main->state->hashes->get_items_entered());
            nbackmain::cache_write(uc.hfs_info.main, uc.flags, *uc.hfs_info.main->state, one_backup.getBackupTime(), one_backup.getDDRIndex());
        }
    }
    return retval;
}




bool list_archive::checkBrowseOverrideForPath(const BackupRootInfo& backupInfo, const upath& frompath, ustring& listing) const {
    fileref browse_override;
    if(do_browse_override && uc.get_view_override(uc.flags.dataview, backupInfo, browse_override)) {
        Out->msg(INFO, "<12604>Displaying alternate view");
        nsViews::view v(browse_override);
        bool res = v.ls_path(frompath, listing, !uc.flags.no_recursion);
        if(res) {
            
            if(uc.flags.dataview == client_config_flags::view_redirect && v.getVersion() == 0) {
                
                DB->msg("list_archive::checkBrowseOverrideForPath view version: %d", v.getVersion());
                xml_messagep tmpmessp = new xml_message(listing, true);
                prepend_path_to_listing(tmpmessp);
                listing = tmpmessp->simage();
            }

            
            
            replace_negative_pidnum_in_browse_response(uc.flags.pluginnum, listing);

            return true;
        }
        else
            DB->msg("list_archive::checkBrowseOverrideForPath could not find path (%s) in view override for backup (%s)",
                    *frompath.image(), *backupInfo.image());
    }
    return false;
}

bool list_archive::list_path_within_backup(const BackupRootInfo& backupInfo, const upath& frompath) {
    if(!uc.flags.rebuildcache) {
        ustring listing;
        if(checkBrowseOverrideForPath(backupInfo, frompath, listing)) {
            Out->msg(STD, "%s", listing.tostr());   
            return true;
        }
    }

    uc.get_ids(backupInfo);
    uc.totalsize = fileoffset(0);

    
    
    
    DIRELEM toplevel_de(get_toplevel_de(backupInfo, uc.hfs_info));
    
    upath listingpath(frompath);

    bool ret(false);
    try {
        
        
        
        if(pid.kind() == pidtype::ndmp || pid.kind() == pidtype::backupboost) {
            
            
            
            get_ndmp_startpoint_and_path(toplevel_de, listingpath);

            
            {
                
                
                
                DIRELEM inode2_de;
                if(get_inode2_de(toplevel_de, inode2_de)) {
                    
                    if(!backupInfo.isFromGsan()) {
                        Out->msg(ERR, "Listing catalog-based Netapp backups is currently not supported");
                        return false;
                    }

                    
                    
                    if(!frompath.isempty())
                        listingpath.set_begin_dirsep(); 

                    uc.set_netapp_browse(true);
                    return ls_dumpformat(backupInfo.getrootrec().getRoot(), toplevel_de.file_hash(), inode2_de, listingpath, frompath);
                }
            }
        }

        
        bool single_file(false);
        DIRELEM::iterator listingpathiter; 
        const DIRELEM::iterator end;
        if(!listingpath.isempty()) {
            upath found_fullpath; ustring errdesc;
            listingpathiter = uc.get_direlem(DIRELEM::iterator(toplevel_de, &uc.hfs_info), listingpath, found_fullpath, errdesc);
            if(listingpathiter == end) { 
                Out->msg(ERR, "<5186>\"%s\" not found in backup.", *frompath.image());
                return false;
            }
            if(listingpathiter->file_hash() == hashcode::zero &&
               listingpathiter->get_location().isFromGsan()) 
            {
                Out->msg(ERR, "<5541>Insufficient privilege to view contents");
                return true;
            }
            single_file = !listingpathiter->is_directory();
            toplevel_de = *listingpathiter;
        }

        
        
        
        
        shared_ptr<outputsink> outsink;
        shared_ptr<cacherebuildsink> rebuildsink;
        if(uc.flags.rebuildcache)
            outsink = rebuildsink = shared_ptr<cacherebuildsink>(new cacherebuildsink(uc, listingpath));
        else if(uc.outputxml)
            outsink = shared_ptr<xmloutputsink>(new xmloutputsink(uc, backupInfo, frompath));
        else
            outsink = shared_ptr<stdoutputsink>(new stdoutputsink(uc, listingpath));

        if(single_file) {  
            
            DB->msg("list_archive::list_path_within_backup is single file");
            assert(listingpathiter != end);
            outsink->set_single_file();
            ret = outsink->process(listingpathiter);
        }else {
            
            DIRELEM::iterator startpoint;
            if(uc.flags.rebuildcache) {
                assert(rebuildsink);
                startpoint = DIRELEM::iterator(toplevel_de, &uc.hfs_info, *rebuildsink);
            }else{
                DB->msg("list_archive::list_path_within_backup skip_set_location: %d", uc.flags.skip_set_location);
                startpoint = DIRELEM::iterator(toplevel_de, &uc.hfs_info, uc.flags.skip_set_location);
            }
            ret = ls_archive(startpoint, outsink);
        }

        outsink->done(); 

    }catch(std::runtime_error& e) {
        Out->msg(ERR, "Caught exception while attempting to list '%s' in backup #%s: %s",
                 frompath.image().tostr(), *backupInfo.getSavesetId().image(), e.what());
        return false;
    }

    if(uc.flags.totals) { 
        if(uc.flags.web_format)
            uwrapper::uprintf("size: %s\n", *uc.totalsize.image()); 
        else
            Out->msg(VERBOSE, "%s bytes total.", *uc.totalsize.image());
    }

    return ret;
}

bool list_archive::ls_archive(DIRELEM::iterator iter, const shared_ptr<list_archive::outputsink>& outsink) {
    if(!outsink)
        return false;
    const DIRELEM::iterator end;
    for(; iter!=end && !outsink->listing_limit_exceeded(); ++iter) {
        if(!outsink->process(iter)) {
            DB->msg("list_archive::ls_archive failed to process '%s' (fullpath='%s')",
                    iter->name().tostr(), iter->fullpath().image().tostr());
            return false;
        }
        if(outsink->listing_limit_exceeded())
            return true; 
        if(outsink->traverse() && !ls_archive(DIRELEM::iterator(*iter, iter), outsink->subdir()))
            return false;
    }
    return true;
}

void list_archive::get_ndmp_startpoint_and_path(DIRELEM& startpoint, upath& listpath) {

    if(((pid.kind() != pidtype::ndmp) ||
       ((pid.os() != pidtype::os_netapp) && (pid.os() != pidtype::os_celerra) &&
        (pid.os() != pidtype::os_isilon) && (pid.os() != pidtype::os_zfs))) &&
        (pid.kind() != pidtype::backupboost) )
        return;

    
    const DIRELEM::iterator end;
    {
        const prep_for_sysinfo context_is_prepped(*uc.hfs_info.main);
        const upath workresults_path = upath(UNDOO_DIRECTORY_NAME) / "workresults.xml";
        upath found_fullpath; ustring errdesc;
        DB->msg("list_archive::get_ndmp_startpoint_and_path looking up %s", *workresults_path.image());
        if(uc.get_direlem(DIRELEM::iterator(startpoint, &uc.hfs_info), workresults_path, found_fullpath, errdesc) == end)
            return;
    }

    
    if(listpath.image() == "/")
        listpath = upath("");

    
    if(listpath.isempty())
        return;

    DIRELEMp matchingvol;
    upath matchingvol_path;
    ustring matchingvol_name;
    for(DIRELEM::iterator i(startpoint, &uc.hfs_info); i!=end; ++i) {
        if(!i->is_directory())
            continue;
        if(i->is_internal() && i->name().equal(UNDOO_DIRECTORY_NAME))
            continue;
        ustring volname;
        
        
        if (uc.flags.pluginid.kind() == pidtype::backupboost) {
            volname = ndmp_unentify_volume(i->name());
        } else if(!dirrec_pack::ndmp_volume(&(*i)).get(volname))
            continue;
        const upath volpath(volname);
        if((listpath.isDescendentOf(volpath) || listpath == volpath) &&
           (matchingvol.isnull() || volpath.numelems() > matchingvol_path.numelems()))
        {
            matchingvol = new DIRELEM(*i);
            matchingvol_path = volpath;
            matchingvol_name = volname;
        }
    }
    if(matchingvol.isdefined()) {
        
        m_vol_path = upath(ndmp_entify_volume(matchingvol_name));

        DB->msg("list_archive::get_ndmp_startpoint_and_path found direlem for %s, location=%s",
                matchingvol_path.image().tostr(), matchingvol->file_hash().partialimage().tostr());

        listpath = listpath.slice(matchingvol_path.numelems(), listpath.numelems()-1).to_relative(); 
        startpoint = *matchingvol;
    }
}

bool list_archive::get_inode2_de(const DIRELEM& volume_de, DIRELEM& inode2_de)
{

    if(!trynewparsing || pid.os() != pidtype::os_netapp || pid.kind() != pidtype::ndmp)
        return false;

    
    directory2inodepath = dumpstream::typemap::format(2, dumpstream::typemap::dir);       

    DB->msg("list_archive::get_inode2_de looking up %s", *directory2inodepath.image());
    upath found_fullpath; ustring errdesc;
    const DIRELEM::iterator found(uc.get_direlem(DIRELEM::iterator(volume_de, &uc.hfs_info), directory2inodepath, found_fullpath, errdesc));

    if(found == DIRELEM::iterator())
        return false;

    inode2_de = *found;

    
    
    uc.hfs_info.main->get_flags().ddrenabled = inode2_de.get_location().isFromDDR();

    return true;
}

static ustring delta_im(dpnobj_types::markers mark) {
    switch (mark) {
        case dpnobj_types::objmark_none:     return "  ";
        case dpnobj_types::objmark_deleted:  return "D ";
        case dpnobj_types::objmark_new:      return "N ";
        case dpnobj_types::objmark_modified: return "M ";
    }
    assert(false);
    return "* ";
}

exitcodes_t list_archive::do_dpnobj_listing(const BackupRootInfo& backup) {
    assert(uc.flags.dpnobj);
    if(uc.flags.rebuildcache ||
       !uc.flags.label.isempty() ||
       !uc.flags.restore_before.isempty() ||
       !(uc.flags.restore_after.isempty()&&(0==uc.flags.restore_within_days)))
    {   
        Out->msg(ERR, "<11110>Options --rebuildcache, --label, --before, --after and --within cannot be used with --dpnobj mode");
        return EXIT_BAD_FLAGS;
    }

    const bool in_deltamode = uc.flags.labelnum_delta != 0;
    if(in_deltamode) {
        Out->msg(INFO, "<7323>Comparing with backup #%d", uc.flags.labelnum_delta);
        DB->msg("Setting xflag[13] (bit 134217728) to ignore atime differences");
        xflag[13] |= 134217728;
        if(!uc.flags.diff_equivalence) {
            
            
            
            uc.hfs_info.main->set_location_info_required(false);
        }
    }

    uc.get_ids(backup);

    
    dpnobj base = dpnobj::connect(&uc.flags, uc.getHfsInfoStruct());
    if(base.isnull())
        return EXIT_MISC;
    
    base = base.make_deltamode(uc.flags.labelnum, uc.flags.labelnum_delta, true);
    if(base.isnull())
        return EXIT_MISC;

    bool do_netapp(false);
    try {
        
        
        DIRELEM not_used; 

        
        do_netapp = get_inode2_de(get_toplevel_de(backup, uc.hfs_info), not_used) &&
                    (xflag[15] & 2097152) == 0;
    }catch(const std::runtime_error& e) {
        Out->msg(ERR, "Caught exception while looking for Netapp-format backup: %s", e.what());
    }
    if(do_netapp) {
        Out->msg(INFO, "<11111>Using NetApp backup format");
        
        if(!backup.isFromGsan())
            Out->msg(WARN, "Backup is catalog-based, this may not work");
    }

    base.set_name_options(false,  false, do_netapp);

    const ustring empty;

    
    dpnobj_ls(base, empty, true, in_deltamode, 0);

    base.terminate();   

    dpnobj::disconnect();

    if(in_deltamode && delta_error_count > 0) {
        Out->msg(ERR, "<12603>Compare found %d mismatched files", delta_error_count);
        return EXIT_OK_WITH_ERRORS;
    }
    return EXIT_OK;
}

void list_archive::dpnobj_ls(dpnobj& obj, const ustring& fullpath, bool recurse, bool deltastyle, int indent) {
    if(obj.isnull() || obj.iszerohash())
        return;
    
    
    dpnobj::iterator iter(obj);
    while(true) {
        dpnobj child;
        
        const char *cname = iter.next(child);
        if(cname == NULL)
            break;
        ustring name(cname);
        
        dpnobj_types::statrecord st;
        child.xstat(st);
        unsigned char attributes = 0;  
        const ustring newpath=fullpath/name;
        const dpnobj_types::markers chm = child.marker();
        if(debug_dpnobj || debug_delta)
            DB->msg("list_archive::dpnobj_ls got child '%s' (%s) kind %d, type %d, mode 0x%x, marker %s", *newpath, *name, st.kind, st.type, st.mode, *delta_im(chm));
        DIRELEM tmp;
        tmp.initialize(upath(newpath), st, attributes);
        tmp.set_marker(DIRELEM::markers(chm));       

        
        
        if(name == UNDOO_DIRECTORY_NAME && (!uc.flags.internal || skip_system_info)) {
            continue;
        }

        
        const ustring mhash(child.get_metadata_hash(uc.flags.path/fullpath).val);          
        const ustring ohash(child.get_metadata_hash_delta(uc.flags.path/fullpath).val);    

        
        
        if(st.type == dpnobj_types::regular && chm == dpnobj_types::objmark_modified) {
            if(mhash == ohash) {
                if(child.object_size() == 0)    
                    continue;
                DB->msg("dpnobj_ls: Found modified file '%s' with matching metadata (%s)", *newpath, *mhash);
            }
            if(debug_delta) DB->msg("dpnobj_ls: comparing files....");
            deltadpnobj delta(child);
            if(delta.files_equal(uc.flags.diff_equivalence))
                continue;
            
            delta_error_count++;    
        }
        else if(chm == dpnobj_types::objmark_new || chm == dpnobj_types::objmark_deleted) {
            
            if(name.equal(EXPORTSTREAM_METADATA_FILENAME) && uc.flags.diff_equivalence)
                continue;
            delta_error_count++;    
        }


        if(uc.flags.search_format)
            Out->msg(STD, "%s", *tmp.search_print((upath) newpath, uc.uids, uc.gids, mhash, ohash));
        else {
            const ustring m = deltastyle ? delta_im(child.marker()) : "";
            Out->msg(STD, "%s%s", *m, *tmp.print((upath) newpath, uc.flags.verbose != 0, uc.uids, uc.gids, uc.flags.web_format,
                     (xflag[19]&2)>0 || uc.flags.inode , 0));
        }

        if(st.type == dpnobj_types::symlink) {
            
        }

        
        if(recurse && st.type == dpnobj_types::directory && child.marker() != dpnobj_types::objmark_deleted) {
            
            if(name == ".") {
                
               name = "curr";
            }

            if(debug_delta)
                DB->msg("dpnobj_ls: looking up '%s' to recurse", *name);
            dpnobj subdir = obj.lookup(*name);
            if(subdir.isnull()) {   
                break;
            }
            dpnobj_ls(subdir, newpath, true, deltastyle, indent+4);
            if (uc.flags.search_format)
                Out->msg(STD, LOCTXT("record:EOD\n\n"));
        }
    }
}








class display : public dumpformat_directory {
public:
    display(const bool outputxml_, const bool verbose_, const bool web_format_, const int threshold_,
            utar_commands& uc_, const hashcode& roothash_, const xml_messagep& mess_, dumpstream::typemap& tmap_)
      : outputxml(outputxml_), verbose(verbose_), web_format(web_format_), threshold(threshold_),
        uc(uc_), roothash(roothash_), mess(mess_), count(0), tmap(tmap_) {};

    ~display() {
        emit_buffered(); 
    }

    bool process_entry(const int ino_num, const ustring name, bool& keepgoing) {

        keepgoing = true;

        
        if (name.isempty() || name=="." || name=="..") return true;

        if ((name.bytelength()>18)  
           && (name.contains("_ntstreams_",name.bytelength()-18)>=0)) return true;

        if (ino_num==0) {  
            if (name=="/") { 
                DB->msg("list_archive::display::process_entry found lara section I think");
                keepgoing = false;
            }
            return true;
        }

        DIRELEMp de = new DIRELEM;
        location starting_loc;
        bool isdir = !tmap.isnull() && tmap.size()>0 && tmap.get(ino_num) == dumpstream::typemap::dir; 

        if (count < threshold) {         
            
            ustring errdesc;
            upath inodepath = dumpstream::typemap::format(ino_num, isdir ? dumpstream::typemap::dir
                                                                         : dumpstream::typemap::file);
            if (dmsg) DB->msg("display::process_entry  ino_num:%x(%d) name:%s (%s)",
                            ino_num, ino_num, *name, *inodepath.image());

            bool force_gsan_metadata(false);
            if (uc.get_starting_location(inodepath, starting_loc, de, roothash)) {
                
                inodepath = upath(inodepath.stripdir());
                force_gsan_metadata = true;
            }
            bool found = uc.get_direlem(starting_loc, inodepath, *de, errdesc, upath(""),
                                        false, force_gsan_metadata);
            if (!found && (tmap.isnull() || tmap.size()==0 ||
                           
                           tmap.get(ino_num) == dumpstream::typemap::unused)) {
                
                isdir = !isdir;
                inodepath = dumpstream::typemap::format(ino_num, isdir ? dumpstream::typemap::dir
                                                                       : dumpstream::typemap::file);
                if (dmsg) DB->msg("display::process_entry  ino_num:%x(%d) name:%s (%s)",
                                ino_num, ino_num, *name, *inodepath.image());

                force_gsan_metadata = false;
                if (uc.get_starting_location(inodepath, starting_loc, de, roothash)) {
                    
                    inodepath = upath(inodepath.stripdir());
                    force_gsan_metadata = true;
                }
                found = uc.get_direlem(starting_loc, inodepath, *de, errdesc, upath(""),
                                       false, force_gsan_metadata);
            }
            if (!found) {
                Out->msg(ERR, "<5186>\"%s\" not found in backup. (%s)", *inodepath.image(), *errdesc);
                keepgoing = false; 
                return true;
            }
        }

        de->set_name(name);
        de->set_is_directory(isdir);
        delist.push_back(de);
        count++;

        
        if (count > threshold) emit_buffered(); 

        return true;
    }
private:
    static bool compare_names(const DIRELEMp &lhs, const DIRELEMp &rhs)  {
        return lhs->name() < rhs->name();
    }

    void emit_buffered() {
        
        if (count <= threshold) { 
            std::sort(delist.begin(), delist.end(), compare_names);
        }
        for (size_t i = 0; i < delist.size(); i++) {
            if (outputxml) {
                mess->children.push_back(delist[i]->xml("", true, NULL, NULL));
            } else {
                Out->msg(STD, "%s", *delist[i]->print(upath(delist[i]->name()), verbose, NULL, NULL, web_format, true, 0));
            }
        }
        delist.clear();
    }

    const bool outputxml, verbose, web_format;
    const int threshold;
    utar_commands& uc;
    const hashcode& roothash;
    const xml_messagep& mess;
    int count;
    dumpstream::typemap& tmap;
    direlemp_list_type delist;
};






bool list_archive::ls_dumpformat(const hashcode& tophash, const hashcode& roothash, DIRELEM& de,
                                 const upath& findpath, const upath& origpath)
{
    Out->msg(INFO, "<8510>Processing NetApp listing '%s'", *origpath.image());

    DB->msg("list_archive::ls_dumpformat '%s' de:%s de.hash:%s de.loc:%s",
            *findpath.image(), *de.name(), *de.file_hash().partialimage(), *de.get_location().image());

    init_container(tophash, roothash, de);

    const xml_messagep mess(new xml_message("browse"));
    mess->enter("path", origpath.image());

    
    
    
    if (findpath.isempty()) {
        DIRELEM de;
        epoch_t now((epoch_t) timer::now());
        unsigned char attributes = 0;
        attributes |= ATTR_DIRECTORY;
        de.set_is_directory();
        ustring name("/");  
        de.initialize(hashcode::zero, now, now, now, fileoffset(0), attributes, name);
        if (uc.outputxml)
            mess->children.push_back(de.xml("", true, NULL, NULL));
        else
            Out->msg(STD, "%s", *de.print(upath(name), uc.flags.verbose != 0, NULL, NULL, uc.flags.web_format, true, 0));
        return true;
    }

    
    
    const int sizetouse = (uc.flags.restorecachesize != 0 && uc.flags.restorecachesize < 1024) ? 1024 : uc.flags.restorecachesize;
    uc.hfs_info.main->restorecache_enable(sizetouse);

    
    dumpstream::typemap tmap;
    
    
    

    hashcode curhash = de.file_hash();  
    int foundinode = 2;       
    bool junk = false;        
    for (int i=0; i<findpath.numelems(); i++) {
        ustring findname(findpath.get(i));
        DB->msg("list_archive::ls_dumpformat findpath in loop findpath[%d]='%s' curhash:%s", i, *findname, *curhash.partialimage());

        
        if (!search_for_inode(curhash, de, findname, foundinode)) {  
            Out->msg(ERR, "<8511>Unable to find path \"%s\".", *findpath.image());
            return false;
        }

        
        upath inodepath_dir(dumpstream::typemap::format(foundinode, dumpstream::typemap::dir));
        
        
        
        de.set_location(m_root_de.get_location());
        ustring errdesc;
        DB->msg("list_archive::ls_dumpformat  foundinode:%x(%d) %s findpath[%d]='%s'", foundinode, foundinode, *inodepath_dir.image(), i, *findpath.get(i));
        const location rootloc(location::media::gsan, roothash);
        if (!uc.get_direlem(rootloc, inodepath_dir, de, errdesc)) {
            Out->msg(ERR, "<5186>\"%s\" not found in backup. (%s)", *inodepath_dir.image(), *errdesc);
            return false;
        }

        
        curhash = de.file_hash();

        DB->msg("list_archive::ls_dumpformat Found inode %x(%d) for path %s", foundinode, foundinode, *findpath.image());
    }

    DB->msg("list_archive::ls_dumpformat Found inode %x(%d) for path %s", foundinode, foundinode, *findpath.image());
    {
        
        
        
        if (pid.os() == pidtype::os_netapp) {
            DIRELEM tmpde;
            ustring errdesc;
            const location root_loc(location::media::gsan, roothash);
            const upath tmap_path(ustring(UNDOO_DIRECTORY_NAME) / TS_TYPEMAP_FILENAME);
            if (uc.get_direlem(root_loc, tmap_path, tmpde, errdesc)) {
                chunktype ctype;
                const hfs_info_struct& hfs_info(uc.getHfsInfoStruct());
                hfs_info.main->restore_gsanonly_file(tmap, tmpde.file_hash(), &ctype);
            } else {
                DB->msg("Could not initialize type map data from %s", TS_TYPEMAP_FILENAME);
            }
        }

        display dir1(uc.outputxml, uc.flags.verbose!=0, uc.flags.web_format, uc.flags.netapp_threshold,
                     uc, roothash, mess, tmap);
        traverse_chunks(foundinode, curhash, de, dir1, junk);
        dir1.finished();
    }

    DB->msg("list_archive::ls_dumpformat after search curhash:%s foundinode:%d", *curhash.partialimage(), foundinode);

    if(uc.outputxml) {
        
        if(uc.flags.dataview == client_config_flags::view_redirect && !skip_listing_hack)
            prepend_path_to_listing(mess);
        if(!uc.requestp.isnull() && !uc.responseq.isnull()) {
            
            uc.requestp->set_res_list_snapup_contents(mess->children);
            const ctl_queue::rettype success(uc.responseq->enqueue(uc.requestp));
            if(success != ctl_queue::enqueued_ret)
                DB->msg("list_archive::ls_dumpformat unable to queue list %s", *ctl_queue::rettype_image(success));
        }else
            Out->msg(STD, "%s", mess->simage().tostr());
    }

    if(uc.flags.totals) { 
        if(uc.flags.web_format)
            uwrapper::uprintf("size: %s\n", *uc.totalsize.image()); 
        else
            Out->msg(VERBOSE, LOCTXT("%s bytes total."), *uc.totalsize.image());
    }

    return true;
}






class search_dir : public dumpformat_directory {
public:
    search_dir(const ustring& lookfor_) : inodefound(0), lookfor (lookfor_) {}

    int inodefound;  

    bool process_entry(const int ino_num, const ustring name, bool& keepgoing) {
        
        if (name.equal(lookfor)) {  
            keepgoing = false;
            inodefound = ino_num;
        } else {
            keepgoing = true;
        }
        return true;
    }

private:
    const ustring lookfor;
};

bool list_archive::search_for_inode(const hashcode& hash, DIRELEM& de, const ustring& lookfor, int& foundinode) {
    foundinode = 0;
    bool junk;
    search_dir dir(lookfor);
    if (!traverse_chunks(foundinode, hash, de, dir, junk)) {
        return false;
    }
    if (!dir.finished()) return false;
    foundinode = dir.inodefound;
    return (foundinode>0);
}


bool list_archive::traverse_chunks(const int dirinode, const hashcode& hash, DIRELEM& de,
                                   dumpformat_directory& dir, bool& keepgoing)
{
    DB->msg("list_archive::traverse_chunks %d : %s de.loc:%s", dirinode, *hash.partialimage(), *de.get_location().image());
    keepgoing = true;

    if (hash == hashcode::zero && de.get_location().getMedia() > location::media::gsan) {
        if (m_container != NULL) {
            fileref data;
            data.initlist(10240);
            if (read_file_from_ucontainer(de, data)) {  
                dir.append_chunk(data, keepgoing);
                return true;
            }
            else
            {
                Out->msg(ERR, "Reading file from ucontainer failed for %d.", dirinode);
                return false;
            }
        }
        else
        {
            return true;    
        }
    }

    fileref data;
    chunktype kind;
    ustring errdesc;

    
    
    
    if (!uc.gethashdata(data, hash, kind, uc.hfs_info, errdesc)) {
        Out->msg(ERR, "<8512>\"%d\" path not found in backup (%s).", dirinode, *errdesc);
        return false;
    }

    DB->msg("list_archive::traverse_chunks got kind:%s for %s", *kind.image(), *hash.partialimage());

    if (kind.is_dir_atomic()) {
        return false;

    } else if (kind.is_anycomposit()) {
        int off=0;
        compelem curr_rec(kind);
        while (off < data.size()) {
            if (dmsg) DB->msg("list_archive::traverse_chunks kind: %s off:%d", *kind.image(), off);
            curr_rec.init(data, off); 
            if (!traverse_chunks(dirinode, curr_rec.gethash(), de, dir, keepgoing)) return false;
            if (!keepgoing) return true;
        }

    } else if (kind.is_atomic() || kind.is_extatomic()) {
        if (kind.is_extatomic() && !data.uncompress(uc.hfs_info.main->get_enckey())) assert(!"data.uncompress failed");
        if (!dir.append_chunk(data, keepgoing)) return false;
        if (!keepgoing) return true;

    } else {
        DB->msg("list_archive::traverse_chunks chunktype %s", *kind.image());
        return false;
    }
    return true;

}

    
    
bool list_archive::get_type_map(const BackupRootInfo& backupInfo, dumpstream::typemap& tmap) {

    const upath filepath(UNDOO_DIRECTORY_NAME "/" TS_TYPEMAP_FILENAME);
    const prep_for_sysinfo context_is_prepped(*uc.hfs_info.main);
    DIRELEM de(get_toplevel_de(backupInfo, uc.hfs_info));
    ustring errdesc;
    
    bool res = uc.get_direlem(backupInfo.getRootLocation(), filepath, de, errdesc);

    if (!res) {
        Out->msg(WARN, "<8513>Path \"%s\" not found in backup (%s), browsing may be slower", *errdesc, *filepath.image());
        return false;
    }

    Out->msg(INFO, "<8514>Reading typemap file \"%s\".", *filepath.image());
    res = uc.get_file(backupInfo, tmap, filepath);
    if (!res) {
        Out->msg(WARN, "<8515>Unable to retrieve \"%s\" from backup (%s), browsing my be slower", *errdesc, *filepath.image());
        return false;
    }
    Out->msg(INFO, "<8516>Typemap file \"%s\" read successfully.", *filepath.image());
    return true;
}


void list_archive::init_container(const hashcode tophash, const hashcode volhash, DIRELEM& de) {
    location loc(de.get_location());
    DB->msg("list_archive::init_container with loc:%s", *loc.image());
    if (loc.isFromDDR() && loc.get_containerid() == 0) {
        DB->msg("list_archive::init_container i'ma fix that for ya");
        loc.set_containerid(1);
    }

    if (m_container != NULL) return;

    
    
    
    uc.flags.extract = true;

    if (uc.init_ddr() != EXIT_OK || uc.getAdeMgr() == NULL) return;

    
    fileref transport;

    
    

    
    
    int ddrHandle = 0;
    uc.getAdeMgr()->get_ddrhandle(ddrHandle);  

    
    DataDomainSysInfo ddrSysInfo;
    uc.getAdeMgr()->getSysInfo(ddrSysInfo);

    DB->msg("list_archive::init_container cid:%s", *ddrSysInfo.clientID);

    location::tbackupid mybackupid(loc.get_backupid()==0? location::tbackupid(ddrSysInfo.hexBackupTime):loc.get_backupid());
    assert(mybackupid != 0);

    ustring errdesc;
    
    location tmploc(m_root_de.get_location());
    
    tmploc.set_backupid(mybackupid);
    m_root_de.set_location(tmploc);
    
    
    
    
    
    
    const location toploc(location::media::gsan, tophash);
    if (!uc.get_direlem(toploc, m_vol_path, m_root_de, errdesc)) {
        Out->msg(ERR, "Could not retrieve volume level direlem for %s", *m_vol_path.image());
        return;
    }
    
    location parentloc;
    uc.hfs_info.main->set_location_info("list_archive::init_container", parentloc, m_root_de);

    
    
    
    de.set_location(m_root_de.get_location());
    const location volloc(location::media::gsan, volhash);
    if (!uc.get_direlem(volloc, directory2inodepath, de, errdesc)) {
        Out->msg(ERR, "Could not retrieve directory/2 direlem");
        return;
    }
    location::tcontainerid containerid = m_root_de.get_location().get_containerid();
    
    ddr_interface::initddrread(transport, ddrHandle, ddr_interface::default_lsu, ddrSysInfo.clientID, mybackupid, containerid);

    DB->msg("context::open_container cdsf");
    int cdsfflags = ucontainer::base::flags_parse_stream;


    
    m_container = new cdsf_container(transport, cdsfflags, loc.getMedia(), containerid);

}


bool list_archive::read_file_from_ucontainer(const DIRELEM &de, fileref &data) {
    const ustring filename = de.fullpath().image(); 
    fileoffset absoffset  = de.get_location().get_abs_offset_in_container();

    if (cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: direlem absoffset = %s", *absoffset.image() );

    fileoffset size(de.file_size());  

    if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: PROCESSING DDR, path=%s location: %s",
                     *filename, *de.get_location().image());

    
    assert(m_container->is_seekable());
    ucontainer::errortype  retval = m_container->seek(absoffset, SEEK_SET);
    if (retval != ucontainer::pce__success) {
        DB->msg("list_archive::read_file_from_ucontainer: processing ucontainer, seek failed: %s", *ucontainer::error_description(retval));
        Out->msg(FATAL, "Failed to restore file \"%s\", get container offset failed", *filename);
        uapp::staging().startTermination(EXIT_RESTORE_FAIL, "get ucontainer offset failed for file system restore");
        return false;
    }

    
    
    
    
    fileoffset remaining_size_to_read(size);
    while (remaining_size_to_read > 0) {
        udirelemp ugetde = NULL;
        fileoffset obj_size;  
        if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: Calling getobj(), range size:%s remaining size:%s", *size.image(), *remaining_size_to_read.image());
        retval =  m_container->getobj(ugetde, obj_size);
        if (retval != ucontainer::pce__success || ugetde.isnull()) {
            
            DB->msg("list_archive::read_file_from_ucontainer: processing ucontainer, getobj failed: %s", *ucontainer::error_description(retval));
            Out->msg(FATAL, "Failed to restore file \"%s\", getobj failed", *filename);
            uapp::staging().startTermination(EXIT_RESTORE_FAIL, "ucontainer offset failed for file system restore");
            return false;
        } else {
            

            
            

            if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: getobj() returned object name:%s, size:%s, location:'%s'",
                                 ugetde.isnull() ? "(nil)" : *ugetde->name(), *tostr(obj_size.value()),
                                 *ugetde->get_location().image());

            if(obj_size > 0) {
                
                
                
                fileoffset sizeleft(obj_size);  
                while (sizeleft > 0 && uapp::staging().canRun()) {
                    fileref fr;  
                    fileoffset byteoffset(-1);  
                                                
                                                
                    if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: Calling getdata(), object size:%s sizeleft:%s", *obj_size.image(), *sizeleft.image());
                    retval = m_container->getdata(sizeleft, fr, byteoffset);
                    if ((retval != ucontainer::pce__success) && (retval != ucontainer::pce__end_of_file)) {
                        
                        DB->msg("list_archive::read_file_from_ucontainer: processing ucontainer, getdata failed: %s", *ucontainer::error_description(retval));
                        Out->msg(FATAL, "Failed to restore file \"%s\", getdata failed", *filename);
                        uapp::staging().startTermination(EXIT_RESTORE_FAIL, "ucontainer getdata failed for file system restore");
                        return false;
                    }

                    if (retval == ucontainer::pce__end_of_file) {
                        if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: getdata() returned \"pce__end_of_file\"");
                        break;
                    } else {
                        if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: getdata() returned data size:%s, offset:%s",
                                         *tostr(fr.size64().value()), *tostr(byteoffset.value()));

                        
                        
                        
                        
                        sizeleft -= fr.size64();

                        
                        if (fr.size64() > 0) {
                            
                            if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: Adding bytes to output. size:%s", *tostr(fr.size64().value()));
                            data.append(fr);

                            
                            remaining_size_to_read -= fr.size64();
                        }
                    }
                }  
            } else {
                
                
                
                
                
                if (ugetde->is_ascend_obj()) {
                    
                    
                    if(cdsf_msg) DB->msg("list_archive::read_file_from_ucontainer: getobj() returned ascend object; file read is complete");
                    break;
                }
            }
        }  
    }
    return true;
}






#if !defined(RESTDIRLIST_H_INCLUDED)
#define RESTDIRLIST_H_INCLUDED












#include "cycle.h"
#include "common.h"
#include "restdirlistproducer.h"
#include "composite_to_direlemp.h"



typedef undoo::shared_ptr<direlemp_list_type> direlemp_list_type_sp;








class restdirlist : public bicycle, restdirlistproducer::consumer
{
public:
    SAFEALLOC(restdirlist);

    
    restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location &parent_data_loc_, composite_to_direlemp_table &dir);

    
    restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location &parent_data_loc_, name_to_direlemp_table &dir);

    
    restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location &parent_data_loc_, direlemp_list_type &dir, std::set<ubigint64> &remove_list_);

    
    
    restdirlist(cycle* parent, const location &parent_metadata_loc_, const upath &relativepath_, const location& parent_data_loc_, direlemp_list_type_sp entries_, context * main = NULL);

    
    void set_no_error_on_path_not_found() {
        no_error_on_path_not_found = true;
    }

    virtual ~restdirlist();

    virtual void init();
    virtual void childdone(cycle *child);

    
    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer);

private:
    enum output_type {
        output_nametable           = 0,  
        output_composite_nametable = 1,  
        output_direlemp_list       = 2   
    };

    const location          parent_metadata_loc;        
    const upath             relativepath;    
    name_to_direlemp_table &nametable;       
    composite_to_direlemp_table &composite_nametable; 
    direlemp_list_type     &direlemp_list;   
    output_type             output_list_type;  
    int                     pathindex;       
    const location          parent_data_loc;      
    direlemp_list_type_sp     entries;      

    
    
    
    std::set<ubigint64> &remove_list;

    
    bool no_error_on_path_not_found;
};






class restdirelem : public bicycle {

public:
    SAFEALLOC(restdirelem);

    restdirelem(cycle* parent_, const DIRELEM& parentde, const upath& fullpath, int& casing);  
    virtual ~restdirelem();

    virtual void init();
    virtual void childdone(cycle *child);

    
    direlemp_list_type answers;  
    ustring errdesc;             

    
    const upath fullpath;

private:
    restdirelem();         
    void enqueue_self();   

    const location::tbackupid backupid; 

    
    DIRELEM         parentde;
    location        parent_data_loc;

    location   curloc;     
    upath      foundsofar;  
    int        curlevel;    
    int&       casesense;	  
#define CASEUNDEFINED    -2	
#define CASEUNDETERMINED -1	
#define CASEINSENSITIVE   0	
#define CASESENSITIVE	  1	

    name_to_direlemp_table *namedirtable;
};

#endif





























#include "common.h"
#include "debug.h"
#include "nbackroot.h"
#include "priqueue.h"
#include "connerror.h"
#include "backstats.h"
#include "timer.h"
#include "workelem.h"
#include "fileref.h"
#include "backstate.h"
#include "hard_link_id.h"
#include "output.h"
#include "filestats.h"
#include "utar_flags_info.h"
#include "utar_commands.h"
#include "compelem.h"
#include "nbackfile.h"
#include "nbackdir.h"
#include "nbackdir_manual_unc.h"
#include "backrand.h"
#include "workcontext.h"
#include "nbackdata.h"
#include "backdumpstream.h"

#include "filenames.h"  
#include "infofile_info.h"
#include "userid.h"
#include "backdump.h"
#include "backstream.h"
#include "axionfsdirelem.h"
#include "backaxionfs.h"
#include "backaxionfsdir.h"
#include "runstage.h"
#include "backviewtop.h"
#include "utar_flags_enums.h"
#include "ndmp_history.h"
#include "tretentiontype.h"
#include "roothashlist.h"
#include "acntmngr.h"
#include "synccall.h"
#include "mediadesc.h"
#include "backupdir2backroot.h"

#include "ade_mgrx.h"
#include "interfaceade_export.h"

#include "statlist.h"
#include "mulqueue.h"

#include "backdirmerge.h"
#include <string.h>
#include "msgpack_c.h"

#include "MetadataStore.h"
#include "ade/adelib/context_ade.h"
#include "ade/adelib/ddrcom_mgr.h"

#include "timecnv.h"

#include "ndmp_volume_entification.h"
#include "backemctarinode2hash.h"
#include "backupboost_interface.h"
#include "uwrapper.h"

#define nbackroot_msg ((xflag[2]&32)!=0)
#define failonhashcodeempty ((xflag[20]&512)==0)
#define partialdetails ((xflag[30]&2048)!=0)

bool VerifyInfrastructureFunctionality(void);



#define USE_UPATHKIND_DIRSEP(x) (x.kind() == upath::kind_win ? "\\" : "/")


class CycleToLaunch {
    public:
        workelem *  w;
        nbackdir_manual_unc *  parent;  
        fileoffset  parentOffset;
        upath       parentPath;

        CycleToLaunch(nbackdir_manual_unc * parent_, fileoffset next_offset, workelem * w, const upath& parentPath);
};

CycleToLaunch::CycleToLaunch(nbackdir_manual_unc * parent_, fileoffset next_offset, workelem * w, const upath& parentPath) {
    this->parent = parent_;
    this->parentOffset = next_offset;
    this->w = w;
    this->parentPath = parentPath;
}


class PathToNBackDirMapType : public DEFINE_STL_MAP_TYPE(upath, nbackdir_manual_unc *) {
    public:
        
        PathToNBackDirMapType::iterator GetLowestAncestorOf(const upath& refPath);

        
        PathToNBackDirMapType::iterator GetHighestAncestorOf(const upath& refPath);

        
        upathlist GetDescendentsOf(const upath& refPath);

        
        void dump(const ustring& title);
};




PathToNBackDirMapType::iterator PathToNBackDirMapType::GetLowestAncestorOf(const upath& refPath) {
    upath tmp(refPath);
    PathToNBackDirMapType::iterator retVal = end();

    if (nbackroot_msg) DB->msg("PathToNBackDirMapType::GetLowestAncestorOf looking for lowest ancestor of '%s' in the PathToNBackDirMap", *(refPath.image(USE_UPATHKIND_DIRSEP(refPath))));

    tmp.pop_back(true);

    
    while (retVal == end() && (tmp.numelems() > 0 || (tmp.kind() == upath::kind_unix && tmp.has_begin_dirsep()))) {
        if (nbackroot_msg) DB->msg("looking for '%s' in map", *tmp.image(USE_UPATHKIND_DIRSEP(tmp)));
        if ((retVal = find(tmp)) == end()) {
            
            if (tmp.numelems() > 0) {
                tmp.pop_back(true);
            }
            else {
                
                
                tmp.set_begin_dirsep(false);
            }
        }
    }

    return retVal;

}



PathToNBackDirMapType::iterator PathToNBackDirMapType::GetHighestAncestorOf(const upath& refPath) {

    upath tmp(refPath);
    PathToNBackDirMapType::iterator retVal = end();
    PathToNBackDirMapType::iterator higher = end();

    if (nbackroot_msg) DB->msg("PathToNBackDirMapType::GetHighestAncestorOf looking for highest ancestor of '%s' in the PathToNBackDirMap", *(refPath.image(USE_UPATHKIND_DIRSEP(refPath))));

    tmp.pop_back(true);
    while (retVal == end() && tmp.numelems() > 0) {
        if ((retVal = find(tmp)) != end()) {
            
            higher = GetHighestAncestorOf(tmp);
            if (higher != end()) {
                retVal = higher;
            }
        }
        else {
            tmp.pop_back(true);
        }
    }

    return retVal;
}


upathlist PathToNBackDirMapType::GetDescendentsOf(const upath& path) {
    upathlist retArray;
    PathToNBackDirMapType::iterator   it;

    for (it = begin(); it != end(); it++) {
        upath tmp = it->first;
        if (tmp.isDescendentOf(path)) {
            retArray.push_back(tmp);
        }
    }

    return retArray;
}


void PathToNBackDirMapType::dump(const ustring& title) {
    PathToNBackDirMapType::iterator   it;

    DB->msg("--Dumping '%s' map --", *title);
    it = begin();
    while (it != end()) {
        upath key = it->first;
        BackCycle * value = it->second;
        DB->msg("   '%s' = %p", *key.image(USE_UPATHKIND_DIRSEP(key)), value);
        ++it;
    }
}


PathToNBackDirMapType CreateParentChildFreeMap(const stringlist& listOfTargets);

nbackroot::nbackroot(context *main, mulqueue& todoQueue_, workelem *info_)
  : multivolumeroot(main, todoQueue_, true ),
    BackCycle(NULL, main, info_),
    destroy_workelem(true),
    ucontainer_finalized(false),
    partial_was_internal(false),
    partial_nohiddendir(false),
    partial_hiddendone(false),
    partial_lockp(NULL),
    backup_list(),
    bb_convert_phase(phase_filesys_backup),
    token(NULL),
    bb_session_id(0),
    write_ddr_file(true)
{
    if (nbackroot_msg) DB->msg("nbackroot::nbackroot (this:%p) constructor '%s'", this, info_?*info_->path.image():"NULL");
    setasroot(this);
    cycle::offset = 0;
    this->backaxionfsp = NULL;
    this->overrideacntpath = NULL;
    m_copying_backup = flags.regenerate_inode2hash; 
}




bool get_roothash(context* main, roothashlistrec& answer, prectime timestamp, bool include_partials, ustring& cid)
{
    if (partialdetails) DB->msg("get_roothash(main %p, &answer, %s, include_partials %c, cid '%s')", main, *timestamp.hexstr(), include_partials ? 'T' : 'F', *cid);
    hfs_info_struct hfs_info = main->getAdeMgr()->getHfsInfo(dpn0);
    roothashlist lst;
    prectime before_time = timestamp;
    prectime after_time = timestamp;
    
    synccall sync(*main, dpn0);
    acntmngr acnt(&sync);
    msgerrors rslt = acnt.getBackups(lst, hfs_info.blk, hfs_info.auth, 1, +after_time, +before_time, include_partials);
    if (rslt != MSG_ERR_NONE) {
        Out->msg(ERR, "<5111>%s(%d) trying to get previous backup.", *message::err_image(rslt), rslt);
        return false;
    }
    lst.get(answer, 0);
    lst.sort(LIST_SORT_HIGH_TO_LOW); 
    if (partialdetails) DB->msg("get_roothash: previous root hash:%s", *answer.getRoot().partialimage());
    if (!cid.isempty()) {    
        blkpath dpnacnt(cid);
        blktraj lblktraj(dpnacnt);
        hashcode id;
        rslt = acnt.getPathId(id, lblktraj);
        if (rslt == MSG_ERR_NONE)
            cid = id.image();
        else cid = "";
    }
    return true;
}

hashcode get_partial_root(context* main, ubigint64 time)
{
    if (partialdetails) DB->msg("get_partial_root(%"LL"d)", time);
    
    roothashlistrec prev_root;
    ustring cid;
    bool foundit = get_roothash(main, prev_root, prectime(time), true, cid);
    if (partialdetails) DB->msg("get_partial_root: foundit:%d, roothash ==>> '%s', ispartial:%d", foundit, *prev_root.getRoot().partialimage(), prev_root.isPartial());
    if (foundit && prev_root.isPartial()) {
        if (partialdetails) DB->msg("get_partial_root: Reading snapup with Snapup Time = %"LL"d", +prev_root.getMtime());
        return prev_root.getRoot();
    }
    DB->msg("get_partial_root: Could not find previous partial snapup, time=%"LL"d", time);
    return hashcode::empty;
}



#if SYSTEM_WINDOWS
#define SKIPSLASH true
#elif SYSTEM_UNIX
#define SKIPSLASH false
#endif

nbackdir *nbackroot::save_rootpath(nbackdir *parent, const upath& fullpath, fileoffset& offset, bool is_mapi, bool use_container)
{
    if (use_container) {
        assert(info->use_container && !info->container.isnull()); 
        
    }

    
    
    
    ustring path(fullpath.image());

    DB->msg("nbackroot::save_rootpath~ path:'%s' use_container:%d info->use_container:%d info->container.isnull():%d",
            *path, use_container, info->use_container, info->container.isnull());
    int ind = 0;
    int loop_iter = 0;
    nbackdir *child = parent;

    if (SKIPSLASH && !is_mapi && !fullpath.isempty()) {
        if (path.byteindex(0) == DIRSEP)
            ind = 1;

        
        if (path.bytelength() > 2 && path.byteindex(0) == DIRSEP && path.byteindex(1) == DIRSEP)
            ind = 2;

#if SYSTEM_WINDOWS
        upath upth(path);
        if (upth.numelems() >= 2) {
            ustring elem_name;
            upath::elemcat elem_cat;
            if (upth.get(0, elem_name, elem_cat) && (elem_cat == upath::elem_wack_wack_prefix) && (elem_name =="?"))
                ind = 4;
        }
#endif
    }

    DIRELEMp parent_path_de(NULL); 
    while (true) {
        DB->msg("nbackroot::save_rootpath main loop: path '%s' ind %d loop_iter %d", *path, ind, loop_iter);
        if (ind >= path.bytelength())
            return parent;

        path = path.chop(); 
        if (path.isempty())
            return parent;

        int next_dirsep = path.find(ind, DIRSEP);

        bool at_end(false);
        if (next_dirsep == -1) {
            next_dirsep = path.bytelength();
            at_end = true;
        }

        ustring reduced_path(path.substr(0, next_dirsep));      
        ustring name(path.substr(ind, next_dirsep-ind));        

        ustring reduced_prefix;  

        
        if (!flags.backup_prefix.isempty()) {      
            reduced_prefix = flags.backup_prefix.chop();
            if (reduced_path != reduced_prefix && reduced_path.contains(reduced_prefix, 0) == 0)
            
                reduced_path = reduced_path.substr(flags.backup_prefix.bytelength());
        }
        
        if (next_dirsep == 0 && path.byteindex(0) == DIRSEP) {  
            reduced_path = ustring(DIRSEP, 1);
            name = reduced_path;
        }
        

        ustring match_name(name);
        
        if (flags.xmlunentitifydpnpaths) {
            
            const ustring unentitified_name(xml_message::convert_xmlstring(match_name));
            if (match_name != unentitified_name) {
                DB->msg("nbackroot::save_rootpath: unentitified name '%s' to '%s'", *name, *unentitified_name);
                match_name = unentitified_name;
            }
        }

        DB->msg("nbackroot::save_rootpath ind=%d, next=%d, name=\"%s\", reduced=\"%s\", match=\"%s\"", ind, next_dirsep, *name, *reduced_path, *match_name);

        if (is_mapi && reduced_path == "\\")
            reduced_path = DIRELEM_ROOT;

        
        
        
        


        
        
        if (parent_path_de.isnull()) {
            parent_path_de = new DIRELEM((upath)reduced_path, is_mapi, !at_end || flags.dereference);
            if (reduced_prefix.contains(reduced_path) == 0) { 
                parent_path_de->set_is_directory(true);
            }
            
        }

        if (is_mapi) {

            
            
            
            
            

            for (int i = reduced_path.bytelength()-1; i >=  0; i--) {
                if (reduced_path.byteindex(i) == DIRSEP) {
                    reduced_path = reduced_path.substr(i+1, reduced_path.bytelength()-i);
                    break;
                }
            }
        }


        
        if (loop_iter > 0) {
            DB->msg("nbackroot::save_rootpath new workelem (%s) use_container %d, info->use_container %d, info->container %p",
                    *reduced_path, use_container, info->use_container, info->container.getimpl());
            workelem *w = new workelem(info, (upath)reduced_path, parent_path_de, info->fstats);
            
            
            child = new nbackdir(parent,
                                 w,
                                 offset,
                                 true,   
                                 false,  
                                 false,  
                                 false,  
                                 0,      
                                 0,     
                                 false, 
                                 NULL,  
                                 use_container);
        }
        int attr = ATTR_DIRECTORY;
        if (is_mapi) {
            int findleft  = reduced_path.find( 0, '<' );
            int findright = reduced_path.find( 0, '>' );
            if( findleft != -1 && findright != -1 ) {
                attr = 0;
            }
        } else if (flags.from_stdin && at_end) attr = 0;        

        DIRELEMp childde(NULL);  
        if (flags.from_stdin && !flags.check_stdin_path) {
            
            offset = child->do_direlem(name, attr, 0, true, false, &childde);
        } else {
            
            
            
            offset = child->do_direlem(reduced_path, attr, 0, is_mapi, !at_end || flags.dereference, &childde);
            if (at_end) {
#if SYSTEM_WINDOWS
                
                (void)ReparsePoints::GetReparseDataAndSetToDirelem(upath(reduced_path), *childde);
#endif
            }
            if (reduced_prefix.contains(reduced_path) == 0 && !childde->is_directory()) {
                
                
                childde->set_is_directory();
            }
        }
        if (!childde.isnull()) {         
            

	    
	    
	    
	    
	    
            if (!flags.backup_prefix.isempty() || !childde->has_error()) {
                parent_path_de = childde;
		
		
                
                
                info->direlemp = parent_path_de;
            } else DB->msg("nbackroot::save_rootpath: childde '%s' has error (no backup prefix)", *childde->name());
        } else assert(false);
        
        child->do_file_finish();
        ind = next_dirsep+1;
        parent = child;
        loop_iter++;
    }
}











nbackdir_manual_unc *nbackroot::create_nbackdirChain( nbackdir_manual_unc * const topLevelNBackDir, const upath& fullpath, fileoffset& nextOffset, bool is_mapi, PathToNBackDirMapType& previouslyCreatedCycles,
        upath& parentPath, bool useContainer) {
    
    
    
    ustring pathAsString(fullpath.image());

    if (nbackroot_msg) DB->msg("nbackroot::create_nbackdirChain path:'%s'", *pathAsString);
    int start = 0;

    
    
    if ((SKIPSLASH || !flags.backup_prefix.isempty()) && !is_mapi && !fullpath.isempty()) {
        if( pathAsString.byteindex(0) == DIRSEP )
            start = 1;

        
        if( pathAsString.bytelength() > 2 && pathAsString.byteindex(0) == DIRSEP && pathAsString.byteindex(1) == DIRSEP)
            start = 2;

#if SYSTEM_WINDOWS
        
        upath upth(pathAsString);
        if(upth.numelems() >= 2) {
            ustring elem_name;
            upath::elemcat elem_cat;
            if(upth.get(0, elem_name, elem_cat) && (elem_cat == upath::elem_wack_wack_prefix) && (elem_name =="?"))
                start = 4;
        }

#endif
    }

    nbackdir_manual_unc * parent = topLevelNBackDir;

    
    PathToNBackDirMapType::iterator it;
    upath refPath(pathAsString);
    refPath.set_end_dirsep(true);
    if ((it = previouslyCreatedCycles.GetLowestAncestorOf(refPath)) != previouslyCreatedCycles.end()) {
        
        upath ancestor = it->first;
        parent = it->second;

        
        
        
        start = ancestor.lengthOfEquivStr();
    }

    fileoffset offsetOfEntry;
    int loop_iter = 0;
    nbackdir_manual_unc * newNBackDir = parent;
    while( true ) {

        if( start >= pathAsString.bytelength() ) {
            
            if (nbackroot_msg) DB->msg("### create_nbackdirChain() exiting ###");
            nextOffset = offsetOfEntry;
            return parent;      
        }

        if (nbackroot_msg) DB->msg("### create_nbackdirChain iteration %d ###", loop_iter);

        pathAsString = pathAsString.chop(); 
        if(pathAsString.isempty())
            return parent;

        int next_dirsep = pathAsString.find( start, DIRSEP );

        bool at_end(false);
        if( next_dirsep == -1 ) {
            next_dirsep = pathAsString.bytelength();
            at_end = true;
        }

        ustring reduced_pathStr(pathAsString.substr(0, next_dirsep));      
        ustring name(pathAsString.substr(start, next_dirsep-start));        

        if( next_dirsep == 0 && pathAsString.byteindex(0) == DIRSEP ) {  
            reduced_pathStr = ustring(DIRSEP, 1);
            name = reduced_pathStr;
        }

        ustring match_name(name);
        
        if(flags.xmlunentitifydpnpaths) {
            
            const ustring unentitified_name(xml_message::convert_xmlstring(match_name));
            if(match_name != unentitified_name) {
                if (nbackroot_msg) DB->msg("nbackroot::create_nbackdirChain: unentitified name '%s' to '%s'", *name, *unentitified_name);
                match_name = unentitified_name;
            }
        }

        if (nbackroot_msg) DB->msg("nbackroot::create_nbackdirChain start=%d, next=%d, name='%s', reduced_pathStr='%s', match='%s'", start, next_dirsep, *name, *reduced_pathStr, *match_name);

        bool dont_stat_file = false;    
        
        upath reducedPath(reduced_pathStr);
        int attr = ATTR_DIRECTORY;
        if (flags.from_stdin && at_end) {
            attr = 0;        
            reduced_pathStr = name;
            dont_stat_file = true;
        }

        reducedPath.set_end_dirsep(true);
        DIRELEMp childde(NULL);  
        if(flags.from_stdin && !flags.check_stdin_path) {
            
            offsetOfEntry = parent->do_direlem( name, attr, 0, true, false, &childde );
        }
        else {
            
            
            offsetOfEntry = parent->do_direlem( reduced_pathStr, attr, 0, dont_stat_file, !at_end || flags.dereference, &childde);
            
            
            if (at_end) {
#if SYSTEM_WINDOWS
                reducedPath.set_end_dirsep(false);
                
                (void)ReparsePoints::GetReparseDataAndSetToDirelem(reducedPath, *childde);
#endif
            }
        }

        if (!at_end) {
            workelem * w = new workelem(info, childde);
            newNBackDir = new nbackdir_manual_unc(parent, w, offsetOfEntry, false, false, useContainer);
            parent->add_subcycle(newNBackDir, false);
            previouslyCreatedCycles[reducedPath] = newNBackDir;
        }
        else {
            
        }

        if (!childde.isnull()) {         
            
            if (!childde->has_error()) {
                
                info->direlemp = childde;
            }
        }
        else {
            assert(false);
        }

        start = next_dirsep+1;
        parent = newNBackDir;
        loop_iter++;
        parentPath = upath(reduced_pathStr);
    }
}


void nbackroot::set_backaxionfs_work(backaxionfs *ba)
{
    
    cycle::main->state->snaptype = AXIONFS;

    backaxionfsp = ba;
    
    
}





bool get_roothash_by_label(context* main, utar_flags_info& flags)
{
    
    utar_flags_info fakeflags;
    fakeflags.path = flags.path;
    fakeflags.label = flags.label;
    fakeflags.labelnum = flags.labelnum;
    fakeflags.incpartials = true;

    
    assert(main);
    hfs_info_struct hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);
    blkpath dpnacnt(flags.path);
    blktraj new_blktraj(dpnacnt);
    hfsinfo.blk = new_blktraj;

    utar_flags_info dstflags;  
    utar_commands uc(fakeflags, hfsinfo, dstflags);

    BackupRootInfo onebackup;
    (void)uc.pick_backup(onebackup, false);
    flags.snapuptime = onebackup.getBackupTime();
    if (flags.snapuptime == 0) {  
        Out->Abort("Can't find backup by label '%s' or number %d", *flags.label, flags.labelnum);
        return false;
    }
    
    
    
    
    if (partialdetails) DB->msg("nbackroot::get_roothash_by_label found backup by time %"LL"u", flags.snapuptime);
    return true;
}

bool nbackroot::init_partial()
{

    if (flags.backupstate == utar_flags_enums::backstate_partial ||
        flags.backupstate == utar_flags_enums::backstate_final)
    {
        if (flags.snapuptime == 0 && !get_roothash_by_label(cycle::main, flags)) {
            
            cycle child(this);
            child.hash = hashcode::empty;
            childdone(&child);
            return true;
        }
        
    }

    switch (flags.backupstate) {
        case utar_flags_enums::backstate_begin_empty:
        {
            
            DB->msg("nbackroot::init_partial -- begin partial, nforked %d ncollected %d", nforked, ncollected);
            flags.backupstate = utar_flags_enums::backstate_begin;  
            flags.nohiddendir = false;      
            partial_hiddendone = true;      
            info->use_container = false;     
            upath what("");     
            workelem *w = new workelem(info, what);
            w->use_container = false;
            nbackdir *empty = new nbackdir(this, w, 0, true, true, false, true, 0, 0, true);
            
            
            empty->todoEnqueueInsert(TODO_DIR, empty, 0);
            return true;
        }

        case utar_flags_enums::backstate_partial:
            
            partial_nohiddendir = flags.nohiddendir;
            flags.nohiddendir = true;
            break;

        case utar_flags_enums::backstate_final:
        {
            
            hashcode prev_root(get_partial_root(cycle::main, flags.snapuptime));
            if (prev_root == hashcode::empty) {     
                Out->Abort("Starting backup - unable to find root hash to finish partial backup (time) %"LL"d", flags.snapuptime);
                return true;
            }
            DB->msg("nbackroot::init_partial -- final partial, nforked %d ncollected %d, hash %s", nforked, ncollected, *prev_root.partialimage());
            flags.nohiddendir = false;      
            cycle child(this);
            child.hash = prev_root;
            childdone(&child);
            return true;
        }
    }

    return false;       
}

#define disableTargetDrivenBackup ((xflag[31]&2048)!=0)
bool nbackroot::useTargetDrivenBackup() const {
    
    
    
    
    
    
    
    
    if (cycle::main->state->targets.getNumUncPaths() > 0 ||
        cycle::main->state->targets.getNumGlobalRoots() > 0 ||
        cycle::main->state->targets.getNumVolGuids() > 0) {
            if (disableTargetDrivenBackup) {
                DB->msg("nbackroot::useTargetDrivenBackup - Ignoring --x31=+2048 - Unc Paths: %d, Global Roots: %d, Volume GUIDs: %d",
                    cycle::main->state->targets.getNumUncPaths(), cycle::main->state->targets.getNumGlobalRoots(),
                    cycle::main->state->targets.getNumVolGuids());
            }
            return true;
    }

    
    if (disableTargetDrivenBackup)
        return false;

    if (flags.pluginid.kind() == pidtype::backupboost || flags.backupboost_convert)
        return false;

    
    if (flags.parallel && flags.parallel_type == utar_flags_enums::parallel_by_target && flags.maxstreams > 1 && !flags.args.isempty())
        return true;

    return false;
}

void nbackroot::init() {
    if (nbackroot_msg) DB->msg("nbackroot::init (this:%p)", static_cast<BackCycle *>(this));

    if (flags.backupstate != utar_flags_enums::backstate_onetime)
        if (init_partial())
            return;

    if(flags.randchunk > 0) {
        delete info;
        destroy_workelem = false;  
        cycle *child = new backrand( this );
        child->noop();
        return;
    }
    if(!uapp::staging().canRun()) {
        DB->msg("nbackroot::init -- Throwing exception EXC_CANCEL");
        throw EXC_CANCEL;
    }

    
    if(!info) {
        DB->msg("nbackroot::init -- Empty work elem");
        throw EXC_CANCEL;
    }

    

    fileoffset second_offset;
    
    const int sizetouse = (flags.restorecachesize != 0 && flags.restorecachesize < 2048) ? 2048 : flags.restorecachesize;
    cycle::main->restorecache_enable(sizetouse, true);

    
    hfs_info_struct& hfsInfo = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
    if (hfsInfo.metaStore != NULL) {
        hfsInfo.metaStore->openBackup(flags);
    }

    if(info->isapi) {
        DoISAPIBackup();
    }
    else if(flags.makeview) {
        DoMakeview();
    }
    else if(cycle::main->state->snaptype == DUMP) {
        DoSnapTypeDump();
    }
    else if(cycle::main->state->snaptype == STREAM) {
        DoStreamBackup();
    }
#if !SYSTEM_WINDOWS
    else if(cycle::main->state->snaptype == AXIONFS) {
        DoAxionfsBackup();
    }
#endif
    else if (useTargetDrivenBackup()) {
        
        if(!flags.backup_prefix.isempty()) {
            info->path = info->direlemp->fullpath();
            
        }
        include targets = cycle::main->state->targets;
        DoTargetDrivenFileSysBackup_NonADE(targets.includelist());
    }
    else if( (SKIPSLASH && (info->path.numelems() == 0 && info->path.has_end_dirsep()))  ) {
        
        
        
        
        
        
        
        
        
        if (nbackroot_msg) DB->msg("nbackroot::init -- multiple targets and SKIPSLASH ([gsan]path='%s') ", *info->path.image());
        assert(!cycle::main->ADEChunkerEnabled());
        DoFileSysRootBackupNonADE_SKIPSLASH();
    }
    else if(!flags.media_in.isempty() && DoBackupDirBackup()) {
        
    }
    else if (flags.pluginid.kind() == pidtype::backupboost) {
        if (!(flags.ddrenabled && flags.ddrindex > 0 &&
              cycle::main->getAdeMgr() &&
              cycle::main->getAdeMgr()->isDDRenabled())) {
            
            Out->msg(ERR, "BackupBoost backups must be stored on a DataDomain");
            throw EXC_CANCEL;
        } else {
            DoBackupBoostBackup();
        }
    }
    else if (flags.backupboost_convert) {
        
        
        const include targets = cycle::main->state->targets;
        const stringlist target_list = targets.includelist();
        if (target_list.size() != 1) {
            Out->Abort("BackupBoost conversion with flag --backupboost-convert must only used for a single BackupBoost mount path.");
            return;
        }
        target_path = upath(target_list.back());
        if (!flags.ddrenabled || flags.ddrindex <= 0) {
            Out->Abort("BackupBoost conversion with flag --backup-convert must be used with --ddr and valid --ddr-index.");
            return;
        }
        DoBackupBoostConvert();
    }
    else {
        
        
        
        
        
        
        
        
        
        
        if (cycle::main->ADEChunkerEnabled()) {
              assert(false);    
        
        }
        else {
            DoFileSysBackupNonADE();
        }
    }
    if (nbackroot_msg) DB->msg("nbackroot::init -- returning");
}


void nbackroot::DoISAPIBackup() {
    DB->msg("nbackroot::DoISAPIBackup -- info->isapi == true");
    cycle *child;
    destroy_workelem = false; 
    if(info->path.isempty()) {
        DB->msg("nbackroot::DoISAPIBackup -- calling nbackdata");
        child = new nbackdata( this, info, fileoffset(0), info->isdir);
    } else {
        DB->msg("nbackroot::DoISAPIBackup -- calling nbackdir");
        child = new nbackdir(this,
                                info,
                                fileoffset(0),
                                false,              
                                false,              
                                false,              
                                false,              
                                0,                  
                                0);                 
    }
    child->noop();
}


void nbackroot::DoMakeview() {
    DB->msg("nbackroot::DoMakeview -- flags.makeview == true");
    Out->msg(INFO, "<6972>Creating backup view (UEHMVSSV)");
    flags.validate = true;  
    
    
    backviewtop *bv = new backviewtop(this, flags.arg, fileoffset(0));
    bv->noop();
}


void nbackroot::DoSnapTypeDump(void) {
    fileoffset second_offset;

    Out->msg(INFO, "<5727>Parsing DUMP stream format");
    DB->msg("nbackroot::DoSnapTypeDump -- DUMP stream format");

    if ((xflag[22] & 4) == 0) {

        if(flags.incremental) {
            
            BackupRootInfo prevBackup;
            location::tbackupid backupid;
            const bool foundBackup = find_prev_backup(prevBackup, backupid);
            if(!foundBackup) {
                Out->msg(FATAL, "<8544>Unable to find backup to base this incremental from.  Please check flags");
                uapp::staging().startTermination(EXIT_ABORT, "unable to find backup to use as base");
                notifyparent();
                return;
            }

            
            
            if (info->container.isdefined()) {
                info->container->set_previous_backupid(backupid);
            }

            
            if (!populate_previous_ndmp_location(prevBackup, backupid)) {
                
                
                return;
            }
        }

        const epoch_t now = (epoch_t)timer::now();
        DIRELEMp de = new DIRELEM;
        de->initialize(hashcode::zero, now, now, now, 0, ATTR_DIRECTORY, "");
        de->set_location(info->direlemp->get_location());
        workelem *w = new workelem(info, info->path, de);
        cycle *child = new backdumpstream(this, w);
        child->noop();
    } else {
        Out->msg(WARN, "<8543>Reverting to original dumpstream parsing");
        destroy_workelem = false;
        nbackdir *root_cycle = new nbackdir(  this,
                                              info,
                                              fileoffset(0),
                                              true,               
                                              !flags.nohiddendir, 
                                              false,              
                                              true,               
                                              0,                  
                                              0);                 

        
        second_offset = root_cycle->do_direlem(DIRELEM_ROOT, ATTR_DIRECTORY, KIND_UNIX_SP, true );  
        root_cycle->do_file_finish();                                         
        workelem *w = new workelem(info, info->path, info->direlemp); 
        cycle *child = new backdump(root_cycle, w, second_offset, info->data, flags);
        child->noop();
    }
}


void nbackroot::DoStreamBackup() {
    DB->msg("nbackroot::DoStreamBackup -- STREAM");
    const ustring streamtxt(flags.media_in.isempty() ?
                            "stdin" :
                            ustring::sprintf("path '%s'", *flags.media_in));

    Out->msg(INFO, "<6995>Parsing '%s' stream format from %s",
             *utar_flags_info::streamformat_image(flags.streamformat_in), *streamtxt);

    location::tbackupid backupid;
    if(flags.incremental) {
        
        BackupRootInfo prevBackup;
        const bool foundBackup = find_prev_backup(prevBackup, backupid);
        if(!foundBackup) {
            Out->msg(FATAL, "<8544>Unable to find backup to base this incremental from.  Please check flags");
            uapp::staging().startTermination(EXIT_ABORT, "unable to find backup to use as base");
            notifyparent();
            return;
        }

        
        
        if (info->container.isdefined()) {
            info->container->set_previous_backupid(backupid);
        }

        
        
        
        if ((flags.streamformat_in == utar_flags_enums::streamformat_emctar) ||
            (flags.streamformat_in == utar_flags_enums::streamformat_isilon) ||
            (flags.streamformat_in == utar_flags_enums::streamformat_zfs)) {

            if (!populate_previous_ndmp_location(prevBackup, backupid)) {
                
                
                return;
            }

            
            
            
            baselocation_sp blp(info->direlemp->get_metadataLocation());
            info->direlemp->set_hash(prevBackup.getRootLocation().getHash(), blp );

            Out->msg(INFO, "Found previous %s %s for %s incremental backup",
                     prevBackup.isFromGsan() ? "roothash" : "metadataId",
                     *(blp ? blp->getMetadataId().partialimage() : info->direlemp->file_hash().partialimage()), 
                     flags.streamformat_in == utar_flags_enums::streamformat_emctar ? "Celerra/VNX" : "Isilon");
        }

        if(flags.streamformat_in == utar_flags_enums::streamformat_emctar) {
            if(nbackroot_msg) DB->msg("nbackroot::init celerrai18n flag is %d", flags.celerrai18n);
            if(!cycle::main->prepare_emctarstream_incremental(prevBackup))    
                Out->msg(INFO, "<8545>Unable to set flag celerrai18n from previous backup.  Using default(%d) instead.", flags.celerrai18n);
        }


        if(nbackroot_msg) DB->msg("nbackroot::init celerrai18n flag is set to %d.", flags.celerrai18n);
        
        cycle::main->restorecache_enable(flags.restorecachesize, false);
    }

    if (m_copying_backup) { 
        BackupRootInfo prevBackup;
        m_prev_acct_info_valid = find_prev_backup(prevBackup, backupid);
        assert(prevBackup.isFromGsan());    
        if (m_prev_acct_info_valid) {
            m_prev_roothashlistrec = cycle::main->prev_backup.getrootrec();
        }
    }
    DB->msg("nbackroot::init about to create backstream, info->path now '%s', set to flags.ndmp_prefix '%s'",
            *info->path.image(), *flags.ndmp_prefix);
    getInfo()->path = upath(flags.ndmp_prefix);
    destroy_workelem = false;
    cycle *child = new backstream(this, cycle::main, info, flags.media_in, exportstream_infop, backupid);
    child->noop();
}

#if !SYSTEM_WINDOWS
void nbackroot::DoAxionfsBackup(void) {
    Out->msg(INFO, "<6760>Beginning backup of axionfs write data");
    DB->msg("nbackroot::DoAxionfsBackup Beginning backup of axionfs write data");

    workelem *w = new workelem(info, info->path, info->direlemp); 
    DB->msg("nbackroot::DoAxionfsBackup made new workelem");

    bool ismeta = false;
    axionfsDIRELEM *rootaxionfsdirelem = backaxionfsp->lookup(upath(DIRELEM_ROOT), ismeta);
    DB->msg("nbackroot::DoAxionfsBackup found root axionfsDIRELEM of %p", rootaxionfsdirelem);
    cycle *child = new backaxionfsdir(this, cycle::main, w, rootaxionfsdirelem, fileoffset(0));
    DB->msg("nbackroot::DoAxionfsBackup made backaxionfsdir (auto-queues)");
    child->noop();
    DB->msg("nbackroot::DoAxionfsBackup did noop");
}
#endif

void nbackroot::DoFileSysRootBackupNonADE_SKIPSLASH(void) {
    DB->msg("nbackroot::DoFileSysRootBackupNonADE_SKIPSLASH");
    
    workelem* w = new workelem(*info);  
    cycle *child = create_nbackdir(
                                this,
                                w,
                                fileoffset(0),
                                false,              
                                !flags.nohiddendir, 
                                false,              
                                true,               
                                0,                  
                                0);                 
    child->noop();
}


void nbackroot::DoFileSysBackupNonADE(void) {
    fileoffset second_offset;
    
    const bool use_container(info->use_container);

    
    
    upath local_root(info->direlemp->fullpath());

    DB->msg("nbackroot::DoFileSysBackupNonADE -- non-adechunker ROOTPATH='%s' use_container:%d info->use_container:%d info->container.isnull():%d",
            *info->direlemp->fullpath().image(),
            use_container, info->use_container, info->container.isnull());
    
    workelem *w = new workelem(*info); 
    w->use_container = false;
    nbackdir* root_cycle = new nbackdir(  this,
                                w,
                                fileoffset(0),
                                true,               
                                !flags.nohiddendir, 
                                false,              
                                true,               
                                0,                  
                                0,                  
                                false,              
                                NULL,               
                                false,              
                                true,               
                                NULL,               
                                NULL,               
                                write_ddr_file      
    );

    
    nbackdir* root_dir = save_rootpath( root_cycle, info->path, second_offset, info->direlemp->is_mapi(), use_container );
    if (root_dir != root_cycle)
        root_dir->do_file_finish();

    
    
    
    if(!flags.backup_prefix.isempty())
    {
        upath original_root_path = info->direlemp->fullpath();
	
	
	
	
	
#if SYSTEM_WINDOWS
        
        
        
        const ustring check_prefix(flags.backup_prefix.chop());
#else
        const ustring check_prefix(flags.backup_prefix);
#endif
	if (original_root_path.image().equal(check_prefix))
	    original_root_path = local_root;
        if (nbackroot_msg) DB->msg("nbackroot::DoFileSysBackupNonADE -- original_root_path='%s'", *original_root_path.image());
        info->path = original_root_path;
        
    }

    
    if(info->direlemp->is_directory()) {
        if (nbackroot_msg) DB->msg("nbackroot::DoFileSysBackupNonADE nbackdir %p use_container:%d", this, cycle::main->getucontainer_yucky_global().isdefined());
        
        
        workelem *w = new workelem(info, info->path, info->direlemp); 

        cycle *child = create_nbackdir(
                                    root_dir,
                                    w,
                                    second_offset,
                                    false,          
                                    false,          
                                    false,          
                                    false,          
                                    0,              
                                    0,              
                                    false,          
                                    NULL,           
                                    use_container
                                    );

        child->noop();
    }
    else {  
        if (nbackroot_msg) DB->msg("nbackroot::DoFileSysBackupNonADE -- backing up a single file '%s'", *info->path.image());
        workelem *w = new workelem(info, info->path, info->direlemp); 
        cycle *child = new nbackfile(root_dir, w, second_offset);
        child->noop();
        if (nbackroot_msg) DB->msg("nbackroot::DoFileSysBackupNonADE created cycle nbackfile %p", child);
        Out->msg(VERBOSE, "%s", *info->fstats.fpath());
    }
}


void nbackroot::DoBackupBoostBackup(void)
{
    
    
    
    
    
    
    
    
    workelem *w = new workelem(info, upath("root"));
    nbackdir_manual_unc *root_cycle = new nbackdir_manual_unc(this,
                                         w,
                                         fileoffset(0),
                                         true,      
                                         true,      
                                         info->use_container);

    
    flags.parallel = true;
    if (flags.maxstreams <= 1) {
        flags.maxstreams = 1;
    }

    include targetlist = cycle::main->state->targets;
    stringlist targets = targetlist.includelist();
    location::tbackupid backupid;

    
    
    
    
    if (flags.backupboostmode != utar_flags_enums::bb_force_level0_full) {
        hfs_info_struct& hfs_info = getAdeMgr()->getHfsInfo(dpn0);
        utar_flags_info dstflags;  
        utar_commands uc(flags, hfs_info, dstflags);

        if (!uc.get_backuplist(backup_list, false, flags.count)) {
            Out->msg(INFO, "Attempting to perform synthetic full backup, but no previous backups found for this client.");
        } else {
            
            backup_list.sort(BackupRootInfoList::SortNewToOld);
        }
    }

    for (int targetNum = 0; targetNum < targets.size(); targetNum++) {
        upath target(targets[targetNum]);
        workelem *w = new workelem(info, target);
        
        
        upath entified_target(ndmp_entify_volume(targets[targetNum]));
        w->direlemp->set_fullpath(entified_target);
        w->direlemp->set_inode_number64(2);
        backstream *child = new backstream(root_cycle, cycle::main, w, flags.media_in, exportstream_infop, backupid, &backup_list, !flags.incremental);
        
        root_cycle->add_subcycle(child, false);
    }
    
    root_cycle->do_file_finish();
    root_cycle->do_stuff();

    destroy_workelem = false;
}



void nbackroot::DoBackupBoostConvert(void)
{
    if (bb_convert_phase == phase_filesys_backup) {
        
        
        info->container = cycle::main->initnextucontainer(info->direlemp, false, false);
        info->use_container = (info->container != NULL);
        
        
        
        write_ddr_file = false;
        
        const ustring err_insuff_privil    = "5136";    
        const ustring err_unable_open_file = "5137";    
        const ustring err_access_share     = "5139";    
        const ustring err_unable_open_dir  = "5244";    
        const ustring err_unable_read_sym  = "7878";    
        stringlist ignerr;
        ignerr.push_back(err_insuff_privil);
        ignerr.push_back(err_unable_open_file);
        ignerr.push_back(err_access_share);
        ignerr.push_back(err_unable_open_dir);
        ignerr.push_back(err_unable_read_sym);
        bb_new_add_ignore_error = DB->enter_ignerr_if_not_exist(ignerr);
        
        
        DoFileSysBackupNonADE();
        bb_convert_phase = phase_filesys_begin_full;
    } else if (bb_convert_phase == phase_filesys_backup_ro) {
        
        
        
        
        
        
        
        
        
        
        
        cycle::main->set_update_file_cache(false);
        
        
        ucontainer_finalized = false;
        
        
        info->container = cycle::main->initnextucontainer(info->direlemp, false, false);
        info->use_container = (info->container != NULL);
        
        DB->remove_ignerr_code(bb_new_add_ignore_error);
        
        
        
        
        DoFileSysBackupNonADE();
        bb_convert_phase = phase_filesys_end_full;
    } else if (bb_convert_phase == phase_metadata_convert) {
        ucontainer_finalized = false;
        cycle::main->set_ddr_loc_info_ignored(true);
        
        
        workelem* w = new workelem(NULL, info->direlemp);
        w->container = cycle::main->initnextucontainer(w->direlemp, false, true);
        w->use_container = (w->container != NULL);
        w->direlemp->set_hash(hash);
        w->path = target_path;
        w->dpninx = info->dpninx;
        
        
        backemctarinode2hash* child = new backemctarinode2hash(this, w, location::tbackupid(), true, false, bb_session_id);
        child->noop();
        bb_convert_phase = phase_convert_done;
    }
}




















void nbackroot::DoTargetDrivenFileSysBackup_NonADE(const stringlist& listOfTargets) {

    DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE");

    if (info->direlemp->is_mapi()) {
        Out->msg(output::SEV_ERR, "MAPI data detected in non-MAPI-safe code path");
        DB->msg("ERROR: MAPI data detected in non-MAPI-safe code path");
    }

    
    if (nbackroot_msg) (void)VerifyInfrastructureFunctionality();

    if (nbackroot_msg) listOfTargets.dump("list of targets");

    PathToNBackDirMapType mapOfTargets = CreateParentChildFreeMap(listOfTargets);

    
    
    workelem * w = new workelem(info, upath("root"));
    nbackdir_manual_unc * const backupRootNBackDir = new nbackdir_manual_unc(this, w, fileoffset(0),  !flags.nohiddendir,
            true, info->use_container);

    if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE top-level nbackdir(%p) created (aka 'backupRootNBackDir') for path'%s'; parent=%p",
            backupRootNBackDir, *info->path.image(), static_cast<cycle *>(this));

    
    
    
    typedef DEFINE_STL_VECTOR_TYPE(nbackdir_manual_unc *) PrefixVectorType;
    PrefixVectorType prefixNBackDirs;
    if (!flags.backup_prefix.isempty()) {
        const upath prefixPath(flags.backup_prefix.chop());
        stringlist prefixDirs;
        if (prefixPath.has_begin_dirsep()) {
            prefixDirs.push_back("/");
        }
        for (int i = 0; i < prefixPath.numelems(); i++) {
            prefixDirs.push_back(prefixPath.get(i));
        }
        nbackdir_manual_unc * prefixParent = backupRootNBackDir;
        int attr = ATTR_DIRECTORY;
        for (int i = 0; i < prefixDirs.size(); i++) {
            const ustring segment = prefixDirs[i];
            fileoffset prefixOffset = 0;
            DIRELEMp childde = NULL;
            prefixOffset = prefixParent->do_direlem(segment, attr, 0, true, false, &childde);
            assert(childde != NULL);
            if (childde != NULL) {
                childde->set_name(segment);
            }
            workelem * w = new workelem(info, (upath)segment, childde);  
            nbackdir_manual_unc * const prefixNBackDir = new nbackdir_manual_unc(prefixParent, w, prefixOffset, false, false,
                                info->use_container);
            if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE prefix nbackdir_manual_unc(%p) created for '%s'", prefixNBackDir, *segment);

            prefixParent->add_subcycle(prefixNBackDir, false);
            prefixNBackDirs.push_back(prefixNBackDir);

            prefixParent = prefixNBackDir;      
        }
    }

    typedef DEFINE_STL_VECTOR_TYPE(CycleToLaunch) CyclesToLaunchType;
    CyclesToLaunchType cyclesToLaunch;
    PathToNBackDirMapType previouslyCreatedCycles; 
    fileoffset next_offset = 0;
    for (PathToNBackDirMapType::iterator it = mapOfTargets.begin(); it != mapOfTargets.end(); it++) {

        upath target(it->first);
        if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE processing target:'%s'", *target.image());

        nbackdir_manual_unc * const parent = prefixNBackDirs.size() > 0 ? prefixNBackDirs[prefixNBackDirs.size() - 1] : backupRootNBackDir;
        if (nbackroot_msg) DB->msg("DoTargetDrivenBackup_NonADE::calling createNBackDirChain(parent=%p, path='%s', offset='%s', ismapi='%s'",
                parent, *target.image(), *next_offset.image(), info->direlemp->is_mapi() ? "true" : "false");

        upath parentPath;
        
        
        
        
        
        
        
        nbackdir_manual_unc * last_nbackman = create_nbackdirChain(parent, target, next_offset, info->direlemp->is_mapi(), previouslyCreatedCycles, parentPath, info->use_container);

        if (nbackroot_msg) previouslyCreatedCycles.dump("Previously Created nbackdir_manual Cycles");

        info->path = info->direlemp->fullpath();
        if ( nbackroot_msg ) {
            DB->msg("last_nbackman=%p parent.path='%s' last_nbackman.path='%s'", last_nbackman, *parentPath.image(), *(last_nbackman->getInfo()->direlemp->fullpath().image()));
            DB->msg("this(nbackroot): info.path='%s' de.path='%s'", *(this->getInfo()->path.image()), *(this->getInfo()->direlemp->fullpath().image()));
        }

        workelem * w = new workelem(info, parentPath, info->direlemp);  
        CycleToLaunch todo(last_nbackman, next_offset, w, parentPath);
        cyclesToLaunch.push_back(todo);
    }

    
    if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE Calling do_file_finish on root and prefix nodes");
    backupRootNBackDir->do_file_finish();

    for (PrefixVectorType::size_type i = 0; i < prefixNBackDirs.size(); i++) {
        prefixNBackDirs[i]->do_file_finish();
    }

    
    if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE Calling do_file_finish() on leaves");
    BackCycle * child = NULL;
    for (CyclesToLaunchType::iterator cit = cyclesToLaunch.begin(); cit != cyclesToLaunch.end(); cit++) {
        workelem *w = cit->w;
        if(w->direlemp->is_directory()) {
            if (nbackroot_msg)
                DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE creating nbackdir for path='%s' parent=%p, parentOffset=%s", *w->path.image(), cit->parent, *cit->parentOffset.image());

            child = create_nbackdir(cit->parent, w, cit->parentOffset,
                    false, false,
                    false, false,
                    0, 0,
                    false, cit->parent,
                    info->use_container);
            
            
            
            cit->parent->add_subcycle(child, child->getThreadNbr() != getThreadNbr());
            if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE created cycle nbackdir %p for %s", child, *w->path.image());
        }
        else {  
            if (nbackroot_msg)
                DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE -- creating nbackfile for path='%s' parent=%p, parentOffset=%s", *w->path.image(), cit->parent, *cit->parentOffset.image());

            
            
            
            
            BackCycle * starter = NULL;
            if (info->use_container && !flags.parallel) {
                starter = cit->parent;
            }
            child = new nbackfile(cit->parent, w, cit->parentOffset, starter);
            cit->parent->add_subcycle(child, (starter == NULL));
            if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE created cycle nbackfile %p for %s", child, *w->path.image());
        }
        child->noop();
    }

    
    if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE Calling do_file_finish on intermediate nodes");
    for (PathToNBackDirMapType::iterator it = previouslyCreatedCycles.begin(); it != previouslyCreatedCycles.end(); it++) {
        nbackdir_manual_unc * tmp = it->second;
        tmp->do_file_finish();
    }

    if (nbackroot_msg) DB->msg("nbackroot::DoTargetDrivenFileSysBackup_NonADE Calling backupRootNBackDir->do_stuff()");
    backupRootNBackDir->do_stuff();

}

bool nbackroot::DoBackupDirBackup(void)
{
    bool had_fatal_error(false);

    
    mediadesc mediad(flags.media_in);
    const location::media::type media(mediad.getmedia());
    const ustring mediatypestr(location::media::image(media));
    
    if(!mediad.valid()) {
        Out->msg(FATAL, "Invalid media specified for media-in %s", *mediatypestr);
        had_fatal_error = true;
    } else {
        const ustring basedirpath(mediad.getdirpath());
        const location::media::type media(mediad.getmedia());

        
        
        if(!basedirpath.isempty() &&
           (media == location::media::disk || media == location::media::magfs)) {
            
            if(!mediad.authenticate(flags.sysdir, flags.vardir)) {
                Out->msg(FATAL, "Authentication failed for media-in %s", *mediatypestr);
                had_fatal_error = true;
            } else {
                if(flags.ddrenabled && flags.ddrindex > 0 &&
                   BackCycle::main->getAdeMgr() && BackCycle::main->getAdeMgr()->isDDRenabled()) {
                    info->use_container = true;
                }

                workelem * w = new workelem(*info);
                if(cycle* mychild = new backupdir2backroot(this, cycle::main, w, mediad, exportstream_infop)) {
                    mychild->noop();
                    return true;
                } else {
                    Out->msg(FATAL, "Allocation of backup directory cycle failed");
                    had_fatal_error = true;
                }
            }
        } else {
            
            
            if (nbackroot_msg) DB->msg("nbackroot::DoBackupDirBackup media dirpath attribute was empty for media %s", *mediatypestr);
        }
    }

    
    if(had_fatal_error) {
        
        
        
        throw EXC_CANCEL;
    }

    return false;
}


DIRELEMp setup_rootde(const hashcode& roothash, location& newloc, const location::tcontainerid contid, const ustring& cid, const bool ddrenabled)
{
    if (partialdetails) {
        DB->msg("nbackroot::setup_rootde(%s, '%s', %s)", *roothash.partialimage(), *newloc.image(), *cid);
        DB->msg("nbackroot::setup_rootde: loc before '%s'", *newloc.image());
    }
    DIRELEMp rootde = new DIRELEM;
    rootde->set_name("");
    rootde->set_is_root_directory();
    rootde->set_hash(roothash);
    assert(newloc.get_backupid() != 0);
    newloc.setHash(roothash);
    
    
    if (ddrenabled) {
        newloc.setMedia(location::media::ddr);
        newloc.set_format(location::tformat::cdsf);
        newloc.set_containerid(contid);
    } else {        
        newloc.setMedia(location::media::gsan);
    }
    newloc.set_clientid(cid);
    newloc.clear_sizes();  
    
    if (partialdetails) DB->msg("nbackroot::setup_rootde: loc after  '%s'", *newloc.image());
    rootde->set_location(newloc, false);        
    return rootde;
}






bool nbackroot::DoPartialMerge(cycle *child, bool final)
{
    if (prevrootde.isnull()) {
        

        if (partial_lockp == NULL) {
            partial_lockp = new persistentlock(cycle::main, flags.path, flags.snapuptime);
            assert(partial_lockp);
            if (partial_lockp == NULL) {
                Out->Abort("Unable to allocate parallel synchronization lock for cumulative backups.");
                return false;
            }
        }
        if (!partial_lockp->lockit())   
        {
            Out->Abort("Unable to set lock for cumulative backup synchronization");
            return false;
        }

        
        if (!final && !info->container.isnull()) {
            
            
            cycle::main->finalizeucontainer(info->container, true);
        }
        
        flags.nohiddendir = partial_nohiddendir;
        
        partial_was_internal = flags.internal;
        flags.internal = true;
        
        roothashlistrec prev_rhl;
        ustring cid(flags.path);
        if (get_roothash(cycle::main, prev_rhl, prectime(flags.snapuptime), true, cid)) {
            hashcode prev_root(prev_rhl.getRoot());
            if (final) {
                
                
                
                flags.ddrindex = prev_rhl.getDDRIndex();
                flags.ddrenabled = flags.ddrindex != 0;
            }
            if (partialdetails) DB->msg("nbackroot::DoPartialMerge: prev root hash %s curr %s", *prev_root.partialimage(), *child->hash.partialimage());
            if (!final && prev_root == child->hash) {
                Out->Abort("Attempt to merge equal root hashes!");
                return false;
            }
            if (prev_root != hashcode::empty && prev_root != hashcode::zero) {
                
                
                
                
                
                
                bool ddrenabled(flags.ddrenabled || prev_rhl.getDDRIndex() != 0);
                if (!final)
                    ddrenabled &= info->use_container && !info->container.isnull();
                
                
                
                
                location prevloc;
                prevloc.set_backupid(location::tbackupid(prev_rhl.getMtime()));
                
                
                prevrootde = setup_rootde(prev_root, prevloc, 2, cid, ddrenabled);

                location currloc;
                if (final)      
                    currloc = prevloc;
                else {
                    currloc = info->direlemp->get_location();
                    
                    currloc.set_backupid(location::tbackupid(flags.snapuptime));
                }
                
                
                
                currrootde = setup_rootde(child->hash, currloc, final?2:1, cid, ddrenabled);

                if (partialdetails) {
                    DB->msg("nbackroot::DoPartialMerge merging partials; prev loc '%s'", *prevloc.image());
                    DB->msg("nbackroot::DoPartialMerge merging partials; curr loc '%s'", *currloc.image());
                }
                merged_info = new workelem(info, currrootde);
                backdirmerge *bdm = new backdirmerge(this, merged_info, prevrootde, currrootde, -1);
                bdm->noop();
                nforked++;
                return false;     
            }
        }
        DB->msg("nbackroot::DoPartialMerge: partial merge for %"LL"u time has no existing root.",
            flags.snapuptime);
        
    }
    
    if (partialdetails) {
        
        
        if (info->direlemp.isnull()) {    
            DB->msg("nbackroot::DoPartialMerge info->direlemp is NULL. Not calling get_location()");
        } else {
            DB->msg("nbackroot::DoPartialMerge: current info loc '%s'", *info->direlemp->get_location().image());
        }
        ustring msg("<nada>");
        if (merged_info) {
            if (merged_info->direlemp.isnull())     
                msg = ustring::sprintf("child's info %p direlemp is empty", merged_info);
            else msg = ustring::sprintf("child's info loc '%s'", *merged_info->direlemp->get_location().image());
        }
        DB->msg("nbackroot::DoPartialMerge: %s", *msg);
    }

    
    flags.internal = partial_was_internal;  
    if (final) {        
        if (partialdetails) DB->msg("nbackroot::DoPartialMerge Final complete. Setting flags.ddrenabled back to 'false'");
        flags.ddrenabled = false;
    }
    return true;
}

void unlock_partial(persistentlock*& partial_lockp)
{
    if (partial_lockp != NULL)
    {
        DB->msg("nbackroot unlock_partial attempting to unlock the partial backup %p", partial_lockp);
        if (!partial_lockp->unlock())
        {
            Out->msg(ERR, "Unable to unlock cumulative backup parallel synchronization");
        }
        delete partial_lockp;
        partial_lockp = NULL;
    }
}


void nbackroot::childdone(cycle *child)
{
    if (nbackroot_msg) DB->msg("nbackroot::childdone (this:%p) (child:%p) hash=%s", this, child, child == NULL ? "<null>" : *child->hash.partialimage());
    ustring errmsg;

    
    cycle::main->workctx->snapupoption = flags.backupstate;
    
    if(flags.snapuptime != 0)
        cycle::main->workctx->atime = flags.snapuptime;

    unsigned int status(flags.hiddensnapup ? RHL_UPDATE_BEGIN : cycle::main->workctx->snapupoption);
    bool final(flags.backupstate == utar_flags_enums::backstate_final);

    
    
    
    
    
    bool sealDDRok(true);

    if ((xflag[26]&8) && uapp::staging().canRun()) {
        
        Out->msg(WARN, "simulating cancelation...");
        uapp::cancel(EXIT_CANCELED);
    }

    if (!uapp::staging().canRun()) {
        DB->msg("nbackroot::childdone %s attempting incomplete backup******************", *uapp::staging().getRunStageImage());
        status = RHL_UPDATE_BEGIN;
        sealDDRok = false;      
    }

    if (flags.backupboost_convert) {
        backupboost::backupboost_interface bb_int;

        if (!bb_int.initialize()) {
            Out->Abort("BackupBoost begin full backup failed to load BackupBoost shared library");
            return;
        }

        if (bb_convert_phase == phase_filesys_begin_full) {
            
            int err_code = bb_int.begin_full_backup(target_path.image(), bb_session_id, token);
            if (err_code != LFS_SUCCESS) {
                Out->Abort("BackupBoost begin full backup failed to put mount path %s in read only mode: (%d: %s)",
                           *target_path.image(), err_code, *bb_int.err_code_to_desc(err_code));
                return;
            }
            cycle::main->add(TODO_DIR, this, false);
            bb_convert_phase = phase_filesys_backup_ro;
            return;
        } else if (bb_convert_phase == phase_filesys_end_full) {
            
            
            int err_code = bb_int.end_full_backup(token, bb_session_id);
            if (err_code != LFS_SUCCESS) {
                Out->Abort("BackupBoost end full backup failed and mount path %s may not be properly put back into read/write mode: (%d: %s)",
                           *target_path.image(), err_code, *bb_int.err_code_to_desc(err_code));
                return;
            }
            cycle::main->add(TODO_DIR, this, false);
            bb_convert_phase = phase_metadata_convert;
            return;
        } else if (bb_convert_phase == phase_convert_done) {
            set_ucontainer_finalized();
            
            
            const ustring paging_cache_file(flags.vardir / PAGING_FILENAME_CACHE_FILENAME);
            if (uwrapper::uunlink(paging_cache_file) != 0)
                Out->msg(WARN, "Delete of %s failed", *paging_cache_file);
            const ustring hash_cache_file(flags.vardir / HASH_CACHE_FILENAME);
            if (uwrapper::uunlink(hash_cache_file) != 0)
                Out->msg(WARN, "Delete of %s failed", *hash_cache_file);
            Out->msg(INFO, "File system backup conversion to BackupBoost backup for '%s' complete.", *target_path.image());
        }
    }

    
    status = get_status(status);

    assert(child != NULL);
    if(info->isapi) {
        info->resulthash = child->hash;
    } else {
        
        if(const backupdir2backroot* backupdir2backroot_childp = dynamic_cast<backupdir2backroot*>(child)) {
            
            if(backupdir2backroot_childp->does_backup_already_exist()) {
                
                todoEnqueue(TODO_DONE);
                notifyparent();
                return;
            }
        }

        cycle::main->final_resulthash = child->hash;
        if (flags.randchunk == 0) {
            if (flags.noroothash) {
                if (flags.backupstate == utar_flags_enums::backstate_partial) {
                    Out->Abort("Partial backup complete but has no root hash");
                    todoEnqueue(TODO_DONE);     
                    notifyparent();
                    return;
                } else
                    Out->msg(WARN, "<12129>Backup has no root hash -- Data may be reclaimed by GC since backup roothash was not entered");
            } else {
                
                
                
                
                
                
                
                
                
                const bool isDDR(flags.ddrenabled && flags.ddrindex > 0);
                bool overwrite(false);  
                const bool isndmp = ((flags.streamformat_in == utar_flags_enums::streamformat_emctar) ||
                                     (flags.streamformat_in == utar_flags_enums::streamformat_dump) ||
                                     (flags.streamformat_in == utar_flags_enums::streamformat_isilon) ||
                                     (flags.streamformat_in == utar_flags_enums::streamformat_zfs));
                if (nbackroot_msg) DB->msg("nbackroot::childdone sealDDRok %d, isDDR %d (use %d, null %d, ddr %d, ddrx %d), overwrite %d, isnmdp %d", sealDDRok, isDDR, info->use_container, info->container.isnull(), flags.ddrenabled, flags.ddrindex, overwrite, isndmp);
                if (cycle::main->final_resulthash == hashcode::empty) {
                    if (failonhashcodeempty && isndmp) {
                        Out->msg(FATAL, "<12128>Attempted to create a backup with no data, failing.");
                        
                        
                        if(cycle::main->histsrv) { delete cycle::main->histsrv; cycle::main->histsrv=NULL; }
                        uapp::staging().startTermination(EXIT_ABORT, "create a backup with no data?");
                        todoEnqueue(TODO_DONE);
                        notifyparent();
                        return;
                    }
                    if (flags.backupstate == utar_flags_enums::backstate_partial) {
                        Out->Abort("Partial backup complete but has no root hash");
                        todoEnqueue(TODO_DONE);     
                        notifyparent();
                        return;
                    } else
                        Out->msg(WARN, "<12129>Creating backup with roothash == hashcode::empty.");
                }

                
                
                
                if (flags.backupstate == utar_flags_enums::backstate_partial || final) {
                    if (!uapp::staging().canRun())
                        DB->msg("nbackroot::childdone: skipping partial merge");
                    else {
                        DB->msg("nbackroot::childdone: initiating partial merge");
                        if (!DoPartialMerge(child, final)) {    
                            todoEnqueue(TODO_DONE);     
                            notifyparent();
                            return;
                        }
                        overwrite = true;
                        
                        DB->msg("nbackroot::childdone: merge done isDDR %d overwrite %d", isDDR, overwrite);
                    }
                }

                

                
                
                
                ADEMgrX* adeMgr = BackCycle::main->getAdeMgr();

                roothashflags Rflags;
                Rflags.newformat = true;
                Rflags.unused = 0;
                Rflags.isencrypted = cycle::main->get_encmode() != fileref::encmode_none;  
                Rflags.retentiontype = tretentiontype(flags.retentiontype);
                if(adeMgr->isDDRenabled()) {
                    Rflags.ddrindex = (tddrindex)255; 
                } else if (flags.backupstate == utar_flags_enums::backstate_final) {
                    
                    Rflags.ddrindex = flags.ddrindex;
                } else { 
                    Rflags.ddrindex = (tddrindex)0;
                }
                backstats * const bkupstats = cycle::main->getstatsobj(context::backupstats);
                const double file_bytes_sent = bkupstats->get_filebytes_sent();
                Rflags.percentnew = (int)(file_bytes_sent*100.0/(bkupstats->get_filebytes_prog()+0.1));
                
                
                if((Rflags.percentnew == 0) && (file_bytes_sent>128*1024*1024))
                    Rflags.percentnew = 1;
                
                Rflags.plugin_num = flags.pluginid.number();
                if (flags.backupboost_convert) {
                    
                    const pidtype backupboost_pid(pidtype::os_linux, pidtype::backupboost);
                    Rflags.plugin_num = backupboost_pid.number();
                }
                Rflags.backuptype = tbackuptype(flags.backuptype);
                if (Rflags.backuptype == tbackuptype::unknown) Rflags.backuptype = tbackuptype::level0_full;    

                if (!(Rflags.retentiontype.get_errors().isempty()))
                    Out->msg(INFO, "<7567>%s -- Ignored.", *Rflags.retentiontype.get_errors());
                if (!(Rflags.backuptype.get_errors().isempty()))
                    Out->msg(INFO, "<7567>%s -- Ignored.", *Rflags.backuptype.get_errors());

                Rflags.appconsistenttype = tappconsistenttype(flags.app_consistent);

                
                rhlLabel label(*flags.label, *flags.backuptag, 0, 0);
                DB->msg("nbackroot::childdone label='%s', backuptag='%s', taghash=%d", *flags.label, *flags.backuptag, label.get_taghash());
                
                
                get_roothashflags(Rflags);
                get_label(label);
                get_snapup_timestamp(cycle::main->workctx->atime);
                bool retval(false);

                
                
                
                
                
                
                
                
                
                
                
                if (!ucontainer_finalized && info->use_container && flags.pluginid.kind() != pidtype::ndmp) {
                    DB->msg("nbackroot::childdone:%p calling finalizeucontainer(%p, true) before sealing backup with gsan",
                            this, info->container.getimpl());
                    cycle::main->finalizeucontainer(info->container, true);
                }

                
                
                
                if (partial_lockp != NULL) {    

                    roothashlistrec prev_rhl;   
                    
                    bool go_on(uapp::staging().canRun());
                    if (go_on) {
                        
                        ustring cid(flags.path);
                        if (!get_roothash(cycle::main, prev_rhl, prectime(flags.snapuptime), true, cid)) {
                            Out->Abort("Unable to retrieve current root hash from the server.");
                            go_on = false;
                        }
                    }
                    if (go_on && prevrootde->file_hash() != prev_rhl.getRoot()) {
                        Out->Abort("Backup %d lock integrity failure: root hash has changed since partial merge started: %s != %s",
                            flags.labelnum, *prevrootde->file_hash().partialimage(), *prev_rhl.getRoot().partialimage());
                        go_on = false;
                    }
                    if (!go_on) {       
                        unlock_partial(partial_lockp);
                        todoEnqueue(TODO_DONE);
                        notifyparent();
                        return;
                    }
                }

                
                backstats* my_stats(cycle::main->getstatsobj(context::backupstats));
                rhlLabel my_label(label);
                prectime expiretime;
                fileoffset totalsize;
                const ustring acntpath = backaxionfsp ? backaxionfsp->get_account_path() : ustring("");
                if (m_copying_backup && m_prev_acct_info_valid) {
                    my_label = m_prev_roothashlistrec.getLabel();
                    expiretime = m_prev_roothashlistrec.getExpires();
                    totalsize = m_prev_roothashlistrec.getTotalBytes();
                    Rflags = m_prev_roothashlistrec.getFlags(); 
                } else {
                    
                    
                    bool got_backup_expirestime(false);
                    if(flags.restore_backup_expirestime) {
                        ubigint64 tmp;
                        if(get_expires_time(tmp)) {
                            expiretime = tmp;
                            got_backup_expirestime = true;
                        } else {
                            Out->msg(WARN, "No expires time in backup metadata, setting backup expires time from flags");
                        }
                    }

                    
                    if(!got_backup_expirestime) {
                        bool ok;
                        expiretime = prectime::evalExpiresTime(flags.expires, ok);
                        if (!ok) Out->msg(ERR, "Invalid expiration value specified (%"LL"u) -- Backup will not expire", flags.expires);
                    }
                    totalsize = get_totalsize(cycle::main->getstatsobj(context::backupstats));
                }

                
                
                
                
                retval = true;  
                workcontextref& workctx(cycle::main->workctx);
                unsigned backupid(0);      
                ubigint64 backuptime(0);
                if (isDDR && sealDDRok) {
                    
                    
                    if (status == RHL_UPDATE_ONETIME || flags.hiddensnapup) {
                        
                        if (status == RHL_UPDATE_ONETIME) {
                            status = RHL_UPDATE_FINAL;  
                        } else if (status == RHL_UPDATE_BEGIN) {        
                            status = RHL_UPDATE_PARTIAL;  
                        }
                    }
                    if (nbackroot_msg) DB->msg("nbackroot::childdone Preparing primary seal for DDR: ok: %d, '%s'", sealDDRok, *my_label.image());
                    retval = adeMgr->commitBackup.addtoplevel2(dpn0, cycle::main->final_resulthash,
                                            my_stats,
                                            workctx->atime,
                                            workctx->etime,
                                            workctx->idnum,
                                            errmsg,
                                            my_label,
                                            RHL_UPDATE_BEGIN,
                                            expiretime,
                                            totalsize,
                                            Rflags,
                                            acntpath);
                    if (!retval || nbackroot_msg) DB->msg("nbackroot::childdone: backup created %d, id %s, seq %u, status %d, using %d", retval, *tostr(workctx->atime), +workctx->idnum, status, RHL_UPDATE_BEGIN);
                    if (retval) {
                        backupid = +workctx->idnum;    
                        backuptime = workctx->atime;
                        if (nbackroot_msg) DB->msg("nbackroot::childdone: DDR temp to final rename with overwrite %d", overwrite);
                        
                        if ((xflag[26]&16) || !adeMgr->renameDDRTempToFinal(overwrite)) {
                            if (xflag[26]&16)
                                Out->msg(WARN, "DDR rename failure simulation");
                            
                            
                            unlock_partial(partial_lockp);
                            Out->msg(FATAL, "DDR rename failure - backup will be deleted");
                            retval = false;       
                        }
                        if (nbackroot_msg) DB->msg("nbackroot::childdone: retval %d", retval);
                    } else {
                        DB->msg("nbackroot::childdone: seal attempt failed - preempting DDR rname (sealDDRok: %d)", sealDDRok);
                        adeMgr->modifyDDRTempToFinal(true); 
                    }
                    sealDDRok = retval;
                }

                
                
                if (retval) {
                    
                    if (!isDDR || sealDDRok) {
                        
                        if (nbackroot_msg) DB->msg("nbackroot::childdone: final seal (isDDR %d, ok %d)", isDDR, sealDDRok);
                        retval = adeMgr->commitBackup.addtoplevel2(dpn0, cycle::main->final_resulthash,
                                            my_stats,
                                            workctx->atime,
                                            workctx->etime,
                                            workctx->idnum,
                                            errmsg,
                                            my_label,
                                            status,
                                            expiretime,
                                            totalsize,
                                            Rflags,
                                            acntpath);
                        if (!retval || nbackroot_msg) DB->msg("nbackroot::childdone: backup #%u(%u), id %s(%s), sealed %d, status %d", +workctx->idnum, backupid, *tostr(workctx->atime), *tostr(backuptime), retval, status);
                    } else {
                        Out->Abort("Backup '%s' to DDR not sealed due to previous errors", *flags.label);
                        unlock_partial(partial_lockp);
                        todoEnqueue(TODO_DONE);     
                        notifyparent();
                        return;
                    }
                }
                
                
                if (!retval) {
                    if (backuptime != 0 && backupid != 0) {
                        
                        const ustring backupstr = ustring::sprintf("backup #%u timestamp %s", backupid, *tostr(backuptime));
                        DB->msg("nbackroot::childdone: deleting %s", *backupstr);
                        hfs_info_struct& hfs_info = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
                        acntmngr acnt(hfs_info.sync);
                        const blktraj block(hfs_info.blk);  
                        const authid  auth(hfs_info.auth);
                        const msgerrors rslt = acnt.delBackup(block, auth, backuptime, false, true);
                        if (rslt == MSG_ERR_NONE) {
                            Out->msg(INFO, "Deleted %s", *backupstr);
                        } else {
                            Out->msg(WARN, "Unable to delete invalid %s: '%s'", *backupstr, *message::err_image(rslt));
                        }
                        unlock_partial(partial_lockp);
                        todoEnqueue(TODO_DONE);     
                        notifyparent();
                        return;     
                    } else {
                        DB->msg("nbackroot::childdone: Unable to delete backup '%s' after error: id #%u, timestamp '%s'", *flags.label, backupid, *tostr(backuptime));
                    }
                } else {
                    
                    if(!exportstream_infop.isnull() && !workctx.isnull()) {
                        ubigint64 originalbackupcreatetime(0);
                        if(exportstream_infop->get_snapup_timestamp(originalbackupcreatetime)) {
                            workctx->original_backup_time = originalbackupcreatetime;
                        }
                    }
                }
            }   
        } else {
            
            Out->msg(INFO, "<7173>RANDCHUNK mode: No backup created");
        }
        
        if (nbackroot_msg)
            DB->msg("nbackroot::childdone -- %s %s", sealDDRok ? "added top level" : "root hash NOT added", *cycle::main->final_resulthash.partialimage());
    }   
    unlock_partial(partial_lockp);
    hfs_info_struct& hfsInfo = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
    if (hfsInfo.metaStore != NULL) {
        
        
        ubigint64 saveTime = 0;
        if (flags.media_out.isempty()) {
            
            
            nsAdeLib::ContextADE * ade = &nsAdeLib::ContextADE::getContext();   
            if (ade != NULL) {
                nsAdeLib::DDRComMgr * const ddrCom = ade->getDDRComMgr();
#if DDRSUPPORTED
                if (ddrCom != NULL) {
                    const ustring backupIdStr = ddrCom->getBackupID();
                    saveTime = backupIdStr.touint64(16);        
                }
#endif
            }
        }

        

        
        if (!saveTime) {
            saveTime = wintime(TIME32(0));       
        }

        
        
        hfsInfo.metaStore->closeBackup(saveTime);
    }

    DB->msg("nbackroot::childdone -- adding TODO_DONE");
    
    
    
    
    
    
    
    
    
    if (cycle::main->is_backupboost_threaded_backup())
        todoEnqueue(TODO_DONE, this);
    else
        todoEnqueue(TODO_DONE);
    
    
    if(cycle::main->histsrv) { delete cycle::main->histsrv; cycle::main->histsrv=NULL; }
    notifyparent();
}

void nbackroot::response(message& outargs) {
    if (nbackroot_msg) DB->msg("nbackroot::response (this:%p)", this);

    notifyparent();
}

void nbackroot::notifyparent() {
    if (nbackroot_msg) DB->msg("nbackroot::notifyparent (this:%p)", this);
    BackCycle::notifyparent();
    
}

nbackroot::~nbackroot() {
    DB->msg("nbackroot::~nbackroot:%p with info:%p and destroy_workelem:%d", this, info, destroy_workelem);
    if (!prevrootde.isnull()) {
        if (partialdetails) DB->msg("nbackroot::~nbackroot: prev loc was '%s'", *prevrootde->get_location().image());
        prevrootde.free();
    }
    if (!currrootde.isnull()) {
        if (partialdetails) DB->msg("nbackroot::~nbackroot: curr loc was '%s'", *currrootde->get_location().image());
        currrootde.free();
    }

    unlock_partial(partial_lockp);       

    if (info && destroy_workelem) {
        delete info;
        info = NULL;
    } else {
        
    }
}






bool nbackroot::find_prev_backup(BackupRootInfo &prevBackup, location::tbackupid &backupid)
{


        bool success(cycle::main->find_prev_backup(prevBackup));
        if(success) {
            DB->msg("nbackroot::find_prev_backup returning backupid:%s", *backupid.image());
            backupid = location::tbackupid(cycle::main->prev_backup.getBackupTime());
        }
        return (success);




}




bool nbackroot::populate_previous_ndmp_location(const BackupRootInfo &prev_backup, const location::tbackupid &backupid) {
    
    
    
    
    hfs_info_struct& hfsInfo = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
    DIRELEM de;
    ustring errdesc;
    upath vol_path = upath(flags.ndmp_prefix);
    upath target;
    location de_loc(de.get_location());

    
    de_loc.set_backupid(backupid);
    de.set_location(de_loc);
    DB->msg("nbackroot::populate_previous_ndmp_location(): looking up volume:%s", *flags.ndmp_prefix);
    if (!utar_commands::get_direlem(hfsInfo, cycle::main->get_flags(), prev_backup.getRootLocation(),
                                    vol_path, de, errdesc, target)) {
        
        Out->Abort("Failed to find volume %s in previous (base) backup", *flags.ndmp_prefix);
        return false;
    } else {
        
        
        const location parent_loc; 
        cycle::main->set_location_info("nbackroot::populate_previous_ndmp_location()", parent_loc, de);

        
        info->direlemp->set_location(de.get_location());
    }
    return true;
}










void nbackroot::get_label(rhlLabel& label) const
{
    if(!exportstream_infop.isnull()) {
        rhlLabel tmp;
        if(exportstream_infop->get_label(tmp)) {
            label = tmp;
        }
    }
}


const int nbackroot::get_status(const int status) const
{
    int ret(status);

    if(!exportstream_infop.isnull()) {
        int tmp;
        if(exportstream_infop->get_status(tmp)) {
            ret = tmp;
        }
    }

    return ret;
}


const fileoffset nbackroot::get_totalsize( backstats *statsp) const
{
    double totalbytes(-1);

    
    
    if(!exportstream_infop.isnull() && !flags.dtopartialimport) {
        if(!exportstream_infop->get_totalsize(totalbytes)) {
            
            assert(totalbytes < 0);
        }
    }

    if(totalbytes < 0) {
        if(statsp) {
            totalbytes = statsp->get_filebytes_prog();
        } else {
            totalbytes = 0.0;
        }
    }

    return (bigint64)totalbytes;
}


void nbackroot::get_roothashflags(roothashflags& rflags) const
{
    if(!exportstream_infop.isnull()) {
        roothashflags tmp(rflags);

        if(exportstream_infop->get_roothashflags(tmp)) {
            
            tmp.percentnew = rflags.percentnew;

            
            
            if(!flags.ddrenabled) {
                tmp.ddrindex = (tddrindex)0;
            } else {
                tmp.ddrindex = flags.ddrindex;
            }

            rflags = tmp;
        }
    }
}


void nbackroot::get_snapup_timestamp(ubigint64& timestamp) const
{
    
    
    
    
    
    
    
    if((((xflag[31]&524288) != 0) && flags.nemoresurrect) || flags.restore_backup_createtime) {
        ubigint64 tmp;
        if(!exportstream_infop.isnull() && exportstream_infop->get_snapup_timestamp(tmp)) {
            timestamp = tmp;
        }
    }
}


bool nbackroot::get_expires_time(ubigint64& expirestime) const
{
    if(flags.restore_backup_expirestime && !exportstream_infop.isnull()) {
        ubigint64 tmp;

        if(exportstream_infop->get_expires_time(tmp)) {
            expirestime = tmp;
            return true;
        }
    }

    return false;
}

PathToNBackDirMapType CreateParentChildFreeMap(const stringlist& listOfTargets) {
    PathToNBackDirMapType retMap;
    PathToNBackDirMapType::iterator it;
    upathlist descendents;
    upathlist::iterator descendentIt;
    bool addIt = false;

    for (int targetNum=0; targetNum < listOfTargets.size(); targetNum++) {
        upath tmp(listOfTargets[targetNum]);
        if (nbackroot_msg) DB->msg("examining '%s'", *tmp.image());
        if ((descendents = retMap.GetDescendentsOf(tmp)).size() > 0) {
            
            upathlist::iterator descendentIt = descendents.begin();
            while (descendentIt != descendents.end()) {
                upath tmp = *descendentIt;
                retMap.erase(tmp);
                ++descendentIt;
            }
            addIt = true;
        }
        if ((it = retMap.GetHighestAncestorOf(tmp)) == retMap.end()) {
            
            addIt = true;
        }

        if (addIt) {
            if (nbackroot_msg) DB->msg("Adding '%s'", *tmp.image());
            retMap[tmp] = (nbackdir_manual_unc *)NULL;
            addIt = false;
        }
    }

    

    if( nbackroot_msg ) retMap.dump("parent/child free map");

    return retMap;
}



bool VerifyInfrastructureFunctionality(void) {

    bool failed = false;

    if (SYSTEM_WINDOWS) {
        ustring tmpStr;

        upath tmp1("c:\\");
        tmpStr = tmp1.image();
        if (tmpStr != "c:\\") {
            DB->msg("tmp1 Failed");
            failed = true;
        }

        upath tmp2("c:\\shared1");
        tmp2.pop_back(true);
        tmpStr = tmp2.image();
        if (tmpStr != "c:\\") {
            DB->msg("tmp2 Failed");
            failed = true;
        }

        upath tmp3("c:\\shared1\\");
        tmp3.pop_back(true);
        tmpStr = tmp3.image();
        if (tmpStr != "c:\\") {
            DB->msg("tmp3 Failed");
            failed = true;
        }

        upath tmp31("\\\\win8node2-dkemp\\");
        tmpStr = tmp31.image();
        if (tmpStr != "\\\\win8node2-dkemp\\") {
            DB->msg("tmp31 Failed");
            failed = true;
        }

        upath tmp4("\\\\win8node2-dkemp\\");
        tmp4.pop_back(true);
        tmpStr = tmp4.image();
        if (tmpStr != "\\") {
            DB->msg("tmp4 Failed");
            failed = true;
        }

        upath tmp5("\\\\win8node2-dkemp\\shared1");
        tmp5.pop_back(true);
        tmpStr = tmp5.image();
        if (tmpStr != "\\\\win8node2-dkemp\\") {
            DB->msg("tmp5 Failed");
            failed = true;
        }

        upath tmp6("\\\\win8node2-dkemp\\shared1\\");
        tmp6.pop_back(true);
        tmpStr = tmp6.image();
        if (tmpStr != "\\\\win8node2-dkemp\\") {
            DB->msg("tmp6 Failed");
            failed = true;
        }

        PathToNBackDirMapType  test;
        test[(upath)"c:\\"] = (nbackdir_manual_unc *)1;
        test[(upath)"c:\\file1"] = (nbackdir_manual_unc *)2;
        test[(upath)"c:\\shared1\\"] = (nbackdir_manual_unc *)3;
        test[(upath)"c:\\shared2\\"] = (nbackdir_manual_unc *)4;
        test[(upath)"c:\\shared1\\foo\\"] = (nbackdir_manual_unc *)5;
        test[(upath)"c:\\shared1\\foo\\AAA\\"] = (nbackdir_manual_unc *)6;
        test[(upath)"c:\\shared1\\foo\\AAA\\111\\"] = (nbackdir_manual_unc *)7;
        test[(upath)"c:\\shared1\\foo\\AAA\\222\\"] = (nbackdir_manual_unc *)8;

        test.dump("test");

        PathToNBackDirMapType::iterator tit;

            
        tit = test.find((upath)"c:\\shared1");
        if (tit == test.end()) {
                Out->msg(DEBUG, "Find Test passed");
        }
        else {
            DB->msg("Find Test failed");
            failed = true;
        }

            
        tit = test.GetLowestAncestorOf((upath)"c:\\file2");
        if (tit != test.end() && tit->first.image() == "c:\\") {
                Out->msg(DEBUG, "LowestAncestor(c:\\shared2) Test passed: %s = %p", *(tit->first.image()), tit->second);
        }
        else {
            DB->msg("LowestAncestor(c:\\file2) Test failed.");
            failed = true;
        }

        tit = test.GetLowestAncestorOf((upath)"c:\\shared1\\foo\\XXX\\YYY\\");
        if (tit != test.end() && tit->first.image() == "c:\\shared1\\foo\\") {
    
        }
        else {
            DB->msg("LowestAncestor(c:\\shared1\\foo\\XXX\\YYY\\) Test failed.");
            failed = true;
        }

        tit = test.GetLowestAncestorOf((upath)"c:\\shared3\\foo\\XXX\\YYY\\");
        if (tit != test.end() && tit->first.image() == "c:\\") {
    
        }
        else {
            DB->msg("LowestAncestor(c:\\shared3\\foo\\XXX\\YYY\\) Test failed.");
            failed = true;
        }
    }   


    
    {
        PathToNBackDirMapType  test_linux;
        PathToNBackDirMapType::iterator tit;

        tit = test_linux.GetLowestAncestorOf(upath("/", upath::kind_unix));
        if (tit == test_linux.end() ) {
            Out->msg(DEBUG, "GetLowestAncestorOf(/ from empty map) Test passed");
        }
        else {
            DB->msg("LowestAncestor(/) Test failed.");
            failed = true;
        }


        test_linux[upath("/", upath::kind_unix)] = (nbackdir_manual_unc *)1;
        test_linux[upath("/usr/", upath::kind_unix)] = (nbackdir_manual_unc *)2;
        test_linux[upath("/tmp/", upath::kind_unix)] = (nbackdir_manual_unc *)3;
        test_linux[upath("/usr/test/", upath::kind_unix)] = (nbackdir_manual_unc *)4;
        test_linux[upath("/usr/test/file1", upath::kind_unix)] = (nbackdir_manual_unc *)5;
        test_linux[upath("/usr/test/file2", upath::kind_unix)] = (nbackdir_manual_unc *)6;

        test_linux.dump("test2");


        tit = test_linux.GetLowestAncestorOf(upath("x", upath::kind_unix));
        if (tit == test_linux.end() ) {
            Out->msg(DEBUG, "GetLowestAncestorOf(x) Test passed");
        }
        else {
            DB->msg("LowestAncestor(x) Test failed.");
            failed = true;
        }

        tit = test_linux.find(upath("/xxx", upath::kind_unix));
        if (tit == test_linux.end()) {
            DB->msg("Find Test passed");
        }
        else {
            DB->msg("Find Test failed");
            failed = true;
        }

        tit = test_linux.GetLowestAncestorOf(upath("/usr/test", upath::kind_unix));
        if (tit != test_linux.end() && tit->first.image(USE_UPATHKIND_DIRSEP(tit->first)) == "/usr/") {
            DB->msg("LowestAncestor(/usr/test) Test passed: %s = %p", *(tit->first.image(USE_UPATHKIND_DIRSEP(tit->first))), tit->second);
        }
        else {
            DB->msg("LowestAncestor(/usr/test) Test failed.");
            failed = true;
        }

        tit = test_linux.GetLowestAncestorOf(upath("/home", upath::kind_unix));
        if (tit != test_linux.end() && tit->first.image(USE_UPATHKIND_DIRSEP(tit->first)) == "/") {
            Out->msg(DEBUG, "LowestAncestor(/home) Test passed: %s = %p", *(tit->first.image(USE_UPATHKIND_DIRSEP(tit->first))), tit->second);
        }
        else {
            DB->msg("LowestAncestor(/home) Test failed.");
            failed = true;
        }

    }

    if (!failed) {
        DB->msg("Infrastructure test passed");
    }

    assert(!failed);
    return (!failed);


}

#if !defined(RESTMAIN_H_INCLUDED)
#define RESTMAIN_H_INCLUDED












#include "context.h"
#include "utar_flags_enums.h"
#include "utar_commands.h"


























class restoremain
{
public:
    restoremain(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const ustring& target);

    
    virtual bool run(bool multiple)=0;

    
    static bool check_xrest_option(const client_config_flags::restore_options_type option, const ustring& target, const assoc& srcdstlist);

    
    
    
    bool find_path_and_restore(const stringlist& frompaths, const ustring& target, bool multiple, const bool showerrormessage=true);

    virtual ~restoremain(void);

    SAFEPOOLALLOC(restoremain);

protected:
    utar_commands *utarcmd;
    context * const main;
    const hfs_info_struct& hfsInfo;
    const BackupRootInfo backupInfo;       
    utar_flags_info& flags;
    ustring restoretarget;          
    ustring saveastargetfilename;   
    bool isSaveas;      
    bool restOptionErr;

    
    
    void build_restorelist(stringlist& fromlist, fileoffset& estimatedsize);

    
    bool check_restoresize(const fileoffset& estimatedsize) const;

    
    bool check_restoreoption(const client_config_flags::restore_options_type option, assoc& srcdstlist);

    
    void uncify_target(void);

    
    bool is_vmwfs() const;

    fileoffset getvmfsfreespace(const char *path) const;
};

class singlepath_restore : public restoremain
{
public:
    singlepath_restore(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const ustring& frompath, const ustring& target);
    bool run(bool multiple);
    ~singlepath_restore(void);

    SAFEPOOLALLOC(singlepath_restore);

private:
    ustring restorefrompath;    

    bool BuildRestoreTargetPath(const ustring& snappath, bool lastGsanElementOnly, utar_commands::dirlistp &head);

#if SYSTEM_WINDOWS
    
    bool discover_sis_enabled_drives(const ustring& target);

    
    bool restore_sis_common_store(bool multiple);
#endif
};

class multipath_restore : public restoremain
{
public:
    multipath_restore(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const stringlist& frompaths, const ustring& target);
    bool run(bool multiple);
    ~multipath_restore(void);
    SAFEPOOLALLOC(multipath_restore);
private:
    stringlist restorefrompaths;

    void log_restorelist(const location& theloc, const ustring& target, const stringlist& list);

    bool log_restore_results(const bool success, const context* cmain);
};

#endif

#if !defined(DIRELEM_NETAPP_H_INCLUDED)
#define DIRELEM_NETAPP_H_INCLUDED












#include "common.h"
#include "memman.h"
#include "direlem.h"
#include "dumpdirelem.h"
#include "dirrec.h"
#include "debug.h"

class DIRELEM_netapp : public dumpDIRELEM {
public:
    DIRELEM_netapp()
      : dumpDIRELEM()
    {}

    DIRELEM_netapp(const DIRELEM& direlem)
      : dumpDIRELEM(direlem)
    {}

    void add_netapp_acl(int aclinode, const fileref& acldata);
    bool get_netapp_acl(int32_t& aclinode, fileref& acldata) const;

  
    void reset_netapp_LARA(const int namelen);
    void add_netapp_LARA(const int namelen, const fileref ldata);
    bool get_netapp_LARA(filereflist& datalist) ;

    SAFEALLOC(DIRELEM_netapp);
};

#endif


#if !defined(BACKUPDIR2BACKROOT_H_INCLUDED)
#define BACKUPDIR2BACKROOT_H_INCLUDED












#include "cycle.h"
#include "mediadesc.h"
#include "ddrfiles_xml.h"

class context;
class workelem;
class parsestream_base;
class exportstream_xmlp;

class backupdir2backroot : public BackCycle   
{

public:
  SAFEALLOC(backupdir2backroot);

  backupdir2backroot(BackCycle* parent_, context* main, workelem *info_, const mediadesc& mediaind_, exportstream_xmlp& infop, const location::tbackupid backupid = 0);

  bool does_backup_already_exist() const {
      return backup_already_exists;
  }

  virtual ~backupdir2backroot();

  virtual void init();
  virtual void childdone(cycle *child);

private:
  NOCOPY(backupdir2backroot);

  enum phases { initial,       
                stream,        
                listing,       
                done,
                fatalerror };

  
  bool initmediafileref(fileref& fr, const ustring& filepath) const;

  
  
  mediadesc* mediaindp;

  phases phase;

  
  
  exportstream_xmlp& exportstream_infop;

  
  ddrfiles_xml containers;

  
  const location::tbackupid prev_backupid;

  
  direlemp_list_type_sp m_delist_sp;

  
  
  
  bool backup_already_exists;
};


#endif

#if !defined(NBACKDIR_MANUAL_UNC_H_INCLUDED)
#define NBACKDIR_MANUAL_UNC_H_INCLUDED


























#include "hashcode.h"
#include "cycle.h"
#include "nbackroot.h"
#include "backhidden.h"
#include "backdataconsumer.h"
#include "backstream.h"

class priqueue;
class connection;
class backstats;
class profile;
class fileref;
class backstate;
class DIRELEM;
class workelem;
class context;
class nbackfile;

#include "sortdirwalk.h"


class nbackdir_manual_unc : public BackCycle, public hiddendirfuncs, backdataconsumer::producer {
public:
    nbackdir_manual_unc(BackCycle *parent, workelem *info_, fileoffset offset,
                     bool reserve_hiddendir=false,  bool top_level_=false,
                    const bool usecontainer=false
                   );
    virtual ~nbackdir_manual_unc();

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();

    
    virtual void do_file_finish();  
    virtual void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false);

    fileoffset do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink=false, DIRELEMp *direlemp=NULL );

    
    bool do_stuff();

    
    
    
    fileoffset add_direlem(DIRELEMp de, bool haschild=false); 

    
    
    
    void add_subcycle(BackCycle* subcycle, bool alreadyEnqueued);



    SAFEPOOLALLOC(nbackdir_manual_unc);

    
    typedef undoo::vector< scalar<nbackdir_manual_unc*> > nbackdir_manual_unc_vector;
    typedef undoo::vector< scalar<nbackdir*> > nbackdir_vector;
    typedef undoo::vector< scalar<nbackfile*> > nbackfile_manual_subcycles;
    typedef undoo::vector< scalar<backstream*> > backstream_vector;

private:
    void do_stuff_ucontainer_pre();
    void do_stuff_ucontainer_post();


    direlemp_list_type *elements;       
    nbackdir_manual_unc_vector nbackdir_manual_unc_subcycles;
    nbackdir_vector nbackdir_subcycles;
    nbackfile_manual_subcycles nbackfile_subcycles;
    backstream_vector backstream_subcycles;


    int          fillindex;             
    int          sendindex;             
    int          drainindex;            

    bool         more_dirgroups;        
    bool         flush_listing;         
    int          maxgroupentries;       
    int          maxsendentries;        
    int          group_count;           
    int          entry_count;           

    bicycle *    datachild;             
    DIRELEMp     hiddendirp;            

    bool         top_level;             

    int          traverse_depth;        
    fileoffset   sizeofchildren;        
    mtex         elements_mut;          

    bool   use_container;         

    recursive_mutex   countersMutex;

    fileoffset add_element(DIRELEMp de);

    bool reserve_hiddendir;
    fileoffset hiddenoff;   

    
    int manual_index;
    int nbackdir_index;
    int nbackfile_index;
    int backstream_index;
    bool doneAddingSubcycles;
    bool ddrDirClosed;


    
    bool processSubcycles();
    inline bool exitProcessSubcycles(bool somethingOutstanding);

  
    bool modify_child_de(const cycle* child); 
    bool spawn_hiddendir(const cycle *child); 
    bool do_flush_listing();                  

    
    virtual fileref nextdatablock(bool& suppress_requeue);
    bool synth_direlem(DIRELEMp de);
    virtual void cancelled();

    bool ShouldDoUcontainerPost(const cycle * child) const;

    
    virtual void setnext(todo_kind kind, cycle *next, const bigint64 priority);

}; 


#endif
#if !defined(ISILONTARPIPE_H_INCLUDED)
#define ISILONTARPIPE_H_INCLUDED












#include "pipe_control.h"
#include "fileref.h"
#include "direlem.h"
#include "ustring.h"
#include "userid.h"
#include "paxndmp.h"

class isilontarpipe : public pipe_control {
public:
    
    isilontarpipe(fileref& data_);

    bool addfile(const DIRELEM& elem,
                 const ustring& path,
                 fileref& dataslice,
                 fileref& altdataslice,
                 fileref& stubdataslice,
                 fileref& gsanextentsdata,
                 const filetype ftype = REGTYPE,
                 const ustring& linkname = "",
                 const fileoffset startoff = fileoffset(0));

    void set_data_slice(const fileref& hdrslice, const ustring& desc);
    void init_data_slice(fileref& dataslice, const fileoffset& size, const ustring& desc);
    void padd_end(fileoffset& size_of_stream);

    SAFEALLOC(isilontarpipe);

protected:
    
    
    
    virtual bool fillheader(fileref& header, fileoffset& filesize,
                            fileoffset& altdatasize, fileoffset& stubdatasize,
                            const DIRELEM& elem,  const ustring& path,
                            const filetype ftype, const ustring& linkname,
                            const fileoffset startoff = fileoffset(0)) { return true; }
};

#endif
#include <algorithm>

#include "common.h"
#include "debug.h"
#include "output.h"
#include "emctar_history.h"
#include "msgpack_c.h"
#include "timer.h"
#include "context.h"
#include "message.h"
#include "runstage.h"
#include "file.h"
#include "cycle.h"
#include "histmap.h"

















































#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define dumphist  ((xflag[14]&131072)!=0)  

emctar_history::emctar_history(context *main,
                           upath fifopath, upath savehistpath)
  : todoqueue('n'),
    readhist_thread(NULL),
    processhist_thread(NULL),
    flags(main->get_flags())
{
    DB->msg(DBTXT("emctar_history::emctar_history starting fifopath:%s"),
            *fifopath.image());

    readhist_thread = new readhist(todoqueue, fifopath, savehistpath, histsem, this);
    processhist_thread = new processhist(todoqueue, this);
    readhist_thread->start();
    processhist_thread->start();
}

emctar_history::~emctar_history() {
    DB->msg("emctar_history::~emctar_history");
    todoqueue.terminate();
    histsem.signal();
    readhist_thread->kick();
    readhist_thread->wait();
    processhist_thread->wait();
    delete readhist_thread;
    delete processhist_thread;
}

void emctar_history::data_stream_done() {
    DB->msg(DBTXT("emctar_history::data_stream_done, signal the history stream reader..."));
    histsem.signal();
    readhist_thread->wait();
    if (flags.ndmpmemthrottlethresh <= 0) {
        
        
        DB->msg(DBTXT("emctar_history::data_stream_done terminating todoqueue"));
        todoqueue.terminate();
    }
    DB->msg(DBTXT("emctar_history::data_stream_done--"));
}

void emctar_history::send(BackCycle* cycle, message& m) {
    if(msg2)DB->msg(DBTXT("emctar_history::send enqueuing message '%s'"), *m.ximage());
    const bool willPackOK = (sizeof(void*) <= sizeof(time_t)); 
    assert(willPackOK);   
    m.info().sendtime = (time_t)cycle;  
    m.info().connection = -1;       
    todoqueue.enqueue(m);
}


emctar_history::readhist::readhist(msgqueue& todoqueue_, upath fifopath, upath savehistpath_, semaphore& histsem_, emctar_history *parent_)
  : todoqueue(todoqueue_),
    fifo(namedpipe::inbound, fifopath),
    savehistpath(savehistpath_),
    histsem(histsem_),
    parent(parent_),
    is_done(false),
    msg_count(0)
{
    setdesc(ustring::sprintf("rhist"));
}

emctar_history::readhist::~readhist() {
    DB->msg(DBTXT("emctar_history::readhist::~readhist calling wait()..."));
    wait();
    DB->msg(DBTXT("emctar_history::readhist::~readhist done"));
}

static char buf[8192];
static int buflen;
static int bufidx;


static ustring readline(int d) {
    char res[8192];
    int i=0;
    while(1) {
        while (bufidx < buflen) {
            const char c = buf[bufidx];
            if (c == '\n') {
                res[i] = 0;
                if(i > 0) {
                    bufidx++;
                    return ustring(res);
                }
            } else if (c != '\r') {
                if (i >= (int)sizeof(res)) {
                     res[sizeof(res)-1]=0;
                     Out->msg(ERR, "<10762>emctar_history readline: Line too long, truncating: '%s'", res);
                     return ustring(res);
                }
                res[i++]= c;
           }
            bufidx++;
        }

        bufidx = 0;
        buflen = ::read(d, buf, sizeof(buf));
        if (buflen <= 0) {
            if (buflen < 0) Out->msg(ERR, "<10763>emctar_history readline: I/O error (%d, errno=%d) on fd %d", buflen, errno, d);
            return "";
        }
    }
}

void emctar_history::readhist::body() {
    DB->msg(DBTXT("emctar_history::readhist::body start"));

    bool mainloopdone = false;

    
    if(!fifo.connect()) {
        Out->msg(FATAL, "<7235>Cannot open history stream for reading, files will not be deleted");
        DB->msg(DBTXT("emctar_history::readhist::body exiting body with error"));
        todoqueue.terminate();
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "cannot open history stream for read");
        mainloopdone=true;   
    }
    DB->msg(DBTXT("emctar_history::readhist::body connected to history pipe"));

    file savehist;
    if (!savehistpath.isempty()) {
        if (!savehist.open(savehistpath.image(), O_RDWR | O_CREAT | O_TRUNC)) {
            Out->msg(ERR, "<8665>NDMP history reading thread failed to open or create file '%s' for saving history stream",
                                   *savehistpath.image());
        } else {
            Out->msg(INFO, "<8666>NDMP history reading thread opened file '%s' to save history stream",
                     *savehistpath.image());
        }
    }

    sum_timer sumt;
    while(!mainloopdone && uapp::staging().canRun()) {
        
        
        
        ustring oneline(readline(fifo.filedescriptor()));
        
        if(oneline.bytelength() == 0) { 
            DB->msg(DBTXT("emctar_history::readhist::body end of file"));
            break;
        }
        if (savehist.isopen()) {
            savehist.append(*oneline, oneline.bytelength());
            savehist.append("\n", 1);
        }

        message m;
        msgpack_c::ndmphistlistline nhll(m);
        nhll.arg(PACK, oneline);
        m.setresponsecode(MSG_ERR_NONE);
        m.setflag(MSGFLAG_NOACK);
        msg_count++;
        
        todoqueue.enqueue(m);

        savehist.close();
        sumt.check_cputime_update("ndmpreadhist");
    }
    is_done = true;

    DB->msg(DBTXT("emctar_history::readhist::body finished reading fifo, wait for data stream to signal us"));
    histsem.wait();
    DB->msg("emctar_history::readhist::body--");
}





emctar_history::processhist::processhist(msgqueue& todoqueue_, emctar_history *parent_)
    : todoqueue(todoqueue_), parent(parent_), mainloopdone(false), todoqueue_terminated(false)
{
    setdesc(ustring::sprintf("phist"));
}

emctar_history::processhist::~processhist() {
    DB->msg("emctar_history::processhist::~processhist");
    terminate();
    wait();
    DB->msg(DBTXT("emctar_history::processhist::~processhist done"));
}

void emctar_history::processhist::terminate() {
    DB->msg("emctar_history::processhist::terminate()");
    todoqueue.terminate();
    kick();
}

void emctar_history::processhist::body() {
    if(msg2)DB->msg("emctar_history::processhist::body");

    bool todoqueue_terminated = false;
    static size_t count_ndmp_histlistline_processed = 0;

    bool some_processed(false);
    while(uapp::staging().canRun() && !todoqueue_terminated) {
        int waittime(10000);       
        
        message m = todoqueue.dequeue(todoqueue_terminated, waittime);
        
        if(todoqueue_terminated) {
          DB->msg(DBTXT("emctar_history::processhist::body todoqueue terminated %d"), todoqueue_terminated);
          break;
        }

        if (m.requestcode() == NO_MESSAGE) {
            
            
            
            
            
            
            
            
            

            

            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("emctar_history::processhist::body handled %"Z"d NDMPHISTLISTLINE "
                        "messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
            }

            continue;
        }

        
        
        
        
        

        some_processed = true;

        
        
        switch(m.requestcode()) {
        case CLIENTONLY_GETNDMPHISTLIST64:
            handle_getndmphistlist(m);
            break;
        case CLIENTONLY_NDMPHISTLISTLINE:
            count_ndmp_histlistline_processed++;
            handle_ndmphistlistline(m);
            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("processhist::body handled %"Z"d NDMPHISTLISTLINE messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
	        }
            break;
        default:
            DB->msg(DBTXT("emctar_history::processhist::body strange message %s"), *m.image());
            continue;
        }
        
    }

    if (some_processed && (parent->flags.ndmpmemthrottlethresh <= 0)) {
        
        
        mark_eof_history();
    }

    
    
    inode_obj_t inode;
    message m;
    if (todoassoc.size() > 0) {
        Out->msg(ERR, "<8667>NDMP history processing thread has read all file history data and is unable to answer remaining %u GETNDMPHISTLIST messages from the data processing thread",
                 todoassoc.size());
    }
    while (todoassoc.pop(inode, m)) {
    	postprocess_getndmphistlist(inode, m);
    }
    DB->msg(DBTXT("emctar_history::processhist::body done"));
}

void emctar_history::processhist::mark_eof_history()
{
	ubigint64 n = historytree.lastparent_done();
    DB->msg("emctar_history::processhist::mark_eof_history lastparent_done inode:%s",*tostr(n));
    attempt_answer(n);
}




void emctar_history::processhist::handle_getndmphistlist(message &m)
{
    msgpack_c::getndmphistlist64 thl(m);
    ubigint64 queryinode(0);
    thl.arg(UNPACK, queryinode); 

    
    
    

    message preexistingmsg;
    bool entered = false;
    {
        scope s(todomut);
        entered = todoassoc.enter_if_undef(queryinode, m, preexistingmsg);
    }
    if (!entered) {
        Out->msg(WARN, "<10764>NDMP history processing thread received another message requesting history for directory with inode %s",
        		*tostr(queryinode));
    }

    
    
    if (historytree.answer_ready(queryinode)) {
        
        attempt_answer(queryinode);
    }
}


bool
emctar_history::processhist::handle_ndmphistlistline(message &m)
{
    msgpack_c::ndmphistlistline nhll(m);
    ustring oneline;
    nhll.arg(UNPACK, oneline);

    
    

    xml_messagep mess(new xml_message(oneline, true));

    ustring cmd(mess->valid() ? mess->getcommand() : "invalid");
    if ((cmd != "hist") && (cmd != "node")) {
        Out->msg(ERR, "<7236>unknown history string: '%s'", *oneline);
        return false;
    }

    if(dumphist) DB->msg("emctar_history::processhist::read_and_enter_xml xml: %s", *mess->simage());

    if (cmd == "hist") {
        const ubigint64 num    = mess->getstring("num").touint64();
        const ubigint64 parent = mess->getstring("parent").touint64();

        
        ustring name   = xml_message::fromathexat(mess->getstring("name"));

        if(msg2)DB->msg(DBTXT("emctar_history::processhist::read_and_enter_xml read hist num:%s parent:%s name:%s"), *tostr(num), *tostr(parent), *name);

        
        
        
        
        ubigint64 finished_inode = historytree.enter_hist(this, num, parent, name);

        if (finished_inode > 0) {
            attempt_answer(finished_inode);
        }
    }

    
    return true;
}

void
emctar_history::processhist::attempt_answer(ubigint64 dirinode)
{
    histvector_t *names = NULL;
    message m;

    {
        scope s(todomut);
        m = todoassoc.lookup(dirinode);
        if (m.isnull()) {
            if (msg2) DB->msg("emctar_history::processhist::attempt_answer inode:%s - no outstanding GETNDMPHISTLIST64 message for this inode",
            		        *tostr(dirinode));
            return; 
        }

        names = historytree.get_names(dirinode);
        if (names == NULL) {
            if (msg2) DB->msg("emctar_history::processhist::attempt_answer inode:%s - no answer for GETNDMPHISTLIST64 message for this inode yet",
                            *tostr(dirinode));
            return; 
        } else {
            if (msg2) {
                DB->msg("emctar_history::processhist::attempt_answer DEBUG DUMP histlist:%p for inode %s with %"Z"u entries",
                        names, *tostr(dirinode), names->size());
                for (histvector_t::const_iterator i=names->begin(); i!=names->end(); i++) {
                    DB->msg("    name:'%s' inode:%s", *((*i).key_string), *tostr((*i).key_number));
                }
            }
        }

        
        
        todoassoc.remove(dirinode);
    }

    assert(m.info().connection == -1);
    BackCycle *cycle = (BackCycle*)m.info().sendtime;

    msgpack_c::getndmphistlist64 thl(m);
    ubigint64 queryinode(0);
    thl.arg(UNPACK, queryinode); 
    assert(dirinode == queryinode);

    bool goodresult(true);
    ubigint64 namesptr = (ubigint64)((ptrint)names);
    thl.res(PACK, goodresult, namesptr);
    if (msg2) DB->msg("emctar_history::processhist::attempt_answer inode %s sending goodresult:%d namesptr:%p",
                      *tostr(dirinode), goodresult, (void*)namesptr);
    sendResponse(cycle, m);
}

void
emctar_history::processhist::postprocess_getndmphistlist(ubigint64 queryinode,
                                                          message &m)
{
    assert(!m.isnull());
    assert(m.info().connection == -1);   
    BackCycle* cycle = (BackCycle*)m.info().sendtime;
    histvector_t *names = historytree.get_names(queryinode, true);
    if (!names) {
        
    }

    msgpack_c::getndmphistlist64 mp(m);
    ubigint64 dirinode(0);
    mp.arg(UNPACK, dirinode); 
    assert(queryinode == dirinode);

    Out->msg(INFO, "<10765>    DEBUG: answering GETNDMPHISTLIST64 message:%s for dir inode:%s with done=false and best effort data histlist:%p",
             *m.ximage(), *tostr(dirinode), names);

    bool done = false;
    ubigint64 namesptr = (ubigint64)((ptrint)names);

    mp.res(PACK, done, namesptr);
    sendResponse(cycle, m);
}





void emctar_history::processhist::sendResponse(BackCycle* cycle, message &m)
{
    
    cycle->enqueueResponse(cycle, m, false);
}



emctar_history::processhist::historytree_class::~historytree_class()
{
    scope s(m);
    DB->msg(DBTXT("historytree_class::~historytree_class with %"Z"u entries in nodes"),
            nodes.size());

    if (0) {
        if (nodes.size()) {
            DB->msg (DBTXT("  nodes entries:"));
            for (iter i = nodes.begin(); i != nodes.end(); i++) {
                DB->msg (DBTXT("    %s -> %s"), *tostr(i->first), *i->second.image());
            }
        }
    }
}



ubigint64
emctar_history::processhist::historytree_class::lastparent_done()
{
    if (lastparentinode != 0) {
        iter old = nodes.find(lastparentinode);

        
        
        
        

        old->second.isdone = true;
        if (msg2) DB->msg("emctar_history::processhist::historytree_class::check_lastparent_done set done=true for inode:%s",
                         *tostr(lastparentinode));
        return lastparentinode;
    }

    return 0;
}

ubigint64
emctar_history::processhist::historytree_class::enter_hist(processhist *ph,
                                                           ubigint64 inode,
                                                           ubigint64 parentinode,
                                                           const ustring &name)
{
	ubigint64 ret = 0;

    scope s(m);

    if ((parentinode != lastparentinode) ) {
        ret = lastparent_done();
        lastparentinode = parentinode;
    }

    dirrecord &dr(nodes[parentinode]); 
    assert(dr.names != NULL);          

    dr.names->push_back(composite_key(inode, name));

    
    return ret;
}

histvector_t *
emctar_history::processhist::historytree_class::get_names(ubigint64 inode, bool accept_unready)
{
    scope s(m);

    iter i = nodes.find(inode);
    if (i == nodes.end()) {
        return NULL;
    }

    if (!i->second.isdone) {
        if (!accept_unready) return NULL;
    }

    histvector_t *result = i->second.names;
    nodes.erase(i);

    return result;
}

bool
emctar_history::processhist::historytree_class::answer_ready(ubigint64 queryinode) const
{
    scope s(m);
    nodemap::const_iterator i = nodes.find(queryinode);
    if (i == nodes.end()) return false;
    if (i->second.isdone) return true;

    return false;
}

































































#include "common.h"
#include "debug.h"
#include "restdir.h"
#include "restdata.h"
#include "todoelem.h"
#include "context.h"
#include "output.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "pipe_control.h"
#include "backdump.h"
#include "utar_commands.h"
#include "backstate.h"
#include "backview.h"
#include "platerror.h"
#include "emctarpipe.h"
#include "restdirpart.h"

#if SYSTEM_WINDOWS
#include "ntsecurity.h"
#include "winpriv.h"
#endif

#ifdef USEADE  
#include "msgpack_c.h"
#include "ade_mgrx.h"
#endif

#include "MetadataStore.h"

#include "dirrec_pack.h"   
#include "data_regions.h"  
#include "emctarstream.h"  

#include "isilontarstream.h"  
#include "restzfssslicefile.h"
#include "zfstarpipe.h"








#define msg1  ((xflag[2]&8)!=0)
#define sslice_msg false

#define dowfs ((xflag[15]&2)==0)




#define MAXRESTDIRS  1
#define MAXRESTFILES 10

enum phases { phase_init = 0,
              phase_sslice_header,
              phase_body };























restdir::restdir(cycle *parent,
                const location& _metadataLocation,
                 const restelem& restinfo, cycle *starter,
                 dumpcontext::dirlistelem *dumpparent_,
                 bool excluded_, int traverse_depth_,
                 bool waspreexisting)
  : cycle(parent),
    ADERestore(parent->main),
#if !NOADECHUNKER
    listingProvider(parent->main),
#endif
    info(restinfo),
    metadataLocation(_metadataLocation),
    altdatachild(NULL),  
    securitychild(NULL),
    dephashes_restored(false),
    dumpparent(dumpparent_), 
    traverse_depth(traverse_depth_),
    altstreamsize(0),
    preexisting(waspreexisting),
    threadStarter(false),
    threadShutdown(false),
    regulator(NULL),
    phase(phase_init)
{

    if (msg1) {
            DB->msg("restdir(%p)::restdir() parent=%p thread:%d metadataloc='%s' destPath='%s'",
                this, parent, getThreadNbr(), *metadataLocation.image(), *info.path.image());
    }

#if !NOADECHUNKER
    if(parent->main->ADEChunkerEnabled())
        listingProvider.setup(this, this);      
#endif

    if (metadataLocation.isFromCatalog()) {
        if (msg1) {
            DB->msg("restdir(%p)::restdir() CATALOG restore of %s", this, *metadataLocation.image());
        }
        this->hash = hashcode::zero;
    }
    else {
        this->hash = metadataLocation.getHash();
    }
    cyexcluded = excluded_;
    cyisdirectory = true;
    
    assert(info.direlem.is_directory() || info.direlem.is_symlink());

    main->num_open_dirs++;
    ustring dirName(info.path.image());

    const location loc(info.direlem.get_location());
    if (msg1) {
        DB->msg("restdir::restdir DIR LOCATION '%s' is %s", *info.path.image(), *loc.image());
        DB->msg("restdir::restdir DIR EMD: %s", *info.direlem.loc_image());
    }

    multivolumeroot* root_info = getrootinfo();
    
    
    const upath pathToCheck(restinfo.direlem.fullpath());
    if (root_info != NULL && isNewStreamThreadOK(getThreadNbr(), pathToCheck)) {
        
        info.container = NULL;

        
        todoEnqueue(TODO_RESPONSE, EMPTYCYCLE);

        
        if (msg1) DB->msg( DBTXT("restdir::restdir() '%s' changing track (parent:%p) (this:%p)"), *dirName, parent, this );
        if (flags.parallel_type == utar_flags_enums::parallel_by_volume)
            threadStarter = root_info->enqueueOnVolumeThread(info.path, TODO_DIR, this, -traverse_depth, NULL);
        else
            threadStarter = root_info->enqueueOnNewThreadRC(dirName, TODO_DIR, this, -traverse_depth);
#if !NOADECHUNKER
        if(parent->main->ADEChunkerEnabled())
            listingProvider.setThreadNbr(cycle::getThreadNbr());
#endif
    }
    else { 
        if ((xflag[21]&32)!=0) {    
            if(starter)
                starter->setnext(TODO_DIR, this, 0);
            else
                todoEnqueue(TODO_DIR, this); 
        } else {
             
            if(starter)
                starter->setnext(TODO_DIR, this, -traverse_depth);
            else
                todoEnqueueInsert(TODO_DIR, this, -traverse_depth);
        }
    }
}

bool restdir::spawn_sslice_header_restore()
{
    ubigint64 sslicesize;
    unsigned char hashoff;
    dirrec_pack::streamslice s(&info.direlem);
    if (!s.get(sslicesize, hashoff)) {
        Out->msg(ERR, "Unable to extract streamslice dirrec for directory '%s' during restore; ACLs will be lost",
                 *info.direlem.fullpath().image());
        return false;
    }

    
    
    
    
    
    hashcode slicehash(hashcode::zero);
    
    
    if (info.direlem.get_location().isFromGsan()) {
        hashvect dephashes;
        info.direlem.getdephashes(dephashes);
        if (dephashes.size() <= (size_t)(hashoff+1)) {
            Out->msg(ERR, "Expected dependent hash[%u] (zero indexed) to contain streamslice data for directory '%s' during restore, but only %s dephashes are present; ACLs will be lost",
                     hashoff+1, *info.direlem.fullpath().image(), *::tostr(dephashes.size()));
            return false;
        }
        slicehash = dephashes[hashoff+1];
    }

    data_regions::endoffsets_t eoff;
    dirrec_pack::regions r(&info.direlem);
    if (!r.get(eoff)) {
        Out->msg(ERR, "Unable to find data regions dirrec for streamslice data for directory '%s' during restore; ACLs will be lost",
                 *info.direlem.fullpath().image());
        return false;
    }
    fileoffset a, b;
    if (!data_regions::findrange(eoff, data_regions::header, true, a, b)) {
        Out->msg(ERR, "No header data indicated in data regions dirrec for streamslice data for directory '%s' during restore; ACLs will be lost",
                 *info.direlem.fullpath().image());
        return false;
    }

    if (b > fileoffset(sslicesize)) {
        Out->msg(ERR, "Found endoffset for header data of %s, but streamslice data only contains %"LL"u bytes for directory '%s' during restore; ACLs will be lost",
                 *b.image(), sslicesize, *info.direlem.fullpath().image());
        return false;
    }

    ustring errmsg;
    cycle *child = cycle::restore_range(slicehash, 0, b, true, sslicebuf, errmsg, info.direlem, info.container);
    if (!child) {
        Out->msg(ERR, "Unable to spawn restore cycle for streamslice '%s' for directory '%s' during restore; ACLs will be lost",
                 *slicehash.partialimage(), *info.direlem.fullpath().image());
        return false;
    }
    orighash = hash; 
    return true;
}


void restdir::spawn_zfs_sslice_restore()
{
    zfstarpipe *ppipe_control = dynamic_cast<zfstarpipe *>(main->getpipe_control(&info));
    if (ppipe_control == 0) {
        assert("ppipe_control is NULL" == 0);
        return;
    }
    fileref altdataslice, stubdataslice, extentsdata;
    ppipe_control->addfile(info.direlem, info.path.image(), sslicebuf, altdataslice, stubdataslice, extentsdata, pipe_control::ZFS_DIRECTORY);
    ustring errmsg;
    fileoffset slicelen = sslicebuf.size();
    const hashcode slicehash = info.direlem.get_location().isFromGsan() ?
                ppipe_control->get_dirslice_hash() : hashcode::empty;
    cycle *child = cycle::restore_range(slicehash, 0, slicelen, true, sslicebuf, errmsg, info.direlem, info.container);
    if (!child) {
        Out->msg(ERR, "Unable to spawn restore cycle for streamslice '%s' for '%s' during restore: %s",
                 *slicehash.partialimage(), *info.direlem.fullpath().image(), *errmsg);
    }
    orighash = hash;
}



void restdir::process_zfs_dir_sslice()
{
    hash = orighash; 
    if (sslicebuf.isnull()) {
        Out->msg(ERR, "No streamslice data retrieved for '%s', directory is not restored.", *info.direlem.fullpath().image());
        return;
    }
    zfstarpipe *ppipe_control = dynamic_cast<zfstarpipe *>(main->getpipe_control(&info));
    if (ppipe_control == 0) {
        assert("ppipe_control is NULL" == 0);
        return;
    }
    
    
    
    
    
    
    
    
    
    
    
    ppipe_control->addobj(pipe_control::DIRTYPE, info.path.image(), info.direlem, 0, sslicebuf);
    sslicebuf.free();
}

bool restdir::process_sslice_header()
{
    hash = orighash; 

    if (sslicebuf.isnull()) {
        Out->msg(ERR, "No streamslice data restored for directory '%s' during restore; ACLs will be lost",
                 *info.direlem.fullpath().image());
        return false;
    }
    emctarstream::parser p("", utar_flags_enums::streamformat_emctar, 512, 30, 0, "");
    p.save_security = true;
    p.set_source_data(sslicebuf);
    DIRELEMp tmpde;
    fileref altref, stubref;
    if (p.getentry(tmpde, altref, stubref)) {
        p.recordmarks(tmpde);
        dirrec_pack::regions drr(tmpde.getimpl());
        data_regions::endoffsets_t tmpeoff;
        (void) drr.get(tmpeoff);        
        if (sslice_msg) DB->msg("restdir::process_sslice_header parser found de for '%s', endoffsets %s, altref.size:%s stubref.size:%s",
                                *tmpde->fullpath().image(), *data_regions::image_endoffsets(tmpeoff), *altref.size64().image(), *stubref.size64().image());
        if (!altref.isnull())
            altref.hexdump(false);
    } else {
        Out->msg(ERR, "Streamslice data did not contain properly formatted NDMP header data for directory '%s' during restore; ACLs will be lost",
                 *info.direlem.fullpath().image());
        return false;
    }

    assert(altref.isnull());
    assert(stubref.isnull());

    
    fileref secref;
    if (tmpde->get_security(secref)) {
        info.direlem.set_security(secref);
    }

    if (tmpde->get_ufs64data().size() > 0) {
        info.direlem.set_ufs64data(tmpde->get_ufs64data());
    }

    sslicebuf.free();
    return true;
}

void restdir::init()
{
    if (msg1 || sslice_msg) {
        DB->msg("-------------------------------------------");
        DB->msg("restdir::init (this:%p) phase:%d nforked:%d ncollected:%d de.Path='%s' loc:%s",
               this, phase, nforked, ncollected, *info.direlem.fullpath().image(), *info.direlem.get_location().image());
    }

    if(threadShutdown) {  
        notifyparent();
        return;
    }

    
    const location loc(info.direlem.get_location());
    if(loc.getMedia() > location::media::gsan && info.container.isnull() && loc.get_enclosing_container() != NULL) {
        if(msg1)DB->msg("restdir::init opening new container");
        info.container = main->open_container_for_read(loc);
    }

    { scope s(restdirlock);

    
    bool isdump = main->getdumpcontext() || main->getbackdump();

    
    
    if (((info.direlem.get_location().getMedia() == location::media::ddr) && regulator==NULL) ||
        
        
        
        
        
        
        
        
        
        (flags.streamformat_out == utar_flags_enums::streamformat_zfs))
        regulator = new Regulator(main, (int)(flags.maxopenfiles*0.80));

    
    bool add_path_element_to_pipe(true);

    
    
    
    if (flags.suppress_leading_path_elements &&
        (flags.streamformat_out == utar_flags_enums::streamformat_emctar) &&
        (xflag[22]&16) == 0 && !info.path.isempty()) { 
        ustring pathname(info.path.image());
        int match_level = INVALID_LEVEL_MATCH;
        bool forcematch = true;
        int includelist_size(main->state->targets.includelist().size());
        if (includelist_size == 0) forcematch = false;
        if (includelist_size > 1) {
            
            
            
            pathname = (ustring)"./" + pathname;
        }

        if (!main->state->targets.pathmatch(upath(pathname), info.direlem.is_directory(), match_level, forcematch)) {
            
            
            if(msg1) DB->msg("restdir::init fullpath '%s' has no match (includelist_size:%d, match_level:%d, forcematch:%d)",
                             *info.direlem.fullpath().image(), main->state->targets.includelist().size(), match_level, forcematch);
            Out->msg(INFO, "Path element '%s' does not match one of the target restore paths.", *info.direlem.fullpath().image());
        } else {
            
            
            
            
            add_path_element_to_pipe = (match_level >= 0);
            
            
        }
    }

    pipe_control *ppipe_control = main->getpipe_control(&info);
    
    if (ppipe_control && !info.path.isempty() &&
        (!info.path.isroot() || flags.restorerootdir) &&
        add_path_element_to_pipe) {
        

        if ((phase == phase_init) && info.direlem.is_dirrec_present(KIND_STREAMSLICE) &&
            (flags.streamformat_out != utar_flags_enums::streamformat_isilon) &&
            
            !flags.dtoexportstream) {
            
            if (flags.streamformat_out == utar_flags_enums::streamformat_zfs) {
                spawn_zfs_sslice_restore();
                phase = phase_sslice_header;
                if (sslice_msg) DB->msg("restdir::init %p spawned sslice header restore cycle, returning now", this);
                return;
            } else {
                if (spawn_sslice_header_restore()) {
                    phase = phase_sslice_header;
                    if (sslice_msg) DB->msg("restdir::init %p spawned sslice header restore cycle, returning now", this);
                    return;
                } else {
                    
                    if (sslice_msg) DB->msg("restdir::init %p failed to spawn sslice header restore cycle, fall through", this);
                    phase = phase_body;
                }
            }
        }

        
        fileref contentslice, altdataslice, stubdataslice, extentsdata;
        ppipe_control->addfile(info.direlem, info.path.image(), contentslice, altdataslice, stubdataslice, extentsdata, pipe_control::DIRTYPE);

        if (contentslice.size64() > 0) {
            Out->msg(ERR, "restdir::init '%s' pipe_control indicates %s bytes of content data, but directories have not content section for celerra/vnx",
                     *info.path.image(), *contentslice.size64().image());
        }

        if(msg1 && ((stubdataslice.size64() > 0) || (altdataslice.size64() > 0)) ) {
            DB->msg(DBTXT("restdir::init '%s' (with dowfs:%d) has stubdataslice at:%s,size():%s, altdataslice at:%s,size:%s"),
                    *info.path.image(), dowfs,
                    *stubdataslice.absoffset().image(), *stubdataslice.size64().image(),
                    *altdataslice.absoffset().image(), *altdataslice.size64().image());
        }

        
        
        if (stubdataslice.size64() > 0) {
            restore_pipe_stubdata(stubdataslice); 
        }

        
        if (dowfs && altdataslice.size64() > 0) {
            restore_pipe_altdata(altdataslice);
        }
    } else {
        if(msg1) DB->msg("restdir::init Path element '%s' not added to pipe (name:'%s')", *info.path.image(), *info.direlem.name());
    }
    if (msg1 || sslice_msg) DB->msg("restdir(%p)::init() de.Path='%s' de.file_hash():%s",
                            this, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage());
    phase = phase_body;

    main->set_cur_filename(info.path, true);

    info.restdircycle = this; 
  

    ADEMgrX* adeMgr = main->getAdeMgr();
    assert(adeMgr != NULL);

    
    
    
    if(!flags.dtoexportstream) {
        if(info.direlem.is_dirrec_present(KIND_DIR_ALTSTREAM) && (!info.direlem.is_encrypted()) &&
           (flags.streamformat_out != utar_flags_enums::streamformat_zfs) &&
           (flags.streamformat_out != utar_flags_enums::streamformat_isilon) && !flags.dtoexportstream) {
            DB->msg("restdir::init - directory direlem has alternative data hash, path = \"%s\".", *info.direlem.fullpath().image());
            restorealtdatastream(&info.direlem);
        }
        if(info.direlem.is_dirrec_present(KIND_LARGE_SECURITY) &&
           (flags.streamformat_out != utar_flags_enums::streamformat_zfs) &&
           (flags.streamformat_out != utar_flags_enums::streamformat_isilon) &&  !flags.dtoexportstream) {
            DB->msg("restdir::init - directory direlem has security dephash for path \"%s\"", *info.direlem.fullpath().image());
            restoresecurity(&info.direlem);
        }
    }

    if(adeMgr->ADEChunkerEnabled()) {
#if !NOADECHUNKER
        
        
        
        
        listingProvider.getListings(hash, info);
#endif
    } else {
        
        
        
        
        cycle *child;
        nforked++;
        
        

        
        
        if((info.isroot && flags.ddrenabled) || isdump || flags.dtoexportstream || info.direlem.get_location().getMedia() > location::media::gsan ||
           (flags.streamformat_out == utar_flags_enums::streamformat_zfs) ||
           (flags.streamformat_out == utar_flags_enums::streamformat_isilon)) {
            
            child = new restdirpart(this, metadataLocation, info, NULL, 0, regulator);
            if(msg1)DB->msg("restdir::init (this:%p) spawning restdirpart=%p", this, child);
        } else {
            child = new restdata(this, metadataLocation.getHash(), NULL, false, info);
            if(msg1)DB->msg("restdir::init (this:%p) spawning restdata=%p", this, child);
        }
        child->noop();
        childdone(NULL);
    }
    } 
}

#if !NOADECHUNKER






void restdir::handleListing(cycle* provider, const restelem& restinfo)
{
    if(restinfo.data.size() > 0) {
        info.restdircycle = this;
        if (msg1) DB->msg("restdir::handleListing, restinfo.data=%d bytes", restinfo.data.size());
        cycle* child = new restdirpart(provider, location(location::media::gsan, hash.zero), restinfo, NULL, 0, regulator);
        child->setautodelete(true);  
    }
}

#endif

void restdir::childdone(cycle *child) {
    { scope s(restdirlock);

    if (child)
        ncollected++;

    if (msg1) {
        DB->msg("restdir(%p)::childdone() child='%s' at %p", this, child ? typeid(*child).name() : "self", child);
        DB->msg("restdir(%p)::childdone() phase:%d nforked:%d ncollected:%d info.data.size():%d", this, phase, nforked, ncollected, info.data.size());
    }

    if (phase == phase_sslice_header) {
        if (!child) {
            assert(false);
            return;
        }
        if (nforked > ncollected) {
            assert(false); 
            return;
        }
        if (sslice_msg) DB->msg("restdir::childdone for phase_sslice_header, going to process");
        phase = phase_body;
        if (flags.streamformat_out == utar_flags_enums::streamformat_zfs) {
            process_zfs_dir_sslice();
        } else {
            process_sslice_header();  
        }
        if (sslice_msg) DB->msg("restdir::childdone for phase_sslice_header, calling into init again");
        init();                   
        return;
    }

    restdata *dchild = dynamic_cast<restdata*>(child);
    
    if(child && (info.data.size() > 0)) {
        if (dchild && (dchild->info.restdircycle)) {
            assert(! (main->getdumpcontext() || main->getbackdump()) );
            if(msg1)
                DB->msg(DBTXT("restdir::childdone non composite dir hash:%s"), *hash.image());
            nforked++;
            cycle *child = new restdirpart(this, location(location::media::gsan, hash), info, NULL, info.data.size(), regulator);
            child->noop();
            
            
            info.data = fileref::empty;
            return;
        } else {
            
        }
    }

    if(dchild) {
        if(dchild == altdatachild) {  
            assert(!flags.dtoexportstream);
            bool dataerr = false;
            if(altdatainfo.data.iserror()) {
                dataerr = true;
                Out->msg(WARN, "Unable to restore alternate data for '%s'.", *info.direlem.fullpath().image());
            }
            
            if(!info.direlem.is_encrypted() && !dataerr) {
                writealtdatastream(info.direlem.fullpath(), altdatainfo.data);
                if(msg1) DB->msg("restdir::childdone Done writting alternative data stream.");
            }
        } else if(dchild == securitychild) {  
            assert(!flags.dtoexportstream);
            if(securityinfo.data.iserror())
                Out->msg(ERR, "Unable to restore security(acl) data for path \"%s\".", *info.direlem.fullpath().image());
            else {
                if(msg1)
                    DB->msg("restdir::childdone directory \"%s\" security data saved for restore.", *info.direlem.fullpath().image());

                info.direlem.set_security(securityinfo.data);
            }
        }
    }

    if (ncollected < nforked)
        return;

    if(msg1)
        DB->msg(DBTXT("restdir::childdone about to handle emctar hardlink stuff"));

    
    if (pipe_control *ppipe_control = main->getpipe_control(&info)) {
        for (size_t i=0; i<hardlink_direlems.size(); i++) {
            fileref dum, altdum, stubdum, extentsdata;
            DIRELEM de = hardlink_direlems[i];
            ustring link = hardlink_linknames[i];
            if(msg1) DB->msg(DBTXT("restdir::childdone calling addfile for %s, is_tar_hardlink:%d"),
                            *de.fullpath().image(), de.is_tar_hardlink());
            ppipe_control->addfile(de, de.fullpath().image(), dum, altdum, stubdum, extentsdata, pipe_control::LNKTYPE, link);
        }

        
        if((flags.streamformat_out == utar_flags_enums::streamformat_avpax ||
            flags.streamformat_out == utar_flags_enums::streamformat_cdsf) &&
           flags.dtoexportstream) {
            if(msg1)DB->msg("restdir::childdone() dephashes_restored:%d", dephashes_restored);

            
            cycle* prevchild(0);
            if(info.restdircycle && !dephashes_restored) {
                const int dephashes_nforked(restdirpart::do_restore_dephashes(this, prevchild, info));
                dephashes_restored = true;
                if(msg1)DB->msg("restdir::childdone() dephashes_nforked:%d", dephashes_nforked);
                if(dephashes_nforked > 0) {
                    nforked += dephashes_nforked;
                    return;
                }
            }
        }

        
        if(!ppipe_control->finobj(pipe_control::DIRTYPE, info.path.image(), info.direlem)) {
            DB->msg(DBTXT("restdir::childdone() call to pipe_control->finobj failed %s"), *info.path.image());
        }
    }

    if (info.path.has_end_dirsep())
        Out->msg(VERBOSE, "%s", *info.path.image());
    else
        Out->msg(VERBOSE, "%s%s", *info.path.image(), DIRSEPSTR);

    } 

    
    
    
    
    if(threadStarter) {
        DB->msg("restdir::childdone(%p) request stop thread:%d, new thread:%d for path '%s'",
                this, getThreadNbr(), parent->getThreadNbr(), *info.path.image());
        threadStarter = false;                  
        todoEnqueue(TODO_DONE);                 
        setThreadNbr(parent->getThreadNbr());   
        threadShutdown = true;                  
        todoEnqueue(TODO_DIR, this);            
    } else {
        notifyparent();
    }
}



restdir::~restdir() {
    main->num_open_dirs--;
    
    if(threadStarter) {
        
        
        DB->msg( DBTXT("restdir::~restdir(%p) stopping thread %d for path '%s'"), this, getThreadNbr(), *info.path.image());
        todoEnqueue(TODO_DONE);   
    }
    
    if (!info.direlem.is_directory() && !info.direlem.is_symlink())
        DB->error("restoring non directory: %s", *info.path.image());
    
    
    
    if( info.direlem.should_skip_this_file() ) {
        
        DB->msg( DBTXT("Internal: restdir should skip %s"), *info.direlem.fullpath().image());
    }

    assert( info.path == info.direlem.fullpath() );
    if( info.path != info.direlem.fullpath() )
        DB->msg("      '%s' != '%s'", *info.path.image(), *info.direlem.fullpath().image() );

    
    if(flags.validate || (flags.streamformat_out != utar_flags_enums::streamformat_none)) {
        
        
        
        
        
        
        
        if (!info.isroot)
        {
            
            
            
            if ((flags.streamformat_out != utar_flags_enums::streamformat_emctar &&
                 flags.streamformat_out != utar_flags_enums::streamformat_isilon &&
                 flags.streamformat_out != utar_flags_enums::streamformat_zfs) ||
                traverse_depth != 1)
            {
                main->getstatsobj(context::restorestats)->add_dircount(1);
            }
        }

        return;
    }

    if(cyexcluded && cyincluded==0) {
      if(msg1) DB->msg(DBTXT("restdir::~restdir dir excluded %s"), *info.direlem.fullpath().image());
      return;
    }

    if( info.path.isempty() ) { 
        return; 
    }

#if SYSTEM_WINDOWS
    if( info.direlem.is_drive() ) { 
        return; 
    }
#endif

    
    
    

    
    
    
    
    
    
    if( (!preexisting && !flags.online_system_state) || flags.existingdiraclrestore ){
        
        
        if(msg1) DB->msg(DBTXT("Restoring directory attributes '%s'"), *info.path.image());
        if (!info.direlem.set_file_attributes(flags.permissions))
            Out->msg(WARN, "<6024>Could not restore all access privileges on \"%s\"", *info.path.image());
    }
    else {
        if(msg1) DB->msg(DBTXT("NOT restoring directory attributes '%s', pre-existing=%d, flags.online_system_state=%d"), *info.path.image(), preexisting, flags.online_system_state);
    }

    if (!info.isroot) main->getstatsobj(context::restorestats)->add_dircount(1);
}


int restdir::restore_pipe_altdata(fileref& altdataslice) {
    if (info.direlem.is_dirrec_present(KIND_STREAMSLICE)) {
        if (sslice_msg) DB->msg("restdir::restore_pipe_altdata %p for streamslice", this);
        if (!restore_pipe_sslice_altdata(altdataslice)) {
            Out->msg(ERR, "restdir::init MUST FILL SLICE WITH 0s for failed restore_pipe_sslice_altdata");
            return -1;
        }
        return 0;
    }

    
    dirrec_pack::emctar_altdata ead(&info.direlem);
    ubigint64 altdatasize;
    unsigned char hashoffset;
    if(!ead.get(altdatasize, hashoffset)) {
        Out->msg(ERR, "<7348>pipe control extra bytes %s", *(info.data.size64() - info.direlem.file_size()).image());
    } else {
        hashvect hashes;
        info.direlem.getdephashes(hashes);
        if(msg1)DB->msg("restdir::restore_pipe_altdata '%s' hashes.size:%Zu altdatasize:%s hashoffset:%d",
                        *info.path.image(), hashes.size(), *altdataslice.size64().image(), hashoffset);

        
        if (hashes.size() > (unsigned int)(hashoffset+1)) {
            restelem altinfo(info.path, info.direlem, info.fstats, altdataslice);
            altinfo.ppipe_control = info.ppipe_control;
            nforked++;
            cycle *altdatac = new restdata(this, hashes[hashoffset+1], NULL, false, altinfo,
                                           fileoffset(0), altdataslice.size64());
            altdatac->noop();
        } else {
            Out->msg(ERR, "<7349>pipe control cannot find enough dephash values (%"Z"u present) for altdata hashoffset (%u)", hashes.size(), hashoffset);
        }
        if(msg1)DB->msg("restdir::restore_pipe_altdata '%s' nforked:%d ncollected:%d", *info.path.image(), nforked, ncollected);
    }
    return 0;
}


bool restdir::restore_pipe_sslice_altdata(fileref& altdataslice) {
    dirrec_pack::streamslice ss(&info.direlem);
    ubigint64 slicesize;
    unsigned char hashoffset;
    if (!ss.get(slicesize, hashoffset)) {
        Out->msg(ERR, "During restore of directory '%s' we should have an alternate data streams region in our stream slice dephash, but we don't have a streamslice dephash at all.",
                 *info.direlem.fullpath().image());
        return false;
    }

    dirrec_pack::regions r(&info.direlem);
    data_regions::endoffsets_t eoff;
    if (!r.get(eoff)) {
        Out->msg(ERR, "During restore of directory '%s' we should have an alternate data streams region in our stream slice dephash, but we don't have a REGIONS dirrec indicating where the alternate data streams are within the data.",
                 *info.direlem.fullpath().image());
        return false;
    }

    fileoffset a, b;
    if (!data_regions::findrange(eoff, data_regions::ads, true, a, b)) {
        Out->msg(ERR, "During restore of directory '%s' we should have an alternate data streams region in our stream slice dephash, but we don't have an ADS section in our REGIONS dirrec, it contains '%s'.",
                 *info.direlem.fullpath().image(), *data_regions::image_endoffsets(eoff));
        return false;
    }

    
    
    
    hashvect hashes;
    info.direlem.getdephashes(hashes);
    if(msg1)DB->msg("restdir::restore_pipe_sslice_altdata '%s' hashes.size:%Zu altdatasize:%s hashoffset:%d",
                    *info.path.image(), hashes.size(), *altdataslice.size64().image(), hashoffset);

    if (hashes.size() <= (unsigned int)(hashoffset+1)) {
        Out->msg(ERR, "During restore of directory '%s', not enough dephash values (%"Z"u present) for altdata hashoffset (%u)",
                 *info.direlem.fullpath().image(), hashes.size(), hashoffset);
        return false;
    }

    
    
    restelem altinfo(altdataslice);
    altinfo.prep_restore_of_slice(hashes[hashoffset+1], a, b);
    altinfo.ppipe_control = info.ppipe_control;
    cycle *altdatac = new restdata(this, hashes[hashoffset+1], NULL, false, 
                                   altinfo);
    if (!altdatac) {
        Out->msg(ERR, "During restore of directory '%s', unable to spawn a restdata cycle to restore our alternate data streams from [%s, %s] in dephash %d %s",
                 *info.direlem.fullpath().image(), *a.image(), *b.image(), hashoffset+1, *hashes[hashoffset+1].partialimage());
        return false;
    }
    nforked++;
    altdatac->noop();

    if(msg1)DB->msg("restdir::restore_pipe_sslice_altdata '%s' nforked:%d ncollected:%d", *info.path.image(), nforked, ncollected);

    return true;
}







int restdir::restore_pipe_stubdata(fileref& stubdataslice) {
    ubigint64     datasize;
    unsigned char hashoffset;

    
    dirrec_pack::streamslice ssd(&info.direlem);
    if (!ssd.get(datasize, hashoffset)) {
        
        dirrec_pack::emctar_stubdata ead(&info.direlem);
        if(!ead.get(datasize, hashoffset)) {
            
            Out->msg(ERR, LOCTXT("<7348>pipe control extra bytes %s"), *(info.data.size64() - info.direlem.file_size()).image());
            return 0; 
        }
        
    }
    

    
    
    
    assert(fileoffset(datasize) == stubdataslice.size64());

    hashvect hashes;
    info.direlem.getdephashes(hashes);
    if(msg1)
        DB->msg("restdir::restore_pipe_stubdata '%s' hashes.size:%"Z"d datasize:%s hashoffset:%d",
                *info.path.image(), hashes.size(), *stubdataslice.size64().image(), hashoffset);

    
    if (hashes.size() > (unsigned int)(hashoffset+1)) {
        
        restelem* altinfo= new restelem(info.path, info.direlem, info.fstats, stubdataslice);
        altinfo->ppipe_control = info.ppipe_control;
        nforked++;
        cycle *stubdatac = new restdata(this, hashes[hashoffset+1], NULL, false, *altinfo,
                                        fileoffset(0), stubdataslice.size64());
        stubdatac->noop();
    } else {
        Out->msg(ERR, LOCTXT("<8714>restdir pipe control cannot find enough dephash values (%"Z"u present) for stubdata hashoffset (%u)"),
                 hashes.size(), hashoffset);
        
    }
    if(msg1)
        DB->msg("restdir::restore_pipe_stubdata '%s' nforked:%d ncollected:%d", *info.path.image(), nforked, ncollected);

    return 0;
}












restdir::Regulator::Regulator(context *main_, int maxFilesOpen_):
    main(main_),
    maxFilesOpen(maxFilesOpen_)         
{
    myMaxOpen[false] = MAXRESTFILES;    
    myMaxOpen[true]  = MAXRESTDIRS;     
    memset(&myIsOpen, 0, sizeof(myIsOpen));
}




bool restdir::Regulator::okToProcessMore()
{


    const bool exceeded = (main->num_open_files.value() > maxFilesOpen);
    if (exceeded) return(false);

    return (myIsOpen[false] < myMaxOpen[false] && myIsOpen[true] < myMaxOpen[true]);
}




void restdir::Regulator::addChild(cycle* child)
{
    if(child == NULL) return;

    const bool isdir = child->cyisdirectory;
    myIsOpen[isdir]++;
    assert(myIsOpen[isdir] <= myMaxOpen[isdir]);
}




void restdir::Regulator::removeChild(cycle* child)
{
    if(child == NULL) return;

    const bool isdir = child->cyisdirectory;
    myIsOpen[isdir]--;
    assert(myIsOpen[isdir] >= 0);
}







bool restdir::restorealtdatastream(DIRELEM* direlemp) {
    if(!direlemp->is_dirrec_present(KIND_DIR_ALTSTREAM))
        return false;

    int hashidx;
    hashvect hashes;

    dirrec_pack::dir_altstream diraltdata(direlemp);
    diraltdata.get(hashidx, altstreamsize);
    direlemp->getdephashes(hashes);
    hashcode altdatahash = hashes[hashidx + 1];
    altdatainfo.direlem = *direlemp;
    altdatainfo.path = direlemp->fullpath();
    altdatainfo.data.initlist(altstreamsize.ivalue());
    altdatainfo.ignoreStats = true;

    if(msg1) DB->msg("restdir::restorealtdatastream - Got alternative data hash %s at offset %d, size=%"LL"d.",
                      *altdatahash.partialimage(), hashidx, altstreamsize.value());

    altdatachild = new restdata(this, altdatahash, NULL, false, altdatainfo);
    nforked++;
    altdatachild->noop();
    return true;
}





bool restdir::writealtdatastream(const upath path, fileref data) {
#if !SYSTEM_WINDOWS
    
    if(flags.validate) {
        return true;
    }
    DB->msg("restdir::writealtdatastream - This function only supported on Windows OS.");
    return false;
#else
    if(!info.direlem.useBackupOps() || info.direlem.is_encrypted()) {
        return false;  
    }

    DWORD winrwmode = GENERIC_WRITE | GENERIC_READ;
    DWORD sharemode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    bool  isNTorlater = win_os_version_info::is_windows_NT_or_newer();
    if( isNTorlater ) {
        winrwmode |= READ_CONTROL;
        sharemode |= FILE_SHARE_DELETE;
    }

    HANDLE altfh = CreateFile(*path.patht("CreateFile"),
                               winrwmode,
                               sharemode,
                               NULL,
                               OPEN_EXISTING,
                               (FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_POSIX_SEMANTICS),
                               NULL );
    BOOL success = (altfh != INVALID_HANDLE_VALUE && altfh != NULL);
    if(!success) {
        int err_code = (int)GetLastError();
        Out->msg(WARN, "Unable to restore alternative data stream to path \"%s\".", *path.image());
        if(msg1)DB->msg("restdir::writealtdatastream - Open \"%s\" failed with err code: %d.", *path.image(), err_code);
        return false;
    }

    fileoffset alt_total_len;
    DWORD alt_data_writen = 0;
    DWORD alt_data_block = flags.blocksize;
    unsigned char*  alt_data = (unsigned char*)data.start();
    void *ctx = NULL;

    while(success && (alt_total_len < altstreamsize)) {
        if((alt_total_len + alt_data_block) > altstreamsize)
            alt_data_block = (DWORD)((altstreamsize - alt_total_len).value());
        success = BackupWrite(altfh, alt_data + alt_total_len.value(), alt_data_block, &alt_data_writen, false, false, &ctx );
        if(msg1)
            DB->msg("restdir::writealtdatastream- call BackupWrite() on \"%s\", alt_data_length = %"LL"d, data writen = %lu, success: %d",
                     *path.image(), altstreamsize.value(), alt_data_writen, success);

        alt_total_len += alt_data_writen;
        if(alt_data_writen < alt_data_block) {
            success = true;
            break;
        }

        if(!success) {
            int err_code = (int)GetLastError();
            DB->error("restdir::writealtdatastream- BackupWrite for alternative data stream on \"%s\" failed, error %d",
                     *path.image(), err_code);
        }
    }
    success = BackupWrite(altfh, alt_data, alt_data_block, &alt_data_writen, true, false, &ctx ) & success;
    CloseHandle(altfh);

    if(!success) {
        DB->msg("restdir::writealtdatastream - BackupWrite failed on \"%s\".", *path.image());
        return false;
    }

    return true;
#endif
}





bool restdir::restoresecurity(DIRELEM* direlemp) {
    if(!direlemp->is_dirrec_present(KIND_LARGE_SECURITY))
        return false;

    int hashidx;
    hashvect hashes;

    securityinfo.direlem = *direlemp;
    securityinfo.path = direlemp->fullpath();
    securityinfo.data.initlist(32768);
    securityinfo.ignoreStats = true;

    dirrec_pack::large_security dirsecurity(direlemp);
    dirsecurity.get(hashidx);
    direlemp->getdephashes(hashes);
    hashcode securityhash = hashes[hashidx + 1];
    if(msg1)
        DB->msg("restdir::restoresecurity - get security hash %s at offset %d.", *securityhash.partialimage(), hashidx);

    securitychild = new restdata(this, securityhash, NULL, false, securityinfo);
    nforked++;
    securitychild->noop();
    return true;
}
















#include "common.h"
#include "debug.h"
#include "cycle.h"
#include "backstate.h"
#include "restroot.h"
#include "restfile.h"
#include "restdir.h"
#include "restpipe.h"
#include "todoelem.h"
#include "restelem.h"

#if SYSTEM_WINDOWS
#include "ntsecurity.h"
#endif

#define msg1  ((xflag[2]&32)!=0)



restroot::restroot(const location& _metadataLocation, context& main_, const upath& path, bool ismapi, const DIRELEM *de , const location parentdataloc )
  : multivolumeroot(&main_, *main_.getTodoQueue(), false ),
    bicycle(NULL, &main_)
{
    setasroot(this);
    cycle *child;


    if (msg1) DB->msg("restroot::restroot this=%p, metadataloc='%s' restoretarget=%s parentdataloc:%s", this, *_metadataLocation.image(), *path.image(), *parentdataloc.image());

    
    assert(!main_.is_in_async_mode());   

    
    
    DIRELEM direlem(path);  
    if(de && !de->name().isempty()) {
        direlem = *de;
        DB->msg("restroot::restroot initializing direlem from passed in de (%s): now has loc_image:%s",
                *de->name(), *direlem.loc_image());
    } else if (direlem.has_error()) {
        direlem.zero();
        direlem.set_is_directory();
        direlem.set_fullpath( path );
        DB->msg("restroot::restroot initializing, but direlem.has_error is true, so zeroed");
    }
    else if (!de) {
        
        
        
        
        
        direlem.set_fullpath(path);
        DB->msg("restroot::restroot initializing from null de");
    } else {
        DB->msg("restroot::restroot WTF? how did we get here? de.name():%s de.fullpath():%s",
                *de->name(), *de->fullpath().image());
    }
    direlem.set_location(parentdataloc); 
    if (ismapi)
        direlem.set_is_mapi();
    ispipe = false;
#if SYSTEM_WINDOWS
    
    volinfo vinfo;
    if (!flags.to_stdout && flags.media_out.isempty()) {
        
        vinfo = VolumeInfo::getVolInfo(direlem.fullpath());
    }
    restelem info(direlem.fullpath().image(), direlem.fullpath(), direlem, filestatsref(), false, vinfo);
#else
    restelem info(direlem.fullpath().image(), direlem.fullpath(), direlem, filestatsref(), false);
#endif
    info.isroot = true;         
    if(1)
        DB->msg("restroot::restroot creating restdir, fullpath=%s direlem loc:%s",
                *direlem.fullpath().image(), *direlem.loc_image());
    child = new restdir(this, _metadataLocation, info, NULL, NULL, false);
}

restroot::restroot(const hashcode& hash, context& main_, fileref& resdata, chunktype* ctypep,
                   bool rawmode, async_callback *incb, fileoffset startoff, fileoffset endoff)
  : multivolumeroot(&main_, *main_.getTodoQueue(), false ),
    bicycle(NULL, &main_)
{
    setasroot(this);
    cycle *child;

  if(msg1)DB->msg("restroot::restroot this=%p, hash=%s, cb=%p", this, *hash.partialimage(), cb);

    
    assert((incb!=NULL) == main_.is_in_async_mode());

    if (incb != NULL) {
        if(msg1)DB->msg("restroot::restroot creating asynccontext restroot with restpipe");
        this->cb = incb;          
        this->autodelete = false; 
    }

    ispipe = true;
    this->resdata = resdata;
    if(msg1)DB->msg("restroot::restroot calling restpipe");
    child = new restpipe(this, hash, resdata, false, startoff, endoff, rawmode, ctypep);
}




restroot::restroot(context* main_, fileref& res, const DIRELEM* direlem, const fileoffset startoff, const fileoffset endoff, ucontainer::basep containerp)
  : multivolumeroot(main_, *main_->getTodoQueue(), false ),
    bicycle(NULL, main_)
{
    setasroot(this);
    this->resdata = res;
    ispipe = true;
    cycle *child = new restpipe(this, resdata, direlem, false, startoff, endoff, containerp);
    child->noop();
}






restroot::restroot(context* main_)
  : multivolumeroot(main_, *main_->getTodoQueue(), false ),
    bicycle(NULL, main_)
{
    setasroot(this);
    cycle::setautodelete(false);   
}





void restroot::loadDirectoryTargetList(const DIRELEM* targetDirelem)
{
    RestoreElement restoreElement;
    restoreElement.child = NULL;
    restoreElement.direlem = *targetDirelem;
    restoreElement.resultOK = false;
    restoreElement.topdirs = NULL;          
    restoreList.push_back(restoreElement);
}




void restroot::pushPriorCloseParams(void* topdirs, const ustring& frompath, const ustring& topath)
{
    const ubigint64 listSize = restoreList.size();
    if(listSize == 0) { 
        assert(listSize > 0);
        return;
    }
    RestoreElement& restoreElement = restoreList[static_cast<unsigned int> (listSize - 1)];
    restoreElement.topdirs = topdirs;
    restoreElement.fromPath = upath(frompath);
    restoreElement.toPath = upath(topath);
}




bool restroot::getCloseParameters(ubigint64 i, void** topdirs, ustring& fromPath, ustring& toPath)
{
    if (i >= restoreList.size()) { 
        assert(false);
        *topdirs = NULL;
        fromPath = "unknown";
        return(false);
    }
    RestoreElement& restoreElement = restoreList[static_cast<unsigned int> (i)];
    *topdirs = restoreElement.topdirs;
    fromPath = restoreElement.fromPath.patha();
    toPath = restoreElement.toPath.patha();
    return(restoreElement.resultOK);
}




void restroot::init()
{
    scope s(restrootlock);

    const int dirCount = (int)restoreList.size();
    
    if(flags.parallel) {
        
        
        if(!flags.isexplicit("max-streams")) {
            hostinfo host;
            if(host.numprocessors() >= 2) {
                flags.maxstreams = host.numprocessors() / 2;
            }
        }
        if(dirCount < flags.maxstreams) {
            
            flags.maxstreams = dirCount;
        }
    }
    else {    
        flags.maxstreams = 1;
    }
    if (flags.maxstreams > 1) {
        setupMultiVolumeThreadPool();
    }
    

    
    
    
    
    for(int i = 0; i < dirCount; i++) {
        RestoreElement& restoreElement = restoreList[i];
        start_one_restore(restoreElement);
    }
    if (flags.maxstreams > 1) { 
        finishedVolumeEnqueues();
    }
}




void restroot::start_one_restore(RestoreElement& restoreElement) {
    DIRELEM& direlem = restoreElement.direlem;
    const ustring pathname(direlem.fullpath().image());
    if(msg1)DB->msg("restroot::start_one_restore de.fullpath:%s frompath:%s topath:%s loc:%s",
                    *pathname, *restoreElement.fromPath.image(), *restoreElement.toPath.image(), *direlem.get_location().image());
    volinfo vinfo;
#if SYSTEM_WINDOWS
    
    vinfo = VolumeInfo::getVolInfo(direlem.fullpath());
#endif

    if( direlem.is_directory() ) {
        restelem info(direlem.fullpath().image(), direlem.fullpath(), direlem, filestatsref(), false, vinfo);
        info.isroot = true;         
        const location theloc(location::media::gsan, direlem.file_hash());
        restoreElement.child = new restdir(this, theloc, info, NULL, NULL, false, 0, true); 
    }
    else {
        restoreElement.child = new restfile(this, direlem.file_hash(), direlem, NULL, NULL, vinfo, 0, 0, unsigned(restfile::opt_none));
    }
}





void restroot::childdone(cycle *child)
{
    restrootlock.lock();

    const int dirCount = (int)restoreList.size();
    if(dirCount > 0) {
        int finishedCount = 0;
        for(int i = 0; i < dirCount; i++) {
            RestoreElement& restoreElement = restoreList[i];
            if(restoreElement.child == child) {
                restoreElement.child = NULL;
                restoreElement.resultOK = true;
                finishedCount += 1;
            }
            else if(restoreElement.child == NULL) {
                finishedCount += 1;
            }
        }
        
        
        
        
        if(finishedCount == dirCount) {
            todoEnqueue(TODO_DONE);
            restrootlock.unlock();
            notifyparent();
            return;
        }
    }
    else {  
        this->size = resdata.size64();
    
        todoEnqueue(TODO_DONE);
        restrootlock.unlock();
        notifyparent();
        return;
    }

    restrootlock.unlock();
}

restroot::~restroot() {
}
#if !defined(CHUNKTREE_INCLUDED)
#define CHUNKTREE_INCLUDED












#include "fileref.h"
#include "chunktype.h"
#include "hashcode.h"
#include "vector.h"
#include "stats.h"
#include "filestats.h"
#include "workelem.h"
#include "msgpack_c.h"

class nbackroot;
class cycle;
class backstats;
class hash_cache;
class backtree;


class chunktree  {
public:
    class node {
    private:
        friend class backtree;
        node();
        node *sibling;
        node *child;
        fileref    data;
        hashcode   hash;
        chunktype  kind;
        stats::reason why;
        bool node_sent; 
        bool node_complete;
        workelem *info;
        backtree *mycycle; 
        int origsize;
        int depth;
        int magic;
    public:
        SAFEPOOLALLOC(node);
        node(workelem *info, fileref& data, hashcode &hash, chunktype kind, int origsize, int depth_, cycle *parent_cycle, backtree *mycycle_);
        ~node();

        
        void delete_subordinate_cycles( bool delete_cycle );

          
        msgerrors send( bool ispresentonly, backstats *stats );
          
        void treestats(backstats *stats, stats::reason parentwhy, bool system_info);
          
        ustring image() const;

        void set_sibling(node *sib) {sibling = sib; };
        void set_child(node *xchild) {child = xchild;};
        void set_why(stats::reason why_) {why = why_;};

        hashcode      get_hash()    const { return hash; };
        fileref       get_data()    const { return data; };
        chunktype     get_kind()    const { return kind; };
        stats::reason get_why()     const { return why; };
        node *        get_sibling() const { return sibling; };
        node *        get_child()   const { return child; };
        int           get_depth()   const { return depth; };
        backtree *    get_cycle()   const { return mycycle; };
        workelem *    get_info()    const { return info; };

        
        bool issimplecomposite() const;

        
        unsigned int get_datasize() const { return data.size(); };

        
        unsigned int get_sibcount() const;

        bool shouldbesent() const;

        void      print( const char * );
    };

    SAFEALLOC(chunktree);
    void add(node * node, chunktree * nchild);
    void send(backstats *stats = NULL);
    void print( const char *);
    void clear();
    chunktree();
    ~chunktree();

private:
    node *top;
    node *last;
};

#endif



#if !defined(REPLICATE_H_INCLUDED)
#define REPLICATE_H_INCLUDED















#include "utar_flags_info.h"
#include "roothashlist.h"
#include "sessionprogress.h"
#include "xml_message.h"
#include "prectime.h"
#include "tretentiontype.h"
#include "interfaceade_flags.h"
#include "hfs_info_struct.h"

#define MIGRATEINFO "migration"
#define REPLDESTFLAG "secondary"
#define BACKUPROOT "roothash"

class context;
class profile;
class utar_commands;
class BackupRootInfoList;
class mediadesc;

class replicate {
public:
    
    replicate(context* main, utar_flags_info& flags, utar_flags_info& dstflags);

    ~replicate();

    static xml_messagep parsedflags_to_xml(const ustring &parsed_flags, const ustring xml_header);
    
    bool run(BackupRootInfoList &backups, utar_commands* utarCmds);

private:
    
    
    typedef struct {
        ustring servertype;
        ustring serveraddr;
        ustring serverpath;
        ustring ddrhostname;
        
        
        ustring snapupid;
    } repl_serverinfo;

    context* main;
    utar_flags_info& flags;
    utar_flags_info& dstflags;
    xml_messagev replsrc_progress_vect;
    xml_messagev repldst_progress_vect;
    ustring hashcachefilename;  

    void log_replprogress(const sessionprogress& start_prog, const sessionprogress& end_prog,
                          const unsigned int newid, const ustring& sessname, const prectime& snapuptime,
                          const bigint64& snapupsize, const unsigned int origid, const cidtype& cid,
                          const ustring& encrypt, const prectime& expiretime,
                          const tretentiontype& retention, const tbackuptype& backuptype,
                          const int plugin_num, const ustring& label, const repl_serverinfo replservers[]);
    void flush_repl_progress(xml_messagev &vect, dpns dpninv);
    void convert_cache_filename(ustring &cachename, hfs_info_struct *src_hfs_info, const bool file_cache);
    bool check_chunker_settings();
    rhlLabel truncate_label(const rhlLabel &src, const bool is_dublin_or_later);

    
    bool is_media_backupdir_valid(mediadesc& mediaoutd, bool& media_error);

    
    void sendEvent(const ustring& clientId, const ustring& backupId, bool success) const;

    
    ustring gen_cache_suffix(const ustring& dsthfsaddr, const ustring& srchfsaddr, const ustring& hostname, const char sepchar, int labelnum = 0) const;
};

#endif

#if !defined(RESTEXTENTS_H_INCLUDED)
#define RESTEXTENTS_H_INCLUDED












#include "common.h"
#include "cycle.h"
#include "hashcode.h"
#include "restelem.h"

class direlemp;
class pipe_control;







class restextents : public bicycle {
public:
    
    restextents(cycle *parent,                             
             const hashcode& hash,                      
             chunktype *ctypep,                         
             const bool expectatomic,                   
             const restelem& restinfo,                  
             const fileoffset offset = fileoffset(0),   
             const fileoffset size = fileoffset(-1),    
             cycle *starter = NULL,                     
             const bigint64 prior = 0,                  
             const fileref& comparedata = fileref::empty,    
             const int conn = -1);                      

    virtual void init();
    virtual void childdone(cycle *child);

    SAFEPOOLALLOC(restextents);

private:
    restelem info;               

    const fileref comparedata;
    const bool expectatomic;
    const int conn;
    const bigint64 prior;
    chunktype *ctypep_to_return;  

    pipe_control *ppipe_control;
    int phase;                    

    void do_next();
};

#endif














#include "common.h"
#include "backfile2rawcontainer.h"
#include "workelem.h"
#include "nbackdata.h"

#define msg1  ((xflag[2]&2048)!=0)   


backfile2rawcontainer::backfile2rawcontainer(BackCycle *parent_,
                                             workelem *info_,
                                             parsestream_base *parser ) :
    BackCycle(parent_, info_),
    containerid(0),
    containerp(NULL)
{
    if(msg1) DB->msg("backfile2rawcontainer::backfile2rawcontainer(%p, %p, %p) main %p",
                     parent, info, parser, main);
    assert(main);
    assert(info);
    assert(!info->direlemp.isnull());

    containerp = main->open_raw_container_for_write(info->direlemp->fullpath(), containerid);
    if(!containerp.isnull()) {
        info->use_container = true;
        info->container     = containerp;
        containerp->beginfile(info->direlemp.getimpl(), fileoffset::unknown);

        cycle *child = new nbackdata(this, info, fileoffset(0), false , parser );
        child->noop();
    } else {
        Out->msg(FATAL, "Unable to create raw container for backup of '%s'", *info->direlemp->fullpath().image());

        
        childdone(0);
    }
}

backfile2rawcontainer::~backfile2rawcontainer()
{}

void backfile2rawcontainer::init()
{}


void backfile2rawcontainer::childdone(cycle *child)
{
    if(child) {
        containerp->endfile(info->direlemp.getimpl(), fileoffset::unknown);
        main->close_raw_container_for_write(containerp);
        containerp = 0;
    }

    notifyparent();
}
#if !defined(BACKAPPEND_H_INCLUDED)
#define BACKAPPEND_H_INCLUDED











               
#include "cycle.h"
#include "fileref.h"
#ifdef USEADE
#include "interfaceade_flags.h"  
#endif

class ADEMgrX;

class workelem; 
#include "hashcode.h"
#include "fileoffset.h"
class chunker;
class context;
class parsestream_base;

class collator;
#include "dump_layout.h"

enum append_format { af_none, af_dumpstream, af_axionfs, af_emctar_ads, af_emctar_dedup,
                     af_not_primary  
};

enum ads_state { s_namelen, s_name, s_datalen, s_data, s_done };

struct emctar_ads_context {
    ads_state state;
    unsigned long namelen;
    ustring sname;
    ubigint64 datalen;

    fileoffset startpos, endpos;

    emctar_ads_context()
        : state(s_namelen), namelen(0), sname(), datalen(0), 
         startpos(fileoffset::unknown), endpos(fileoffset::unknown) 
    {}
    ustring image() const { return ustring::sprintf("(state:%d namelen:%lu sname:'%s' datalen:%"LL"u)",
                                                    state, namelen, *sname, datalen); }
};


class restelem;

class backappend : public BackCycle {
public:
    SAFEPOOLALLOC(backappend);

    
    
    
    
    backappend(BackCycle *parent,                       
               context *main,                           
               workelem *info,                          
               fileref f,                               
               const bool isdir,                        
               const fileoffset size = 0,               
               const append_format fmt_ = af_none,      
               const dump_header *headerp = NULL,       
               parsestream_base *parser = NULL,         
               const bool destroy_workelem_ = false     
               );

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();
    virtual ~backappend();
    void set_chunk( chunker *chunk_ ); 
    void set_chunk_top( chunker *chunk_ );
    void set_max_offset( fileoffset endoff ) { max_offset = endoff; };
    chunker *get_chunker() const { return (m_chunker); };
    chunker *get_top_chunker() const { return (chunk_top); };
private:
    
    
    void doappend(fileref& data, bool checkData = false);

    
    void getAndSpawnChunks();

    
    void spawnChunk(const fileref& datachunk);

    bool read_dump_stream();
    bool read_emctar_ads(const ustring &fname, emctar_ads_context *ctx);
    bool read_emctar_ads_streambytes(ubigint64 datalen);

    
    
    
    
    
    
    
    
    
    void set_sizes_as_needed(const fileoffset& totalsize);

    
    
    
    bool set_sizes_from_data_regions();

    fileref  f;

    int buff_size;
    fileoffset totalsize;
    fileoffset curr;
    bool got_flush;
    chunker *m_chunker;
    chunker *chunk_top; 
    collator *m_collater;
    const bool isdir;
    const bool isSystemInfo;
    parsestream_base *parser;

    append_format fmt; 
    const dump_header *headerp;
    fileoffset total_bytes_read;
    ustring fname;      
    const bool destroy_workelem;

    
    cycle *restdata_child;
    fileref old_data;
    restelem *back_restelem;
    chunktype rest_ctype;                         
    fileoffset max_offset;


    ADEMgrX*    adeMgr;
    BuilderID   chunkerID;

    emctar_ads_context *adsctx;

    bool lastChunkWasZeros;

    
    
    static bool file_is_socket; 
    static int file;

    
    bool DoOptimizedExtentsRead();

};

#endif
#if !defined(CLIENT_H_INCLUDED)
#define CLIENT_H_INCLUDED















#include "uapp_staged.h"
#include "context.h"
#include "mctypes.h"
#include "agent_message.h"
#include "utar_flags_info.h"
#include "arglist.h"
#include "runstage.h"
class IPADDR;

#include "ctl_state.h"
#include "ctl_queue.h"
#include "ctl_connection.h"
class utar_ctl_sup;
class ctl_table;
class ctl_callhome;


class client     :   public uapp_staged
{
private:
  utar_flags_info flags;
  utar_flags_info dstflags;
  bool       istar;
  context   *mycontext;



  ustring    ctl_key;
  ctl_queuep mainq;
  ctl_table*  mytable;
  ctl_callhome *callhome; 
  ctl_connectionp ctl_conn;
  
  ctl_connectionp dto_ctl_conn;

  static int workorder_parse(agent_messagep mess, utar_flags_info& uflags);
  bool check_for_workorder();
  void check_pluginid();
  static bool read_workorder(ustring filename, agent_messagep& mess);
  int do_wfp_test();
  bool run_in_ctl_mode(const IPADDR connect_to, utar_flags_info& flags, utar_flags_info& dstflags);
  exitcodes_t main_control(const cidtype& clientid);

  
  exitcodes_t prepForMetadata(const cidtype client_id);

  
  void handle_wrapup(const int exitcode, const backstats* stats);

  void check_script_allowed(stringlist &s, bool is_stdout, bool is_create, bool is_extract, const ustring& caller);

  
  
  void validate_stream_flags();
  bool run_in_adhoc_mode(const IPADDR connect_to, utar_flags_info& flags);

public:
  SAFEALLOC(client);
  client(int argc, char **argv);
  virtual ~client();

  void SetTarFlag( const bool bIsTar ) {
    
    istar = bIsTar;
  }

  void CreateContext( void );

  
  exitcodes_t ExecuteCommand (
     const ustring& command,     
     const cidtype  clientid,
     ctl_messagep   requestp,    
     ctl_queuep     responseq    
  );

  
  context  *GetContext( void ) { return ( mycontext ); }
  
  virtual int run();
  exitcodes_t RunEx( int iSpecialFlag );

  utar_flags_info& getflags() { return flags; }
};


#endif
















#include "common.h"
#include "debug.h"
#include "restisilonsslicefile.h"
#include "restdata.h"
#include "context.h"
#include "utar_flags_info.h"
#include "output.h"
#include "pipe_control.h"
#include "emctarpipe.h"
#include "platerror.h"
#include "utar_flags_enums.h"
#include "uwrapper.h"
#include "dirrec_pack.h"
#include "filerefx.h"
#include "backstate.h"
#include "isilontarstream.h"

#ifdef USEADE  
#include "msgpack_c.h"
#include "ade_mgrx.h"
#endif

#include "data_regions.h"
#include "ndmp_volume_entification.h"

#define sslice_msg ((xflag[2] & 4) != 0)


#define disablefilepipethrottling ((xflag[15] & 16777216) != 0)

const int INITIAL_HEADER_BUF_SIZE = 16384;
const int INITIAL_ADS_BUF_SIZE = 1024 * 32;

enum phases {
    phase_init                 = 0,     
    phase_sslice_real_header   = 1,     
    phase_sslice_header        = 2,     
    phase_forksdone            = 3      
};

restisilonsslicefile::restisilonsslicefile(bicycle* parent, const hashcode& hash,
                               DIRELEM& direlem, cycle* starter,
                               ucontainer::basep rest_container)
  : bicycle(parent),
    ADERestore(parent->main),
    decrementfilecount(false),
    phase(phase_init),
    ppipe_control(NULL),
    realde(),
    tmpde(),
    realsize(0),
    realh(),
    isregularfile(false),
    islnk(false),
    isfirst(false),
    parser_real(NULL),
    parser_current(NULL),
    dir_offset(0),
    use_container(false),  
    setactivelimit(false),
    catalog_enabled(main ? ((main->getAdeMgr()->getHfsInfo(dpn0)).metaStore != NULL) : false)
{
    ppipe_control = (main ? dynamic_cast<isilontarpipe*>(main->getpipe_control(&info)) : NULL);

    
    
    dataProvider.setup(this, this);

    assert(!direlem.is_directory());
    assert(ppipe_control);
    assert(flags.streamformat_out == utar_flags_enums::streamformat_isilon);

    nforked = 0;
    ncollected = 0;

    info.direlem = direlem;
    info.path = direlem.fullpath();

    dirrec_pack::regions drr(&info.direlem);

    if (!drr.get(eoff) || eoff.empty()) {
        Out->msg(ERR, "During restore of '%s', unable to find REGIONS dirrec, or is empty",
                 *info.direlem.fullpath().image());
        phase = phase_forksdone;
        todoEnqueue(TODO_DONE, this);
        return;
    }

    cur_loc = info.direlem.get_location();
    use_container = (cur_loc.getMedia() > location::media::gsan);
    if (use_container) {
        if (rest_container.isdefined()) {
            
            info.container = rest_container;
        } else {
            
            if (sslice_msg) DB->msg("restisilonsslicefile::restisilonsslicefile opening container (ID:%d)", cur_loc.get_containerid());
            info.container = main->open_container_for_read(cur_loc);
        }
    }

    
    
    
    
    
    
    tmpsz = 16384;
    if (starter)
        starter->setnext(TODO_FILE, this, 0);
    else
        todoEnqueue(TODO_FILE, this);
}





void restisilonsslicefile::init_real_location_data()
{
    realde = new DIRELEM;
    real_loc.setMedia(cur_loc.getMedia());
    real_loc.set_backupid(cur_loc.get_backupid());
    real_loc.set_containerid(cur_loc.get_containerid());
    real_loc.set_format(cur_loc.get_format());
    real_loc.set_abs_offset_in_container(dir_offset);
    real_loc.set_coverage_size(realsize);
    realde->set_location(real_loc);
}

void restisilonsslicefile::init()
{
    
    
    islnk = main->check_emctar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset);

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    
    
    
    
    
    
    
    
    
    if (!disablefilepipethrottling) {
        
        
        
        bigint64 maxfilepipedepth = (bigint64)flags.filecyclethrottlethresh * (1024 * 1024);
        
        
        
        bigint64 maxpipequeuedepth = (bigint64)flags.maxpipemb * (1024 * 1024);
        
        fileoffset reservedbytespending = ppipe_control->reserved_bytes_pending();
        
        
        fileoffset filesize = islnk ? realsize : eoff.back().second;
        
        
        
        if ( (reservedbytespending > 0) && ((reservedbytespending + filesize) > maxfilepipedepth) ) {
            
            todoEnqueueInsert(TODO_FILE, this, 1);
            return;
        }
        
        
        
        setactivelimit = ((reservedbytespending + filesize) > maxpipequeuedepth);
        if (setactivelimit)
            
            
            main->safesetactivelimit(TODO_FILE_CACHE, "wait for large file cycle to complete", true);
    }

    if (islnk) {
        if (sslice_msg)
            DB->msg("restisilonsslicefile::restisilonsslicefile %s inode %"LL"u, context says we're a hardlink: "
                    "isfirst:%d realde:%s realh:%s realsize:%s",
                    *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                    (realde.isnull()?"(nullde)":*realde->fullpath().image()),
                    *real_metadataid.partialimage(), *realsize.image());

        
        
        
        
        
        isregularfile = use_container ?
                    
                    ((ubigint64)info.direlem.get_location().get_abs_offset_in_container().value() == dir_offset) :
                    
                    (realh == info.direlem.file_hash());

        if (realsize < tmpsz) {
            tmpsz = realsize;
        }

        
        fileoffset startpos, endpos;
        if (!data_regions::findrange(eoff, data_regions::header, true, startpos, endpos))
            Out->msg(ERR, "During restore of %s, endoffset '%s' does not contain a header section; ACLs will not be restored for this object",
                     *info.direlem.fullpath().image(), *data_regions::image_endoffsets(eoff));

        
        cycle *child1 = restore_range(info.direlem.file_hash(), 0, endpos, true, tmpcurbuf, errmsg, info.direlem, info.container);
        if (!child1)
            Out->msg(ERR, "restisilonsslicefile unable to create restdata cycle for header section: %s %s %s",
                     *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(), *errmsg);

        if (use_container)
            init_real_location_data();

        
        
        
        cycle* child2 = restore_range(realh, 0, tmpsz, true, tmprealbuf, errmsg,
                                      
                                      
                                      (use_container ? *realde : info.direlem),
                                      info.container, use_container);

        if (!child2)
            Out->msg(ERR, "Unable to spawn restore of hardlink real file header data for %s: %s",
                     *info.direlem.fullpath().image(), *errmsg);

        phase = phase_sslice_real_header;
    } else {
        process_regular_file();

        main->print_path(info.direlem);
        main->addfilebytes(context::restorestats, data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());

        
        
        
        phase = phase_forksdone;
    }

    
    
    
    main->set_cur_filename(info.direlem.fullpath());

    if (nforked == 0) {
        notifyparent();
        return;
    }
}

void restisilonsslicefile::handleData(fileoffset foOffset, fileref& restoreData)
{
    Out->msg(ERR, "restisilonsslicefile class does not implement nsAdeLib::ADERestore interface");
    assert(false);
}


bool restisilonsslicefile::process_header_buffer(const fileref& buf, DIRELEMp& de,
                                                 const MetadataId& metadataid, isilontarstream::parser& parser)
{
    parser.set_source_data(buf);
    fileref altref, stubref;
    if (!parser.getentry(de, altref, stubref))
        return false;

    parser.recordmarks(de);
    dirrec_pack::regions drr(de.getimpl());
    data_regions::endoffsets_t tmpeoff;

    if (!drr.get(tmpeoff) || tmpeoff.empty()) {
        Out->msg(ERR, "During restore of '%s', unable to find data regions dirrec for hardlink realde streamslice data",
                 *de->fullpath().image());
        return false;
    }

    if (sslice_msg)
        DB->msg("restisilonsslicefile::process_header_buffer parser found de for '%s', "
                "endoffsets %s, altref.size:%s stubref.size:%s",
                *de->fullpath().image(), *data_regions::image_endoffsets(tmpeoff),
                *altref.size64().image(), *stubref.size64().image());

    if (!altref.isnull())
        altref.hexdump(false);

    baselocation_sp blp(de->get_metadataLocation());
    de->set_hash(metadataid.tohashcode(), blp );

    if (rangesize(tmpeoff, data_regions::header, false) == 0) {
        Out->msg(ERR, "During restore of '%s', unable to determine the header section for hardlink realde.",
                 *info.direlem.fullpath().image());
        return false;
    }

    fileoffset startbyte;
    fileoffset endbyte;
    if (!findrange(tmpeoff, data_regions::primarydata, false, startbyte, endbyte)) {
        Out->msg(ERR, "During restore of '%s', unable to determine the primary data sections for hardlink direlem.",
                 *info.direlem.fullpath().image());
        return false;
    }

    return true;
}

void restisilonsslicefile::childdone(cycle* child)
{
    if (sslice_msg)
        DB->msg("restisilonsslicefile::childdone 1 child:%p nforked:%d ncollected:%d phase:%d",
                child, nforked, ncollected, phase);

    if (child)   
        ncollected++;

    
    
    if (phase == phase_sslice_real_header) {
        if (ncollected < nforked)
            return;

        
        isilontarstream::header hdr;
        hdr.initialize(tmprealbuf);

        if (!hdr.isgood())
            Out->msg(ERR, "Bad header data for real file found when restoring header data for %s: %s",
                     *info.direlem.fullpath().image(), *hdr.errormsg());

        phase = phase_sslice_header;

        fileoffset startpos = isilontarstream::PAX_HDR_SIZE;
        fileoffset endpos = startpos + hdr.size + isilontarstream::get_padding(hdr.size) + startpos;

        
        if (endpos > tmpsz) {
            cycle* child = restore_range(realh, tmpsz, endpos, true, realbuf, errmsg,
                                         
                                         
                                         (use_container ? *realde : info.direlem),
                                         info.container, use_container);
            if (!child)
                Out->msg(ERR, "Unable to spawn restore of hardlink real file header data for %s: %s",
                         *info.direlem.fullpath().image(), *errmsg);
            return;
        }
    }

    
    
    if (phase == phase_forksdone) {
        if (ncollected < nforked)
            return; 

        if (sslice_msg || info.data.getrefcount() != 1)
            DB->msg("restisilonsslicefile::childdone %s, info.data.getrefcount = %d",
                     *info.direlem.fullpath().image(), info.data.getrefcount());

        info.data.free();   

        
        
        if (setactivelimit)
            main->safesetactivelimit(TODO_MAX, "large file cycle complete", true);

        if (sslice_msg)
            DB->msg("restisilonsslicefile::childdone %s num_open_files=%d",
                     *info.direlem.fullpath().image(), +main->num_open_files);

        if (decrementfilecount)
            main->num_open_files--;

        decrementfilecount = false;
        notifyparent();

        return;
    }

    if (phase == phase_sslice_header) {
        if (ncollected < nforked) {
            if (sslice_msg)
                DB->msg("returning because we have not collected all forked children");
            return;
        } else {
            if (sslice_msg)
                DB->msg("continuing with phase_sslice_header: nforked %d ncollected %d", nforked, ncollected);
        }

        if (sslice_msg)
            DB->msg("realbuf:%s for '%s' %"LL"u", *realbuf.size64().image(),
                    *info.direlem.fullpath().image(), info.direlem.inode_number64());

        
        if (realbuf.isnull()) {
            realbuf = tmprealbuf;
        } else {
            fileref tempref;
            tempref.initmem(realbuf);
            realbuf.initmem(tmprealbuf.size() + tempref.size());
            realbuf.setslice(0, tmprealbuf);
            realbuf.setslice(tmprealbuf.size(), tempref);
        }

        
        
        
        
        
        parser_real = new isilontarstream::parser("", utar_flags_enums::streamformat_isilon, 512, 30, 0, "");
        parser_current = new isilontarstream::parser("", utar_flags_enums::streamformat_isilon, 512, 30, 0, "");

        
        if (process_header_buffer(realbuf, realde, real_metadataid, *parser_real)) {
            dirrec_pack::regions drr(realde.getimpl());
            if (!drr.get(realeoff) || realeoff.empty())
                Out->msg(ERR, "During restore of '%s', unable to find REGIONS dirrec, or is empty",
                         *info.direlem.fullpath().image());
            if (use_container)
                realde->set_location(real_loc);
        } else {
            Out->msg(ERR, "Restore of %s from inode_table for '%s' inode:%"LL"u resulted in non streamslice data",
                     *real_metadataid.partialimage(), *info.direlem.fullpath().image(), info.direlem.inode_number64());
        }

        if (sslice_msg)
            DB->msg("tmpbuf:%s for '%s' %d", *tmpcurbuf.size64().image(),
                    *info.direlem.fullpath().image(), info.direlem.inode_number());

        
        MetadataId de_metadataid(info.direlem.file_hash());
        if (!process_header_buffer(tmpcurbuf, tmpde, de_metadataid, *parser_current))
            Out->msg(ERR, "Restore of %s had an invalid header", *info.direlem.fullpath().image());

        if (!realde.isnull()) {
            if (sslice_msg)
                DB->msg("restisilonsslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde:'%s' %s eattr:%d",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *tmpde->fullpath().image(), *tmpde->file_hash().partialimage(), tmpde->get_security_size(),
                                    *realde->fullpath().image(), *realde->file_hash().partialimage(), realde->get_security_size());
        } else {
            if (sslice_msg)
                DB->msg("restisilonsslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde: (null)",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *tmpde->fullpath().image(), *tmpde->file_hash().partialimage(), tmpde->get_security_size());
        }
    }

    islnk = main->check_emctar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset);

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    if (islnk) {
        if (!isfirst) {
            DB->msg("%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, %s to link",
                    *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                    *info.direlem.file_hash().partialimage(), isregularfile ? "regular" : "link");
            
            process_reg_or_link_to_link();

            
            main->record_one_hardlink_restore(info.direlem);

            main->byteprogress(context::restorestats, stats::hardlink,
				data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());

        } else {
            if (isregularfile) {
                DB->msg("%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, regular to regular",
                        *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                        *info.direlem.file_hash().partialimage());

				process_regular_file();

            } else {
                DB->msg("%s inode %"LL"u, context says we're a hardlink: isfirst:%d hash:%s, link to regular",
                        *info.direlem.fullpath().image(), info.direlem.inode_number64(), isfirst,
                        *info.direlem.file_hash().partialimage());

                
                
                
                if (!catalog_enabled) {
                    
                    realde->set_hash(realh);
                }
                process_link_to_reg();
			}

            main->record_hardlinked_file(*tmpde.getimpl());
        }
    }

    main->print_path(info.direlem);
    
    
    
    
    
    main->addfilebytes(context::restorestats, data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());

    phase = phase_forksdone;
    childdone(NULL);
}

restisilonsslicefile::~restisilonsslicefile()
{
    if (decrementfilecount)
        main->num_open_files--;

    delete parser_real;
    delete parser_current;
}

cycle* restisilonsslicefile::restore_section(data_regions::section_t sectiontype,
                                             data_regions::endoffsets_t& endoff,
                                             DIRELEM& de,
                                             bool fromend,
                                             fileref& outslice,
                                             ustring& errmsg)
{
    errmsg = "";

    fileoffset startbyte;
    fileoffset endbyte;

    if (!data_regions::findrange(endoff, sectiontype, fromend, startbyte, endbyte)) {
        errmsg = ustring::sprintf("could not find range for section type:%d in '%s' direlem with filehash %s, endoffsets %s",
                                  sectiontype, *de.fullpath().image(),
                                  *de.file_hash().partialimage(),
                                  *data_regions::image_endoffsets(endoff));
        return NULL;
    }

    if (startbyte == endbyte) {
        errmsg = ustring::sprintf("empty section type:%d found", sectiontype);
        return NULL;
    }

    cycle* child = restore_range(de.file_hash(), startbyte, endbyte, true, outslice, errmsg, de, info.container, use_container);

    if (sslice_msg)
        DB->msg("restsslicefile::restore_section child:%p %s using file_hash():%s [%s %s]",
                child, *de.fullpath().image(), *de.file_hash().partialimage(),
                *startbyte.image(), *endbyte.image());

    return child;
}



void restisilonsslicefile::process_regular_file()
{
    if (rangesize(eoff, data_regions::header, false) == 0) {
        Out->msg(ERR, "No header data in data regions dirrec for streamslice data for '%s' during restore",
                 *info.direlem.fullpath().image());
        return;
    }

    fileoffset totalslicelen = eoff.back().second;

    ppipe_control->init_data_slice(info.data, totalslicelen, "data");

    if (!restore_range(info.direlem.file_hash(), 0, totalslicelen, true, info.data, errmsg, info.direlem, info.container, use_container))
        Out->msg(ERR, "Failed to restore data section for file '%s' with hash:'%s': %s",
                 *info.direlem.fullpath().image(), *info.direlem.file_hash().image(), *errmsg);
}

void restisilonsslicefile::update_sparse_file_attributes()
{
    
    
    if (parser_real->pax_recs.defined("GNU.sparse.major") &&
        parser_real->pax_recs.defined("GNU.sparse.minor") &&
        parser_real->pax_recs.defined("GNU.sparse.name") &&
        parser_real->pax_recs.defined("GNU.sparse.realsize")) {
        ustring gnusparsemajor;
        parser_real->pax_recs.get_str("GNU.sparse.major", gnusparsemajor);
        parser_current->pax_recs.put_str("GNU.sparse.major", gnusparsemajor);

        ustring gnusparseminor;
        parser_real->pax_recs.get_str("GNU.sparse.minor", gnusparseminor);
        parser_current->pax_recs.put_str("GNU.sparse.minor", gnusparseminor);

        ustring sparsefilerealsize;
        parser_real->pax_recs.get_str("GNU.sparse.realsize", sparsefilerealsize);
        parser_current->pax_recs.put_str("GNU.sparse.realsize", sparsefilerealsize);

        ustring isisparsemapsize;
        parser_real->pax_recs.get_str("ISI.sparse.mapsize", isisparsemapsize);
        parser_current->pax_recs.put_str("ISI.sparse.mapsize", isisparsemapsize);

        ustring sparsedatasize;
        parser_real->pax_recs.get_str("size", sparsedatasize);
        parser_current->pax_recs.put_str("size", sparsedatasize);

        fileref isipathref;
        parser_current->pax_recs.get_fr("ISI.enc_path", isipathref);
        ustring sparsefilepath;
        isilontarstream::convert_from_isi_enc_path(isipathref, sparsefilepath);
        parser_current->pax_recs.put_str("GNU.sparse.name", sparsefilepath);
    }
}

void restisilonsslicefile::update_link_to_reg_attributes()
{
	
    parser_current->pax_hdr.linkpath = "";

	
    parser_current->pax_recs.remove("linkpath");

	
	ustring linkoffset;
    parser_current->pax_recs.get_str("linkoffset", linkoffset);
	main->inode64_to_linkoffset[info.direlem.inode_number64()] = linkoffset;

	
    parser_current->pax_recs.remove("linkoffset");

	
	update_sparse_file_attributes();

	
    parser_current->ustar_hdr.linkpath = "";

	
    parser_current->ustar_hdr.typeflag = parser_real->ustar_hdr.typeflag;

	
    parser_current->ustar_hdr.size = realde->file_size().value();
}


void restisilonsslicefile::process_link_to_reg()
{
    fileoffset startbyte, endbyte;
    if (findrange(realeoff, data_regions::primarydata, false, startbyte, endbyte)) {
        
        update_link_to_reg_attributes();

        
        output_header_to_stream(*parser_current);

        fileoffset dataendoffset = endbyte;
        fileoffset datasize = endbyte - startbyte;

        if (datasize > 0) {
            
            
            fileoffset padsize = rangesize(realeoff, data_regions::padding, false);
            dataendoffset += padsize;
            
            ppipe_control->init_data_slice(info.data, datasize + padsize, "filedata");
            if (!restore_range(realde->file_hash(), startbyte, dataendoffset, true, info.data, errmsg, *realde.getimpl(), info.container, use_container)) {
                Out->msg(ERR, "Failed to restore file '%s' with hash:'%s': %s", *info.direlem.fullpath().image(),
                         *info.direlem.file_hash().image(), *errmsg);
            }
        }
        
        
        if (realsize > dataendoffset)
            Out->msg(WARN, "Unable to properly handle (CIFS) alternate data streams on (NFS) hardlinks: %s. "
                     "Alternate data streams may not have been restored correctly.",
                     *info.direlem.fullpath().image());
    }
}



void restisilonsslicefile::process_reg_or_link_to_link()
{
    
    parser_current->ustar_hdr.typeflag = PAXNDMP_LNKTYPE;

    
    parser_current->ustar_hdr.size = 0;

    
    if (parser_current->pax_recs.defined("GNU.sparse.major") &&
        parser_current->pax_recs.defined("GNU.sparse.minor") &&
        parser_current->pax_recs.defined("GNU.sparse.realsize") &&
        parser_current->pax_recs.defined("GNU.sparse.name")) {
        
        
        ustring sparsefilename;
        parser_current->pax_recs.get_str("GNU.sparse.name", sparsefilename);

        
        
        parser_current->ustar_hdr.pathname = "";
        parser_current->ustar_hdr.pathprefix = "";
        parser_current->pax_recs.put_str("path", sparsefilename);

        
        parser_current->pax_recs.remove("GNU.sparse.major");
        parser_current->pax_recs.remove("GNU.sparse.minor");
        parser_current->pax_recs.remove("GNU.sparse.name");
        parser_current->pax_recs.remove("GNU.sparse.realsize");
        parser_current->pax_recs.remove("ISI.sparse.mapsize");
        parser_current->pax_recs.remove("size");
    }

    
    DIRELEMp realde = main->emctar_hardlinked_direlems[info.direlem.inode_number64()].direlemp;
    ustring realpath = realde->fullpath().image();
    parser_current->pax_recs.put_str("linkpath", realpath);

    
    
    
    parser_current->ustar_hdr.linkpath = "../@LongHardLink";

    
    ustring linkoffset;
    linkoffset = main->inode64_to_linkoffset[info.direlem.inode_number64()];
    parser_current->pax_recs.put_str("linkoffset", linkoffset);

    output_header_to_stream(*parser_current);
}



void restisilonsslicefile::output_header_to_stream(isilontarstream::parser& p)
{
    
    
    
    
    
    
#ifdef S_IFMT
    p.ustar_hdr.mode = (p.ustar_hdr.mode & (~S_IFMT));
#endif

    fileref tempref;
    p.pax_recs.image(tempref);
    p.pax_hdr.size = tempref.size();

    int paddedsize = tempref.size() + isilontarstream::get_padding(tempref.size());

    fileref ext_hdr;
    ext_hdr.initmem(paddedsize);
    ext_hdr.clrdata();
    ext_hdr.setslice(0, tempref);

    
    fileref paxslice;
    p.pax_hdr.get_header_buf(paxslice);

    fileref ustarslice;
    p.ustar_hdr.get_header_buf(ustarslice);

    if (sslice_msg) {
        paxslice.hexdump(false);
        ext_hdr.hexdump(false);
        ustarslice.hexdump(false);
    }

    
    ppipe_control->set_data_slice(paxslice, "pax_header");
    ppipe_control->set_data_slice(ext_hdr, "extended_header");
    ppipe_control->set_data_slice(ustarslice, "ustar_header");
}

#if !defined(RESTZFSSSLICEFILE_H_INCLUDED)
#define RESTZFSSSLICEFILE_H_INCLUDED












#include "common.h"
#include "cycle.h"
#include "layout.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "fileoffset.h"
#include "utar_flags_info.h"
#include "hashcode.h"
#include "ade_restore.h"
#include "zfstarpipe.h"
#include "zfstarstream.h"
#include "restdataproducer.h"



class restzfssslicefile : public bicycle, nsAdeLib::ADERestore {
public:
    enum phases {
        phase_init                 = 0,     
        phase_sslice_real_header   = 1,     
        phase_sslice_header        = 2,     
        phase_process_hdr_cycle    = 3,
        phase_write_data_cycle     = 4,
        phase_file_cycle_done      = 5,
        phase_forksdone            = 6,     
        phase_cross_platform       = 7      
    };

    restzfssslicefile(bicycle* parent, DIRELEM& direlem, cycle* starter, ucontainer::basep rest_container);

    virtual void init();
    virtual void handleData(fileoffset foOffset, fileref& restoreData);
    virtual void childdone(cycle* child);
    virtual ~restzfssslicefile();

    SAFEPOOLALLOC(restzfssslicefile);

protected:
    restelem info;

private:
    void process_header_buffer(const fileref &buf, DIRELEMp &realde,
                               const MetadataId &metadataid, zfstarstream::parser &p);

    cycle* restore_section(data_regions::section_t sectiontype,
                           data_regions::endoffsets_t& endoff,
                           DIRELEM& de,
                           bool fromend, fileref& outslice,
                           ustring& errmsg);

    void process_regular_file();
    void process_link_to_reg();
    void process_reg_or_link_to_link();
    void init_real_location_data();
    void throttle_file_cycles();

    
    int phase;

    zfstarpipe* ppipe_control;

    DIRELEMp realde;
    DIRELEMp curde;
    fileref realbuf;
    fileref hdrbuf;
    fileref databuf;
    fileoffset realsize;
    MetadataId real_metadataid;
    hashcode realh;
    bool isregularfile;
    bool islnk;
    bool isfirst;
    ustring errmsg;
    zfstarstream::parser realparser;
    zfstarstream::parser curparser;
    data_regions::endoffsets_t eoff;
    data_regions::endoffsets_t realeoff;
    ubigint64 dir_offset;
    location real_loc;
    location cur_loc;
    bool update_path;
    bool use_container;
    bool setactivelimit;
    bool catalog_enabled;
};


class restzfscrossfile : public cycle {
public:
    enum phases {
        phase_file_hdr,
        phase_subfile_hdr,
        phase_subfile_data,
        phase_forksdone
    };

    restzfscrossfile(cycle* parent, DIRELEM& de, cycle* starter, ucontainer::basep container);

    virtual void init();
    virtual void childdone(cycle* child);
    virtual ~restzfscrossfile() {}

    SAFEPOOLALLOC(restzfscrossfile);

private:
    void init_file_stream();
    void process_file_hdr();
    void process_subfile_hdr();
    void process_subfile_data();
    void read_data(const fileoffset& pos, const fileoffset& size);
    void write_data(const fileoffset& pos, const fileoffset& size);

    int phase;
    restelem info;
    fileref streambuf;
    fileref readbuf;
    fileoffset curoffset;
    fileoffset streamoffset;
    fileoffset datasize;
    endoffsets_t eoff;
    bool usecontainer;
    ustring errmsg;
};

#endif
























#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backstreamdir.h"
#include "backavpaxobj.h"
#include "parsestream_base.h"
#include "parser_fileref.h"
#include "filerefx.h"
#include "paxndmp.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "dirrec_pack.h"
#include "filenames.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "paxrec.h"       
#include "avpx_ext.h"     
#include "restdata.h"     

#include "hash_cache.h"
#include "backstate.h"
#include "data_regions.h"
#include "utar_ctl_sup.h"
#include "resource_identifier.h"

#include <algorithm>







#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define verbosealternative ((xflag[1]&16384)!=0) 

#define dowfs             ((xflag[15]&2)==0)      
#define dodirsort         ((xflag[10]&524288)==0) 
#define doincrementaldirs ((xflag[18]&64)!=0)     

#define enable_cbt_size_check ((xflag[29]&64)==0)

#define ispax      (flags.streamformat_in == utar_flags_enums::streamformat_pax)
#define isavpax    (flags.streamformat_in == utar_flags_enums::streamformat_avpax)
#define istar      (flags.streamformat_in == utar_flags_enums::streamformat_tar)
#define issavestream (flags.streamformat_in == utar_flags_enums::streamformat_savestream)


#define CHGBLK_INFOS 10

enum phases { phase_init        = 0,  
              phase_waitonprev  = 1,  
              phase_read_data   = 2,  
              phase_changeblock = 3,  
              phase_forksdone   = 4,  
              phase_do_hidden   = 5,  
              phase_write_dir   = 6,  
            };

const fileoffset off_datahash(1);                
const fileoffset off_data_extents(2);            
const fileoffset off_restextents(3);             
const fileoffset off_level0_use_extents(4);      
const fileoffset off_changeblock_extents(5);     
const fileoffset off_changeblock_append_data(6); 





#define inodenum_64bit(dep) \
              (((ubigint64)((dep)->unix_rdev()) << 32) | \
               ((ubigint64)((dep)->inode_number()) & 0xffffffff))








backstreamdir::backstreamdir(BackCycle* parent_, context *main, workelem *info_,
                             parsestream_base *parser_, int traverse_depth_,
                             const bool use_container_ )
  : BackCycle(parent_, info_),
    ADEBackup(parent->main),
    parser(parser_), traverse_depth(traverse_depth_),
    reserved_hiddendir(false), phase(-1),
    forked_prev_restore(!flags.incremental),
    curlistcount(0),                            
    directories_after_files(issavestream),      
    auto_close_directories(issavestream),       
    restoring_extents(false),
    extent_index(0),
    extent_interval(0),
    isonqueue(false),                           
    change_block_child(NULL),                   
    data_hasher_child(NULL),                    
    increased_change_filesize(fileoffset::unknown),
    changeBlockHasher(parent->main),
    dataHasher(parent->main),
    use_container(use_container_)
{
    if(msg1) DB->msg("backstreamdir::backstreamdir constructor (this:%p), (parent:%p), (main:%p), (parser:%p) (traverse_depth:%d)", this, parent, main, parser, traverse_depth);
    if (main == NULL) {
        set_error(true, "Null context pointer in backstreamdir constructor");
        
    }
    assert(parent != NULL);
    assert(info != NULL);
    if (info->use_container) {
        assert(!info->container.isnull());
    }
    changeBlockHasher.setup(this, this);
    dataHasher.setup(this, this);

    sysinfo = 0;
    size = 0;
    change_filesize = 0;        
    last_offset = 0;            

    
    set_phase(phase_init);

    
    if (!flags.nohiddendir && !flags.dtoexportstream)
    {
        if (traverse_depth == 0) {
            DIRELEMp hiddendir(new DIRELEM);
            const epoch_t now((epoch_t)timer::now());
            hiddendir->initialize( hashcode::zero, now, now, now, fileoffset(0),
                    ATTR_DIRECTORY|ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);
            curlist.enter(UNDOO_DIRECTORY_NAME, hiddendir);
            reserved_hiddendir = true;
        }
    }

    
    
    
    insert_self(save_obj_direlem);
}

backstreamdir::~backstreamdir()
{
    if (extent_stats.count()>0) Out->msg(STATS, "<10689>Changeblock range average %s", *extent_stats.ximage());
  
    if(msg1) DB->msg("backstreamdir::~backstreamdir destructor (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)", parent, this, parser, traverse_depth);

    delete info;
}







void backstreamdir::init()
{
    assert(info!=NULL);
    isonqueue = false;
    static int count;
    if(msg1 || ((++count)%1000) == 0)
        DB->msg("backstreamdir::init cnt=%d (parent:%p) (this:%p), depth=%d info->direlemp:%s, isonqueue:%d phase:%d",
                count, parent, this, traverse_depth, *info->direlemp->fullpath().image(), isonqueue, phase);

    assert(phase==phase_init || phase==phase_read_data || phase ==phase_write_dir);
    if( (phase != phase_init && phase != phase_read_data) || phase== phase_write_dir) {
        Out->msg( INFO, "<8461>backstreamdir::init phase=%d %s", phase, *phase_image() );
    }

    
    
    if(!get_next_header(save_obj_direlem, save_altdata, save_stubdata)) {
        return;
    }
    

    
    if(phase==phase_waitonprev) {
        assert(ispax||isavpax);
        
        
        
        
        main->safesetactivelimit(TODO_FILE, "waitonprev prevlist", true);
        return;
    }

    assert(phase==phase_init || phase==phase_read_data);
    set_phase(phase_read_data);

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *save_obj_direlem->name(), save_obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *save_obj_direlem->name(), save_obj_direlem->file_size().dvalue());

    process_direlem(save_obj_direlem, save_altdata, save_stubdata);

    
    if(phase!=phase_changeblock) insert_self(save_obj_direlem);
}



void backstreamdir::insert_self(DIRELEMp obj_direlem) {
    const ustring name(obj_direlem.isnull() ? ustring("NULL") : obj_direlem->fullpath().image());
    if(msg1)DB->msg("backstreamdir::insert_self (%p)  name:%s depth:%d isonqueue:%d", this, *name, -traverse_depth, isonqueue);
    assert(!isonqueue);
    isonqueue = true;
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);         
}




bool backstreamdir::get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata) {
    
    
    
    
    
    
    
    

    
    altdata = fileref::empty;
    stubdata = fileref::empty;

    
    
    bool have_entry = parser->pop_entry(obj_direlem, altdata, stubdata);

    
    if (!have_entry)
    {
        have_entry = parser->getentry(obj_direlem, altdata, stubdata);

        
        
        
        
        if (flags.streamformat_in == utar_flags_enums::streamformat_emctar)
        {
            if (!have_entry && info->direlemp->is_root())
            {
                
                if (main->tomato)
                {
                    ctl_messagep max_changed_date_msg(new ctl_message(ctl_message::type::send_max_changed_date));
                    max_changed_date_msg->set_max_changed_date(parser->get_max_changed_date(flags.incremental));
                    main->tomato->post_to_parent(max_changed_date_msg, NULL);
                }
            }
        }
    }

    
    if(!have_entry || obj_direlem.isnull()) {
        
        

        
        
        if(flags.incremental && phase==phase_init) {
            if(parser->is_empty_stream()) {
                const upath parent_path("");
                DB->msg("backstreamdir::get_next_header empty stream reading previous backup path for parent '%s'", *parent_path.image());

                cycle * child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, location(), prevlist);
                child->noop();
                nforked++;
                forked_prev_restore = true;
            } else {
                request_prevlist();
            }
        }

        set_phase(phase_forksdone);
        childdone(NULL);

        
        
        
        
        if ((NULL != main->histsrv) && (traverse_depth == 0))
            main->histsrv->data_stream_done(); 

        return false;
    }

    const upath curpath(info->direlemp->fullpath());
    const int   cur_path_elems(curpath.numelems()); 
    const upath newpath(obj_direlem->fullpath());
    const int   new_path_elems(newpath.numelems());    

    if(msg2)
        DB->msg("backstreamdir::get_next_header cur_path_elems:%d(%s)[0]='%s' new_path_elems:%d(%s)[0]='%s' curroffset:%s",
                cur_path_elems, *curpath.image(), *curpath.get(0),
                new_path_elems, *newpath.image(), *newpath.get(0),
                *parser->get_headeroffset().image());

    
    
    if(auto_close_directories) {
        const upath newpath_parent(newpath.slice(0, cur_path_elems - 1));

        
        if(!curpath.compare(newpath_parent)) {
            DB->msg("Auto closing cycle for '%s' because we received '%s'",
                    *curpath.image(), *newpath_parent.image());
            parser->push_entry(obj_direlem, altdata, stubdata);    
            
            set_phase(phase_forksdone); 
            childdone(NULL);
            return false;
        }
    }

    
    
    if(directories_after_files && (new_path_elems < (cur_path_elems + 1))) {
        assert(stubdata.isnull());
        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_forksdone);         
        childdone(NULL);
        return false;
    }

    
    
    
    
    if (new_path_elems > cur_path_elems+1) {
        assert(stubdata.isnull());
        if(msg1)DB->msg("backstreamdir::get_next_header big step '%s' vs '%s' new_path_elems:%d cur_path_elems+1:%d",
                        *curpath.image(), *newpath.image(), new_path_elems, cur_path_elems+1);

        
        
        
        
        if((ispax || isavpax || istar) &&
           (obj_direlem.isnull() || !obj_direlem->is_directory())
        ) {
            Out->msg(FATAL, "<7203>Internal error with path levels, exiting.");
            uapp::staging().startTermination(EXIT_MISC, "internal error with path levels");
            set_phase(phase_forksdone);
            childdone(NULL);
            return false;
        }

        
        
        if(directories_after_files) {
            
            
            obj_direlem->set_is_directory();
        }

        assert(obj_direlem->is_directory()); 

        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        

        
        altdata = fileref::empty;
        
        obj_direlem->set_security(fileref::empty);

        
        obj_direlem->set_fullpath(newpath.slice(0, cur_path_elems));
        obj_direlem->set_name(obj_direlem->fullpath().stripdir());
        obj_direlem->set_is_root();  
        if(msg1)DB->msg("backstreamdir::get_next_header big step new path '%s' name '%s'", *obj_direlem->fullpath().image(), *obj_direlem->name());
    } else {
        
        
        if(directories_after_files && (cur_path_elems + 1 == new_path_elems)) {
            
            
            {
                const upath path(obj_direlem->fullpath());

                if(!obj_direlem->fullpath().has_end_dirsep()) {
                    obj_direlem->set_is_directory(false);
                }

                obj_direlem->set_fullpath(path);
                obj_direlem->set_name(path.stripdir());
            }

            
            
            
            if(curlist.defined(obj_direlem->name())) {
                DB->msg("'%s' already defined in '%s'", *obj_direlem->name(), *newpath.image());

                
                init();
                return false;
            }
        }
    }

    
    if(phase==phase_init && flags.incremental) {
        request_prevlist();
        
        
        
        
        if((ispax || isavpax) && parser->dochangeblocks()) {
            if(msg2)DB->msg("backstreamdir::get_next_header doing changeblocks, set phase to waitonprev");
            set_phase(phase_waitonprev);
        }
    }

    
    
    if (new_path_elems <= cur_path_elems) {
        if(msg2)DB->msg("backstreamdir::get_next_header exiting2 because path is in parent (%d <= %d) '%s'",
                        new_path_elems, cur_path_elems, *obj_direlem->fullpath().image());
        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_forksdone); 
        childdone(NULL);
        return false;
    }

    if(msg2)DB->msg("backstreamdir::get_next_header returns obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *obj_direlem->file_size().image(), *altdata.size64().image(), *stubdata.size64().image());
    return true;
}


void backstreamdir::process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata) {

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *obj_direlem->name(), obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2), *obj_direlem->name(), obj_direlem->file_size().dvalue());

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)DB->msg("backstreamdir::process_direlem obj_direlem1:%s dir:%d  kind:%d file_size=%s altdata:%s stubdata:%s",
        *obj_direlem->fullpath().image(), obj_direlem->is_directory(), obj_direlem->get_kind(), *datasize.image(), *altdata.size64().image(), *stubdata.size64().image());

    
    paxrec paxrecs;
    if ((ispax || isavpax)
        && (!altdata.isnull() || altdata.size64() > 0)) {
      if (!paxrecs.parse(altdata))
        DB->msg("backstreamdir::process_direlem unable to parse paxrecs");
      else if(msg2)paxrecs.log(obj_direlem->name());
    }

    {
        ustring objname(obj_direlem->name());

        if((flags.noduplicatepaths || issavestream || flags.xdrctl) && !curlist.lookup(objname).isnull()) {
            Out->msg(ERR, "<7827>Processing '%s': Duplicate path '%s' in stream",
                     *info->direlemp->fullpath().image(), *objname);
            if(issavestream || flags.xdrctl) {
                
                
                
                
                objname = parser ? parser->generate_unique_name(objname, curlist) : objname;
                obj_direlem->set_name(objname);
                obj_direlem->set_internal();
            }
        }

        ubigint64 headflags(0);
        (void)paxrecs.get_u64(PAXKEY_HEADFLAGS, headflags);
        if(msg1)DB->msg("backstreamdir::process_direlem HEADFLAGS name:%s desend:%d cont:%d ascend:%d",
                        *obj_direlem->name(), (headflags & PAX_HEADFLAGS_DESCEND)!=0,
                        (headflags & PAX_HEADFLAGS_TO_BE_CONTINUED)!=0,
                        (headflags & PAX_HEADFLAGS_ASCEND)!=0);

        
        
        if((ispax||isavpax)
           && ((headflags & PAX_HEADFLAGS_ASCEND) != 0)
           && ((headflags & PAX_HEADFLAGS_TO_BE_CONTINUED) == 0)
        ) {
              if(msg1)DB->msg("backstreamdir::process_direlem found ascend for \"%s\"", *obj_direlem->name());
              if(!curlist.defined(obj_direlem->name())) {
                  Out->msg(ERR, "<8462>Processing '%s': Cannot find beginfile for file:\"%s\"",
                           *info->direlemp->fullpath().image(), *obj_direlem->name());
              } else {
                  if(msg2)DB->msg("backstreamdir::process_direlem found curlist for \"%s\"", *obj_direlem->name());
                  DIRELEMp curde1(curlist.lookup(obj_direlem->name())); 
                  if(change_block_child == &changeBlockHasher) { 
                      changeBlockHasher.populateDirelem(&*obj_direlem);
                      changeBlockHasher.populateDirelem(&*curde1);  
                      changeBlockHasher.resetFirstBlock();          
                      change_block_child = NULL;    
                      if (curde1->get_location().getMedia() == location::media::ddr)
                          Out->msg(INFO, 2, "Processed file (change block) on Data Domain: \"%s\" (%s bytes)", *curde1->fullpath().image(), *commas(curde1->file_size().dvalue()));
                  }
                  else if(data_hasher_child == &dataHasher) { 
                      dataHasher.populateDirelem(&*obj_direlem);
                      dataHasher.populateDirelem(&*curde1);  
                      data_hasher_child = NULL;    
                      if (curde1->get_location().getMedia() == location::media::ddr)
                          Out->msg(INFO, 2, "<10690>Processed file on Data Domain: \"%s\" (%s bytes)", *curde1->fullpath().image(), *commas(curde1->file_size().dvalue()));
                  }
                  else { 
                      
                      
                      
                      hashcode currenthash(curde1->file_hash());


                      curde1->set_hash(currenthash);
                      obj_direlem->set_hash(currenthash); 
                  }
              }
        } else {
            
            curlist.enter(objname, obj_direlem);
        }

        if(!ucontainer_addobj(headflags, obj_direlem, objname)) {
            
            assert(false);
        }

        if(msg2)DB->msg("backstreamdir::process_direlem curlist.enter('%s', '%s')", *objname, *obj_direlem->fullpath().image());
    }

    if (!stubdata.isnull() || stubdata.size() > 0) {
        if(msg1)
            DB->msg("calling nbackdata on stubdata for '%s' with stubdata.size():%d", *obj_direlem->fullpath().image(), stubdata.size());
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem, filestatsref(), stubdata);
        w->use_container = false; 
        nbackdata *back_stubdata = new nbackdata( this, w, emctar_stubdata, parser, use_container);
        back_stubdata->noop();
        nforked++;
    }

    
    if(msg2)
        DB->msg("backstreamdir::process_direlem %p %s",
                this, *obj_direlem->name());

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    
    if(obj_direlem->is_directory()) {
        
        
        if(msg2)DB->msg("backstreamdir::process_direlem subdir for %s", *obj_direlem->fullpath().image());

        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        backstreamdir *subdir = new backstreamdir(this, main, w, parser, traverse_depth+1, use_container);
        subdir->noop();
        nforked++;

    
    } else if(obj_direlem->is_symlink() && datasize == 0) {
        
        
        fileref link = parser->get_symlink_data();
        assert(!link.isnull());
        datasize = link.size();
        obj_direlem->set_file_size(datasize);

        if(msg2)DB->msg("Handling inline symlink, size=%d", datasize.ivalue());
        workelem *w = new workelem( info, link );
        cycle *linkchild = new nbackdata(this, w, off_datahash, false , 0, use_container );
        linkchild->noop();
        nforked++;

    
    
    
    
    
    
    } else if(obj_direlem->is_device_file() && !obj_direlem->is_tar_hardlink() && !flags.celerra_vnx_streamslices) {
        if(msg2)DB->msg("Device file");
        if (obj_direlem->file_size() != 0) {
            Out->msg(ERR, "<9980>Found data stream entry for %s which claims to be a device special file, but has non zero size %s",
                     *obj_direlem->fullpath().image(), *obj_direlem->file_size().image());
        }
        
        
        
    } else {
        
        if(msg2)DB->msg("%s file, size=%"LL"d truncate?%d", (flags.celerra_vnx_streamslices ? "Streamslice mode" : "Regular"), datasize.value(), false); 

       
        
        
        if((datasize > fileoffset(0)) || issavestream || flags.cachepaxstream     

        ){                                                                        
            
            
            hashcode   mydata_hash;
            fileoffset mydata_size;
            if(parser->readhash(obj_direlem, mydata_hash, mydata_size)) {
                

                
                obj_direlem->set_hash(mydata_hash);
                obj_direlem->set_file_size(mydata_size);

                
                size += mydata_size;

                
                main->byteprogress(context::backupstats, stats::filecache, mydata_size.dvalue(), info->fstats);

                
                main->addfilebytes(context::backupstats, mydata_size.dvalue());

                if(flags.cachepaxstream) {
                    
                    parser->reject_data(datasize);
                }
            } else {
                
                
                
                if(issavestream && flags.xdrctl) {
                    
                    main->safesetactivelimit(TODO_HARD_LINK, " waiting for hash", true);
                }

                obj_direlem->set_stdin();       

                
                
                
                const bool hasextents(paxrecs.defined(PAXKEY_EXTENTS)); 
                ubigint64 headflags(0);
                (void)paxrecs.get_u64(PAXKEY_HEADFLAGS, headflags);
                bool islevel0( (headflags & PAX_HEADFLAGS_LEVEL0_EXTENTS) != 0);
                if (msg2) DB->msg("backstreamdir::process_direlem hasextents:%d islevel0:%d", hasextents, islevel0);
                fileoffset::value_type last_off = 0;

                if((ispax || isavpax)
                   && (flags.incremental || islevel0)
                   && hasextents
                ) {
                    assert(parser->dochangeblocks() || islevel0);
                    fileref dataextentsfr;
                    paxrecs.get_fr(PAXKEY_EXTENTS, dataextentsfr);
                    if(msg2)DB->msg("backstreamdir::process_direlem found extents fr.size:%s", *dataextentsfr.size64().image());
                    
                    backupextents(obj_direlem, dataextentsfr, islevel0 ? off_data_extents : off_changeblock_extents);
                    const ustring objpathstr(obj_direlem->fullpath().image());
                    if(islevel0) {
                        if (msg2) DB->msg("backstreamdir::process_direlem islevel0");
                        dataextents level0extents(dataextentsfr);
                        if(level0extents.totalfilesize() > 0) {
                            DB->msg("backstreamdir::process_direlem level0 changing size of %s from %s to %s",
                                    *objpathstr, *datasize.image(), *level0extents.totalfilesize().image());
                            datasize = level0extents.totalfilesize();
                        }
                    } else {
                        dataextents_from_pax_stream.clear();
                        changes.clear();

                        dataextents_from_pax_stream.parse("backstreamdir::process_direlem", obj_direlem->fullpath().image(), dataextentsfr);

                        changes = dataextents_from_pax_stream;

                        
                        if (flags.allowchangeblockfilesizeincrease) {
                            if (!changes.empty()) {
                                last_off = changes.rbegin()->off.value() + changes.rbegin()->len.value();
                            } else {
                                
                                if (main->ADEChunkerEnabled() && changes.totalfilesize() > 0) {
                                    DB->msg("dataextents::parse no change block found, enter 1 byte ex before total file size at %ld",
                                             +(changes.totalfilesize().value() - 1));
                                    changes.enter(+(changes.totalfilesize().value() - 1), +1);
                                    last_off = changes.rbegin()->off.value();
                                }
                            }
                        }

                        DB->msg("backstreamdir::process_direlem lastoff = %ld", last_off);
                        increased_change_filesize = fileoffset::unknown;
                        
                        if(changes.totalfilesize() > 0) {
                            bool ignored_value(true);
                            const fileoffset extents_totalfilesize(changes.totalfilesize());

                            if(flags.allowchangeblockfilesizeincrease) {
                                
                                if(datasize <= extents_totalfilesize) {
                                    if(datasize < extents_totalfilesize) {
                                        DB->msg("backstreamdir::process_direlem incremental size increase of %s to %s",
                                                *objpathstr, *extents_totalfilesize.image());
                                        increased_change_filesize = datasize = extents_totalfilesize;
                                    }
                                    ignored_value = false;
                                }
                            }

                            if(ignored_value && datasize != extents_totalfilesize) {
                                DB->msg("backstreamdir::process_direlem incremental ignoring size increase of %s to %s",
                                        *objpathstr, *extents_totalfilesize.image());
                            }
                        }
                    }
                }
                if(!islevel0 && hasextents && iterate_changeblocks(true, obj_direlem, last_off, true)) {
                    main->safesetactivelimit(TODO_FILE, "changeblock", true);
                } else {

                    
                    if(!flags.ddrenabled || !main->ADEChunkerEnabled()) {
                        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);

                        if (obj_direlem->is_tar_hardlink()) {
                            if (msg2)
                                DB->msg("backstreamdir::process_direlem this:%p obj_direlem:%s is_tar_hardlink:1", this, *obj_direlem->fullpath().image());
                            
                            
                            
                            
                            
                            w->hold_data = true;
                        }

                        
                        w->streamslice = parser->datasize(obj_direlem, datasize);

                        nbackdata *cycle_chunk = new nbackdata( this, w,
                                                                (islevel0 && hasextents) ? off_level0_use_extents : off_datahash,
                                                                false, parser, w->use_container );
                        cycle_chunk->noop();

                    } else {                    
                        const fileoffset streamsize = parser->datasize(obj_direlem, datasize);
                        dataHasher.setSendStreamToDDRIfEnabled();
                        dataHasher.setSizeToRead(streamsize.value());
                        
                        
                        
                        
                        
                        ustring fname = obj_direlem->fullpath().image();
                        dataHasher.setChunkerArgs(fname, obj_direlem->useBackupOps(), false, false, obj_direlem->is_recent(), 0);
                        data_hasher_child = &dataHasher;    
                        continueReading();
                    }

                    nforked++;

                    
                    size += datasize;
                }
            }
        } else {
            

            
            
            
            
            obj_direlem->set_file_size(0);
            obj_direlem->set_hash(hashcode::empty);
        }
    }
    if(msg2)DB->msg("backstreamdir::process_direlem DONE obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(), *stubdata.size64().image());
}

void backstreamdir::childdone(cycle *child)
{
    if(msg1)
        DB->msg("backstreamdir::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d, phase=%d", parent, this, child, nforked, ncollected, phase);

    if (child) {
        ncollected++;

        
        
        if (child->offset == off_data_extents || child->offset == off_changeblock_extents) {
            const ustring extent_desc(child->offset == off_data_extents ? "existence" :
                                      (child->offset == off_changeblock_extents ? "change block" :
                                       "unknown"));

            DB->msg("backstreamdir::childdone process childdone for %s extents", *extent_desc);

            BackCycle *bc = dynamic_cast<BackCycle *>(child);
            assert(bc != NULL);
            assert(!bc->getInfo()->direlemp.isnull());
            if (bc && !bc->getInfo()->direlemp.isnull()) {
                DIRELEMp childde(bc->getInfo()->direlemp);
                
                const int depoffset(childde->adddephash(hash));

                if (child->offset == off_data_extents) {
                    
                    dirrec_pack::data_extents data_extents_pack(childde.getimpl());
                    data_extents_pack.set(depoffset);
                } else if(child->offset == off_changeblock_extents) {
                    
                    dirrec_pack::changeblock changeblock_pack(childde.getimpl());
                    const hfs_info_struct hfs_info(main->getAdeMgr()->getHfsInfo(dpn0));
                    const resource_identifier rl(hfs_info,
                                                 main->determineClientID(hfs_info),
                                                 main->getAdeMgr()->getHfsCreateTime(dpn0),
                                                 main->prev_backup,
                                                 flags,
                                                 childde);
                    changeblock_pack.set(rl.to_fileref(), depoffset);

                    

                    DB->msg("backstreamdir::childdone Resource identifier for previous backup '%s'", *rl.image());
                    main->backup_resource_list.add_to_list(rl);
                }

                if (msg1) DB->msg("backstreamdir::childdone %p setting %s extents dirrec for file:%s depoff:%d",
                                  this, *extent_desc, *childde->name(), depoffset);
            }

        
        } else {

        switch (phase) {

        case phase_init:
            return;

            
          
          
        case phase_waitonprev:
            assert((ispax || isavpax) && flags.incremental);
            if(msg2)DB->msg("backstreamdir::childdone returned from request_prevlist");
            set_phase(phase_read_data);

            main->safesetactivelimit(TODO_MAX, "return from prevlist", true);

            process_direlem(save_obj_direlem, save_altdata, save_stubdata);

            
            
            
            
            
            if(phase!=phase_changeblock) insert_self(save_obj_direlem);
            return;
            break;

        case phase_changeblock:
            assert((ispax || isavpax) && flags.incremental);

            if( child == change_block_child || child->offset==off_restextents) {

                if(msg2)DB->msg("backstreamdir::childdone returned from changeblock hash:%s", *hash.partialimage());

                if(child->offset==off_restextents) {
                    restoring_extents = false;

                    
                    const dataextents prev(prevextentsdata, false);
                    dataextents eunion(prev | dataextents_from_pax_stream);  

                    
                    
                    if(flags.allowchangeblockfilesizeincrease && increased_change_filesize != fileoffset::unknown) {
                        eunion.set_totalfilesize(increased_change_filesize);
                    }

                    
                    fileref newdata;
                    newdata.initlist();
                    eunion.image(newdata);   

                    DB->msg("backstreamdir::childdone returning from backing up extents prev:%d dataextents_from_pax_stream:%d size:%d",
                            (int)prev.size(), (int)dataextents_from_pax_stream.size(), (int)eunion.size());

                    
                    
                    
                    
                    
                    

                    
                    backupextents(save_obj_direlem, newdata, off_data_extents);
                    break;
                }

                
                if(!iterate_changeblocks(false, save_obj_direlem)) {
                    
                    
                    
                    if(!main->ADEChunkerEnabled() || changeBlockHasher.isFinalHashWaiting()) {
                        
                        set_phase(phase_read_data);
                        insert_self(save_obj_direlem);
                        main->safesetactivelimit(TODO_MAX, "return from prevlist", true);
                    }
                    else {  
                        set_phase(phase_changeblock);
                        nforked++;  
                        changeBlockHasher.changeBlockComplete(true);
                    }
                } else {
                    if(msg1)DB->msg("backstreamdir::childdone doing more changeblocks");
                }
                return;
                break;
            }
            

        case phase_read_data:
        case phase_forksdone:
    
    
    




            
            if(child == change_block_child) {
                break; 
            }
            if(child == data_hasher_child)  {
                
                main->safesetactivelimit(TODO_MAX, "return from prevlist", true);
                break; 
            }

            
        case phase_do_hidden: {
            
            break;
        }
        case phase_write_dir: {
            
            assert(ncollected == nforked);
            if(msg1)DB->msg("backstreamdir::childdone: All done, hash=%s", *hash.partialimage());
            info->direlemp->set_hash(hash);

            
            notifyparent();
            
            
            return;
        }
        default:
            assert(false);
        }
        }
    }

    if(msg1)
        DB->msg("backstreamdir::childdone this:%p phase:%d forked_prev_restore:%d nforked=%d ncollected=%d", this, phase, forked_prev_restore, nforked, ncollected);
    
    if ((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)) {
        if (flags.incremental) {
          switch (flags.streamformat_in) {
            case utar_flags_enums::streamformat_pax:
            case utar_flags_enums::streamformat_avpax:
            case utar_flags_enums::streamformat_tar:
              merge_lists_avpax(prevlist, curlist);
              break;

            default:
            Out->msg(ERR, "<7204>Unknown streamformat %s, unable to merge streams.",
                     *utar_flags_info::streamformat_image(flags.streamformat_in));
          }
        } else if(issavestream) {
            if(parser) parser->finalize_listing(prevlist, curlist);
        }

        if(reserved_hiddendir) {
            if(msg1)DB->msg("backstreamdir::childdone calling backhidden nforked:%d ncollected:%d", nforked, ncollected);
            
            
            
            xflag[5] |= (2|8|32|64|1024); 
            flags.nomachinedesc = true;
            const fileoffset hiddenoffset(0);           

            workelem *w = new workelem(info, curlist.lookup(UNDOO_DIRECTORY_NAME));
            w->use_container = false;

            bool write_ddrfiles_xml(false);
            if(flags.ddrenabled) {
                
                if(backstream *bs = dynamic_cast<backstream *>(parent)) {
                    if(nbackroot *nbr = dynamic_cast<nbackroot *>(bs->parent)) {
                        const workelem *grandparentinfo(nbr->getInfo());

                        
                        
                        if(grandparentinfo && grandparentinfo->use_container && !grandparentinfo->container.isnull()) {
                            cycle::main->finalizeucontainer(grandparentinfo->container, false);

                            
                            nbr->set_ucontainer_finalized();

                            
                            write_ddrfiles_xml = true;
                        }
                    }
                }
            }

            
            backhidden *hidden = new backhidden(this, w, hiddenoffset, 0, false , write_ddrfiles_xml);

            hidden->noop();
            nforked++;
        }
        set_phase(phase_do_hidden);
    }

    
    if ((phase == phase_do_hidden) && (ncollected == nforked)) {
        fileoffset dirsize(0);

        
        
        
        
        

        if (!uapp::staging().canRun()) {
            DB->error("backstreamdir::childdone error merging history stream data during phase_do_hidden while processing directory '%s'",
                      *info->direlemp->fullpath().image());
        }

        {
            const fileref listingx(build_dirblock(curlist, dirsize, flags.inode, true));
            consumed_size = listingx.size64();
            info->direlemp->set_file_size(dirsize);
            workelem *w = new workelem( NULL, listingx );
            cycle *datachild = new nbackdata(this, w, fileoffset(0), true   );
            datachild->noop();
        }
        nforked++;
        set_phase(phase_write_dir);

        
        
        if(main->histsrv) {
            int inum = info->direlemp->inode_number();
            if (inum >= 0) main->histsrv->directory_complete(inum);
            else DB->msg("backstreamdir::childdone not calling directory_complete for inode:%d for info->direlemp->fullpath:%s",
                         inum, *info->direlemp->fullpath().image());
        }
    }

    
    
    if (child && !flags.incremental && (phase == phase_read_data) && child->offset == off_level0_use_extents) {
        if(const nbackdata* const nbdchild = dynamic_cast<nbackdata*>(child)) {
            if(const workelem* const we = nbdchild->getInfo()) {
                const fileoffset bytesread(we->size);
                
                const fileoffset extentfilesize(we->streamslice);

                if(bytesread != fileoffset::unknown && extentfilesize > 0) {
                    const ustring filepath(we->direlemp.isnull() ? "(nul)" : we->direlemp->fullpath().image());
                    if(bytesread < extentfilesize) {
                        Out->msg(ERR, "File '%s' only has %s bytes, expected at least %s bytes",
                                 *filepath, *bytesread.image(), *extentfilesize.image());
                    } else if(bytesread != extentfilesize) {
                        Out->msg(WARN, "File '%s' has %s bytes, expected %s bytes",
                                 *filepath, *bytesread.image(), *extentfilesize.image());
                    }
                }
            }
        }
    }
}


void backstreamdir::notifyparent()
{
    if(msg1) DB->msg("backstreamdir::notifyparent (parent:%p) (this:%p)", parent, this);
    if(has_error()) parent->set_error(true, "backstreamdir failed");
    cycle::notifyparent();
    
}


void backstreamdir::set_phase(int phasenum) {
    if (phase!=phase_changeblock && phasenum <= phase) return; 

    if(msg1)DB->msg("backstreamdir::set_phase setting phase to %d", phasenum);

    phase = phasenum;
}

static bool comparenames(const ustring& lhs, const ustring& rhs) {
  
    return strcmp(*lhs, *rhs) < 0;
}


void
backstreamdir::update_stats_counts(const DIRELEMp &de) const
{
    

    if (de->is_internal()) {
        DB->msg("backstreamdir::update_stats_counts skipping %s as it is internal", *de->fullpath().image());
        return;
    }

    
    
    if (de->is_directory()) main->getstatsobj(context::backupstats)->add_dircount(1);
    else                    main->getstatsobj(context::backupstats)->add_filecount(1);
}


void backstreamdir::check_and_set_ddr_media(const ustring& calledfrom, const bool has_ddr_data, DIRELEMp direlemp) const
{
    if(!direlemp.isnull()) {
        if (has_ddr_data) {
            location loc(direlemp->get_location());
            if (loc.getMedia() != location::media::gsan) {
                if(msg2) DB->msg("%s for '%s' found some media == ddr children, but our location is: %s",
                                 *calledfrom, *direlemp->fullpath().image(), *loc.image());
            } else {
                if(msg2) DB->msg("%s for '%s' found some media == ddr children",
                                 *calledfrom, *direlemp->fullpath().image());
            }
            loc.setMedia(location::media::ddr);
            direlemp->set_location(loc);
        } else {
            if(msg2) DB->msg("%s for '%s' did not find some media == ddr children",
                             *calledfrom, *direlemp->fullpath().image());
        }
    }
}



fileref backstreamdir::nextdatablock(bool& suppress_requeue)
{
    
    
    suppress_requeue = false;
    fileref nextbuf;

    DIRELEMp cur;
    fileoffset totalsize = 0;
    
    if (curlist.size() == 0) {
        return nextbuf;                 
    }

    nextbuf.initlist(std::min(unsigned(1000), curlist.size()) * DIRELEM_DOLAYOUT_AVERAGE_SIZE);
    ustring name;
    bool has_ddr_data(false);
    while (curlist.pop(name, cur)) {
        curlistcount++;

        
        if (cur->get_location().getMedia() == location::media::ddr)
            has_ddr_data = true;

        main->layout_direlem(*cur, nextbuf, false, true, true);
        if (!cur->is_internal()) {
            totalsize += cur->file_size();
        }

        info->direlemp->increment_dirsizes(*cur);

        
        
        if (!flags.incremental) update_stats_counts(cur);

        
        if (nextbuf.size64() > 1024*1024)
            break;
    }

    
    check_and_set_ddr_media("backstreamdir::nextdatablock", has_ddr_data, info->direlemp);

    info->direlemp->set_file_size(info->direlemp->file_size()+totalsize);

    
    
    return nextbuf;
}




fileref backstreamdir::build_dirblock(name_to_direlemp_table& de_listing,
                                      fileoffset& totalsize,
                                      bool flags_inode, bool sortrequired
) {
    if(msg1)
        DB->msg ("backstreamdir::build_dirblock %p %s inode:%d",
                 this, *info->direlemp->fullpath().image(), info->direlemp->inode_number());

    fileref listing2;
    
    
    
    
    
    
    
    listing2.initlist(int(de_listing.size() * DIRELEM_DOLAYOUT_AVERAGE_SIZE));
    

    
    if (reserved_hiddendir) {
        const DIRELEMp cur(de_listing.lookup(UNDOO_DIRECTORY_NAME));
        main->layout_direlem(*cur, listing2, false, true, flags_inode);
        
        de_listing.remove(UNDOO_DIRECTORY_NAME);
    }

    bool has_ddr_data(false);
    
    undoo::vector<ustring> names = de_listing.keys();
    if(use_container){
        direlemp_list_type de_vector;
        for (unsigned int i=0; i<names.size(); i++) {
            const DIRELEMp cur(de_listing.lookup(names[i]));
            de_vector.push_back(cur);
        }
        std::sort(de_vector.begin(), de_vector.end(), DIRELEM::direlemp_list_type_container_cmp);

        for (unsigned int i=0; i<de_vector.size(); i++) {
            DIRELEMp cur(de_vector[i]);

            if (cur->get_location().getMedia() == location::media::ddr) has_ddr_data = true;

            
            
            main->layout_direlem(*cur, listing2, false, true, flags_inode);
            totalsize += cur->file_size();

            
            
            if (!flags.incremental) update_stats_counts(cur);
        }

    } else {

        if(dodirsort && sortrequired) {
            
            std::sort(names.begin(), names.end(), comparenames);
        }

        
        for (unsigned int i=0; i<names.size(); i++) {
            DIRELEMp cur(de_listing.lookup(names[i]));

            if (cur->get_location().getMedia() == location::media::ddr) has_ddr_data = true;

            
            
            main->layout_direlem(*cur, listing2, false, true, flags_inode);
            totalsize += cur->file_size();

            
            
            if (!flags.incremental) update_stats_counts(cur);
        }

    }

    
    check_and_set_ddr_media("backstreamdir::build_dirblock", has_ddr_data, info->direlemp);

    curlistcount = names.size();
    
    

    
    return listing2;
}



void backstreamdir::request_prevlist(ubigint64 parentinode) {
    assert(phase==phase_init);
    if(!flags.incremental) return;

    
    
    
    const upath parent_path(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), false);

    if(msg1)
        DB->msg("backstreamdir::request_prevlist \"%s\"", *parent_path.image());

    
    
    if (msg1 || (parent_path.numelems() > 0))
        DB->msg("backstreamdir::request_prevlist reading previous backup path:'%s' nforked:%d ncollected:%d phase:%d forked_prev_restore:%d",
                *parent_path.image(), nforked, ncollected, phase, forked_prev_restore);

    restdirlist *child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, info->direlemp->get_location(), prevlist);

    
    if(flags.pluginid.kind() == pidtype::hypervvss) {
        child->set_no_error_on_path_not_found();
    }

    child->noop();
    nforked++;
    forked_prev_restore = true;
}

  
  
  


bool backstreamdir::merge_lists_avpax(const name_to_direlemp_table& prevlist,
                                name_to_direlemp_table& currlist)
{
    
    
    

    assert(istar || isavpax || ispax);

    DB->msg("backstreamdir::merge_lists_avpax prevlist:%d currlist:%d", prevlist.size(), currlist.size());
    int merged=0;
    const undoo::vector<ustring> names(currlist.keys());
    for (unsigned int i=0; i<names.size(); i++) {
        const ustring myname(names[i]);
        if(msg2)DB->msg("backstreamdir::merge_lists_avpax checking currlist:%s", *myname);
        if(!currlist.defined(myname)) {
            Out->msg(ERR, "<7205>Processing '%s': Cannot find direlem for '%s'",
                     *info->direlemp->fullpath().image(), *myname);
            continue;
        }

        if(currlist.lookup(myname)->get_marker() == DIRELEM::mark_new) {
            DIRELEMp prevDE;
            
            if(!prevlist.defined(myname)) {
                

                
                
                
                
            } else {
                prevDE = prevlist.lookup(myname);
            }

            if(prevDE.isnull()) {
                
                const ubigint64 de_inode(inodenum_64bit(info->direlemp));
                const upath parpath(info->direlemp->fullpath());

                Out->msg(ERR, "<7526>Unable to find '%s' in base backup (under directory '%s' with inode number %"LL"u in incremental)", *myname, *parpath.image(), de_inode);
            } else {
                currlist.enter(myname, prevDE);
                main->byteprogress(context::backupstats, stats::ispresent, prevDE->file_size().dvalue(), info->fstats);
                merged++;
            }
        }
    }
    if(msg2)DB->msg("backstreamdir::merge_lists_avpax merged %d elements", merged);
    return true;
}

dataextents backstreamdir::limit_extents_to_base_file(const dataextents& changes, const fileoffset base_filesize) const
{
    if(flags.allowchangeblockfilesizeincrease && increased_change_filesize != fileoffset::unknown) {
        dataextents ret;

        for(dataextents::const_iterator ei = changes.begin(); ei != changes.end(); ei++) {
            if(ei->off >= base_filesize) {
                break;
            }
            if(ei->off + ei->len <= base_filesize) {
                
                ret.enter(ei->off, ei->len);
            } else {
                
                ret.enter(ei->off, base_filesize - ei->off);
            }
        }

        if(increased_change_filesize > base_filesize) {
            
            
            
            ret.enter(base_filesize, increased_change_filesize - base_filesize);
        }

        if(msg1) {
            for(dataextents::const_iterator ei = ret.begin(); ei != ret.end(); ei++) {
                DB->msg("backstreamdir limit_extents_... extent[%s] = {%s, %s}",
                        *tostr(ei - ret.begin()), *ei->off.image(), *ei->len.image());
            }
        }

        return ret;
    }

    return changes;
}




bool backstreamdir::iterate_changeblocks(bool initializeme, const DIRELEMp& obj_direlem, const fileoffset::value_type last_off, bool send_off) { 
    if(!((ispax || isavpax)
         && flags.incremental
    )) return false;

    
    
    if(!uapp::staging().canRun()) return false;

    const ustring objname(save_obj_direlem->name());
    hashcode prevhash;          
    bool use_increased_filesize(flags.allowchangeblockfilesizeincrease && increased_change_filesize != fileoffset::unknown);

    if(msg1)DB->msg("backstreamdir::iterate_changeblocks name:%s index:%d init:%d last_off:%s (last_offset:%s)", *objname, extent_index, initializeme, *tostr(last_off), *last_offset.image());

    if(initializeme) {
        extent_index = 0;
        last_offset = 0;            

        if(!prevlist.defined(objname)) {
            Out->msg(ERR, "<8464>Processing '%s': Cannot find file %s in previous backup to apply change logs",
                     *info->direlemp->fullpath().image(), *objname);
            return false;
        }

        
        DIRELEMp prev_direlem = prevlist.lookup(objname);
        prevhash = prev_direlem->file_hash();
        change_filesize = prev_direlem->file_size();            
        const bool is_ddrdata(prev_direlem->get_location().getMedia() == location::media::ddr);

        if(change_filesize >= increased_change_filesize) {
            Out->msg(WARN, "Ignoring increased file size (%s) less than or equal to base file size (%s).",
                     *increased_change_filesize.image(), *change_filesize.image());

            increased_change_filesize = fileoffset::unknown;
            use_increased_filesize = false;
        }

        
        if((!is_ddrdata || !main->ADEChunkerEnabled()) && use_increased_filesize) {
            changes = limit_extents_to_base_file(changes, change_filesize);
        }

        if (changes.size() <= 0) {
            Out->msg(WARN, "<8465>Missing changeblocks for %s", *objname);
            return false;
        }

        Out->msg(INFO, "<10695>Processing %"Z"d changeblocks for \"%s\" (%s bytes%s)", changes.size(), *objname, *commas(change_filesize.dvalue()),
                 (increased_change_filesize != fileoffset::unknown) ? *ustring::sprintf(" increasing to %s bytes", *commas(increased_change_filesize.dvalue())) : "");
        if (changes.size() > 10000) Out->msg(WARN, "<10696>VERY HIGH number of changeblocks (%"Z"d) for \"%s\"", changes.size(), *objname);
        extent_interval = int((changes.size()+CHGBLK_INFOS-1)/CHGBLK_INFOS);   

        
        
        if (main->state->hashes != NULL) {        
            DB->msg("Suppressing hashcache writes");
            main->state->hashes->suppress_update();
        }

        
        if(prevhash == hashcode::zero) {
            if(is_ddrdata) {
                if (!prev_direlem->is_dirrec_present(KIND_deprecated_DDR_ALTDATA)) {
                    
                    location loc(prev_direlem->get_location());

                    
                    loc.set_backupid(location::tbackupid(main->prev_backup.getBackupTime()));

                    prev_direlem->set_location(loc);

                    
                    
                    location parent_loc(loc);

                    
                    parent_loc.set_enclosing_container(0);
                    parent_loc.set_emd_relative_path(save_obj_direlem->fullpath().parentdir());

                    
                    main->set_location_info("backstreamdir::iterate_changeblocks()", parent_loc, *prev_direlem);
                }

                changeBlockHasher.setDDRArgs(&*prev_direlem);
            } else {
                
                
                Out->msg(FATAL, "Attempt to perform change block processing on zero hash object \"%s\" that is not DDR hosted", *objname);

                uapp::staging().startTermination(EXIT_ABORT, "object data location unknown while processing changeblock");
                return false;
            }
        }

        
        
        if (prev_direlem->is_dirrec_present(KIND_DATA_EXTENTS)) {
            restoring_extents = restoredataextents(prev_direlem, obj_direlem);
        }

        if(msg2) {
            if(prev_direlem->is_dirrec_present(KIND_CHANGEBLOCK)) {
                DB->msg("backstreamdir::iterate_changeblocks: Previous backup has changeblock dirrec for %s, loc %s", *prev_direlem->fullpath().image(), *prev_direlem->loc_image());
                const dirrec_pack::changeblock changeblock_dirrec(prev_direlem.getimpl());
                fileref resourceidentifier_data;
                int hashoffset;
                if(changeblock_dirrec.get(resourceidentifier_data, hashoffset)) {
                    const resource_identifier rf(resourceidentifier_data);

                    DB->msg("backstreamdir::iterate_changeblocks: Base file url is '%s', extents dephash index %d", *rf.image(), hashoffset);
                }
            } else {
                DB->msg("backstreamdir::iterate_changeblocks: Previous backup has NO changeblock dirrec for %s, loc %s", *prev_direlem->fullpath().image(), *prev_direlem->loc_image());
            }
        }

    } else {
        prevhash = curlist.lookup(objname)->file_hash();
        assert(prevhash == save_obj_direlem->file_hash());

        
        
        if(enable_cbt_size_check && !flags.ddrenabled) {        
            
            const fileoffset new_change_filesize(use_increased_filesize ? increased_change_filesize : change_filesize);
            const DIRELEMp curDE = curlist.lookup(objname);
            DB->msg("backstreamdir::iterate_changeblocks: Filename: %s Original disk length: %s Current disk length: %s New disk length: %s",
                    *objname,
                    *change_filesize.image(),
                    *curDE->file_size().image(),
                    *new_change_filesize.image());
            const bool end_of_extents(extent_index >= (int)changes.size());
            if(end_of_extents) {
                DB->msg("backstreamdir::iterate_changeblocks: End of extents index: %d/%d", extent_index, (int)changes.size());
            } else {
                DB->msg("backstreamdir::iterate_changeblocks: Extent index: %d/%d Off: %s Len: %s",
                        extent_index, (int)changes.size(),
                        *changes[extent_index].off.image(), *changes[extent_index].len.image());
            }
            if(new_change_filesize != curDE->file_size() &&
               !(use_increased_filesize && curDE->file_size() <= new_change_filesize)) {
                Out->msg(FATAL, "Disk size changed from %s to %s when processing changeblock %d (%s, %s). Aborting backup.",
                         *new_change_filesize.image(),
                         *curDE->file_size().image(),
                         extent_index,
                         (!end_of_extents ? *changes[extent_index].off.image() : "Out of Range"),
                         (!end_of_extents ? *changes[extent_index].len.image() : "Out of Range"));
                uapp::staging().startTermination(EXIT_ABORT, "disk sized change while processing changeblock");
                return false;
            }
            if((new_change_filesize % 512) !=0) {
                Out->msg(FATAL, "Disk size isn't a multiple of 512 (it's %s). Please perform a non-Change Block Tracking backup (Level-0). Aborting backup.",
                                 *new_change_filesize.image());
                uapp::staging().startTermination(EXIT_ABORT, "disk size isn't multiple of 512");
                return false;
            }
        } 
    }

    
    
    
    const bool addProgressBytes = (prevhash != hashcode::zero) || changeBlockHasher.isFinalHashWaiting();

    if((unsigned int)extent_index >= changes.size()) {
        
        if(addProgressBytes && (last_offset <= change_filesize)) {
            double bytes_already_on_server = fileoffset(change_filesize - last_offset).dvalue();
            main->addfilebytes(context::backupstats, bytes_already_on_server );
            main->byteprogress(context::backupstats, stats::ispresent, bytes_already_on_server, info->fstats);
            last_offset = 0;
        }
        return false;
    }

    const fileoffset new_change_filesize(use_increased_filesize ? increased_change_filesize : change_filesize);
    extent changex(changes[extent_index++]);
    if(msg2)DB->msg("backstreamdir::iterate_changeblocks processing changes %s [%d]=%s,%s prevhash:%s",
            *objname, extent_index, *changex.off.image(), *changex.len.image(), *prevhash.partialimage());
    extent_stats.enter(changex.len.dvalue());

    
    
    {
        if(changex.off+changex.len > new_change_filesize) {
            if(!use_increased_filesize) {
                Out->msg(FATAL, "<10697>Invalid changeblock detected in \"%s\", changeblock(off=%s, len=%s) extends past the end of the base file (%s bytes).  Possible level zero backup recommended.",
                         *obj_direlem->name(), *changex.off.image(), *changex.len.image(), *new_change_filesize.image());
            } else {
                Out->msg(FATAL, "Invalid changeblock detected in \"%s\", changeblock(off=%s, len=%s) extends past the end of the increased file size (%s bytes).  Possible level zero backup recommended.",
                         *obj_direlem->name(), *changex.off.image(), *changex.len.image(), *new_change_filesize.image());
            }
            uapp::staging().startTermination(EXIT_ABORT, "invalid changeblock");
            return false;
        }
    }

    
    
    const double bytes_already_on_server = fileoffset(changex.off - last_offset).dvalue();
    main->byteprogress(context::backupstats, stats::ispresent, bytes_already_on_server, info->fstats);
    main->addfilebytes(context::backupstats, bytes_already_on_server );

    if (extent_interval==0 || (extent_index%extent_interval)==0)
        Out->msg(INFO, 2, "<10698>Changeblock #%d offset=%s, bytes=%s", extent_index, *changex.off.image(), *changex.len.image());

    assert(changex.off >= 0);
    assert(changex.len >= 0);

    if (!main->ADEChunkerEnabled()) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if(!use_increased_filesize || changex.off + changex.len <= change_filesize) {
            workelem *w = new workelem(info, save_obj_direlem->fullpath(), save_obj_direlem);
            w->changeblock    = true;
            w->changeblockoff = changex.off;
            w->streamslice    = changex.len;
            w->resulthash     = prevhash;
            if(msg1)DB->msg("backstreamdir::iterate_changeblocks found changeblock file:%s off:%s len:%s hash:%s", *save_obj_direlem->fullpath().image(), *w->changeblockoff.image(), *w->streamslice.image(), *w->resulthash.partialimage());

            change_block_child = new nbackdata( this, w, 1, false, parser);
            change_block_child->noop();
        } else {
            
            assert(prevhash != hashcode::zero);

            
            assert(static_cast<size_t>(extent_index) == changes.size());

            
            fileref increased_size_data;
            filerefx::initparser_fileref(increased_size_data, parser, dataextents_from_pax_stream, change_filesize);

            
            
            save_obj_direlem->set_stdin(false);

            workelem *w = new workelem(info, save_obj_direlem->fullpath(), save_obj_direlem, filestatsref(), increased_size_data);

            
            w->changeblock    = true;
            
            
            
            
            w->changeblockoff = change_filesize;
            
            w->cb_append      = true;
            
            w->streamslice    = increased_size_data.size64();
            w->resulthash     = prevhash;

            change_block_child = new nbackdata(this, w, off_changeblock_append_data, false, NULL);
            change_block_child->noop();
        }
    } else {
        
        
        
        
        if(changeBlockHasher.isFirstBlock() ) {
            if(msg1) DB->msg("backstreamdir::iterate_changeblocks first changeblock file:%s off:%"LL"u len:%"LL"u hash:%s",
                                    *save_obj_direlem->fullpath().image(), changex.off.value(), changex.len.value(), *prevhash.partialimage());
            ustring fname(save_obj_direlem->fullpath().image());
            changeBlockHasher.setChunkerArgs(prevhash, fname, false);
        }
        else {
            if(msg1) DB->msg("backstreamdir::iterate_changeblocks changeblock file:%s off:%"LL"d len:%"LL"d",
                                    *save_obj_direlem->fullpath().image(), changex.off.value(), changex.len.value());
        }
        const bool resultOK = changeBlockHasher.expandRim(changex.off, changex.len, last_off, changes.totalfilesize().value(), send_off);

        if(!resultOK) return(false);
        change_block_child = &changeBlockHasher; 
    }
    nforked++;
    last_offset = changex.off+changex.len-1;
    set_phase(phase_changeblock);
    
    
    return true;
}





void backstreamdir::continueReading()           
{
    if(change_block_child == &changeBlockHasher) { 
        fileref buf;
        const int nextReadSize = changeBlockHasher.getSizeToRead(flags.blocksize);
        if(nextReadSize > 0) {  
            buf.initmem(nextReadSize);
            const int sizeRead = (int)parser->readdata(buf.start(), nextReadSize);
            if(sizeRead == nextReadSize) { 
                changeBlockHasher.append(buf);
            } else if(sizeRead <= 0) {
                
                
                Out->Abort("Received EOF or error during change block data read");
                return; 
            } else {
                fileref slice;
                slice.initslice64(buf, 0, sizeRead); 
                changeBlockHasher.append(slice);
            }
            
            main->addprogbytes(context::backupstats, sizeRead);
            main->addfilebytes(context::backupstats, sizeRead);
        }
        else { 
            changeBlockHasher.changeBlockComplete();
        }
    }
    else { 
        fileref buf;
        const int nextReadSize = dataHasher.getSizeToRead(flags.blocksize);
        if(nextReadSize > 0) {  
            buf.initmem(nextReadSize);
            const int sizeRead = (int)parser->readdata(buf.start(), nextReadSize);
            if(sizeRead == nextReadSize) { 
                const bool rescheduleOK = dataHasher.append(buf);
                if (rescheduleOK) {
                    todoEnqueueInsert(TODO_FILE, &dataHasher, traverse_depth+1);   
                }
                else {
                    
                    main->safesetactivelimit(TODO_FILE, "wait on dataHasher response", true);
                }
            } else if(sizeRead <= 0) {
                
                
                Out->msg(FATAL, "Received EOF or error during data read");
                dataHasher.getFinalHash();
            } else {
                fileref slice;
                slice.initslice64(buf, 0, sizeRead); 
                bool rescheduleOK = dataHasher.append(slice);
                if (!uapp::staging().canRun()) {
                    uapp::staging().setStageFinal("Error or cancellation detected");
                    rescheduleOK = false;
                }
                if (rescheduleOK) {

                    todoEnqueueInsert(TODO_FILE, &dataHasher, traverse_depth+1);   
                }
                else {
                    
                    main->safesetactivelimit(TODO_FILE, "wait on dataHasher response", true);
                }
            }
            
            main->addprogbytes(context::backupstats, sizeRead);
            main->addfilebytes(context::backupstats, sizeRead);
        }
        else { 
            main->safesetactivelimit(TODO_FILE, "wait on dataHasher response", true);
            dataHasher.getFinalHash();
        }
    }
}


void backstreamdir::backupextents(DIRELEMp de, const fileref extentsdata, const fileoffset& off_marker) {
    
    DB->msg("backstreamdir::backupextents marker %s", *off_marker.image());
    workelem *w = new workelem(NULL, extentsdata);
    w->direlemp = de;
    
    
    nbackdata *extents_child = new nbackdata( this, w, do_not_set_hash, 0);
    extents_child->offset = off_marker;
    nforked++;
}




bool backstreamdir::restoredataextents(DIRELEMp prevde, DIRELEMp curde) {
   DB->msg("backstreamdir::restoredataextents ");
    if(prevde.isnull()) {
        DB->msg("Did not find prev direlem for '%s'", *curde->name());
        return false;
    }
    
    dirrec_pack::data_extents data_extents_dirrec(prevde.getimpl());
    int hashoffset;
    if(data_extents_dirrec.get(hashoffset)) {

        
        hashvect hashes;
        prevde->getdephashes(hashes);
        const hashcode ehash(hashes[hashoffset+1]);

        
        prevextentsdata.initlist(1000*8);
        restelem re(curde->fullpath(), *curde, info->fstats, prevextentsdata);
        re.startbyte = off_restextents;  
        nforked++;
        DB->msg("backstreamdir::restoredataextents, restoring previous existing data extents %s", *ehash.partialimage());
        cycle *restprevextents = new restdata(this, ehash, NULL, false, re, off_restextents);
        restprevextents->noop();

    } else { 
        
        DB->msg("Did not find prev existing data extents record for '%s'", *save_obj_direlem->name());
        return false;
    }
    return true;
}

ustring backstreamdir::phase_image() {
    switch(phase) {
    case phase_init:        return "phase_init"; break;
    case phase_waitonprev:  return "phase_waitonprev"; break;
    case phase_read_data:   return "phase_read_data"; break;
    case phase_changeblock: return "phase_changeblock"; break;
    case phase_forksdone:   return "phase_forkdone"; break;
    case phase_do_hidden:   return "phase_do_hidden"; break;
    case phase_write_dir:   return "phase_write_dir"; break;
    default:                return "unknown"; break;
    };
}





bool backstreamdir::ucontainer_addobj(const ubigint64 headflags, DIRELEMp& de, const ustring objname) {
    if(!info->use_container) return true;
    assert(!de.isnull());

    const bool ascend((headflags & PAX_HEADFLAGS_ASCEND) != 0);
    const bool descend ((headflags & PAX_HEADFLAGS_DESCEND)!=0);
    const bool isdir(de->is_directory());
    const ustring mypath(de->fullpath().image());
    if(msg2)DB->msg("backstreamdir::ucontainer_addobj name:'%s' objname:'%s' ascend:%d descend:%d isdir:%d",
                    *mypath, *objname, ascend, descend, isdir);

    
    if(ascend+descend==0) { assert(false); Out->msg(ERR, "This streamformat is incompatible when writing to a DDR (element:'%s')", *mypath); return false; } 

    ucontainer::errortype errcode(ucontainer::pce__success);

    
    if (descend) {
        if(isdir) {
            errcode = info->container->begindir(de.getimpl());
            if(errcode == ucontainer::pce__success) errcode = info->container->begindircontent(de.getimpl());
        } else
            errcode = info->container->beginfile(de.getimpl(), 0);

    
    } else if (ascend) {
        
        DIRELEMp curlistde = curlist.lookup(objname); 
        if(curlistde.isnull()) { assert(false); return false; }
        DB->msg("objname:%s\n deloc:%s\ntmploc:%s", *objname, *de->get_location().image(), *curlistde->get_location().image());
        if(isdir)
            errcode = info->container->enddir(curlistde.getimpl());
        else
            errcode = info->container->endfile(curlistde.getimpl(), 0);
        de->set_location(curlistde->get_location());
    }

    if(msg2)DB->msg("backstreamdir::ucontainer_addobj after call name:'%s' loc:%s", *mypath, *de->get_location().image());

    if(errcode != ucontainer::pce__success) {
        Out->msg(ERR, "Problem encountered writing '%s' to container on destination media (%s)",
                 *mypath, *ucontainer::error_description(errcode));
        return false;
    }
    return true;
}












#include "restextents.h"
#include "restdata.h"
#include "restpipe.h"
#include "direlem.h"
#include "pipe_control.h"
#include "dataextents.h"

enum phases { phase_init        = 0,  
              phase_forksdone
            };

restextents::restextents(cycle *parent,
                   const hashcode& hash_,
                   chunktype *ctypep,              
                   const bool expectatomic_,
                   const restelem& restinfo,
                   const fileoffset offset_,
                   const fileoffset size_,
                   cycle *starter,
                   const bigint64 prior_,
                   const fileref& comparedata_,
                   const int conn_)
  : bicycle(parent),
    info(restinfo),  
    comparedata(comparedata_),
    expectatomic(expectatomic_),
    conn(conn_),
    prior(prior_),
    ctypep_to_return(ctypep),
    phase(phase_init)
{
    assert(hash_ != hashcode::zero || (info.direlem.get_location().getMedia() == location::media::ddr));
    this->hash = hash_;
    this->offset = offset_;
    this->size = size_;

    ppipe_control = main->getpipe_control(&info);
    assert(ppipe_control != NULL);

    assert(main->getAdeMgr());

   DB->msg("restextents::restextents  info.data.getrefcount:%d", info.data.getrefcount());
    if(starter)
        starter->setnext(TODO_FILE_CACHE, this, prior);      
    else
        main->add_insert(TODO_FILE_CACHE, this, prior);
}



void restextents::do_next() {
    extent e;
    fileoffset sectionoffset;

    
    if(!ppipe_control->getnextextent(e, sectionoffset, info.direlem.fullpath().image())) {
      DB->msg("restextents::init restore of file:%s no more extents", *info.direlem.fullpath().image());
      phase = phase_forksdone;
      return;
    }

    DB->msg("restextents::init restore of file:%s hash:%s extent off:%s len:%s sectionoff:%s",
            *info.direlem.fullpath().image(), *hash.partialimage(), *e.off.image(), *e.len.image(), *sectionoffset.image());

    
    restelem extentinfo(info.path, info.direlem, info.fstats, true, volinfo(), e.off, e.off+e.len-1);

    
    extentinfo.data.initslice6464(info.data, sectionoffset, e.len);

    DB->msg("restextents::init restelem data=%s startbyte:%s endbyte:%s", *extentinfo.data.desc(), *extentinfo.startbyte.image(), *extentinfo.endbyte.image());

    
    nforked++;
  
  
    cycle *child = new restpipe(this, extentinfo.data, &info.direlem, true, e.off, e.off+e.len-1, info.container);
    child->noop();
}


void restextents::init() {
    DB->msg("restextents::init");
    DB->msg("restextents::init name:%s fullpath:%s", *info.direlem.name(), *info.direlem.fullpath().image());

    
    do_next();

    childdone(NULL);
}


void restextents::childdone(cycle *child) {
    if (child) {         
        ncollected++;

        if(child->has_error()) {
            Out->msg(INFO, "<11005>Unable to restore \"%s\" - File could not be fully restored.", *info.direlem.fullpath().image());
            return;
        }

        
        do_next();
    }

    DB->msg("restextents::childdone phase:%d ncollected:%d nforked:%d info.data.getrefcount:%d", phase, ncollected, nforked, info.data.getrefcount());
    if (phase == phase_forksdone && ncollected >= nforked) {





        notifyparent();
    }

}


















#include "common.h"
#include "debug.h"
#include "runstage.h"
#include "restdumpdir.h"
#include "restdumpfile.h"
#include "todoelem.h"
#include "context.h"
#include "dumpcontext.h"
#include "ndmpcontrol.h"
#include "pipe_control.h"

#define dbg ((xflag[11]&32768)!=0)   

enum phases { phase_init        = 0,  
              phase_read_data   = 1,  
              phase_forksdone   = 2,  
            };

restdumpdir::restdumpdir(cycle *parent, dumpcontext *dumpctx_,
                         dumpcontext::dirlistelem *head_)
  : cycle(parent),  
    dumpctx(dumpctx_),
    dirlist_head(head_),
    curdir(head_),
    phase(0)
{
    if (!dirlist_head) { assert(false); set_error(true, "restdumpdir called with no dirlist"); return; }

    if(dbg)DB->msg("restdumpdir::restdumpdir name:%s",  *dirlist_head->direlem.fullpath());

    if (!dumpctx) { assert(false); set_error(true, "Unable to get dumpcontext"); return; }
    
    set_phase(phase_init);
    nforked = 0;
    ncollected = 0;

    
    main->add(TODO_DIR, this, false);
};

void restdumpdir::init() {
    set_phase(phase_read_data);
    if(dbg)DB->msg("restdumpdir::restdumpdir init");

    if (curdir == NULL) {    
        DB->msg("restdumpdir::init curdir is null");
        set_phase(phase_forksdone);
        childdone(NULL);
        return;
    }

    if(curdir->parent == NULL) { 
        int inode = curdir->direlem.inode_number();
        DB->msg("restdumpdir::init top inode is %d", inode);
        dumpctx->control->sendinode(inode, curdir->direlem, dumpctx->get_streamoffset());  
    }

    
    DIRELEM::diriterator dit(curdir->data);
    DIRELEM de;
    while(uapp::staging().canRun() && dit.next(de)) {
        if(dbg)DB->msg("restdumpdir::init, 1 de.name:%s de.inode_number:%d", *de.name(), de.inode_number());

        if(de.file_hash() == hashcode::zero)
            continue;

        int inode = dumpctx->get_seq(de, curdir);   
        de.set_inode_number(inode); 
        if(dbg)DB->msg("restdumpdir::init, 2 de.name:%s de.inode_number:%d inode:%d", *de.name(), de.inode_number(), inode);

        if(de.is_directory())  { 
            dumpctx->control->sendinode(inode, de, dumpctx->get_streamoffset());  
            continue;
        }

        
        if(de.hard_links() > 1) {
            
            bool prev;
            
            if(! dumpctx->linkseen.enter_if_undef(inode, true, prev))
                continue;
        }

        if(dbg)DB->msg("restdumpdir::restdumpdir init calling restdumpfile, name:'%s' inode:%d hash:%s", *de.name(), de.inode_number(), *de.file_hash().partialimage());
        restdumpfile* dumpfile_cycle = 

          
          
          new restdumpfile(this, inode, de, inode);
        dumpfile_cycle->noop();
        nforked++;
    }

    
    curdir = curdir->link;
    main->add(TODO_DIR, this, false);
}

void restdumpdir::childdone(cycle *child) {
    if(has_error())
        DB->msg("restdumpdir::childdone, error=%d\n", has_error());

    if (child) ncollected++;
    if(dbg)DB->msg("restdumpdir::childdone, nforked:%d ncollected:%d phase:%d", nforked, ncollected, phase);

    if (phase == phase_forksdone && nforked == ncollected) {
        
        pipe_control* ppipe = main->getpipe_control(0);
        if (ppipe) {
            ppipe->fillblock_normal();  
            if(dbg)DB->msg("restdumpdir::childdone setting streamoffset(%s) to %s",
                    *dumpctx->streamoffset.image(), *(ppipe->get_curroffset().image()));
            dumpctx->streamoffset = ppipe->get_curroffset();
        } else {
            set_error(true, ustring::sprintf("restdumpdir::childdone missing pipe_control"));
        }

        
        main->add(TODO_DONE, NULL, false );
        notifyparent();
        return;
    }
}

restdumpdir::~restdumpdir() {
}

void restdumpdir::set_phase(int phasenum) {
    
    if (phasenum <= phase) return; 
    DB->msg("restdumpdir::set_phase setting phase to %d", phasenum);
    phase = phasenum;
}













#include "common.h"
#include "restnofilter.h"
#include "restfile.h"
#include "restdata.h"
#include "compelem.h"
#include "context.h"
#include "pipe_control.h"
#include "runstage.h"
#include "output.h"

#define restnofilter_msgs ((xflag[2]&4)!=0)
#define dowfs             ((xflag[15]&2)==0)
#define scan_all_cdsf_objects ((xflag[28]&8192)!=0)
#define scan_with_getdata     ((xflag[28]&16384)!=0)


restnofilter::restnofilter(bicycle         *parent,
                           const hashcode&  hash,
                           DIRELEM&         direlem,
                           ucontainer::basep container,
                           cycle           *starter ,
                           const volinfo   vinfo ,
                           fileoffset      startoff ,
                           fileoffset      endoff   
                           )
    : restfile(parent, hash, direlem, container, starter, vinfo, startoff, endoff), have_created_restfile(false)
{
    if(restnofilter_msgs) {
        DB->msg("restnofilter::restnofilter name:%s", *this->info.path.image());
    }
}


void restnofilter::init()
{
    const location loc(info.direlem.get_location());
    if(loc.getMedia() == location::media::gsan && !is_known_hash(info.direlem.file_hash())) {
        if (!have_created_restfile && main->get_flags().restoreprefetchmb > 0) {
            
            
            restfile *rf = dynamic_cast<restfile*>(next_cycle);
            if (rf) {
                cycle *c = new smallfile_prefetcher(rf, main);
                c->noop();
            }
        }

        

        info.data.initlist();

        
        info.rawmode = true;

        
        info.ignoreStats = true;

        
        nforked++;

        cycle *rawdatac = new restdata(this, info.direlem.file_hash(), &ctype, false, info);
        rawdatac->noop();
    } else {
        
        childdone(0);
    }
}



fileoffset restnofilter::calculate_raw_size(const chunktype ct, const fileref& topmost) const
{
    fileoffset ret(fileoffset::unknown);

    if(topmost.size() > 0) {
        const fileoffset topmost_size(topmost.size64());

        
        if(ct.is_anyatomic()) {
            ret = topmost_size;
        } else {
            
            compelem ce(ctype);

            int off(0);
            while(uapp::staging().canRun()) {
                
                ce.init(info.data, off);

                
                const fileoffset endoff(ce.getendoff());

                
                if(fileoffset(off) >= topmost_size) {
                    
                    ret = endoff;
                    break;
                }
            }
        }
    }

    return ret;
}


bool restnofilter::is_known_hash(const hashcode& hash) const
{
    return (hash == hashcode::empty) || (hash == hashcode::zero) || (hash == hashcode::ones);
}



bool restnofilter::scan_object_with_getobj(const location &objectloc, fileoffset &datasize)
{
    bool ret(false);
    datasize = fileoffset::unknown;

    
    ucontainer::basep container(info.container.isnull() ? main->open_container_for_read(objectloc) : info.container);
    if(!container.isnull() && container->is_seekable()) {
        
        if(container->seek(objectloc.get_abs_offset_in_container(), SEEK_SET) == ucontainer::pce__success) {
            bool success_scanning_data(false);
            fileoffset totaldatasize(0);

            
            udirelemp ude;
            fileoffset sectionsize;
            fileoffset last_curroffset(fileoffset::unknown);
            while(uapp::staging().canRun() && (container->getobj(ude, sectionsize) == ucontainer::pce__success)) {
                const fileoffset curroffset(container->get_curroffset());
                
                if(last_curroffset != fileoffset::unknown) {
                    if(last_curroffset == curroffset) {
                        DB->msg("restnofilter::scan_object_with_getobj: scan isn't advancing, breaking out of scan loop");
                        break;
                    }
                }
                last_curroffset = curroffset;

                
                if(!ude->is_meta() && ude->is_ascend_obj()) {
                    success_scanning_data = true;
                    break;
                }

                
                totaldatasize += sectionsize;

                
                const ucontainer::errortype et(container->skipdata());
                if(et != ucontainer::pce__success && et != ucontainer::pce__end_of_file) {
                    break;
                }

                
                ude = 0;
            }

            
            if(success_scanning_data) {
                datasize = totaldatasize;
                ret = true;
            }
        }
    } else {
        assert("Don't know how to calculate data size of this unknown format (getobj)" == 0);
    }

    return ret;
}


bool restnofilter::scan_object_with_getdata(const location &objectloc, fileoffset &datasize)
{
    bool scanret(false);
    datasize = fileoffset::unknown;

    
    ucontainer::basep container(main->open_container_for_read(objectloc));
    if(!container.isnull() && container->is_seekable()) {
        
        if(container->seek(objectloc.get_abs_offset_in_container(), SEEK_SET) == ucontainer::pce__success) {
            bool success_scanning_data(false);
            fileoffset totaldatasize(0);

            
            {
                ucontainer::errortype result(ucontainer::pce__unknown);

                
                udirelemp de_from_container(NULL);
                fileoffset obj_size;  
                result = container->getobj(de_from_container, obj_size);

                
                if (result != ucontainer::pce__success || de_from_container.isnull()
                    || (!de_from_container->is_descend_obj()) 
                    || de_from_container->is_directory()      
                    ) {
                    const bool denull(de_from_container.isnull());
                    const ustring isdescend(denull? "N/A" : de_from_container->is_descend_obj()? "true" : "false"),
                        isdir    (denull? "N/A" : de_from_container->is_directory()? "true" : "false");
                    DB->msg("restnofilter::scan_object_with_getdata: processing ucontainer, "
                            "de_from_container isnull():%d is_descend_obj():%s is_directory():%s "
                            "getobj failed: %s", denull, isdescend.tostr(), isdir.tostr(), *ucontainer::error_description(result));
                } else {
                    if(restnofilter_msgs) DB->msg("restnofilter::scan_object_with_getdata: %s %s offset %s result %s", *de_from_container->fullpath().image(), *info.direlem.file_size().image(), *totaldatasize.image(), *ucontainer::error_description(result));
                    while(uapp::staging().canRun()) {
                        if(de_from_container->is_ascend_obj() && !de_from_container->is_meta()) {
                            if(restnofilter_msgs) DB->msg("container_getdata end of %s offset %s", *de_from_container->fullpath().image(), *totaldatasize.image());
                            break;
                        }

                        

                        
                        while (uapp::staging().canRun()) {
                            fileref dataread;  
                            result = container->getdata(flags.media_in_size, dataread);

                            
                            if (result == ucontainer::pce__end_of_file || dataread.size64() == fileoffset(0)) {
                                success_scanning_data = true;
                                if (result != ucontainer::pce__end_of_file) {
                                    if(restnofilter_msgs) DB->msg("restnofilter::scan_object_with_getdata: size %s offset %s result %s", *dataread.size64().image(), *totaldatasize.image(), *ucontainer::error_description(result));
                                }
                                break;
                            }

                            if(result != ucontainer::pce__success && result != ucontainer::pce__end_of_file) {
                                if(restnofilter_msgs) DB->msg("  container_getdata %s offset %s result %s", *info.direlem.file_size().image(), *totaldatasize.image(), *ucontainer::error_description(result));
                                break;
                            }

                            if(!de_from_container->is_meta()) {
                                totaldatasize += dataread.size64();
                            }
                        }

                        if(result != ucontainer::pce__success && result != ucontainer::pce__end_of_file) { 
                            if(restnofilter_msgs) DB->msg("restnofilter::scan_object_with_getdata returned unexpected value %s", *ucontainer::error_description(result));
                        }

                        
                        de_from_container = NULL;  
                        result = container->getobj(de_from_container, obj_size);
                        if (result != ucontainer::pce__success || de_from_container.isnull()) {
                            if(restnofilter_msgs) DB->msg("restnofilter::scan_object_with_getdata processing ucontainer, getobj failed: %s", *ucontainer::error_description(result));
                            break;
                        }
                    }
                }
            }

            
            if(success_scanning_data) {
                datasize = totaldatasize;
                scanret = true;
            }
        }
        if(restnofilter_msgs) DB->msg("  de %s filesize %s", *info.direlem.fullpath().image(), *info.direlem.file_size().image());
    } else {
        assert("Don't know how to calculate data size of this unknown format (getdata)" == 0);
    }

    return scanret;
}


void restnofilter::childdone(cycle *child)
{
    if (child) {         
        ncollected++;
    }

    if(restnofilter_msgs)DB->msg("restnofilter::childdone 1 child:%p nforked:%d ncollected:%d", child, nforked, ncollected);

    
    if(!have_created_restfile) {
        
        
        const fileoffset saved_file_size(info.direlem.file_size());

        hashcode hash(info.direlem.file_hash());
        if (child) {         
            
            assert(!is_known_hash(hash));
            assert(ncollected == 1);

            
            
            

            
            const fileoffset raw_size(calculate_raw_size(ctype, info.data));

            
            if(raw_size != fileoffset::unknown && raw_size >= 0) {
                info.direlem.set_file_size(raw_size);
            }
        } else {           
            assert(ncollected == 0);

            
            const location loc(info.direlem.get_location());
            if(hash == hashcode::zero && loc.getMedia() > location::media::gsan) {
                bool know_size(false);

                if(loc.get_format() == location::tformat::raw) {
                    
                    fileoffset offset(loc.get_abs_offset_in_container());
                    fileoffset raw_size(loc.get_coverage_size());

                    
                    info.direlem.set_file_size(raw_size);

                    know_size = true;
                } else if (loc.get_format() == location::tformat::cdsf) {
                    
                    
                    if(loc.get_data_bytes() != fileoffset::unknown && !scan_all_cdsf_objects && loc.get_data_bytes() > 0) {
                        info.direlem.set_file_size(loc.get_data_bytes());
                        know_size = true;
                    } else {
                        static bool already_output_warning(false);
                        if(flags.dtoexportstream && !already_output_warning) {
                            if(!already_output_warning) {
                                Out->msg(INFO, "Scanning object data to determine exact data size");
                                already_output_warning = true;
                            }
                        }

                        
                        fileoffset datasize(fileoffset::unknown);
                        if(scan_with_getdata) {
                            if(scan_object_with_getdata(loc, datasize)) {
                                assert(datasize != fileoffset::unknown);
                                info.direlem.set_file_size(datasize);
                                know_size = true;
                            }
                        } else {
                            if(scan_object_with_getobj(loc, datasize)) {
                                assert(datasize != fileoffset::unknown);
                                info.direlem.set_file_size(datasize);
                                know_size = true;
                            }
                        }
                        if(restnofilter_msgs) DB->msg("scan_object_with_x %d (%d) calculated size of '%s' to %s bytes",
                                                      scan_with_getdata, know_size, *info.direlem.fullpath().image(), *info.direlem.file_size().image());
                    }
                }

                if(!know_size) {
                    Out->msg(ERR, "Don't know how to calculate data size of '%s' at location '%s' (location data_bytes %s)",
                             *info.direlem.fullpath().image(), *info.direlem.loc_image(), *loc.get_data_bytes().image());
                    
                    
                    
                    info.data.free();
                    notifyparent();
                    return;
                }
            } else if(is_known_hash(hash)) {
                
                info.direlem.set_file_size(0);
                
                hash = hashcode::empty;
            }
        }

        
        

        nforked++;

        restfile* mychild = new restfile(this, hash, info.direlem, info.container, 0, info.vinfo, 0, 0,
                                         restfile::opt_nofilter);
        
        mychild->set_info_pipe_control(info.ppipe_control);
        
        
        mychild->set_original_file_size(saved_file_size);
        mychild->noop();
        have_created_restfile = true;
    } else {
        
        info.data.free();
        notifyparent();
    }
}


restnofilter::~restnofilter()
{
    if(restnofilter_msgs)DB->msg("restnofilter::~restnofilter()");
}

#if !defined(REPLROOT_H_INCLUDED)
#define REPLROOT_H_INCLUDED












#include "cycle.h"
#include "queue.h"
#include "context.h"
#include "ustring.h"
#include "ade_backup.h"


class replroot : public replcycle {
protected:
    
    typedef struct {
        bool         ddrResult;
        unsigned int index;
        fileoffset     offset;
        fileoffset     size;
    } DDRValue;

    class CopyDDRFile : public bicycle {
    public:
        CopyDDRFile(context* main, bicycle* parent_ = NULL) : bicycle(parent_, main),
            dataHasher_msg((xflag[2]&4)!=0),
            adeMgr(main->getAdeMgr()),
            fname("full_ddr_list") { memset(&ddrValue, 0, sizeof(ddrValue)); }

        inline void setup(bicycle *parent_ = NULL) { setparentandroot(parent_); }
        void replicate();
        virtual void response(message& outargs);    
        const bool isFinalHashWaiting() { return(ddrValue.ddrResult); }
    private:
        bool        dataHasher_msg;        
        ADEMgrX*    adeMgr;
        
        ustring     fname;                  
        DDRValue    ddrValue;               
    };  

public:
    
    replroot(hashcode& tophash, context& main, const ustring &sessname, const int ddrIndexFromBackup, workelem *info, const exportstream_xmlp backupinfop, bool search_sysinfo = false);

    
    virtual void childdone(cycle *child);

    
    virtual void responseReceived(CopyDDRFile* copyDDRFile);

    void set_comp_root_hash(bool comp_hash);

    virtual ~replroot();

    SAFEALLOC(replroot);

private:
    hashcode& tophash;
    const ustring name;
    CopyDDRFile* replicateDDR;
    bool startedTableGen;
    bool search_sysinfo;
    bool comp_root_hash;
};

#endif











#include "common.h"
#include "direlem.h"
#include "restfileusingextents.h"
#include "extentsonlytarpipe.h"
#include "restdata.h"
#include "restextents.h"
#include "fileextentspipe.h"
#include "dataextents.h"
#include "filerefx.h"









restfileusingextents::restfileusingextents(bicycle*          parent,
                                           DIRELEM&          direlem,
                                           const restelem&   restinfo,
                                           const hashcode&   extentshash_,
                                           ucontainer::basep container ,
                                           cycle*            starter ,
                                           const volinfo     vinfo )
  : bicycle(parent),
    ADERestore(parent->main),
    info(restinfo),
    extentshash(extentshash_),
    phase(phase_construction),
    ppipe_control(0)
{
    
    if(extentshash != hashcode::zero) {
        
        extentsdata.initlist(1000*8);

        restelem re(direlem.fullpath(), direlem, info.fstats, extentsdata, container);

        cycle *restextents = new restdata(this, extentshash, NULL, false, re, 0);
        restextents->noop();
        nforked++;

        phase = phase_restoring_extents;
    } else {
        
        childdone(0);
    }
}

void restfileusingextents::init()
{}

void restfileusingextents::childdone(cycle *child)
{
    if(child) {
        ncollected++;
    }

    
    if(phase == phase_construction || phase == phase_restoring_extents) {
        

        
        const location loc(info.direlem.get_location());
        const bool use_container(loc.getMedia() > location::media::gsan);
        if(use_container && info.container.isnull()) {
            info.container = main->open_container_for_read(loc);
        }

        const hashcode hash(info.direlem.file_hash());
        cycle* data_restore_child(0);
        
        if(phase == phase_restoring_extents) {
            
            ppipe_control = new extentsonlytarpipe(extentsdata);
            info.ppipe_control = ppipe_control;

            
            const dataextents extents(extentsdata);

            
            fileref extentspipe;
            filerefx::initextentspipe(extentspipe, info.data, resourceid, extents);

            info.data = extentspipe;

            data_restore_child = new restextents(this, hash, NULL, info.direlem.is_atomic(), info, fileoffset(0), fileoffset(0));
        } else {
            

            
            data_restore_child = new restdata(this, hash, NULL, false, info,
                                              fileoffset(0), fileoffset(-1), NULL, 0, fileref::empty, -1, NULL,
                                              use_container);
        }
        if(data_restore_child) {
            data_restore_child->noop();
            nforked++;
        }

        phase = phase_restoring_data;
    }

    if(phase == phase_restoring_data) {
        
    }

    if(nforked == ncollected) {
        notifyparent();
    }
}

restfileusingextents::~restfileusingextents()
{
    delete ppipe_control;
}
#include "common.h"
#include "debug.h"
#include "persistentlock.h"
#include "ade_mgrx.h"
#include <string.h>
#include "msgpack_c.h"
#include "xml_message.h"

#define dbg ((xflag[30]&2048)!=0)

#define LOCK_SLEEP_SECS 30
#define LOCK_SLEEP_TIME LOCK_SLEEP_SECS * 1000

persistentlock::persistentlock(context* main, const ustring& account, const ubigint64 backupid)
    : error(false), conn(NULL), is_locked(false), lockits(0), unlocks(0)
{
    const ustring bidstr(account + tostr(backupid));
    if (dbg) DB->msg("persistentlock::persistentlock id %s", *bidstr);
    if (!main) {
        DB->msg("persistentlock::persistentlock bid %"LL"u no main!", backupid);
        error = true;
        return;
    }

    ADEMgrX* ade = main->getAdeMgr();
    if (ade == NULL) {
        DB->msg("persistentlock::persistentlock bid %"LL"u no ade!", backupid);
        error = true;
        return;
    }
    synccall* sc(ade->getHfsInfo(dpn0).sync);
    if (!sc) {
        DB->msg("persistentlock::persistentlock bid %"LL"u no ade->getHfsInfo(dpn0).sync!", backupid);
        error = true;
        return;
    }

    conn = new persistentlockconnection(*sc);
    lockhash = hashcode(bidstr.tostr(), bidstr.bytelength());
    if (dbg) DB->msg("persistentlock::persistentlock: hash '%s'", *lockhash.partialimage());
}

bool persistentlock::lockit()
{
    if (error) {        
        DB->msg("persistentlock::lockit: error previously encountered - action not permitted");
        return false;
    }
    lockits++;
    if (is_locked) {
        DB->msg("persistentlock::lockit: already locked; attempt #%"LL"u", lockits);
        return true;
    }
    bool retval(false);
    message lockargs;
    msgpack_c::lockrequest pls(lockargs);
    pls.arg(PACK, lockhash);
    if (dbg) DB->msg("persistentlock::lockit: lock request '%s'", *lockargs.ximage());
    ubigint64 count(0);
    bool loop(true);
    while (loop) {
        if (!uapp::staging().canRun()) {
            DB->msg("persistentlock::lockit: terminated - exiting without the lock");
            error = true;
            break;
        }
        message outargs = conn->sendcommand(lockargs, lockhash);
        if (!outargs.isnull()) {         
            switch (outargs.responsecode()) {
                case MSG_ERR_NONE:      
                {
                    Out->msg(INFO, "Obtained lock. Proceeding with backup merge.");
                    is_locked = true;
                    retval = true;
                    loop = false;
                    break;
                }
                case MSG_ERR_LOCKED:    
                case MSG_ERR_TIMEOUT:
                {
                    if (count > 0) {  
                        
                        ustring result;
                        msgpack_c::lockrequest rsp(outargs);
                        rsp.res(UNPACK, result);
                        xml_message rxml;
                        rxml.parse(result);
                        Out->msg(INFO, "Waiting for client %s at IP %s (sessionid %s) to finish before continuing merge.", *rxml.getstring("client-id"), *rxml.getstring("client-addr"), *rxml.getstring("session-id"));
                        if (dbg) DB->msg("persistentlock::lockit: %"LL"u seconds, rcvd '%s:%s'", count, *outargs.ximage(), *result);
                    }
                    uapp::sleep(LOCK_SLEEP_TIME);
                    count += LOCK_SLEEP_SECS;
                    break;      
                }
                default:        
                {
                    Out->msg(FATAL, "persistentlock::lockit: Error on lock '%s': '%s'", *lockhash.partialimage(), *message::err_image(outargs.responsecode()));
                    error = true;
                    loop = false;
                }
            }
        } else {
            DB->msg("persistentlock::lockit: empty message returned from the server");
        }
    }
    return retval;
}

bool persistentlock::unlock()
{
    if (error) {        
        DB->msg("persistentlock::unlock: error previously encountered - action not permitted");
        return false;
    }
    unlocks++;
    if (!is_locked) {
        DB->msg("persistentlock::unlock: attempt #%"LL"u to unlock but lock is not set.", unlocks);
        return false;
    }
    message unlockargs;
    msgpack_c::unlockrequest pls(unlockargs);
    pls.arg(PACK, lockhash);
    if (dbg) DB->msg("persistentlock::unlock: unlock request '%s'", *unlockargs.ximage());
    message outargs = conn->sendcommand(unlockargs, lockhash);
    if (dbg) DB->msg("persistentlock::unlock: response '%s'", *outargs.ximage());
    if (!outargs.isnull()) {         
        if (outargs.isgoodresponse())       
            return true;
        Out->msg(ERR, "persistentlock::unlock: Error on unlock '%s': '%s'", *lockhash.partialimage(), *message::err_image(outargs.responsecode()));
    } else {
        Out->msg(ERR, "Empty unlock response message returned from the server");
    }
    error = true;
    return false;
}












#include "common.h"
#include "synccallmult.h"
#include "context.h"
#include "ade_mgrx.h"

#include "msgvect.h"





void synccallmult::call(msgvect& inargs, msgvect& outargs) {
    ADEMgrX* adeMgr = main.getAdeMgr();
    assert(adeMgr != NULL);
    adeMgr->callAndWait(dpninx, inargs, outargs);
}



















#include "common.h"
#include "debug.h"
#include "restore_prefetchmanager.h"
#include "ustring.h"
#include "hashcode.h"
#include "dpnobject.h"
#include "restore_prefetchthread.h"


depthfirst_prefetchmanager::depthfirst_prefetchmanager(const fileoffset &ringblocksize_)
    : directorystack(), hasdir(false), hasfile(false), currentdir(NULL), 
      ringblocksize(ringblocksize_), done(false)
{
}

depthfirst_prefetchmanager::~depthfirst_prefetchmanager()
{
    while (directorystack.size()) {
        dpnobj::iterator *p = directorystack[directorystack.size() - 1];
        directorystack.pop_back();
        delete p;
    }
}

bool
depthfirst_prefetchmanager::advance()
{
    
    if (done)
        return false;

    if (hasfile) {
        
        start = end;
        end = start + ringblocksize - 1;
        if (start > max) {
            return advancefile();
        } else {
            
            
        }
        return true;
    }

    if (hasdir) {
        
        assert(currentdir != NULL);
        return advancefile();
    }

    return false;
}


bool 
isspecialdir(const char *name)
{
    if (!name) return false;

    if (name[0] == '.' && name[1] == '\0')
        return true;

    if (name[0] == '.' && name[1] == '.' && name[2] == '\0')
        return true;

    return false;
}


bool 
depthfirst_prefetchmanager::advancefile() 
{
    
    if (done)
        return false;

    if (!hasdir) {
        assert(currentdir == NULL);
        return false;
    }

    const char *nd = NULL;
    dpnobj nobj;
    while (currentdir) {
        {
            scope s(dpnobj::noncachelookupmut);
            nd = currentdir->next(nobj);
        }
        if (nd && isspecialdir(nd)) {
            
            continue;
        }

        if (!nd) {
            
            delete currentdir;
            currentdir = NULL;
            hasdir = false;
            if (directorystack.size()) {
                currentdir = directorystack[directorystack.size() - 1];
                directorystack.pop_back();
                hasdir = true;
                
            }
            continue;
        }

        
        dpnobj_types::statrecord st;
        nobj.xstat(st);

        switch (st.type) {
        case dpnobj_types::directory:
            
            directorystack.push_back(currentdir);
            {
                scope s(dpnobj::noncachelookupmut);
                currentdir = new dpnobj::iterator(nobj);
            }
            continue;
            break;
        case dpnobj_types::regular:
            
            hasfile = true;
            h = *((hashcode *)st.hash);
            start = 0;
            end = start + ringblocksize - 1;
            max = st.size - 1;

            
            

            return true;
            break;
        default:
            hasfile = true;
            start = 0;
            end = start + ringblocksize - 1;
            max = st.size - 1; 
            h = *((hashcode *)st.hash);
            DB->msg ("pfmanager::advancefile found OTHER %s hashcode %s size %lld type %d kind %d", 
                     nd, *h.image(), st.size, st.type, st.kind);
            return true;
            break;
        }
    }

    done = true;
    return false;
}


void 
depthfirst_prefetchmanager::hint(const dpnobj *obj)
{
    
    if (done) return;

    if (hasdir) return; 

    
    

    if (NULL == obj)
        return;

    dpnobj_types::statrecord st;
    obj->xstat(st);

    if (st.kind != dpnobj_types::normal) {
        
        
        return;
    }

    if (st.type == dpnobj_types::directory) {
        {
            scope s(dpnobj::noncachelookupmut);
            currentdir = new dpnobj::iterator(*obj);
        }
        hasdir = true;
        
        
        advance();
        return;
    }
}

bool 
depthfirst_prefetchmanager::fill(tprefetchblock &b) 
{
    
    if (!hasfile) {
        if (!advance()) 
            return false;
    }

    b.h = h;
    b.startoff = start;
    b.endoff = end;
    
    if (end > max)
        b.endoff = max;

    return true;
}


bool 
depthfirst_prefetchmanager::reset(const tprefetchwork &work)
{
    
    if (done) {
        
        return true;
    }

    if (!hasfile) {
        
        advance();
    }

    if (!hasfile) {
        
        return false;
    }

    if (hasfile && (h != work.h)) {
        
        advance();
        if (h != work.h) {
            DB->error ("depthfirst_prefetchmanager::reset with work %s not in sync with our position (hash %s, start %s).",
                       *work.image(), *h.image(), *start.image());
            start = end = max = fileoffset(0);
            delete currentdir;
            currentdir = NULL;
            hasdir = hasfile = false;
            return false;
        }
    }
    start = work.endoff + 1;
    end = start + ringblocksize - 1;
    if (start > max) {
        
        bool af = advancefile();
        if (!af)
            DB->msg ("depthfirst_prefetchmanager::reset advancefile() returned %d", af);
    }

    return true;
}

















#include "common.h"
#include "debug.h"
#include "repldir.h"
#include "repldata.h"
#include "replfile.h"
#include "chunktype.h"
#include "compelem.h"
#include "backstate.h"
#include "runstage.h"
#include "workelem.h"
#include "filenames.h"
#include "filename_cache.h"
#include "safeint.h"
#include "ade_mgrx.h"
#include "timer.h"
#include "nbackdata.h"
#include "mctypes.h"
#include "utar_commands.h"
#include "filerefx.h"

#define debug_msgs ((xflag[11]&2097152)!=0)
#define dmsg1 ((xflag[19]&4)!=0)
#define dmsg2 ((xflag[19]&8)!=0)
#define disable_generating_sysinfo_files ((xflag[31]&1024)!=0)
#define generating_migrate_info_file ((xflag[31]&524288)!=0)
#define disable_workresults_processing ((xflag[10]&8388608)!=0)

namespace { safebool g_sysinfo_write; }

repldir::repldir(replcycle *parent, hashcode& myhash_, fileref& listing_,
                 const bool can_cancel_, const chunktype ctype_,
                 const ustring& name_, const time_t filetime_,
                 const int traverse_depth_, workelem* info_)
  : replcycle(parent, NULL, info_),
    myhash(myhash_),                    
    listing(listing_),                  
    can_cancel(can_cancel_),            
    ctype(ctype_),                      
    name(name_),                        
    filetime(filetime_),                
    traverse_depth(traverse_depth_),    
    migrateinfochild(NULL),
    ddrfilechild(NULL),
    workresultschild(NULL),
    modified_data(false),
    workresults_de(NULL),
    migrateinfo_de(NULL)
{
    
    main->add_insert(TODO_DIR, this, -traverse_depth);   
}

void repldir::init() {
    assert(info != NULL);

    
    main->set_cur_filename((upath)name, true);
    if (Out->is_enabled(VERBOSE)) Out->msg(VERBOSE, "%s", *name);

    int nextoff = 0;            
    int curroff = 0;            
    int hashoff = 0;            
    cycle *prevcycle = NULL;
    const int size = listing.size();
    while(nextoff < size) {
        curroff = nextoff;
        DIRELEM de;
        if(!de.populate(listing, nextoff)) {        
            Out->msg(ERR, "Failed to read directory listing in '%s'", name.tostr());
            break;
        }
        if(migration_sysinfo_write != NULL){
            if((backupinfop->get_pid().kind() == pidtype::ndmp) && (de.name() == WORKRESULTS_FILENAME)) {
                workresults_de = new DIRELEM(de);
            }
            if(de.name() == MIGRATEINFO_FILENAME) {
                migrateinfo_de = new DIRELEM(de);
            }
        }

        hashvect hv;
        de.getdephashes(hv);                    

        const bool isdir = de.is_directory();
        for(size_t i = 0; i < hv.size(); i++) {
            const hashcode& hash = hv[i];
            if(hash == hashcode::zero || hash == hashcode::empty)
                continue;
            chunktype dtype = chunktype::recipe8;
            double filesize = 0;
            ustring pathname;
            if (i==0) {      
                filesize = de.file_size().dvalue();
                
                if(isdir) {
                    dtype = chunktype::atomicdir;
                    pathname = name/de.name();
                } else {
                    if(de.is_atomic())
                        dtype = chunktype::atomic;
                    
                    
                    
                }
            }

            if(dmsg1)
                DB->msg("repldir::init(): hv.size() = %d, dephash_count in listing = %d", (int)hv.size(), (int)DIRELEM::get_dephash_count(listing, curroff));

            hashoff = DIRELEM::get_hash_off(listing, curroff, (int)i);

            if((hashoff < curroff) || ((int)(hashoff + sizeof(hashcode)) > nextoff)) {
                DB->error("INTERNAL ERROR in repldir: hashoff=%d, curroff=%d, nextoff=%d", hashoff, curroff, nextoff);
                assert(false);          
                break;
            }
            else if(dmsg2 && (i==0))DB->msg("repldir::init(): curroff = %d, dep_hashoff = %d and nextoff = %d in hv[%d]", curroff, hashoff, nextoff, (int)i);
            else if(dmsg1 && (i>0))
                DB->msg("repldir::init(): curroff = %d, dep_hashoff = %d and nextoff = %d in hv[%d]. the listing size = %d", curroff, hashoff, nextoff, (int)i, size);

            DIRELEMp del(new DIRELEM(de));
            workelem* w = new workelem(info->rechunk, del, info->container);
            if (i==0 && !isdir && info->rechunk) {
                assert(can_cancel);
                pathname = name/de.name();
                nforked++;
                cycle *child = new replfile(this, hv[i], curroff, pathname, dtype, traverse_depth+1, w, NULL);
                child->noop();
            } else {
                
                
                hashcode h;
                listing.getslice64(hashoff, sizeof(hash), &h);
                if(h != hv[i]) {
                    DB->error("INTERNAL ERROR in repldir: @hashoff = %d, listing hash: %s !=  dep hash hv[%d]: %s", hashoff, *h.image(), (int)i, *hv[i].image());
                    assert(false);          
                    break;
                }
                nforked++;
                cycle *child(NULL);
                if(dmsg1) DB->msg("repldir::init(): hv[%d]= %s, dtype: %s, isdir: %d", (int)i, *hv[i].image(), *dtype.image(), isdir);
                if(!isdir && flags.reportonly && ((xflag[19]&32768)==0))
                    child = new replreportdata(this, hv[i], hashoff, can_cancel && i==0, filesize, pathname, dtype, de.mtime(), 0, w, true);
                else
                    child = new repldata(this, hv[i], hashoff, can_cancel && i==0, filesize, pathname, dtype, de.mtime(), traverse_depth+1, w, prevcycle, true);

                if(info->rechunk)
                    prevcycle = child;

                if((dmsg1&&(i>0)) || dmsg2)
                    Out->msg(INFO, "<7917>repldir::init() - input to repldata : hash value hv[%d] = %s, hashoff = %d, child = %p", (int)i, *hv[i].partialimage(), hashoff, child);

                child->noop();
            }
        }
    }
    forksdone = true;
    childdone(NULL);
}

void repldir::response(message& outargs) {
    assert(false);
}

void repldir::childdone(cycle *child) {
    assert(forksdone); 

    if(child)
        ++ncollected;

    const bool is_in_sysinfo_dir = (migration_sysinfo_write != NULL);  
    if(dmsg2) {
        DB->msg("repldir::childdone(forked=%d, collected=%d) this=%p child=%p, %s", nforked, ncollected, this, child, is_in_sysinfo_dir? "(in .system_info)":"");
    }

    const bool is_sysinfo_child((ddrfilechild && (ddrfilechild == child)) || (migrateinfochild && (migrateinfochild == child)) || (workresultschild && (workresultschild == child)));
    if(is_sysinfo_child)
        assert(modified_data);

    if(child && !is_sysinfo_child) {
        
        
        
        
        
        hashcode h;
        listing.getslice64(child->offset, sizeof(hashcode), &h);

        if(child->hash != h) {
            assert(!uapp::staging().canRun() || info->rechunk || (flags.destination_data != client_config_flags::same_destination ));
            if(debug_msgs || dmsg1)
                DB->msg("repldir: child returned new hash: orighash %s != new hash %s. The child->offset = %s, %p", *h.image(), *child->hash.partialimage(), *((child->offset).image()), child);
            listing.setslice64(child->offset, sizeof(hashcode), &child->hash);
            modified_data = true;
        }
    }

    assert(ncollected <= nforked);
    if((ncollected == nforked) && !is_sysinfo_child) {
        
        
        
        
        const bool write_to_sysinfo(should_write_sysinfo());

        if(write_to_sysinfo) {
            DB->msg("Writing sysinfo files under %s depth %d (%p)", *info->direlemp->fullpath().image(), traverse_depth, this);
            assert(!disable_generating_sysinfo_files);

            
            if(ddrfilechild == NULL) {
                spawn_ddrfiles_child();     
            }

            
            if(((flags.pluginid.kind() == pidtype::migrate) || generating_migrate_info_file) && (migrateinfochild == NULL)) {
                spawn_migrateinfo_child();  
            }

            
            if(!disable_workresults_processing && (backupinfop->get_pid().kind() == pidtype::ndmp) && (workresultschild == NULL)){
                spawn_workresults_child();  
            }
            if(disable_workresults_processing) {
                Out->msg(INFO, "Workresults processing disabled.");
            }
            DB->msg("    repldir::childdone(this:%p) child:%p (writing sysinfo files) done", this, child);
            return;
        }
    }

    if(modified_data && is_in_sysinfo_dir && *migration_sysinfo_write && is_sysinfo_child) {
        
        
        
        BackCycle* const sysinfo_child = dynamic_cast<BackCycle*>(child);
        assert(sysinfo_child && sysinfo_child->getInfo() && sysinfo_child->getInfo()->direlemp.isdefined());
        const DIRELEMp sysinfo_child_de(sysinfo_child->getInfo()->direlemp);
        const hashcode sysinfo_child_hash(sysinfo_child_de->file_hash());
        assert(sysinfo_child_hash == sysinfo_child->hash && sysinfo_child_hash == this->hash);
        fileref newlisting;
        if((sysinfo_child == workresultschild) && (workresults_de!=NULL))  
            remove_from_listing(WORKRESULTS_FILENAME, listing);     
        if((sysinfo_child == migrateinfochild) && (migrateinfo_de!=NULL))
            remove_from_listing(MIGRATEINFO_FILENAME, listing);  

        newlisting.initlist(listing.size() + DIRELEM_DOLAYOUT_AVERAGE_SIZE);
        newlisting.append(listing);
        
        
        
        sysinfo_child_de->set_computed_file_size(sysinfo_child_de->file_size());
        sysinfo_child_de->dolayout(newlisting, false, true, false, main->getmaxdirelemsize(dpn1));
        DB->msg("repldir::childdone oldlisting size=%s, newlisting size=%s", tostr(listing.size()).tostr(), tostr(newlisting.size()).tostr());
        listing = newlisting;
        
        info->direlemp->set_computed_file_size(info->direlemp->file_size() + sysinfo_child_de->computed_file_size());
    }

    if(ncollected == nforked) {
        const hashcode newhash = hashcode(listing);
        if(debug_msgs) DB->msg("Repldir returning modified directory (depth=%d) %s", traverse_depth, *uapp::staging().getRunStageImage());
        
        if(debug_msgs) DB->msg("repldir %p FINAL: orighash=%s, new hash=%s", this, *myhash.partialimage(), *newhash.partialimage());
        myhash = newhash;
        notifyparent();
    }
    DB->msg("    repldir::childdone(this:%p) child:%p done", this, child);
}

bool repldir::should_write_sysinfo() const {
    
    
    
    
    return migration_sysinfo_write && !migration_sysinfo_write->set(true);
}

void repldir::spawn_ddrfiles_child() {
    if(backupinfop.isnull()) {
        DB->msg("repldir::spawn_ddrfiles_child(this:%p) - No backup information available to create "DATADOMAINFILES_FILENAME" to "UNDOO_DIRECTORY_NAME"", this);
        Out->msg(ERR, "Unavailable to save "DATADOMAINFILES_FILENAME" to "UNDOO_DIRECTORY_NAME" directory");
        return;
    }
#ifdef USEADE
    ADEMgrX* adeMgr = main->getAdeMgr();
    if(!adeMgr || !adeMgr->isDDRenabled()) {
        DB->msg("repldir::spawn_ddrfiles_child(this:%p) - no adeMgr or adeMgr has DDR disabled", this);
        Out->msg(ERR, "Cannot save "DATADOMAINFILES_FILENAME" to "UNDOO_DIRECTORY_NAME" directory of replicated backup");
        return;
    }
    if(!backupinfop.isnull() && !replcycle::should_use_raw_containers(main->get_avtar_version_that_created_backup(), backupinfop->get_pid())) { 
        assert(info->container.isdefined());
        main->finalizeucontainer(info->container, false);
    }
    DataDomainSysInfo ddrSysInfo;
    
    if(!adeMgr->write_ddrfilesxml(&ddrSysInfo) || ddrSysInfo.fileName.isempty() || ddrSysInfo.ddrfilesData.isnull() || ddrSysInfo.ddrfilesData.size() == 0) {
        DB->msg("repldir::spawn_ddrfiles_child(this:%p) adeMgr failed to return valid ddrSysInfo", this);
        Out->msg(ERR, "Cannot save "DATADOMAINFILES_FILENAME" to "UNDOO_DIRECTORY_NAME" directory of replicated backup");
        return;
    }
    DB->msg("repldir::spawn_ddrfiles_child(this:%p) %s is %s bytes", this, ddrSysInfo.fileName.tostr(), tostr(ddrSysInfo.ddrfilesData.size()).tostr());
    assert(ddrfilechild == NULL);
    ddrfilechild = spawn_sysinfo_child(ddrSysInfo.fileName, ddrSysInfo.ddrfilesData);
#else
    assert(!"Unsupported function");
    Out->msg(ERR, "Unable to save ddr_files.xml to .system_info directory of replicated backup");
#endif
}

void repldir::spawn_migrateinfo_child(){
    xml_messagep xml_migrateinfo(NULL);
    if(!backupinfop.isnull()) {
        xml_migrateinfo = backupinfop->to_xmlp();
        if(!xml_migrateinfo.isnull()) {
            datetime migrate_time;
            xml_migrateinfo->enter("migrate_time",  migrate_time.image());
        }
        else
            DB->msg("repldir::spawn_migrateinfo_child(this:%p) - No backup xml information available for migration", this);
    }
    else {
        DB->msg("repldir::spawn_migrateinfo_child(this:%p) - No backup information available for migration", this);
        return;
    }
    assert(!xml_migrateinfo.isnull());
    fileref f_migrateinfo;
    f_migrateinfo.initlist(1);
    f_migrateinfo.append(xml_migrateinfo->fimage());
    
    if(migrateinfo_de != NULL) {
#if 0
        
        
        utar_flags_info empty_dstflags;
        const utar_commands uc(flags, main->getAdeMgr()->getHfsInfo(dpn0), empty_dstflags);
        const context::prep_for_sysinfo context_is_prepped(*main);
        fileref f_migration;
        if(uc.restore_file(f_migration, migrateinfo_de)) {
            f_migrateinfo.append(f_migration);  
        } else {
            DB->msg("repldir::spawn_migrateinfo_child(this:%p) - failed to read "MIGRATEINFO_FILENAME"", this);
            Out->msg(WARN, "Failed to read existing migration_info from backup.");
        }
#else
        if(!utar_commands::migrateinfo_fr.isnull() && utar_commands::migrateinfo_fr.size64() > 0) {
            f_migrateinfo.append(utar_commands::migrateinfo_fr);  
         }
#endif
    }
    DB->msg("repldir::spawn_migrateinfo_child(this:%p) %s is %s bytes", this, MIGRATEINFO_FILENAME, tostr(f_migrateinfo.size()).tostr());
    assert(migrateinfochild == NULL);
    migrateinfochild = spawn_sysinfo_child(MIGRATEINFO_FILENAME, f_migrateinfo);
}

void repldir::spawn_workresults_child() {
    if(workresults_de == NULL) {
        DB->msg("repldir::spawn_workresults_child(this:%p) - No "WORKRESULTS_FILENAME" in "UNDOO_DIRECTORY_NAME" to update", this);
        return;    
    }
    fileref f_workresult;
#if 0
    
    
    utar_flags_info empty_dstflags;
    const utar_commands uc(flags, main->getAdeMgr()->getHfsInfo(dpn0), empty_dstflags);
    const context::prep_for_sysinfo context_is_prepped(*main);
    
    if(uc.restore_file(f_workresult, workresults_de)) {
        
        xml_messagep workresults_xmlp(new xml_message(f_workresult, true));
        if(dmsg1) DB->msg("repldir::spawn_workresults_child(this:%p) - existing "WORKRESULTS_FILENAME":\n%s", this, workresults_xmlp->simage().tostr());
        if(workresults_xmlp->defined("ddr_index")) {
            
            DataDomainLoginArgs ddlogininfo;
            
            ddlogininfo.dpninx = dpn1;
            
            if(main->getAdeMgr()->getDDRLoginInfo(ddlogininfo)) {
                workresults_xmlp->enter("ddr_index", ddlogininfo.serverIndex);
                DB->msg("repldir::spawn_workresults_child(this:%p) - Updated "WORKRESULTS_FILENAME":\n%s", this, workresults_xmlp->simage().tostr());
            }
            f_workresult = workresults_xmlp->fimage();
        }
    } else {
        DB->msg("repldir::update_workresults(this:%p) - failed to read "WORKRESULTS_FILENAME"", this);
        Out->msg(WARN, "Failed to read ndmp backup work result.");
        return;
    }
#else
    if(!utar_commands::workresults_fr.isnull() && utar_commands::workresults_fr.size64() > 0) {
        
        xml_messagep workresults_xmlp(new xml_message(utar_commands::workresults_fr, true));
        if(dmsg1) DB->msg("repldir::spawn_workresults_child(this:%p) - existing "WORKRESULTS_FILENAME":\n%s", this, workresults_xmlp->simage().tostr());
        if(workresults_xmlp->defined("ddr_index")) {
            
            DataDomainLoginArgs ddlogininfo;
            
            ddlogininfo.dpninx = dpn1;
            
            if(main->getAdeMgr()->getDDRLoginInfo(ddlogininfo)) {
                workresults_xmlp->enter("ddr_index", ddlogininfo.serverIndex);
                DB->msg("repldir::spawn_workresults_child(this:%p) - Updated "WORKRESULTS_FILENAME":\n%s", this, workresults_xmlp->simage().tostr());
            }
            f_workresult = workresults_xmlp->fimage();
        }
    }
#endif
    DB->msg("repldir::spawn_workresults_child(this:%p) %s is %s bytes", this, WORKRESULTS_FILENAME, tostr(f_workresult.size()).tostr());
    assert(workresultschild == NULL);
    workresultschild = spawn_sysinfo_child(WORKRESULTS_FILENAME, f_workresult);
}

BackCycle* repldir::spawn_sysinfo_child(const ustring filename, const fileref data){
    const DIRELEMp de(new DIRELEM());
    de->zero();
    const epoch_t now((epoch_t)timer::now());
    de->initialize(hashcode::empty, now, now, now, data.size64(), ATTR_INTERNAL, filename);
    workelem* const w(new workelem(info, upath(filename), de, info->fstats, data));
    w->dpninx = dpn1;
    DB->msg("repldir::spawn_sysinfo_child(this:%p) starting nbackdata for %s", this, filename.tostr());
    BackCycle* child = new nbackdata(this, w, fileoffset::zero, false, NULL, false);
    child->noop();
    modified_data = true;
    nforked++;

    return child;
}











void repldir::remove_from_listing(const ustring filename, fileref &listing) {
    direlemp_list_type de_listing;
    int de_off = 0;            
    const int size = listing.size();
    if(dmsg1) DB->msg("repldir::remove_from_listing() - filename: %s", filename.tostr());
    
    while(de_off < size) {
        DIRELEM de;
        if(!de.populate(listing, de_off)) {       
            DB->msg("repldir::remove_from_listing() - failed to read directory '%s' listing at offset %d", name.tostr(), de_off);
            Out->msg(ERR, "Failed to read directory '%s' listing for '%s'.", name.tostr(), filename.tostr());
            return;
        }
        if(de.name() != filename)
            de_listing.push_back(new DIRELEM(de));
        else if(dmsg1)
            DB->msg("repldir::remove_from_listing() - remove  '%s' from directory '%s' listing", filename.tostr(), name.tostr());
    }
    fileoffset totalsize;
    listing = build_diratomic(de_listing, totalsize, flags.inode, main->getmaxdirelemsize(dpn1));
}


repldir::~repldir() {
}







replwholedir::replwholedir(replcycle *parent, const hashvect& hv_, const int sliceoff_,
                           const bool can_cancel_, const ustring& name_,
                           chunktype ctype_, const epoch_t filetime_, const int traverse_depth_,
                           workelem* info_, cycle* starter)
  : replcycle(parent, NULL, info_),
    hvect(hv_),
    can_cancel(can_cancel_),
    name(name_),
    ctype(ctype_),
    filetime(filetime_),
    traverse_depth(traverse_depth_),
    has_container_began_dir(false),
    meta_de(NULL),
    dep_child(NULL),
    phase(dir_content)
{
    this->rhash = hvect[0];
    this->offset = fileoffset(sliceoff_);       
    this->hash = hashcode::empty;               
    assert(!flags.reportonly);
    if(dmsg1) {
        DB->msg("replwholedir::replwholedir - The hashoff (or this->offset) = %s with sliceoff_ = %d, traverse_depth = %d, "
                "atomic_depth = %d, rechunk = %d",
                *((this->offset).image()), sliceoff_, traverse_depth, getAtomicDepth(), info->rechunk);
    }

    location parent_loc(info->direlemp->get_location());
    if((parent_loc.getMedia() > location::media::gsan) && (parent_loc.get_format() == location_types::tformat::cdsf)) {
        info->running_coverage_size.clear();
        info->running_coverage_size[parent_loc.get_containerid()] = parent_loc.get_abs_offset_in_container() + parent_loc.get_header_size();
    }

    use_raw_container = (!backupinfop.isnull() && replcycle::should_use_raw_containers(main->get_avtar_version_that_created_backup(), backupinfop->get_pid()));

    if(!backupinfop.isnull() && (backupinfop->get_pid().kind() == pidtype::ndmp) && info->rechunk) phase = dir_metadata;

    
    if(starter)
        starter->setnext(TODO_CHUNK, this, -traverse_depth);
    else
        main->add_insert(TODO_CHUNK, this, -traverse_depth);         
}






replwholedir::repldumper::repldumper(replwholedir* repl_, workelem* info_) : repl(repl_), info(info_) {
    if(dmsg1) DB->msg("replwholedir::repldump::repldumper()  file: %s, this(%p), info(%p)",
                       *info->direlemp->name(), this, info);
}


replwholedir::repldumper::~repldumper() {
  if(dmsg1) DB->msg("replwholedir::repldump::~repldumper()");
}


int replwholedir::repldumper::dump(const fileref& data) {
    assert(info != NULL);
    if(dmsg1) DB->msg("replwholedir::repldumper::dump file: %s, data size=%d bytes info:%p",
                       *info->direlemp->name(), data.size(), info);
    if (info->use_container) {
        ucontainer::errortype errcode = info->container->continuemeta(repl->get_meta_de().getimpl(),
                                                                      data.size(),
                                                                      0,
                                                                      udirelem::meta(udirelem::meta::pmt_directory_streamslice));
        if(errcode != ucontainer::pce__success) {
            Out->Abort("replwholedir::repldumper::dump: Problem calling continuemeta for %s (%s)",
		       *(repl->get_meta_de()->fullpath().image()), *ucontainer::error_description(errcode));
            return 0;
        }

        if((errcode = info->container->appenddata(data)) != ucontainer::pce__success) {
            Out->Abort("replwholedir::repldumper::dump: Problem calling appenddata for %s (%s)",
		       *(repl->get_meta_de()->fullpath().image()), *ucontainer::error_description(errcode));
            return 0;
        }

        if(dmsg1) DB->msg("DDR: after appenddata (offset: %s, dir %s)",
                          *info->container->get_curroffset().image(), *(repl->get_meta_de()->fullpath().image()));

        if(dmsg1) DB->msg("replwholedir::repldumper::dump() - data progression size %d", data.size());
        repl->update_stats(context::restorestats, stats::ddsent, chunktype::atomicdir, data.size());
        if(dmsg1) DB->msg("replwholedir::repldumper::dump done.");
        return data.size();
    }
    if(dmsg1) DB->msg("replwholedir::repldumper::dump continer is not in use!");
    Out->msg(ERR, "Container is not in use for celerra_vnx enhancements!");
    return 0;
}


void replwholedir::init() {
    
    filename_cache *fcache = main->state->fcache;
    if (fcache != NULL && rhash != hashcode::empty && (ctype.is_anycomposit() || ctype.is_dir_atomic())) {
        int tagword = 0;
        bool isatom;
        unsigned int atime;
        location loc;
        hashcode dsthash;

        
        bool getchunkinfo = !migration_sysinfo_write && fcache->get_chunk_info(rhash,
                                                                               getThreadNbr(),
                                                                               fileoffset(0),
                                                                               dsthash,
                                                                               tagword,
                                                                               isatom,
                                                                               atime,
                                                                               loc,
                                                                               false  );
        if(dmsg1)DB->msg("replwholedir::init() - getchunkinfo = %s, name = %s, tagword = %d, rhash = %s, dsthash = %s, loc = %s",
                          getchunkinfo?"true":"false", *name, tagword, *rhash.partialimage(), *dsthash.partialimage(), *loc.image());

        if(getchunkinfo && dsthash != hashcode::zero && tagword != 0) {
            if(loc.getMedia() == location::media::ddr && !loc.get_checksum().isempty() ) {
                loc.set_checksum_type(1);
            }
            if(loc.getMedia() != location::media::gsan) {
                if(container_cachehit(info->direlemp, loc, dsthash)) {
                    
                    if(phase == dir_content) update_stats(context::restorestats, stats::filecache, chunktype(0), info->direlemp->file_size().dvalue());
                    if(dmsg1) DB->msg("replwholedir fcache->get_chunk_info cache hit %s: %s --> %s, %s",
                                       *name, *rhash.partialimage(), *dsthash.partialimage(), *hash.partialimage());
                    hash = dsthash;
                    info->direlemp->set_hash(dsthash);
                    forksdone = true;
                    notifyparent();
                    return;
                }
            }
        }
    }

    if(info->rechunk) {
        assert(!info->direlemp.isnull());
        if(info->use_container) assert(!info->container.isnull());

        if(flags.destination_data == client_config_flags::gsan_to_ddr) {
            if(info->use_container) {
                if(!has_container_began_dir) {
                    if(dmsg1) DB->msg("replwholedir::init() - begin_dir");
                    begin_dir(info->container, info->direlemp, "replwholedir::init");
                    has_container_began_dir = true;
                }
                if(phase == dir_metadata) {
                    unsigned char hashoffset;
                    if(is_ndmp_dephash_available(hashoffset)) {
                        if(dmsg1) DB->msg("replwholedir::init() - process celerra_vnx dephash, hashoffset = %d", hashoffset);
                        process_dephash_data(hvect[hashoffset+1], info);
                    } else {
                        if(dmsg1) DB->msg("replwholedir::init() - No ndmp dependent hash sent for directory '%s'. Re-queue self for directory content",
                                           *info->direlemp->fullpath().image());
                        phase = dir_content;
                        main->add_insert(TODO_CHUNK, this, -traverse_depth);
                        return;
                    }
                } else if(phase == dir_content) {
                    if(dmsg1) DB->msg("replwholedir::init() - begin_dir_content");
                    begin_dir_content(info->container, info->direlemp, "replwholedir::init");
                } else
                    DB->msg("replwholedir::init() - invalid dir phase %d", phase);
            } else {
                DB->msg("replwholedir::init() - Container is empty in gsan to ddr replication %s! (path %s)", use_raw_container?"with using raw container":"", *name);
                if(!use_raw_container) Out->Abort("Container is empty for GSAN to DDR replication");  
            }
        } else {
            DB->msg("replwholedir::init() - Replication is running in DDR to GSAN mode");
        }
    }

    
    
    if(rhash != hashcode::empty && rhash != hashcode::zero && ((phase == dir_content) || use_raw_container)) {
        DB->msg("replwholedir::init() - cycle down to directory content. rhasg = %s", *rhash.partialimage());
        cycle* child = new repldata(this, rhash, offset.ivalue(), can_cancel, info->direlemp->file_size().dvalue(), name, ctype,
                                    filetime, traverse_depth, info, NULL);
        child->noop();
        nforked++;
    } else {
        assert(!info->direlemp.isnull());
        DB->msg("replwholedir::init() - jump over of new repldata(). rhash = %s, path: %s, phase: %d", *rhash.partialimage(), *info->direlemp->fullpath().image(), phase);
    }
    forksdone = true;
    childdone(NULL);
}


void replwholedir::childdone(cycle *child) {
    if (child != NULL)
        ncollected++;

    if((dep_child != NULL) && (dep_child == child)) {
        assert(phase == dir_metadata);
        
        ucontainer::errortype errcode = info->container->endmeta(meta_de.getimpl(),0,udirelem::meta(udirelem::meta::pmt_directory_streamslice));
        if (errcode != ucontainer::pce__success) {
            Out->Abort("replwholedir::childdone: Problem calling endmeta for %s (%s)",
                        *meta_de->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        }

        if (dmsg1) DB->msg("DDR: after endmeta (offset: %s, dir %s), location: %s",
                            *info->container->get_curroffset().image(), *meta_de->fullpath().image(),
                            *meta_de->get_location().image());
        phase = dir_content;
        main->add_insert(TODO_CHUNK, this, -traverse_depth);
        return;
    }

    if(forksdone && ncollected == nforked) {
        
        if(info->rechunk && !info->container.isnull() && (flags.destination_data == client_config_flags::gsan_to_ddr)) {
            const ustring path(info->direlemp->fullpath().image());
            end_dir(info->container, info->direlemp, "replwholedir::childdone", path);
        }

        if (flags.destination_data == client_config_flags::ddr_to_gsan) {
            info->direlemp->clear_location();
        }
        if (child != NULL) {
            hash = child->hash;
            if(hash == hashcode::zero) {
                assert(!"Directory hash can not be zero!");
                Out->msg(ERR, "Replication gets zero hash at \"%s\"", *name);
            }
            info->direlemp->set_hash(hash);  
            if(!migration_sysinfo_write && use_raw_container) {  
                location loc = info->direlemp->get_location();
                loc.setMedia(location::media::ddr);
                loc.set_format(location_types::tformat::unknown);
                info->direlemp->set_location(loc);
            }
        }

        if(!migration_sysinfo_write && main->state->fcache && (hash != hashcode::zero) && (hash != hashcode::empty)) {
            main->state->fcache->put_chunk_info(rhash,
                                                hash, 
                                                DIRELEM::extflag_is_directory,
                                                parent->getThreadNbr(),
                                                cyisatomic,
                                                0,
                                                info->direlemp->get_location(),
                                                fileoffset(0));
            if(debug_msgs) DB->msg( "replwholedir::childdone fcache->put_chunk_info(...). rhash=%s, delhash=%s, name=%s",
                                     *rhash.partialimage(), *info->direlemp->file_hash().partialimage(),*name);
        }

        notifyparent();
    }
}

void replwholedir::response(message& outargs) {
    assert(false);
}


bool replwholedir::container_cachehit(DIRELEMp direlem, location loc, hashcode dsthash) {
    if (debug_msgs) DB->msg("replwholedir::container_cachehit name: %s, loc:%s", *name, *loc.image());
    hash = hashcode::zero; 

    if (loc.get_backupid() == 0) {
        Out->msg(WARN, "Unable to use filename cache for file '%s', previous data not found in container.  Backing up data.", *direlem->name());
        return false;
    }

    ucontainer::errortype errcode;
    DB->msg("replwholedir::container_cachehit calling synthobj loc:%s, rhash = %s, direlem_hash = %s",
             *loc.image(), *rhash.partialimage(), *direlem->file_hash().partialimage());
    direlem->set_location(loc);
    if ((errcode = info->container->synthobj(direlem.getimpl())) != ucontainer::pce__success) {
        Out->msg(WARN, "replwholedir::container_cachehit: Problem calling synthobj for %s (%s)",
                 *direlem->fullpath().image(), *ucontainer::error_description(errcode));
        
        return false;
    }

    
    
    if(dmsg1) DB->msg("replwholedir::container_cachehit after calling synthobj direlem loc:%s, rhash = %s, dsthash = %s",
                       *direlem->get_location().image(), *rhash.partialimage(), *dsthash.partialimage() );
    const location synthloc = direlem->get_location();
    const int streamnum = parent->getThreadNbr();
    main->state->fcache->put_chunk_info( rhash,
                                         dsthash,    
                                         DIRELEM::extflag_is_directory,
                                         streamnum,
                                         cyisatomic,
                                         0,
                                         synthloc,
                                         fileoffset(0));

    int file_count = 0;
    int dir_count = 0;
    if ((loc.getMedia() == location::media::ddr) && (loc.getMedia() == synthloc.getMedia())) {
        main->state->fcache->copy_forward(streamnum, loc, synthloc, rhash, &file_count, &dir_count);
        if (debug_msgs)
            DB->msg("replwholedir::container_cachehit synthed %d files and %d directories", file_count, dir_count);
    }
    if (debug_msgs) {
        DB->msg("replwholedir::container_cachehit path=%s synthed from\n    loc:%s to\n    loc:%s",
                *name, *loc.image(), *synthloc.image());
    }

    
    backstats* stat_data = main->getstatsobj(context::restorestats);
    stat_data->add_filecount(double(file_count));
    stat_data->add_dircount(double(dir_count + 1));

    return true;
}

void replwholedir::process_dephash_data(const hashcode& dephash, workelem *info) {
    if (dmsg1) DB->msg("replwholedir::process_dephash_data - dephash = %s", *dephash.partialimage());
    
    meta_de = new DIRELEM(upath(""));
    meta_de.getimpl()->set_fullpath(upath("meta"));
    meta_de.getimpl()->set_name("meta");

    ucontainer::errortype errcode = info->container->beginmeta(meta_de.getimpl(),0,udirelem::meta(udirelem::meta::pmt_directory_streamslice));
    if (errcode != ucontainer::pce__success) {
        Out->Abort("replwholedir::process_dephash_data : Problem calling beginmeta for %s (%s)",
                    *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
        return;
    }

    chunktype dep_ctype(ctype);

    if (dmsg1) DB->msg("replwholedir::process_dephash_data : calling byteprogress for dephash %s", *dephash.partialimage());
    main->byteprogress(context::backupstats, stats::ddsent, info->data.size64().dvalue(), info->fstats, dep_ctype);

    DIRELEMp delp = info->direlemp;
    restinfo.direlem = *delp;
    restinfo.path = upath(name);

    filerefx::initpipedump(restinfo.data, new repldumper(this, info), false, false);
    dep_child = new restdata(this, dephash, &dep_ctype, delp->is_atomic(), restinfo);
    dep_child->noop();
    nforked++;
    if(dmsg1) DB->msg("replwholedir::process_dephash_data - child(restdata)=%p, restinfo data pointer = %p", dep_child, restinfo.data.base());
    restinfo.data.free();
}


bool replwholedir::is_ndmp_dephash_available(unsigned char& hashoffset) {
    bool ret(false);
    if(backupinfop->get_pid().kind() == pidtype::ndmp) {
        ubigint64 slicesize;
        DIRELEM depelem = *info->direlemp;
        dirrec_pack::streamslice dep_ss(&depelem);

        ret = true;
        if(!dep_ss.get(slicesize, hashoffset)) {
            DB->msg("replwholedir::is_ndmp_dephash_available() - there is no dependent hash at directory '%s' at all.",
                     *info->direlemp->fullpath().image());
            ret = false;
        }
        if(ret) {
            DB->msg("replwholedir::is_ndmp_dephash_available() - directory '%s' contains dependent stream hash at offset: %d, size: %"LL"d, hvect size: %d",
                     *info->direlemp->fullpath().image(), hashoffset, slicesize, (int)hvect.size());
            ret = (hvect.size() > hashoffset)? (hvect[hashoffset+1] != hashcode::empty) : false;
        }
    }
    return ret;
}


ucontainer::errortype replwholedir::begin_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc) {
    const ustring path = direlemp->fullpath().image();
    
    
    
    
    fileoffset offset = container->get_curroffset();
    if(dmsg1)DB->msg("replwholedir::begin_dir    ucontainer before begindir  '%s' (offset:%s, mysize:%s) %s",
                    *path, *offset.image(), *direlemp->file_size().image(), *desc);
    const ucontainer::errortype errcode1(container->begindir(direlemp.getimpl()));
    if (errcode1 != ucontainer::pce__success) {
        if (uapp::staging().canRun())
            Out->Abort("Problem calling begindir for '%s' (%s) offset=%s",
                        *path, *ucontainer::error_description(errcode1), *offset.image());
        else {  
            
            Out->msg(ERR, "Problem after cancellation calling begindir for '%s' (%s) offset=%s",
                           *path, *ucontainer::error_description(errcode1), *offset.image());
            const ustring errmsg("Fatal error encountered during cancellation");
            uapp::staging().startTermination(EXIT_ABORT, errmsg);
            uapp::staging().setStageFinal(errmsg);
        }

        return errcode1;
    }
    if(dmsg1)DB->msg("replwholedir::begin_dir    ucontainer after  begindir  '%s' loc:%s size:%s",
                    *path, *direlemp->get_location().image(), *direlemp->file_size().image());

    return ucontainer::pce__success;
}


ucontainer::errortype replwholedir::begin_dir_content(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc) {
    const ustring path = direlemp->fullpath().image();
    assert(has_container_began_dir);
    
    
    
    
    fileoffset offset = container->get_curroffset();

    if(dmsg1)DB->msg("replwholedir::begin_dir_content    ucontainer before begindircontent  '%s' (offset:%s, mysize:%s) %s",
                    *path, *offset.image(), *direlemp->file_size().image(), *desc);

    const ucontainer::errortype errcode2(container->begindircontent(direlemp.getimpl()));
    if (errcode2 != ucontainer::pce__success) {
        Out->Abort("Problem calling begindircontent for '%s' (%s) offset=%s",
                    *path, *ucontainer::error_description(errcode2), *offset.image());
        return errcode2;
    }
    if(dmsg1)DB->msg("replwholedir::begin_dir_content    ucontainer after  begindircontent '%s' loc:%s size:%s",
                    *path, *direlemp->get_location().image(), *direlemp->file_size().image());

    return ucontainer::pce__success;
}

replwholedir::~replwholedir() {
    if(info) {
        delete info;
        info = NULL;
    }
}








migratedir::migratedir(replcycle *parent, hashcode& myhash_, fileref& listing_,
                 const bool can_cancel_, const chunktype ctype_,
                 const ustring& name_, const time_t filetime_,
                 const int traverse_depth_, workelem* info_,
                 const int sysinfo_comp_off_, const bool search_sysinfo_)
  : replcycle(parent, NULL, info_),
    myhash(myhash_),                    
    listing(listing_),                  
    can_cancel(can_cancel_),            
    ctype(ctype_),                      
    name(name_),                        
    filetime(filetime_),                
    traverse_depth(traverse_depth_),    
    sysinfo_comp_off(sysinfo_comp_off_),   
    search_sysinfo(search_sysinfo_)        
{
    
    main->add_insert(TODO_DIR, this, -traverse_depth);   
}

void migratedir::init() {

    

    
    main->set_cur_filename((upath)name, true);
    if (Out->is_enabled(VERBOSE)) Out->msg(VERBOSE, "%s", *name);

    int nextoff = 0;            
    int curroff = 0;            

    cycle* prevcycle = NULL;
    DIRELEMp sysinfo_de;
    int sysinfo_off(0), sysinfo_end(0);

    const int size = listing.size();
    while(nextoff < size) {
        curroff = nextoff;
        
        
        const DIRELEMp del(new DIRELEM());
        if(!del->populate(listing, nextoff)) { 
            Out->msg(ERR, "Failed to read directory listing within '%s'", name.tostr());
            break;
        }

        
        if(traverse_depth == 0 && del->is_internal() && del->is_directory() && del->name().equal(UNDOO_DIRECTORY_NAME)) {
            
            
            if(flags.pluginid.kind() == pidtype::migrate) {
                if(!search_sysinfo) {
                    DB->msg("migratedir::init found "UNDOO_DIRECTORY_NAME", will process it last");
                    assert(sysinfo_de.isnull() && sysinfo_off == 0 && sysinfo_end == 0); 
                    sysinfo_off = curroff;
                    sysinfo_end = nextoff;
                    sysinfo_de = del;
                    continue;
                }
                else {
                    DB->msg("migratedir::init found "UNDOO_DIRECTORY_NAME" when search, parent composite hash offset is %d", sysinfo_comp_off);
                    utar_commands::sysinfo_off = sysinfo_comp_off;
                    notifyparent();
                    return;
                }
            } else {
                DB->msg("migratedir::init found "UNDOO_DIRECTORY_NAME", will process it last");
                assert(sysinfo_de.isnull() && sysinfo_off == 0 && sysinfo_end == 0); 
                sysinfo_off = curroff;
                sysinfo_end = nextoff;
                sysinfo_de = del;
                continue;
            }
        }

        if(flags.pluginid.kind() == pidtype::migrate) {
            if(!search_sysinfo) {
                if(!process_dirlisting(del, curroff, nextoff, prevcycle))
                    break;
            }
        } else {
            if(!process_dirlisting(del, curroff, nextoff, prevcycle))
                break;
        }
    }

    
    if(search_sysinfo && ((flags.pluginid.kind() == pidtype::migrate))) {
        notifyparent();
        return;
    }

    
    if(sysinfo_de.isdefined() && !process_dirlisting(sysinfo_de, sysinfo_off, sysinfo_end, prevcycle, true))
        Out->msg(ERR, "Failed to process "UNDOO_DIRECTORY_NAME);

    forksdone = true;
    childdone(NULL);
}

bool migratedir::process_dirlisting(DIRELEMp del, const int curroff, const int nextoff, cycle*& prevcycle, bool is_sysinfo) {

    if(del.isnull())
        return false;

    ustring pathname;
    if(traverse_depth > 0)
        pathname = name/del->name();
    else
        pathname = del->name();

    const bool isdir(del->is_directory());
    chunktype dtype;
    if(isdir)
        dtype = chunktype::atomicdir;
    else if(del->is_atomic())
        dtype = chunktype::atomic;

    assert(can_cancel);

    ucontainer::basep container(NULL);
    if(flags.destination_data == client_config_flags::gsan_to_ddr || is_sysinfo)
        container = info->container;
    else if((flags.destination_data == client_config_flags::ddr_to_gsan) &&
            (del->get_location().getMedia() > location::media::gsan)) {    
        update_location(info, del);
        location loc = del->get_location();
        
        
        if(((info->container == NULL) || (info->direlemp->get_location().get_containerid() != loc.get_containerid())) && !backupinfop.isnull() && !replcycle::should_use_raw_containers(main->get_avtar_version_that_created_backup(), backupinfop->get_pid()))
            container = main->open_container_for_read(loc);
        else
            container = info->container;
    }

    workelem* w(NULL);
    if(((traverse_depth == 0) || (traverse_depth == 1)) &&
       isdir && del->is_internal() && del->name().equal(UNDOO_DIRECTORY_NAME))  
        w = new workelem(false, del, container);   
    else
        w = new workelem(info->rechunk, del, container);

    if(dmsg1) DB->msg("migratedir::process_dirlisting() - is_sysinfo %d, pathname = %s, traverse_depth = %d, isdir = %d, is_internal = %d, del->name = %s, rechunk = %d",
                       is_sysinfo, *pathname, traverse_depth, isdir, del->is_internal(), *del->name(), w->rechunk);

    safebool* l_sysinfo_write(NULL);
    if(is_sysinfo) {     
        assert(pathname.equal(UNDOO_DIRECTORY_NAME));
        
        if(flags.destination_data == client_config_flags::gsan_to_ddr && !disable_generating_sysinfo_files) {
            Out->msg(INFO, "Generating new "DATADOMAINFILES_FILENAME" metadata for migrated backup");
            g_sysinfo_write = false;
            l_sysinfo_write = &g_sysinfo_write;
        }else
            Out->msg(INFO, "Not generating "DATADOMAINFILES_FILENAME" metadata for migrated backup");
        DB->msg("migratedir::process_dirlisting found "UNDOO_DIRECTORY_NAME", traverse depth = %d, pathname='%s', rechunk:%d",
                traverse_depth, pathname.tostr(), w->rechunk);
    } else {
        
        
        
        if((container != NULL) && (flags.destination_data == client_config_flags::gsan_to_ddr)) {
            
            w->use_container = true;
        }
        
    }
    int listing_index = add_de(del).ivalue();  

    hashvect hv;
    del->getdephashes(hv); 
                           

    if(dmsg1)DB->msg("migratedir::process_dirlisting: rechunk = %d, hv.size() = %d, dephash_count = %d, isdir:%d",
                      w->rechunk, (int)hv.size(), (int)DIRELEM::get_dephash_count(listing, curroff), isdir);

    cycle *child;
    if(isdir) {
        replcycle* tmpkid = new replwholedir(this, hv, listing_index, can_cancel, pathname, dtype, del->mtime(), traverse_depth+1, w, prevcycle);
        tmpkid->migration_sysinfo_write = l_sysinfo_write;
        child = tmpkid;
        if(dmsg1) DB->msg("migratedir::process_dirlisting - child %p is replwholedir. pathname = %s hash(hv[0])=%s", child, *pathname, *hv[0].partialimage());
    }
    else {
        child = new replfile(this, hv[0], listing_index, pathname, dtype, traverse_depth+1, w, prevcycle);
        if(dmsg1) DB->msg("migratedir::process_dirlisting - child %p is replfile. pathname = %s", child, *pathname);
    }
    child->noop();
    nforked++;
    if(w->rechunk)
        prevcycle = child; 

    
    
    for(size_t i = 1; i < hv.size(); i++) {
        const hashcode& hash = hv[i];
        if(hash == hashcode::zero || hash == hashcode::empty)
            continue;
        dtype = chunktype::recipe8;
        double filesize = 0;
        int hashoff = DIRELEM::get_hash_off(listing, curroff, (int)i);
        
        
        if((hashoff < curroff) || ((int)(hashoff + sizeof(hashcode)) > nextoff)) {
            DB->error("INTERNAL ERROR in migratedir: hashoff=%d, curroff=%d, nextoff=%d", hashoff, curroff, nextoff);
            assert(false);          
            break;
        } else if(dmsg1)
            DB->msg("migratedir::process_dirlisting: curroff = %d, dep_hashoff = %d and nextoff = %d in hv[%d]", curroff, hashoff, nextoff, (int)i);

            hashcode h;
	    listing.getslice64(hashoff, sizeof(hash), &h);
	    if(h != hash) {
            DB->error("INTERNAL ERROR in migratedir: @hashoff = %d, listing hash: %s !=  dep hash hv[%d]: %s",
                      hashoff, *h.partialimage(), (int)i, *hash.partialimage());
            assert(false);          
            break;
        }

        nforked++;
        if(dmsg1) DB->msg("migratedir::process_dirlisting: hv[%d]= %s, dtype: %s, isdir: %s", (int)i, *hash.partialimage(), *dtype.image(), isdir?"true":"false");
        workelem *w_dep = new workelem(false, del, NULL);
        
        cycle* child = new repldata(this, hash, hashoff, false, filesize, name, dtype, del->mtime(), traverse_depth+1, w_dep, NULL, true);

        if(dmsg1 || dmsg2)
            DB->msg("migratedir::process_dirlisting - input to repldata : hash value hv[%d] = %s, hashoff = %d, and child(repldata) = %p",
                    (int)i, *(hash.partialimage()), hashoff, child);

        child->noop();
        
    }

    return true;
}


void migratedir::childdone(cycle *child) {
    if (child != NULL)
        ncollected++;

    if(dmsg2)DB->msg("migratedir::childdone(forked=%d, collected=%d, forksdone=%d) child=%p", nforked, ncollected, forksdone, child);
    if((debug_msgs || dmsg1) && child != NULL)
        DB->msg("migratedir: child returned hash: %s. The child index = %s, %p", *child->hash.partialimage(), *child->offset.image(), child);
    assert(ncollected <= nforked);

    

    if ((child != NULL) && child->cyisatomic) {
        const int child_index = (int)child->offset.ivalue();
        if(child_index > (int)de_listing.size() || de_listing[child_index].isnull()) {
            Out->msg(ERR, "Internal problem offset:%s > size:%d", *child->offset.image(), (int)de_listing.size());
            
        }

        const DIRELEMp childde(de_listing[child_index]);
        if(child->has_error()) {
            childde->set_internal(true);
        }
        
    }

    if(forksdone && ncollected >= nforked) {
        
        fileoffset totalsize;
        listing = build_diratomic(de_listing, totalsize, flags.inode, main->getmaxdirelemsize(dpn1));

        const hashcode newhash = hashcode(listing);
        if(debug_msgs) DB->msg("Migratedir returning modified directory (depth=%d) %s", traverse_depth, *uapp::staging().getRunStageImage());
        if(debug_msgs) DB->msg("migratedir FINAL: orighash=%s, new hash=%s, name = %s", *myhash.partialimage(), *newhash.partialimage(), *name);

        
        info->direlemp->set_hash(newhash);
        myhash = newhash;
        notifyparent();
    }
}

void migratedir::response(message& outargs) {
    assert(false);
}





fileoffset migratedir::add_de(DIRELEMp de)
{
     scope s(de_listing_mut);
     const fileoffset index = de_listing.size();
     de_listing.push_back(de);
     return index;
}

void migratedir::update_location(workelem *info, DIRELEMp direlem) {
    const location parent_loc = info->direlemp->get_location();
    main->set_location_info("migratedir::update_location()", parent_loc, *direlem);

    location loc = direlem->get_location();
    if((loc.getMedia() > location::media::gsan) && (loc.get_format() == location_types::tformat::cdsf)) {  
        loc.set_abs_offset_in_container(info->running_coverage_size[loc.get_containerid()]);
        
        direlem->set_location(loc);
        info->running_coverage_size[loc.get_containerid()] += loc.get_coverage_size();
    }
}



#if !defined(backemctardir7_H_INCLUDED)
#define backemctardir7_H_INCLUDED












#include "backndmptardir_base.h"

class backemctardir7 : public backndmptardir_base
{

public:
  SAFEALLOC(backemctardir7);

  
  
  
  
  backemctardir7(BackCycle* parent_,
                 workelem *info_,
                 parsestream_base *parser,
                 int traverse_depth,
                 inode_table &inodetab_,
                 int mount_point_numelems = 0,
                 emctar_history *hist = 0,
                 MetadataIntf_sp parent_metadataIntfp_ = MetadataIntf_sp());

  virtual ~backemctardir7();

  virtual void init();
  virtual void response(message& outargs);  
  virtual void childdone(cycle *child);

  virtual void responseReceived(DataHasher* dataHasher) { childdone(dataHasher); }

private:
  backemctardir7(); 

  
  bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata);
  void process_direlem(DIRELEMp  obj_direlem, fileref  altdata, fileref  stubdata);

  
  
  
  void remember_hardlinked_info(DIRELEMp &de);

  void request_prevlist();     
  void request_history();      
  bool merge_lists();          

  void finish_top_level_directory(cycle *child);
  void commit_directory_metadata();

  histvector_t   *histlist;    

  emctar_history *histsrv;         
};

#endif

#if !defined(NBACKDIR_H_INCLUDED)
#define NBACKDIR_H_INCLUDED


























#include "hashcode.h"
#include "cycle.h"
#include "nbackroot.h"
#include "backhidden.h"
#include "backdataconsumer.h"
#include "hardlink_path_table.h"
#include "inode_table.h"
using namespace backupboost;

class priqueue;
class connection;
class backstats;
class profile;
class fileref;
class backstate;
class DIRELEM;
class workelem;
class context;

#include "sortdirwalk.h"


class nbackdir : public BackCycle, public hiddendirfuncs, backdataconsumer::producer {
public:
    nbackdir(BackCycle *parent, workelem *info_, fileoffset offset,
             bool manual=false, bool reserve_hiddendir=false, bool excluded=false, bool top_level_=false,
             int traverse_depth = 0, int callers_reparse_traverse_depth = 0,
             bool skip_contents_ = false, cycle* starter = NULL, const bool use_container = false,
             bool enqueue_on_thread_pool = true, inode_table *inode_tab_ = NULL,
             hardlink_path_table *hardlink_path_tab_ = NULL,
             bool write_ddrfiles_xml_ = true);
    virtual ~nbackdir();

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();

   
    virtual void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false);
    fileoffset do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink=false, DIRELEMp *direlemp=NULL );

    
    
    
    fileoffset add_direlem(DIRELEMp de, bool haschild=false);

    virtual void do_file_finish();  

    void set_partial_listing(fileref &listing) { partial_listing = listing; }

    SAFEPOOLALLOC(nbackdir);

private:
    dirwalkgroup *dirgroup;             
    direlemp_list_type *elements;       
    fileref      partial_listing;       
    int          fillindex;             
    int          sendindex;             
    int          drainindex;            

    bool         more_dirgroups;        
    bool         flush_listing;         
    int          maxgroupentries;       
    int          maxsendentries;        
    int          group_count;           
    int          entry_count;           
    fileoffset   altstreamsize;         

    bicycle *    datachild;             
    DIRELEMp     hiddendirp;            
    BackCycle*   altstrchild;           
    BackCycle *  securitychild;         

    bool         top_level;             
    bool         skip_contents;         
    bool         threadStarter;         

    int          traverse_depth;        
    int          reparse_traverse_depth;
    fileoffset   sizeofchildren;        
    mtex         elements_mut;          
    recursive_mutex nbackdirlock;       

    const bool   use_container;         

    
    
    
    
    
    
    bool         skip_dir_container_entry;
    bool         manual; 

    inode_table *inode_tab;
    hardlink_path_table *hardlink_path_tab;
    inode_table::child_dir_list child_list;

    const bool   write_ddrfiles_xml;

    bool         initialize_dir();

    fileoffset add_element(DIRELEMp de);
    bool backupaltstream(DIRELEMp de);
    bool backupsecurity(DIRELEMp de);

    
    virtual fileref nextdatablock(bool& suppress_requeue);
    virtual void cancelled();

    
    
    bool HandleReparsePoint(DIRELEMp dirp, const upath& fullpath, bool walkOverride = false);

    
    
    bool check_cache(const bool begindir, const DIRELEMp de, const ustring& path);

  
    void container_begindir(const DIRELEMp de, const ustring& desc);
    void container_enddir(const DIRELEMp de, const ustring& desc);


}; 


extern BackCycle *create_nbackdir(
                       BackCycle *parent,
                       workelem *info,
                       fileoffset offset,
                       bool manual = false,
                       bool reserve_hiddendir_ = false,
                       bool excluded_ = false,
                       bool top_level_ = false,
                       int traverse_depth_= 0,
                       int reparse_traverse_depth_= 0,
                       bool skip_contents_ = false,
                       cycle* starter = NULL,
                       const bool use_container = false,
                       bool enqueue_on_thread_pool = true,
                       inode_table *inode_tab = NULL,
                       hardlink_path_table *hardlink_path_tab = NULL
);

#endif
















#ifndef DUMPSTREAMUTILS_H
#define DUMPSTREAMUTILS_H

#include "dump_layout.h"
#include "parsestream.h"
#include "pipe_control.h"

class utar_flags_info; 


#define TS_TYPEMAP_FILENAME "inode.type.map"
#define TS_DIRMAP_FILENAME  "inode.dir.map"
#define TS_ACLMAP_FILENAME  "inode.aclref.map"
#define TS_TAPE_FILENAME    "start"
#define TS_CLRI_FILENAME    "inode.use.map"
#define TS_BITS_FILENAME    "inode.stream.map"
#define TS_DIR_FILENAME     "directory"
#define TS_FILE_FILENAME    "file"
#define TS_EOM_FILENAME     "inode.acl.map"
#define TS_ACL_FILENAME     "acl"
#define TS_END_FILENAME     "end"

#define TS_ACL3_FILENAME    "acl3"


#define TS_DIR_ROOT_INODE_FILENAME "2"

#define DIRMAP_VERSION 2

namespace dumpstream
{












class typemap : public fileref
{
public:
    SAFEPOOLALLOC(typemap);

    typemap() { initlist(0); }

    enum inodetype {
        unused = 0,
        dir    = 1,
        file   = 2,
        acl    = 3
    };

    inodetype get(int32_t inum) const;
    void      set(int32_t inum, inodetype itype);

    int32_t max_inode() const { return size()*4+1; } 

    
    static upath format(int32_t inum, inodetype itype, bool eom = true);

    
    
    upath format(int32_t inum, bool eom = true) const { return format(inum, get(inum), eom); }

    
    static int32_t parse(const upath &path, inodetype &itype);
};






class inodemap : public fileref
{
public:
    SAFEPOOLALLOC(inodemap);

    inodemap() { initlist(0); }

    bool get(int32_t inum) const;
    void set(int32_t inum, bool present = true);

    
    
    void clear(int32_t inum) { set(inum, false); }

    int32_t max_inode() const { return size()*8+1; } 

    int32_t count() const;  
    void print() const;  
};






 
class dirmap : public tassoc<intobj, fileref>
{
private:
    
    
    struct dirinfo {
        int32_t  dir_inode;     
        uint32_t dir_mtime;     
        int32_t  dir_acl_inode; 
        uint32_t child_count;   
        int32_t  child[2];      
    };

public:
    SAFEPOOLALLOC(dirmap);

    dirmap();

    void init(fileref flattened); 
    void setversion();            
    int  version() const;         

    bool has(int32_t inum) const;
    bool get(int32_t inum, epoch_t &mtime, undoo::vector<intobj> &chld) const;
    bool get(int32_t inum, epoch_t &mtime, int32_t &acl_inode, undoo::vector<intobj> &chld) const;
    void set(int32_t inum, epoch_t mtime, const undoo::vector<intobj> &chld);
    void set(int32_t inum, epoch_t mtime, int32_t aclinode, const undoo::vector<intobj> &chld);
    bool add(fileref dumpdata); 
    bool del(int32_t inum);

    fileref flatten() const; 
    void print() const;
};


int32_t parsedumpdir(fileref dumpdata, epoch_t &mtime, int32_t &nt_ads, undoo::vector<intobj> &childinode,
                     undoo::vector<ustring> &childname, int32_t &acl_inode);






bigint64 file_count(const dirmap &dmap, const typemap &tmap, const inodemap &imap = inodemap());







int32_t decodeNTstreamsdirinode(ustring dirname);








class aclmap : public dirmap 
{

#if 0 
private:
    
    using dirmap::get;
    using dirmap::set;
    using dirmap::add; 
public:
    using dirmap::del;
#endif

public:
    bool get(int32_t acl, undoo::vector<intobj> &refs) const;
    void add(int32_t acl, int32_t inum);
    bool del(int32_t acl, int32_t inum);
};















class parser : public parsestream
{
public:
    SAFEALLOC(parser);

    parser(const utar_flags_info &flags, const ustring& streamdesc = "&0", const int stream_timeoutsecs = 30);
    ~parser();

    
    
    typemap get_type_map() { return type_map; }

    
    
    dirmap &get_dir_map() { return dir_map; }

    
    
    aclmap &get_acl_ref_map() { return acl_ref_map; }

    enum path_action {
        no_more_items,      
        subdir_item,        
        save_item,          
        delete_item,        
    };

    
    
    
    

    path_action next_modified_path(const upath &dir, ustring &name);

    bool getentry(DIRELEMp &de, fileref &dummy1, fileref &dummy2); 
    bigint64 readdata(void *bufp, size_t n);                       

    void validatebitmaps(bool incremental);                        

    epoch_t get_ddate() const { return ddate; }                    

    
    bigint64 get_file_count() const { return file_count(dir_map, type_map); }

    bigint64 get_object_size() const { return object_size; }

private:
    const utar_flags_info &flags; 

    void update_acl_ref(int32_t oldaclref, DIRELEMp de); 

    dump_header cur_header;     

    epoch_t ddate;              

    bool eom_seen;              

    typemap::inodetype last_type;   
    int32_t            last_inode;  

    bigint64 object_size;       
    bigint64 object_bytes_read; 

    fileref  buffer;            

    dirmap   dir_map;           
    aclmap   acl_ref_map;       
    typemap  type_map;          
    typemap  prev_type_map;     

    inodemap use_map;           
    inodemap stream_map;        
    inodemap acl_map;           

    int32_t  acl_bytes_left;    
};



class parserp : public refcounter<parser>
{
public:
    parserp() : refcounter<parser>() {}
    parserp(parser* de) : refcounter<parser>(de) {}
    SAFEALLOC(parserp);
};







class pipectrl : public pipe_control
{
public:
    SAFEALLOC(pipectrl);

    pipectrl(fileref output);

    
    bool addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                const fileoffset datasize, fileref& dataslice);

protected:
    
    bool fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                    const DIRELEM& elem,  const ustring& path,
                    const filetype ftype, const ustring& linkname,
                    const fileoffset startoff=fileoffset(0));
};


}
















class dumpformat_directory {
public:
    dumpformat_directory();
    virtual ~dumpformat_directory();

  
    bool append_chunk(const fileref& data, bool& keepgoing);

  
    bool finished();

private:
    fileref data;     

    bool haveheader;  
    int header_type;  
    int direct_bytes; 

  
  
    virtual bool process_entry(const int ino_num, const ustring name, bool& keepgoing)=0;

    bool check_header(int offset = 0);                 
    bool check_magic(swapint magic);     
    bool parse_directs(bool& keepgoing, int offset = 0); 
};













class crossplatform_ctl {
public:

    enum XP_action {
        xp_write_next,
        xp_sparse_next,
        xp_get_tsaddr,
        xp_file_done
    };

    crossplatform_ctl (ustring& filename);
    bool       parsefileheader (fileref& buffer, int32_t inode, int64_t& actual_filesize);
    void       set_backup_size(fileoffset::value_type size_in_backup);
    XP_action  get_next_action(fileoffset::value_type &backup_loc, fileoffset::value_type &outfile_loc, int& nbytes);
    void       set_outfile_size (fileoffset::value_type fsz) { m_outfile_size = fsz; }
    void       dump();

private:
    fileoffset::value_type   m_backup_size;  
    fileoffset::value_type   m_backup_loc;   
    fileoffset::value_type   m_outfile_size; 
    fileoffset::value_type   m_outfile_loc;  
    int  m_hdr_loc;           
    int  m_count;             
    char m_data[TP_NINDIR];   
    ustring m_filename;       
};


#endif





















#include "common.h"
#include "debug.h"
#include "restdumpfile.h"
#include "restdata.h"
#include "todoelem.h"
#include "context.h"
#include "dumpcontext.h"
#include "pipe_control.h"


#define deb ((xflag[11]&1024)!=0)

restdumpfile::restdumpfile(cycle *parent, int inode_, DIRELEM de_, int priority_id_)
  : cycle(parent),  
    inode(inode_),
    de(de_),
    priority_id(priority_id_)
{
    if(deb) DB->msg("restdumpfile::restdumpfile name:%s  to-stdout:%d priority_id:%d",
                    *de.fullpath().image(), flags.to_stdout, priority_id);

    dumpctx = main->getdumpcontext();
    if (!dumpctx) { assert(false); set_error(true, "Unable to get dumpcontext"); return; }

    path = de.fullpath();
    totalsize = de.file_size();

    main->add_insert(TODO_FILE, this, priority_id);
};

void restdumpfile::init() {
    if(deb)DB->msg("restdumpfile::init path:%s size:%s startoff:%s", *path.image(), *totalsize.image(), *startoff.image());

    fileref    reserved_slice;      
    
    fileref altdummy, stubdummy, extentsdata;
    main->getpipe_control(0)->addfile(de, path.image(), reserved_slice, altdummy, stubdummy, extentsdata, pipe_control::REGTYPE, "", startoff );

    fileoffset endoff(startoff+reserved_slice.size()-1);

    
    
    
    restelem rinfo(path, de, filestatsref(), true, volinfo(), startoff, endoff);
    rinfo.data = reserved_slice;
    if(deb)DB->msg("restdumpfile::init startoff:%s endoff:%s check:%d size:%d",
            *rinfo.startbyte.image(), *rinfo.endbyte.image(), rinfo.checkrange, rinfo.data.size());

    
    
  

    bool isatomic(false);  
    cycle *child = new restdata(this, de.file_hash(), NULL, isatomic, rinfo,
                                fileoffset(0), fileoffset(-1), NULL,
                                main->getpipe_control(0)->get_curroffset().value());
    child->noop();
    startoff += reserved_slice.size();
    nforked++;

    if (startoff >= totalsize) {
      if(deb)DB->msg("restdumpfile::init done");
      forksdone = true;
      childdone(NULL);
      return;
    }

    
    main->add_insert(TODO_FILE, this, priority_id);
}

void restdumpfile::childdone(cycle *child) {
    if(has_error())
        DB->msg("restdumpfile childdone, error=%d\n", has_error());

    if(deb)DB->msg("restdumpfile::childdone child:%p forksdone:%d ncollected:%d nforked:%d",
                   child, forksdone, ncollected, nforked);

    if (child) ncollected++;

    if (forksdone && ncollected == nforked) {
      
      if (main) main->getstatsobj(context::restorestats)->add_filecount(1);
      notifyparent();
    }
}

restdumpfile::~restdumpfile() {
}











#include "common.h"
#include "debug.h"
#include "ndmpcontrol.h"
#include "direlem.h"
#include "fileoffset.h"
#include "uapp.h"
#include "context.h"
#include <stdio.h>










































ndmpcontrol::ndmpcontrol(bool _enable) {
    enabled = false;
    prefix = "";        
    system = "";        
    outf = NULL;
    if (_enable) {
        if (uapp::fd3_was_passed()) {
            outf = fdopen(3, "w");
            enabled = (outf != NULL);
            if (!enabled) Out->msg(WARN, "<6042>Cannot enable ndmpcontrol mode, fd3 could not be opened (errno=%d)", errno);
        } else Out->msg(WARN, "<6039>Cannot enable ndmpcontrol mode, fd3 not passed");
    } 
    if(enabled) Out->msg(INFO, "<7367>Started ndmp catalog stream");
}

ndmpcontrol::~ndmpcontrol() {
    if(outf != NULL)
        fclose(outf);
}

char ndmpcontrol::getfilechar(const DIRELEM& info) {
    if (info.is_directory())   return 'd';      
    if (info.is_symlink())     return 'l';      
    if (info.is_fifo())        return 'p';      



    if (info.is_device_file()) return 'c';      
    return '-';                                 
}

void ndmpcontrol::start(int rootinode) {
    if(! enabled)
        return;


}

void ndmpcontrol::senddirelem(int dirinum, const ustring& name, int inum) {
    if(! enabled)
        return;

    
    if (name.bytelength()==1 && name=="/") {
        ustring newname;
        name.filesystem_encode(newname);
        ::fprintf(outf, "%sHD %d %s %s%d\n",
                  *prefix, dirinum, *newname, *system, inum);
    } else {
        ::fprintf(outf, "%sHD %d %s %s%d\n",
                  *prefix, dirinum, *name, *system, inum);
    }
}

void ndmpcontrol::sendinode(int inum, const DIRELEM& de, const fileoffset& offset) {
    if(! enabled)
        return;
    
    char filechar = getfilechar(de);
    int mode = de.unix_mode() & 0777;
    int uid = de.unix_uid();
    int gid = de.unix_gid();
    ustring size = " s0";  
    if(! de.is_directory())
        size = ustring(" s") + de.file_size().image();
    int mtime = de.mtime();
    ustring off = "0";   
    if(! de.is_directory())
        off = offset.image();

    ::fprintf(outf, "%sHN %d %sf%c m0%o u%d g%d%s tm%d @%s\n",
              *prefix, inum, *system, filechar, mode, uid, gid, *size, mtime, *off);
}

void ndmpcontrol::finish() {
    if(! enabled)
        return;
    
}
















#include "common.h"
#include "debug.h"
#include "isilontarpipe.h"
#include "output.h"
#include "utar_flags_enums.h"
#include "dirrec_pack.h"
#include "ndmp_volume_entification.h"
#include "restelem.h"
#include "data_regions.h"

using namespace data_regions;

#define BLOCKSIZE 512
#define MAXPREFIX 155
#define MAXNAME 100

#define dowfs ((xflag[15] & 2) == 0)
#define msg1 ((xflag[11] & 4194304) != 0)

const int ISILON_EOF_PAD_SIZE = 2 * 1024 * 1024;

isilontarpipe::isilontarpipe(fileref& data_)
    : pipe_control(data_, BLOCKSIZE, utar_flags_enums::streamformat_isilon)
{
}



bool isilontarpipe::addfile(const DIRELEM& elem,
                 const ustring& path,
                 fileref& dataslice,        
                 fileref& altdataslice,     
                 fileref& stubdataslice,    
                 fileref& gsanextentsdata,  
                 const filetype ftype,
                 const ustring& linkname,
                 const fileoffset startoff)
{
    data_regions::endoffsets_t eoff;
    dirrec_pack::regions r(&elem);

    if (!r.get(eoff)) {
        Out->msg(ERR, "Unable to find data regions dirrec for streamslice data for directory '%s' during restore",
                 *elem.fullpath().image());
        return false;
    }

    if (eoff.empty()) {
        Out->msg(ERR, "Empty data regions dirrec for streamslice data for directory '%s' during restore",
                 *elem.fullpath().image());
        return false;
    }

    
    if (elem.is_directory()) {
        fileoffset lastoffset((eoff.back()).second);
        dirrec_pack::streamslice ssp(&elem);
        ubigint64 datasize;
        unsigned char dephashoffset;
        if (!ssp.get(datasize, dephashoffset)) {
            Out->msg(ERR, "isilontarpipe::addfile found dir '%s' "
                     "with KIND_REGIONS %s, but no streamslice dirrec",
                     *elem.fullpath().image(), *image_endoffsets(eoff));
            return false;
        }

        if (lastoffset != datasize)
            Out->msg(ERR, "Found direlem '%s' with dirrecs dataregions:%s "
                     "and streamslice datasize:%"LL"u which should match but do not.",
                     *elem.fullpath().image(), *image_endoffsets(eoff), datasize);

        stubdataslice.initslice6464(data, curroffset, datasize);
        add_to_curroffset(datasize, "directory");
    }

    return true;
}


void isilontarpipe::set_data_slice(const fileref& hdrslice, const ustring& desc)
{
    if (!hdrslice.isnull()) {
        data.setslice64(curroffset, hdrslice, false);
        add_to_curroffset(hdrslice.size64(), desc);
    }
}


void isilontarpipe::init_data_slice(fileref& dataslice, const fileoffset& size, const ustring& desc)
{
    dataslice.initslice6464(data, curroffset, size);
    add_to_curroffset(size, desc);
}

void isilontarpipe::padd_end(fileoffset& size_of_stream) {
    fillblock_normal();
    fileref zero = makezeros(ISILON_EOF_PAD_SIZE);
    data.setslice64(curroffset, zero, false);
    if(msg1) DB->msg("isilontarpipe::padd_end zeros:%d curroffset:%s", zero.size(), *curroffset.image());
    add_to_curroffset(zero.size(), "padd_end");
    size_of_stream = curroffset;
}
















#include "common.h"
#include "debug.h"
#include "restcomp.h"
#include "restdata.h"
#include "layout.h"
#include "chunktype.h"
#include "compelem.h"
#include "tnodeid.h"
#include "utar_flags_info.h"
#include "restdirpart.h"
#include "chunkselector.h"
#include "restcompdata.h"
#include "utar_flags_enums.h"

#define restcomp_msg ((xflag[2]&1024)!=0)     
#define enable_consolidated_restore ((xflag[10]&262144)!=0)  
#define chgblkmsg      ((xflag[19]&4096)!=0)
#define ConsiderIsBig  ((xflag[31]&2)==0)



static safeint restcomp_cnt;
static safeint restcomp_max;



class chunkselectorbynode : public chunkselector<tnodeid, int> {
  public:
    chunkselectorbynode(context *m, chunktype ckind, const fileref& compdata, nodevector* nh)
      : chunkselector<tnodeid, int>(m->getmaxdpnmessagedatasize(dpn0), ckind, compdata),
        main(m), 
        nodehints(nh)
    {
        assert(m != NULL);
        init();
    }
  private:
    context *main;
    nodevector *nodehints;
    
    bool lookup(size_t idx, const hashcode& hash, tnodeid& nodeid, int& hintconn) {
        
        
        if (nodehints == NULL || idx >= nodehints->size() || main->restorecache_defined(hash)) {
            hintconn = -1;
            return false;
        }
        nodeid   = (*nodehints)[idx];
        hintconn = main->nodeid_to_conn(dpn0, nodeid);
        return true;
    }
};






restcomp::restcomp(cycle *parent, restelem& restinfo, fileref& srclist_, fileref& hintdata_, chunktype ckind_, 
                   bigint64 prior_, fileoffset offset_, backappend *root_file_cycle_  )
: cycle(parent), info(restinfo), srclist(srclist_), hintdata(hintdata_), ckind(ckind_), 
childcount(0), prior(prior_), root_file_cycle( root_file_cycle_ )
{
    offset = offset_;
    done = false;
    restcomp_cnt++;
    if(+restcomp_cnt > +restcomp_max) restcomp_max = restcomp_cnt;
    todoEnqueueInsert(TODO_FILE_CACHE, this, prior);
    
}












bool restcomp::isbig_composite(const chunktype ckind, fileref composite)
{
    
    
    
    if (flags.restcompdirmax) {
        
        int off = 0;
        compelem elem(ckind);
        fileoffset compsize(0);
        while(off < composite.size()) {
            elem.init(composite, off);              
    
            assert(elem.getendoff() > compsize);    
            compsize = elem.getendoff();
        }

        
        

        fileoffset threshold(0);
        if (ckind.is_dir()) {  

            
            
            
            
            
            if (flags.restcompdirchainthresh <= 0) {
                
                threshold = bigint64(flags.restcompdirmax)*(1024*1024);
            } else {
                
                threshold = bigint64(flags.restcompdirchainthresh)*(1024);
            }
        } else {
            
            threshold = bigint64(flags.restcompmax)*(1024*1024);
        }

        const bool isbig = (compsize > threshold);  
                                                    

        if (DB->messages_on && (restcomp_msg || isbig))
            DB->msg("restcomp (count=%d, max=%d): threshold=%.0f, compsize=%.0f, isbig=%d: \"%s\"(%.0f)", 
                    +restcomp_cnt, +restcomp_max, threshold.dvalue(), compsize.dvalue(), isbig, *info.path.image(), offset.dvalue());

        return isbig;
    } else {
        return false;  
    }
}

void restcomp::init() {
    
    if(srclist.isnull()) {
        info.data.free();
        restcomp_cnt--;
        notifyparent();
        return;
    }

    int size = srclist.size();
    compelem elem(ckind);

    if(xflag[1]&0x10)DB->msg("restcomp::init %s START level:%"LL"d size:%d offset:%.0f start:%.0f endbyte:%.0f checkrange:%d isdir:%d, count:%d", 
             *info.path.image(), prior, size, offset.dvalue(), info.startbyte.dvalue(), info.endbyte.dvalue(), info.checkrange, info.direlem.is_directory(), +restcomp_cnt);

    
    
    
    
    const bool isbig = isbig_composite(ckind, srclist);

    cycle *prevchild = NULL;    
    nodevector *nodehints = NULL;
    if(!hintdata.isnull()) nodehints = new nodevector(hintdata);       
    
    
    bool can_consolidate = enable_consolidated_restore 
                           && !ckind.is_dir()
                           && nodehints != NULL 
                           && nodehints->size() > 0
                           && !flags.incremental      
                           && main->getdpnmaxmessage(dpn0) >= GETCOMPDATA;
    
    
    if (can_consolidate) {
        int compoffs = 0;
        elem.init(srclist, compoffs);
        can_consolidate = elem.getisatom();
    }
    
    if (can_consolidate && !root_file_cycle) {  
    
        
        
        
        
        
        
        
        
        chunkselectorbynode chunker(main, ckind, srclist, nodehints);
        
        
        
        
        
        
        chunker.partition(sizeof(univuns)+4, false);
        
        size_t cidx = 0;
        const chunkselectorbynode::descriptor* desc;
        compelem elem(chunktype::recipe4);    
        fileoffset compoffs(0);
        
        while ((desc = chunker.getdesc(cidx++)) != NULL) {
    
            cycle *child = NULL;
            
            const chunkselectorbynode::descriptor* base = desc;
            const int hintconn = base->getarg();
            fileoffset endoffs(base->size());
             
            if (desc->ismarked()) {
                
                
                fileref newcomp;
                newcomp.initlist((int)((chunker.numdescriptors()-cidx+1)*(sizeof(hash)+elem.getsize())));
                
                elem.sethash(base->gethash());
                elem.setendoff(endoffs, true);
                newcomp.append(elem.getdata());
                
                
                int numelems = 1;
                while ((desc = chunker.getdesc(cidx)) != NULL && 
                       desc->ismarked() && 
                       desc->iscontinuation()) {
                    assert(base->getwhere() == desc->getwhere());
                    
                    elem.sethash(desc->gethash());
                    endoffs += desc->size();
                    elem.setendoff(endoffs, true);
                    newcomp.append(elem.getdata());
                    
                    ++cidx;
                    ++numelems;
                }
                
                if (numelems > 1) {
                    childcount++;
                    child = new restcompdata(this, info, newcomp, offset + compoffs, 
                                             chunktype::recipe4,
                                             prevchild, prior + compoffs.value(), hintconn, root_file_cycle);
                    compoffs += endoffs;
                }
            }
            
            if (child == NULL) {
                
                childcount++;
                child = new restdata(this, base->gethash(), NULL, true, info, offset+compoffs,
                                        base->size(), prevchild, prior + compoffs.value(), 
                                        fileref(), hintconn, root_file_cycle );
                compoffs += base->size();
            }
            
            child->noop();
            
            if(isbig) prevchild = child;
            
            
            if( info.data.iserror(filebase::ERRCODE_ERR) ) {
                
                
                break; 
            }
        }
        delete nodehints;
        done = true;
        if (info.checkrange && childcount == 0) { childcount++; this->childdone(NULL); }
        return;
    }

    int off = 0;                
    fileoffset curroff(0);      
    unsigned int idx = 0;       
    while(off < size) {
        elem.init(srclist, off);  
        fileoffset nextoff(elem.getendoff());
        const int hintconn = (nodehints == NULL || (unsigned)idx >= nodehints->size()) ? -1 : main->nodeid_to_conn(dpn0, (*nodehints)[idx]);

        if(restcomp_msg)
            DB->msg("restcomp::init %s offs %3d: %6.0f .. %6.0f childcount:%2d, idx:%2d of %2d, hint:%2d", 
                     *info.path.image(), off, curroff.dvalue(), nextoff.dvalue(), childcount, idx, (int)(nodehints==NULL?0:nodehints->size()), hintconn);

        if (info.checkrange && !info.direlem.is_directory()) {
            
          
            
            bool docache=false;
            if(! docache) {
                if (info.startbyte > offset+nextoff-1) {
                  
                  curroff = nextoff;
                  continue;
                }
                if (info.endbyte < offset+curroff) {
                  
                  curroff = nextoff;
                  continue;
                }
            }
        }
        

        fileoffset compsize(nextoff - curroff);
        cycle *child = NULL;
        

        
        
        
        
        
        
        if(ckind.is_dir() && info.data.isnull() && (!ConsiderIsBig || !isbig)) {
            if(restcomp_msg)DB->msg("restcomp::init checking restdirpart ckind:%s isbig:%d offset:%d", *ckind.image(), isbig, compsize.ivalue());
            childcount++;
            child = new restdirpart(this, location(location::media::gsan, elem.gethash()), info, prevchild, compsize.ivalue());
        } else {
            const bool isatom = elem.getisatom(); 

            bool do_restdata = true;
            if( root_file_cycle ) {
                
                
                
                
                
                do_restdata = false;
                fileoffset startoff = offset+curroff;
                fileoffset endoff   = offset+curroff+compsize;

                
                if( (info.startbyte >= startoff) &&
                    (info.startbyte <= endoff ) ) {
                    do_restdata = true;
                    if( chgblkmsg ) DB->msg( "CHGBLK restoring pre composite %s..%s", *startoff.image(), *endoff.image() );
                }

                
                if( (info.endbyte >= offset+curroff) &&
                    (info.endbyte <= offset+curroff+compsize )) {
                    do_restdata = true; 
                    if( chgblkmsg ) DB->msg( "CHGBLK restoring post composite %s..%s", *startoff.image(), *endoff.image() );
                }

                if( chgblkmsg && !do_restdata) {
                    DB->msg( "CHGBLK not restoring composite %s..%s", *startoff.image(), *endoff.image() );
                }

            }
            if( do_restdata ) {
                childcount++;
                child = new restdata(this, elem.gethash(), NULL, isatom, info,
                                     offset + curroff,
                                     compsize, prevchild, prior + curroff.value(), fileref(),
                                     hintconn, root_file_cycle );
                child->noop();
            }
        }

        if(isbig) prevchild = child;    
        
        
        
        
        

        curroff = nextoff;
        
        if( info.data.iserror(filebase::ERRCODE_ERR) ) {
            
            
            break; 
        }
        idx++;
    }
    delete nodehints;
    done = true;
    if (info.checkrange && childcount == 0) { childcount++; this->childdone(NULL); }
}

void restcomp::childdone(cycle *child) {
    childcount--;
    if(done && childcount == 0) {
        info.data.free();
        
        restcomp_cnt--;
        notifyparent();
    }
}

restcomp::~restcomp() {
}

#if !defined(NBACKROOT_H_INCLUDED)
#define NBACKROOT_H_INCLUDED















#include "hashcode.h"
#include "cycle.h"
#include "threadbase.h"
#include "vector.h"
#include "ade_multivolume.h"
#include "exportstream_xml.h"
#include "persistentlock.h"
#include "backupboost_interface.h"
#include "direlem.h"

class nbackdir_manual_unc;
class nbackdir;
class workelem;
class context;
class backaxionfs;
class statlist;
class mulqueue;
class ADEMgrX;
class exportstream_xmlp;


#define WORK_DIR 0
#define WORK_FILE 1
#define WORK_CHUNK 2
#define WORK_STATS 3
#define WORK_COUNT 4



class PathToNBackDirMapType;

class nbackroot : public multivolumeroot, public BackCycle
{
public:
    nbackroot(context *main, mulqueue& todoQueue, workelem *info);
    virtual ~nbackroot();
    SAFEALLOC(nbackroot);
    
    virtual void init();
    virtual void response(message& outargs);
    
    virtual void notifyparent();
    
    virtual void childdone(cycle *child);

    void set_backaxionfs_work(backaxionfs *ba);
    
    

    
    void set_ucontainer_finalized() {
        ucontainer_finalized = true;
    }

private:
    nbackdir *save_rootpath( nbackdir *parent, const upath& fullpath, fileoffset& offset, bool is_mapi, bool use_container );

    backaxionfs *backaxionfsp; 
    ustring *overrideacntpath; 
    
    bool find_prev_backup(BackupRootInfo& prevBackup, location::tbackupid &backupid);

    
    
    bool populate_previous_ndmp_location(const BackupRootInfo &prev_backup, const location::tbackupid &backupid);

    
    void DoISAPIBackup(void);
    void DoMakeview(void);
    void DoSnapTypeDump(void);
    void DoStreamBackup(void);
#if !SYSTEM_WINDOWS
    void DoAxionfsBackup(void);
#endif
    void DoFileSysRootBackupNonADE_SKIPSLASH(void);
    void DoFileSysBackupADE(void);
    void DoFileSysBackupNonADE(void);
    void DoTargetDrivenFileSysBackup_NonADE(const stringlist& listOfTargets);
    bool DoBackupDirBackup(void);
    void DoBackupBoostBackup(void);
    void DoBackupBoostConvert(void);

    nbackdir_manual_unc *create_nbackdirChain(nbackdir_manual_unc * const topLevelNBackDir, const upath& fullpath, fileoffset& nextOffset,
                            bool is_mapi, PathToNBackDirMapType& previouslyCreatedCycles, upath& parentPath, bool useContainer);

    
    
    bool useTargetDrivenBackup() const;

    
    
    

    
    
    

    
    void get_label(rhlLabel &label) const;

    
    const int get_status(const int status) const;

    
    const fileoffset get_totalsize( backstats *statsp) const;

    
    void get_roothashflags(roothashflags& rflags) const;

    
    void get_snapup_timestamp(ubigint64& timestamp) const;

    
    bool get_expires_time(ubigint64& expirestime) const;

    
    
    exportstream_xmlp exportstream_infop;

    
    bool               m_copying_backup;
    bool               m_prev_acct_info_valid;
    roothashlistrec    m_prev_roothashlistrec;

    
    
    
    bool               destroy_workelem;

    
    bool               ucontainer_finalized;

    

    
    
    bool init_partial();

    
    DIRELEMp prevrootde;        
    DIRELEMp currrootde;        

    workelem *merged_info;      

    
    bool partial_was_internal;

    
    bool partial_nohiddendir;

    
    bool partial_hiddendone;

    
    bool DoPartialMerge(cycle *child, bool final);

    
    persistentlock* partial_lockp;

    
    BackupRootInfoList backup_list;

    
    enum backupboost_convert_phase {
        phase_filesys_backup,
        phase_filesys_begin_full,
        phase_filesys_backup_ro,
        phase_filesys_end_full,
        phase_metadata_convert,
        phase_convert_done
    };

    

    
    backupboost_convert_phase bb_convert_phase;

    
    
    backupboost::backupboost_interface::lfs_handle token;

    
    
    ubigint64 bb_session_id;

    
    stringlist bb_new_add_ignore_error;

    
    
    bool write_ddr_file;

    
    upath target_path;

}; 

#endif

















#include "common.h"
#include "debug.h"
#include "output.h"

#include "avpaxpipe.h"
#include "pax_container.h"
#include "cdsf_container.h"
#include "ucontainer_base.h"
#include "xdrclass.h"   

#include "filenames.h"
#include "utar_flags_enums.h"


#define deb   ((xflag[11]&2048)!=0)

avpaxpipe::avpaxpipe(fileref data, const int streamformat, const ustring& stream_filename, const unsigned long flags_,
                     const int ddrhandle, const ustring clientid, const location::tbackupid backupid,
                     fileref ddrwrite,
                     const int restorebufmb
)
    : tarpipe(data, 0, 0, "", utar_flags_enums::streamformat_avpax, pax_container::pax_stream_blocksize),
      has_error(false), pcp(0), saved_datasize(0), saved_metasize(0),
      need_begindircontent(false),
      just_processed_out_of_stream_object(false),
      is_streamformat_cdsf(streamformat == utar_flags_enums::streamformat_cdsf),
      is_media_out_ddr(!ddrwrite.isnull()),
      outofstream_patterns(true)
{
    if(is_streamformat_cdsf) {
        
        if(ddrwrite.base()) {
            pcp = new cdsf_container(data, flags_, location::media::pipe, 0);
            if(pcp) {
                
                (void)pcp->set_ddrhandle(ddrhandle);
                (void)pcp->set_clientid(clientid);
                (void)pcp->set_previous_backupid(backupid);

                
                pcp->transport = ddrwrite;
            }
        } else {
            if(!stream_filename.isempty()) {
                pcp = new cdsf_container(stream_filename, flags_, location::media::pipe, 0);
            } else {
                pcp = new cdsf_container(data, flags_, location::media::pipe, 0);
            }
        }
    } else {
        pcp = new pax_container(stream_filename, flags_, location::media::pipe, 0, restorebufmb);
    }

    has_error = (pcp == 0);

    if(deb) DB->msg("avpaxpipe::avpaxpipe() pcp:%p", pcp);
}


avpaxpipe::~avpaxpipe()
{
    delete pcp;
}



bool avpaxpipe::init_fileref(const ustring& streamdesc, const int buffermb, const int stream_timeoutsecs, const bool closefilewhendone)
{
    
    return true;
}




bool avpaxpipe::addfile(const DIRELEM& elem,
                      const ustring& path,
                      fileref& dataslice,
                      fileref& altdataslice,   
                      fileref& stubdataslice,  
                      fileref& gsanextentsdata,
                      const filetype ftype ,
                      const ustring& linkname ,
                      const fileoffset startoff 
                      )
{
    bool ret(false);

    const fileoffset datasize(ftype == pipe_control::DIRTYPE ? 0 : elem.file_size());
    if(addobj(ftype, path, elem, datasize, dataslice)) {
        ret = true;
    }

    if(deb) DB->msg(DBTXT("avpaxpipe::addfile(%p) adding obj '%s' size %s ret %d"), this, *path, *datasize.image(), ret);

    return ret;
}




bool avpaxpipe::output_avamar_archive_info(const xml_messagep xmlp)
{
    bool ret(false);

    if(deb) DB->msg(DBTXT("avpaxpipe::output_avamar_archive_info()"));

    if(!xmlp.isnull()) {
        const fileref xmldata(xmlp->fimage());

        DIRELEM de;
        de.set_name(xmlp->getcommand());  
        de.set_unix_attributes(0700, 0, 0);
        de.set_internal();
        de.set_mtime(prectime(prectime::now()).toUnixTime());
        de.set_file_size(xmldata.size64());

        fileref dataspace;
        if(addobj(pipe_control::BACKUPEXPORT_METAINFOTYPE, de.name(), de, xmldata.size64(), dataspace)) {
            
            dataspace.setslice64(0, xmldata, true);
            if(!finobj(pipe_control::BACKUPEXPORT_METAINFOTYPE, de.name(), de)) {
                Out->msg(WARN, "<12473>Unable to finish file '%s' into archive", *de.name());
            } else {
                ret = true;
            }
        } else {
            Out->msg(WARN, "<12474>Unable to place file '%s' into archive", *de.name());
        }
    }

    return ret;
}


udirelemp avpaxpipe::convertde(const DIRELEM& elem, const bool isroot ) const
{
    DIRELEMp dep(new DIRELEM(elem));

    
    
    if(isroot) {
        
        dep->set_name(ucontainer::base::rootelem_name);
    }

    
    return new udirelem(dep);
}

DIRELEMp avpaxpipe::noconvertde(const DIRELEM& elem, const bool isroot ) const
{
    DIRELEMp dep(new DIRELEM(elem));

    
    
    if(isroot) {
        
        dep->set_name(ucontainer::base::rootelem_name);
    }

    
    return dep;
}


udirelemp avpaxpipe::convertde_dephash(const DIRELEM& elem, const udirelem::meta meta) const
{
    
    DIRELEMp dep(new DIRELEM(elem));

    
    dep->set_name(meta.image());

    
    return new udirelem(dep);
}

DIRELEMp avpaxpipe::noconvertde_dephash(const DIRELEM& elem, const udirelem::meta meta) const
{
    
    DIRELEMp dep(new DIRELEM(elem));

    
    dep->set_name(meta.image());

    
    return dep;
}











static const ucontainer::errortype check_pc_error(const ucontainer::errortype et, bool& haserror)
{
    if(et != ucontainer::pce__success) {
        
        if(!haserror) {
            Out->msg(ERR, "<12475>Stream generator indicated %s", *ucontainer::error_description(et));
        }
        haserror = true;
    }

    return et;
}








bool avpaxpipe::addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                       const fileoffset datasize, fileref& dataslice)
{
    bool ret(false);

    if(deb) DB->msg(DBTXT("avpaxpipe::addobj(%p) pcp:%p type: %d, path:'%s' name:%s size %"LL"d"),
                    this, pcp, otype, *path, *elem.name(), datasize.value());

    if(pcp) {
        const bool ismeta(otype == pipe_control::BACKUPEXPORT_METAINFOTYPE ||
                          ((otype >= pipe_control::DEPHASHTYPE_FIRST) && (otype <= DEPHASHTYPE_LAST)));

        ucontainer::errortype et(ucontainer::pce__unknown);

        
        if(need_begindircontent && !ismeta) {
            
            et = check_pc_error(pcp->begindircontent(noconvertde(dir_direlem, elem.fullpath().isroot()).getimpl()),
                                has_error);
            need_begindircontent = false;
        } else {
        }

        if(otype == pipe_control::DIRTYPE) {

            
            et = check_pc_error(pcp->begindir(noconvertde(elem, elem.fullpath().isroot()).getimpl()),
                                has_error);

            
            if(is_streamformat_cdsf) {
                dir_direlem = elem;
                need_begindircontent = true;
            }

        } else if(ismeta) {
            if(deb) DB->msg(DBTXT("avpaxpipe::addobj() beginmeta call with otype:%d size:%s path:%s name:%s"),
                            otype, *datasize.image(), *elem.fullpath().image(), *elem.name());

            
            const udirelem::meta meta(otype == BACKUPEXPORT_METAINFOTYPE ?
                                         udirelem::meta(udirelem::meta::pmt_backupexport_metainfo) :
                                         udirelem::meta(udirelem::meta::pmt_dephash, otype - pipe_control::DEPHASHTYPE_FIRST));
            
            const DIRELEMp pdep(noconvertde_dephash(elem, meta));

            
            if(!is_streamformat_cdsf || otype != BACKUPEXPORT_METAINFOTYPE) {
                
                et = check_pc_error(pcp->beginmeta(pdep.getimpl(), datasize, meta),
                                    has_error);
            } else {
                
                et = check_pc_error(pcp->beginfile(pdep.getimpl(), datasize),
                                    has_error);
            }

            
            saved_metasize = datasize;
            saved_metaname = pdep->name();

            et = check_pc_error(pcp->reservedata(datasize, dataslice),
                                has_error);

        } else {
            if(deb) DB->msg(DBTXT("avpaxpipe::addobj() beginfile call with size %s"), *datasize.image());

            if(outofstream_patterns.match(elem.fullpath())) {
                
                et = check_pc_error(pcp->beginfile_xcontents(noconvertde(elem).getimpl()), has_error);

                
                dataslice = fileref();

                
                out_of_stream_list.push_back(new DIRELEM(elem));

                
                just_processed_out_of_stream_object = true;
            } else {

                
                et = check_pc_error(pcp->beginfile(noconvertde(elem).getimpl(), datasize),
                                    has_error);

                
                saved_datasize = datasize;

                
                const location loc(elem.get_location());

                
                
                if(is_media_out_ddr && (loc.getMedia() == location::media::ddr)) {
                    et = check_pc_error(pcp->synthdata(loc), has_error);
                    
                    
                    dataslice = fileref();
                } else {
                    
                    et = check_pc_error(pcp->reservedata(datasize, dataslice),
                                        has_error);
                }
            }
        }

        ret = !has_error;
    }

    return ret;
}




bool avpaxpipe::finobj(const filetype otype, const ustring& path, const DIRELEM& elem)
{
    bool ret(false);

    if(deb) DB->msg(DBTXT("avpaxpipe::finobj() pcp:%p name:'%s' path:'%s'"),
                    pcp, *elem.name(), *path);

    if(pcp && !path.isempty()) {
        const bool ismeta(otype == pipe_control::BACKUPEXPORT_METAINFOTYPE ||
                          ((otype >= pipe_control::DEPHASHTYPE_FIRST) && (otype <= DEPHASHTYPE_LAST)));

        ucontainer::errortype et(ucontainer::pce__unknown);

        
        if(!ismeta && need_begindircontent) {
            assert(otype == pipe_control::DIRTYPE);

            
            et = check_pc_error(pcp->begindircontent(noconvertde(elem, elem.fullpath().isroot()).getimpl()),
                                has_error);

            
            need_begindircontent = false;
        }

        if(otype == pipe_control::DIRTYPE) {

            
            et = check_pc_error(pcp->enddir(noconvertde(elem, elem.fullpath().isroot()).getimpl()),
                                has_error);

        } else if(ismeta) {

            
            const udirelem::meta meta(otype == BACKUPEXPORT_METAINFOTYPE ?
                                         udirelem::meta(udirelem::meta::pmt_backupexport_metainfo) :
                                         udirelem::meta(udirelem::meta::pmt_dephash, otype - pipe_control::DEPHASHTYPE_FIRST));
            
            DIRELEMp pdep(noconvertde_dephash(elem, meta));

            if(deb) DB->msg(DBTXT("avpaxpipe::finobj() endmeta call with size %s"), *saved_metasize.image());

            
            if(!is_streamformat_cdsf || otype != BACKUPEXPORT_METAINFOTYPE) {
                
                et = check_pc_error(pcp->endmeta(pdep.getimpl(), saved_metasize, meta),
                                    has_error);
            } else {
                et = check_pc_error(pcp->endfile(pdep.getimpl(), saved_metasize),
                                    has_error);
            }

            saved_metasize = 0;
        } else {

            if(deb) DB->msg(DBTXT("avpaxpipe::finobj() endfile call with size %s"), *saved_datasize.image());

            if(just_processed_out_of_stream_object) {
                just_processed_out_of_stream_object = false;
            }

            
            et = check_pc_error(pcp->endfile(noconvertde(elem).getimpl(), saved_datasize),
                                has_error);

            saved_datasize = 0;
        }

        if(deb) DB->msg(DBTXT("avpaxpipe::finobj() end* returned %d"), et);

        ret = !has_error;
    }

    return ret;
}


fileoffset avpaxpipe::reserved_bytes_pending()
{
    return pcp ? pcp->reserved_bytes_pending() : 0;
}



bool avpaxpipe::iserror()
{
    return has_error;
}



void avpaxpipe::padd_end(fileoffset& size_of_stream)
{
    if(ucontainer::base *tmp = pcp) {
        size_of_stream = pcp->get_curroffset() + (is_streamformat_cdsf ? xdrclass::xdralign : 0);
        pcp = 0;
        delete tmp;
    } else {
        size_of_stream = fileoffset::unknown;
    }
}





void avpaxpipe::match_content_out_of_stream(const ustring& pattern)
{
    outofstream_patterns.enter_single(pattern, exclude::user);
}




direlemp_list_type avpaxpipe::retrieve_all_content_out_of_stream() const
{
    return out_of_stream_list;
}

#if !defined(BACKSTATE_H_INCLUDED)
#define BACKSTATE_H_INCLUDED












#include "assoc.h"
#include "hard_link_id.h"
#include "file_system_info.h"
#include "exclude.h"
#include "include.h" 
#include "ustring.h"
#include "mctypes.h"
#include "ade/cache.h"

class context;
class utar_flags_info;



enum snapkind {  
  FILESYSTEM,
  MAPI,
  RMAN,
  EXCHANGE_DB,
  DUMP,            
  AXIONFS,         
  STREAM,           
  VSS
};

class hash_cache;
class filename_cache;

class backstate {
public:
    backstate(stringlist args, bool validate_includes, const int grouptype, bool warn_on_missing_target=false, const stringlist *pathmap=NULL, bool fakeprogress=false); 

    bool is_valid() { return valid; }

    int numthreads;
    int hfs_send_depth;
    tsessionid sessionid;

    include targets; 
    exclude excludes;
    exclude includes; 
    exclude cache_excludes; 
    exclude ddr_blocks;     

    exclude stream_out_excludes; 

    hash_cache *hashes;
    filename_cache *fcache;

    hard_link_to_hash_t hard_link_to_hash;  
    file_system_info fsinfo;

    snapkind snaptype;  

    pidtype pid_of_backup;  

    bool needs_direlem_init;  
    SAFEPOOLALLOC(backstate);

#if SYSTEM_WINDOWS
    typedef long (CALLBACK *GetLongPathNamefp)(const WCHAR*, WCHAR*, long);

    static void GatherRegKeyValues(const GetLongPathNamefp getlongpathnamefp, const ustring& value_name, const TCHAR *value, DWORD value_size, exclude *excludes, int& added_count, const stringlist& targets);
#endif

    exitcodes_t  enter_targets_exclude_include_lists(utar_flags_info& flags, bool ignoredefaultexcludes);
    exitcodes_t  enter_exclude_include_lists(utar_flags_info& flags, bool ignoredefaultexcludes, bool isbackup=true);

 private:
    bool valid;

    bool enter_default_excludes(utar_flags_info& flags);
    bool check_valid_path(const stringlist list, const ustring actual_path);
    static stringlist expand_paths(const stringlist &paths);
    static stringlist replace_vars(const stringlist &paths);
#if SYSTEM_WINDOWS
    void enter_registry_excludes(HKEY hkey, const ustring& keytext);
    int enter_vhd_excludes(utar_flags_info& flags);
#endif
};

#endif

#if !defined(HEXHASH_H_INCLUDED)
#define HEXHASH_H_INCLUDED












#include "hashcode.h"


class hexhash {
public:
    hexhash();
    hexhash(const hashcode& hash);
    void set(const hashcode& hash);
    char *operator &();
private:
    char image[sizeof(hashcode) * 2 + 1];
    NOCOPY(hexhash);
};

#endif


















#include "common.h"
#include "debug.h"
#include "restore_prefetchthread.h"
#include "context.h"
#include "filemem.h"
#include "dpnobject.h"
#include "restore_prefetchmanager.h"




ustring 
tprefetchwork::image() const
{
    return ustring::sprintf(" (resultcode %d, h: %s, soff: %s, eoff: %s, nexttofill: %s) ", 
                            resultcode, *h.image(), *startoff.image(), *endoff.image(), 
                            *nexttofill.image()); 
}


ustring 
tprefetchwork::ntfdump() const
{
    fileoffset ntfoff = nexttofill - startoff;
    int ioff = ntfoff.ivalue();

    return ustring::sprintf("%0x%0x %0x%0x", 
                            (unsigned int) result[ioff], 
                            (unsigned int) result[ioff + 1], 
                            (unsigned int) result[ioff + 2], 
                            (unsigned int) result[ioff + 3]);
}


bool 
tprefetchwork::isapplicable(const tprefetchblock &pb) const
{
    
    

    if (isfull())
        return false;

    return ((pb.h == h) &&
            (pb.startoff <= nexttofill) &&
            (pb.endoff > nexttofill)); 
}





tprefetchblock::tprefetchblock() 
{
    
    
    
}


tprefetchblock::tprefetchblock(bool initmem) 
{
    if (initmem)
        result.initmem(63*1024);
    
    
}


ustring 
tprefetchblock::image() const
{
    
    

    return ustring::sprintf(" (h: %s, soff: %s, eoff: %s, %s) ", 
                            *h.image(), *startoff.image(), *endoff.image(),
                            *result.image()); 
    
}





restore_prefetchcache::restore_prefetchcache(context *main_, 
                                             size_t blockcount,
                                             size_t blocksize,
                                             bool debugmsgs) 
    : main(main_), ringbuf(blockcount),
      ringblocksize(blocksize), cm(NULL)
{
    cm = new depthfirst_prefetchmanager(blocksize);
}


void
restore_prefetchcache::fill(tprefetchwork &work)
{
    static long hits = 0;
    static long misses = 0;
    static long calls = 0;

    if (calls % 500 == 1) {
        DB->msg ("restore_prefetchcache::fill call %ld has %ld/%ld hits/misses (%f %%)",
                 calls, hits, misses, (double) hits / (double) misses);
    }
    calls++;

    
    
    if (work.result.isnull()) {
        fileoffset worksize = work.endoff - work.startoff;
        work.result.initmem(worksize.ivalue() + 1);
        
    }

    
    tprefetchblock cb;

    
    

    bool foundcb = ringbuf.read(cb);
    
    
    
    
    while (foundcb && !work.isfull() && work.isapplicable(cb)) {
        
        
        
        hits++;

        bool blockdone = apply(cb, work);
        if (blockdone) {
            ringbuf.erase();
        } else {
            
            break;
        }

        foundcb = ringbuf.read(cb);
        
        
        
        
    } 

    if (!work.isfull()) {
        
        
        misses++;
        fileref workslice = work.result.makeslice64(work.nexttofill - work.startoff,
                                                    work.endoff - work.nexttofill + 1);
        chunktype ctype;
        work.resultcode = main->restore_gsanonly_file(workslice, work.h, &ctype,
                                                      fileoffset(0), 
                                                      work.nexttofill, work.endoff);
        work.isdir = ctype.is_dir();
        if (work.resultcode)
            work.setfull();

        
        if (!cm->reset(work))
            ringbuf.erase();
    } else {
        work.resultcode = true;
    }

    
    
}


bool
restore_prefetchcache::apply(const tprefetchblock &block,
                             tprefetchwork &work) const
{
    if (!work.isapplicable(block)) 
        return false;

    
    

    
    fileoffset slicesize;
    slicesize = (std::min<fileoffset>(block.endoff, work.endoff) - 
        std::max<fileoffset>(block.startoff, work.nexttofill)) + 1;

    fileoffset blockoff = work.nexttofill - block.startoff;

    fileref sslice;
    
    
    sslice = block.result.makeslice64(blockoff, slicesize);

    work.result.setslice64(work.nexttofill - work.startoff,
                           sslice);

    

    work.nexttofill = std::min<fileoffset>(block.endoff, work.endoff) + 1;
    bool blockdone = (block.endoff > work.endoff) ? false : true;

    return blockdone;
}


void restore_prefetchcache::prefetch(const undoo::queue &workqueue)
{
    while (!cm->isdone() && !ringbuf.isfull() && (workqueue.length() == 0)) {
        
        ringbuffer_writescope<tprefetchblock> rbws(ringbuf);
        tprefetchblock *nb = rbws.getwriteable(); 
        if (NULL == nb) 
            break;

        if (!cm->fill(*nb))
            break;

        bool result = main->restore_gsanonly_file(nb->result, nb->h, NULL,
                                                  fileoffset(0), 
                                                  nb->startoff, nb->endoff);

        if (!result) {
            DB->msg ("restore_prefetchcache::prefetched, restore_file returned false for %s",
                     *nb->image());
            break;
        } else {
            
        }

        if (!cm->advance()) {
            DB->msg("cm advance returned false, we shouldn't attempt to prefetch any more!");
            break;
        }

        
        
    }

    
    
}






void
restore_prefetchthread::terminate()
{
    termsem.signal();
    worksem.signal();
}


void
restore_prefetchthread::body() {
    while(termsem.wait(1)) {
        
        
        worksem.wait();

        tprefetchwork *work;
        work = dynamic_cast<tprefetchwork *>(workqueue.dequeue());
        if (NULL == work) 
            break;

        
        cache.fill(*work);

        
        resultsem.signal();

        
        cache.prefetch(workqueue);
    }
}


bool
restore_prefetchthread::read(fileref &data, const hashcode &h, bool &isdir,
                             fileoffset sizehint, 
                             fileoffset startoff, fileoffset endoff)
{
    
    
    

    
    

    tprefetchwork work(data, h, isdir, startoff, endoff);
    workqueue.enqueue(&work);
    worksem.signal();

    

    resultsem.wait();

    
    

    return work.resultcode;
}


void 
restore_prefetchthread::hint(const dpnobj *obj)
{
    if (cache.cm)
        cache.cm->hint(obj);
}






















#include "common.h"
#include "debug.h"
#include "replcomp.h"
#include "repldata.h"
#include "compelem.h"
#include "chunktype.h"
#include "runstage.h"
#include "workelem.h"
#include "utar_commands.h"

#define replcomp_msg ((xflag[19]&8)!=0)

replcomp::replcomp(replcycle *parent, hashcode& myhash_, fileref& listing_,
                   const bool can_cancel_, const chunktype ctype_,
                   const ustring& name_, const epoch_t filetime_, const int traverse_depth_,
                   workelem* info_, const bool search_sysinfo_)
  : replcycle(parent, NULL, info_),
    myhash(myhash_),                    
    listing(listing_),                  
    nextoffnew(0),
    can_cancel(can_cancel_),            
    ctype(ctype_),                      
    name(name_),                        
    filetime(filetime_),                
    traverse_depth(traverse_depth_),    

    childcount(0),
    modified_data(false),
    computedoff(0),
    computed_lastoff(0),
    spawn_sysinfo(false),
    search_sysinfo(search_sysinfo_)
{
    listingnew.initlist(listing.size());
    
    
    
    
    const todo_kind priority = ctype.is_dir()? TODO_DIR : TODO_FILE;
    if(xflag[19]&8 && (priority == TODO_DIR)) DB->msg(DBTXT("replcomp - The composit type is dir,  name  = \"%s\"."), *name);
    main->add_insert(priority, this, -traverse_depth);  

}

void replcomp::init() {
    int size = listing.size();

    
    
    assert(!info->rechunk || ctype.is_dir() || (flags.destination_data != client_config_flags::same_destination));

    compelem elem(ctype);

    childcount++;
    int nextoff = computedoff;       
    int curroff = computedoff;       
    fileoffset lastoff(computed_lastoff);
    cycle* prevcycle = NULL;

    while(nextoff < size) {
        curroff = nextoff;
        elem.init(listing, nextoff);    

        
        if((!search_sysinfo) && (curroff == utar_commands::sysinfo_off) && (flags.pluginid.kind() == pidtype::migrate) && (traverse_depth == 0)) {
            utar_commands::sysinfo_chunksize = elem.getendoff().dvalue() - lastoff.dvalue();
            lastoff = elem.getendoff();
            spawn_sysinfo = true;
            DB->msg(" replcomp::init will process .system_info at last, curroff=%d, chunksize=%d", curroff, (int)utar_commands::sysinfo_chunksize);
            continue;
        }

        if(elem.gethash()!= hashcode::empty) {    
            
            
            
            childcount++;
            chunktype etype;
            if(ctype.is_dir())
                etype = chunktype::atomicdir;
            else if(elem.getisatom())
                etype = chunktype::atomic;
            else
                etype = chunktype::recipe8;
            double chunksize = elem.getendoff().dvalue() - lastoff.dvalue();

            if(replcomp_msg)DB->msg("replcomp::init() etype: %s, traverse_depth+1 = %d, max atomic depth = %d, chunksize = %d, nextoff = %d "
                                     "curroff = %d, comp hash = %s, search_sysinfo = %d",
                                    *etype.image(), traverse_depth+1, getAtomicDepth(), (int)chunksize, nextoff, curroff, *elem.gethash().partialimage(), search_sysinfo);
            cycle *child;
            if(flags.reportonly && !etype.is_dir_atomic() && ((xflag[19]&32768)==0))  
                child = new replreportdata(this, elem.gethash(), curroff, can_cancel, chunksize, name, etype, filetime, traverse_depth+1, info);
            else {
                if (!flags.migrate_err_inject) {
                    
                    if(flags.pluginid.kind() == pidtype::migrate) {
                        if(traverse_depth == 0) {
                            if(replcomp_msg)DB->msg("replcomp::init() traverse_depth==0, not increase");
                            child = new repldata(this, elem.gethash(), curroff, can_cancel, chunksize, name, etype, filetime, traverse_depth, info, prevcycle, false, search_sysinfo);
                        }
                        else {
                            child = new repldata(this, elem.gethash(), curroff, can_cancel, chunksize, name, etype, filetime, traverse_depth+1, info, prevcycle);
                        }
                    }
                    else {
                        child = new repldata(this, elem.gethash(), curroff, can_cancel, chunksize, name, etype, filetime, traverse_depth+1, info, prevcycle);
                    }
                 }
                 else {
                     
                     child = new repldata(this, elem.gethash(), curroff, can_cancel, chunksize, name, etype, filetime, traverse_depth+1, info, prevcycle);
                 }
                 if(info->rechunk)
                     prevcycle = child;
            }
            child->noop();
        }
        lastoff = elem.getendoff();
        if(flags.reportonly && count_atomic_depth && (xflag[19]&32768)) {  
            computedoff = nextoff;                    
            computed_lastoff = lastoff;               
            nextoff = size;                           
            if(replcomp_msg)DB->msg("replcomp::init() traverse_depth = %d, max atomic depth = %d", traverse_depth, getAtomicDepth());  
        }
    }
    childdone(NULL);
}

void replcomp::childdone(cycle *child) {
    bool write_in_sysinfo_dir = migration_sysinfo_write && *migration_sysinfo_write;
    if( (info->rechunk || write_in_sysinfo_dir || can_cancel) && child != NULL ) {
        if(flags.destination_data == client_config_flags::same_destination || !info->rechunk || write_in_sysinfo_dir) {
            
            
            
            
            
            
            hashcode h;
            listing.getslice64(child->offset, sizeof(hashcode), &h);
            if(child->hash != h) {
                if(replcomp_msg) {
                    if(write_in_sysinfo_dir || info->rechunk)
                        DB->msg("replcomp::childdone: orighash %s != new hash %s due to child hashcode changed", *h.image(), *child->hash.image());
                    else
                        DB->msg("replcomp: CANCEL child: orighash %s != new hash %s", *h.image(), *child->hash.image());
                }
                listing.setslice64(child->offset, sizeof(hashcode), &child->hash);
                modified_data = true;
            }
        } else {  
            compelem elemnew(chunktype::recipe8);  
            if(replcomp_msg) DB->msg("replcomp::childdone(): new hash %s, new size = %d", *child->hash.partialimage(), child->size.ivalue());
            elemnew.sethash(child->hash);
            nextoffnew += child->size.ivalue();
            elemnew.setendoff(nextoffnew, false);
            listingnew.append(elemnew.getdata());
        }
    }

    if( --childcount == 0) {

        
        if(spawn_sysinfo && (flags.pluginid.kind() == pidtype::migrate) && (traverse_depth == 0)) {
            
            spawn_sysinfo=false;

            compelem elem(ctype);
            elem.init(listing, utar_commands::sysinfo_off);    
            if(elem.gethash()!= hashcode::empty) {    
                
                
                
                childcount++;
                chunktype etype;
                if(ctype.is_dir())
                    etype = chunktype::atomicdir;
                else if(elem.getisatom())
                    etype = chunktype::atomic;
                else
                    etype = chunktype::recipe8;

            if(replcomp_msg)DB->msg("replcomp::init()spawn .system_info composite hash child etype: %s, traverse_depth = %d, max atomic depth = %d, chunksize = %d, "
                                     "curroff = %d, comp hash = %s",
                                    *etype.image(), traverse_depth, getAtomicDepth(), (int)utar_commands::sysinfo_chunksize, utar_commands::sysinfo_off, *elem.gethash().partialimage());
                cycle *child;

                child = new repldata(this, elem.gethash(), utar_commands::sysinfo_off, can_cancel, utar_commands::sysinfo_chunksize, name, etype, filetime, traverse_depth, info, NULL);
                child->noop();
            }

            return;
        }

        if(modified_data) {
            
            
            
            assert(!uapp::staging().canRun() || ctype.is_dir());
            const hashcode newhash = hashcode(listing);
            if(!uapp::staging().canRun() && xflag[19]&8) DB->msg("replcomp: CANCEL: Replcomp returning partial composite (depth=%d)", traverse_depth);
            
            myhash = newhash;
            size = listing.size();
            if(replcomp_msg) DB->msg("replcomp::childdone(): composit endoffset = %d", size.ivalue());
        }

        if(info->rechunk) {
            assert(!uapp::staging().canRun() || ctype.is_dir() || ctype.is_anycomposit());
            listing = listingnew;
            const hashcode newhash = hashcode(listing);
            if(!uapp::staging().canRun() && replcomp_msg) DB->msg("replcomp: CANCEL: Replcomp returning partial composite (depth=%d)", traverse_depth);
            if(replcomp_msg)
                DB->msg("replcomp: FINAL orighash=%s, new hash=%s, composit endoffset = %d", *myhash.partialimage(), *newhash.partialimage(), nextoffnew);
            myhash = newhash;
            size = nextoffnew;
        }
        if(flags.reportonly && parent && ((xflag[19]&32768)==0)) {
            ((replcycle *)parent)->setAtomicDepth(getAtomicDepth());
            ((replcycle *)parent)->count_atomic_depth = count_atomic_depth;
        }

        if((traverse_depth < getAtomicDepth()) && count_atomic_depth) {
            if(replcomp_msg)DB->msg("replcomp::childdone() childcount = 0 - traverse_depth = %d, max atomic depth = %d", traverse_depth, getAtomicDepth()); 
	        count_atomic_depth = false;  
	        main->add_insert(TODO_FILE, this, -traverse_depth);
        }
        else
            notifyparent();
    }
}

replcomp::~replcomp() {

}














#include "common.h"
#include "debug.h"
#include "output.h"
#include "parsestream_base.h"
#include "parsestream_ucontainer.h"
#include "ddr_interface.h"
#include "nbackdata.h"
#include "backfile2rawcontainer.h"
#include "timer.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"

#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "avpx_ext.h"
#include "udirelem.h"  
#include "filenames.h"
#include "mediadesc.h"

#include "backavpaxobj.h"

#define msg1  ((xflag[2]&2048)!=0)   





backavpaxobj::backavpaxobj(BackCycle* parent_, context* main, workelem *info_,
                           parsestream_base *parser_, int traverse_depth,
                           const fileref paxrecs_fr, const exportstream_xmlp _metainfop ,
                           const unsigned objflags ) :
    backavpaxstream(parent_, main, info_, parser_, traverse_depth, metainfop, undoo::make_shared<direlemp_list_type>(), flag_should_output_listing | objflags),
    had_metadata(false), is_root_direlem(false),
    is_system_info(m_isdir && info && !info->direlemp.isnull() && info->direlemp->is_internal() && (traverse_depth == 1) && m_objname.equal(UNDOO_DIRECTORY_NAME)),
    is_backup_indio_or_greater(_metainfop.isnull() ? false : _metainfop->is_backup_indio_or_greater()),
    is_ddrfiles_xml(false),
    is_backuptag_object(false),
    already_output_exportstream_metadata(false), synthesized_file(false), synthesized_containerid(0), synthesized_size(fileoffset::unknown), curphase(bpo_nul), m_basehash(hashcode::zero),
    metainfop(_metainfop)
{
    if(msg1) DB->msg(DBTXT("backavpaxobj::backavpaxobj('%s') constructor parent:%p this:%p is_dir:%d .system_info:%d parser:%p traverse_depth:%d"), *m_objname, parent, this, m_isdir, is_system_info, parser, traverse_depth);
    assert(parser);
    assert(info);
    assert(info && !info->direlemp.isnull());
    assert(m_delist_sp);

    if(backavpaxobj* op = dynamic_cast<backavpaxobj *>(parent)) {
        
        if(op->is_system_info && op->m_isdir && !m_isdir && traverse_depth == 2 && m_objname == DATADOMAINFILES_FILENAME) {
            is_ddrfiles_xml = true;
        }

        
        if(op->is_system_info && op->m_isdir && !m_isdir && traverse_depth == 2 && m_objname == BACKUPTAG_FILENAME) {
            if(!metainfop.isnull()) {
                is_backuptag_object = true;
            }
        }
    }

    
    if(paxrecs_fr.size() > 0) {
        if (!m_paxrecs.parse(paxrecs_fr)) {
            DB->msg("backavpaxobj::backavpaxobj(): Unable to parse paxrecs");
        }
    }

    
    todoEnqueueInsert(m_isdir ? TODO_DIR : TODO_FILE, this, traverse_depth+1);

    curphase = bpo_enqueued;
}

backavpaxobj::~backavpaxobj()
{
    if(msg1) DB->msg(DBTXT("backavpaxobj::~backavpaxobj destructor parent:%p this:%p parser:%p traverse_depth:%d"), parent, this, parser, traverse_depth);
    
    
}

const location::tcontainerid backavpaxobj::getde_containerid_from_metainfo(const ddrfiles_xmlp ddrfilesxmlp, const DIRELEM de) const
{
    if(!ddrfilesxmlp.isnull()) {

        bool whole_container(false);
        const emd_elementp emdp(ddrfilesxmlp->queryEmd(de.fullpath(), de.ignorecase(), whole_container));
        if(!emdp.isnull()) {
            return emdp->streamIndex;
        }
    }

    
    
    return de.get_location().get_containerid();
}

void backavpaxobj::init()
{
    if(msg1) DB->msg(DBTXT("backavpaxobj::init parent:%p this:%p is_dir:%d depth:%d info->direlemp:%s"),
                     parent, this, m_isdir, traverse_depth, *info->direlemp->fullpath().image());

    assert(curphase == bpo_enqueued);
    if(curphase != bpo_enqueued) {
        
        return;
    }

    if(!m_isdir) {
        
        if(!is_system_info && (flags.ddrenabled && flags.nemoresurrect)) {
            
            fileref flatten;
            if(m_paxrecs.get_fr(PAXKEY_FLATTENED_DIRELEM, flatten) && flatten.size() > 0) {
                DIRELEM de;

                int off(0);
                if(!de.populate(flatten, off)) {
                    DB->msg("backavpaxobj::init(): Unable to initialize direlem with flatten data");
                } else {
                    
                    const location original_loc(de.get_location());

                    
                    if(check_headflag(PAX_HEADFLAGS_DESCEND, m_paxrecs)) {
                        de.set_fullpath(info->direlemp->fullpath());
                    }

                    
                    if(original_loc.getMedia() == location::media::ddr && original_loc.get_format() == location::tformat::raw && flags.streamformat_out == utar_flags_enums::streamformat_raw) {
                        
                        ddrfiles_xmlp ddrfilesxmlp(metainfop->get_ddrfiles_xmlp(exportstream_xml::ddrfilesxml_from_gsan_then_ddr));
                        
                        const location::tcontainerid containerid(getde_containerid_from_metainfo(ddrfilesxmlp, de));

                        
                        if(parsestream_ucontainer* ucontainer_parser = dynamic_cast<parsestream_ucontainer*>(parser)) {
                            
                            ucontainer::basep cdsf_basep(ucontainer_parser->get_ucontainer_basep());

                            
                            const emd_elementp emdp(metainfop->get_containerid_emdp(exportstream_xml::ddrfilesxml_from_gsan_then_ddr, containerid));

                            if(!ddrfilesxmlp.isnull() && !emdp.isnull()) {
                                
                                ustring ddrfilename;
                                if(!cdsf_basep.isnull() && ddrfilesxmlp->getDDRFileNameForStream(containerid, ddrfilename)) {
                                    const fileoffset datasize((original_loc.get_data_bytes() > 0 ? original_loc.get_data_bytes() :
                                                               (original_loc.get_coverage_size() > 0 ? original_loc.get_coverage_size() :
                                                                de.file_size())));
                                    const fileoffset dataoffset(cdsf_basep->get_curroffset());

                                    
                                    
                                    int ddrhandle = 0;
                                    getAdeMgr()->get_ddrhandle(ddrhandle);

                                    
                                    ustring stagingpath;
                                    getAdeMgr()->getStagingPath(stagingpath);
                                    const ustring objpath(emdp->gsanFullPath.isempty() ? emdp->clientFilePath / emdp->clientFileName : emdp->gsanFullPath);

                                    if(getAdeMgr()->add_ddrfilesxml_entry(emdp->streamType, *objpath, emdp->streamIndex, *objpath) == EXIT_OK) {
                                        
                                        ustring new_ddrfilename;
                                        if(getAdeMgr()->ddrfilesxml_entry_ddrfilename(emdp->streamIndex, new_ddrfilename)) {
                                            
                                            {
                                                const mediadesc mediad(flags.media_in);

                                                
                                                
                                                const ustring cdsf_stream_path(mediad.getpath());

                                                
                                                
                                                const ustring srclsu(mediad.get_lsu());

                                                
                                                fileref ddrfile;
                                                ddr_interface::initddrwrite(ddrfile, ddrhandle, stagingpath, new_ddrfilename);

                                                
                                                fileref entirestream;
                                                ddr_interface::initddrread(entirestream, ddrhandle, ddrfile, srclsu, cdsf_stream_path);

                                                
                                                ddrfile.append(entirestream.makeslice64(dataoffset, datasize));
                                            }

                                            if(getAdeMgr()->finalize_ddrfilesxml_entry(emdp->streamIndex) == EXIT_OK) {
                                                
                                                cdsf_basep->skipdata();

                                                synthesized_containerid = emdp->streamIndex;
                                                synthesized_size = datasize;

                                                synthesized_file = true;
                                            }
                                        } else {
                                            Out->msg(ERR, "Can't retrieve DDR filename information for '%s', storing data on gsan", *info->direlemp->fullpath().image());
                                        }
                                    }
                                }
                            } else {
                                Out->msg(ERR, "Can't retrieve DDR related information for '%s', storing data on gsan", *info->direlemp->fullpath().image());
                            }
                        }
                    }
                }
            }
        }

        if(!synthesized_file) {
            
            if(!process_outofstream_content_file(info->direlemp)) {
                
                if(info->direlemp->file_size() > 0) {
                    
                    info->direlemp->set_stdin();       

                    workelem *w = new workelem(info, info->direlemp->fullpath(), info->direlemp);
                    w->streamslice = parser->datasize(info->direlemp, info->direlemp->file_size());      

                    bool create_backfile2rawcontainer_cycle(false);
                    if(info->use_container) {
                        
                        const bool metadata(check_headflag(PAX_HEADFLAGS_METADATA, m_paxrecs));
                        if(metadata) {
                            w->use_container = false;
                            w->container     = 0;
                        } else {
                            
                            create_backfile2rawcontainer_cycle = true;
                        }
                    }

                    create_data_cycle(create_backfile2rawcontainer_cycle, w, parser);
                } else {
                    
                    curphase = bpo_objdata;
                    hash = hashcode::empty;
                    childdone(0);
                }
            }
        } else {
            
            hash = hashcode::zero;
            curphase = bpo_objdata;
            childdone(0);
        }
    } else {
        curphase = bpo_dirdata;
        childdone(0);
    }
}




bool backavpaxobj::process_outofstream_content_file(const DIRELEMp& dep)
{
    
    if(parsestream_ucontainer* pucp = dynamic_cast<parsestream_ucontainer*>(parser)) {
        
        fileref content;
        if(pucp->outofstreamcontentfile(dep, content)) {
            
            dep->set_stdin(false); 
            workelem *w = new workelem(info, upath(), dep, info->fstats, content);

            
            create_data_cycle(info->use_container, w, parser);

            return true;
        }
    }

    return false;
}




void backavpaxobj::create_data_cycle(const bool use_raw_container, workelem* wep, parsestream_base *parser )
{
    if(use_raw_container) {
        cycle *child = new backfile2rawcontainer( this, wep, parser );
        child->noop();
    } else {
        cycle *child = new nbackdata( this, wep, 0, false, parser );
        child->noop();
    }
    nforked++;
    curphase = bpo_objdata;
}

void backavpaxobj::childdone(cycle *child)
{
    if(child) ncollected++;

    if(msg1) DB->msg(DBTXT("backavpaxobj::childdone parent:%p this:%p is_dir:%d curphase:%d wait_for_ascend:%d child:%p nforked=%d ncollected=%d"),
                     parent, this, m_isdir, curphase, check_headflag(PAX_HEADFLAGS_TO_BE_CONTINUED, m_paxrecs), child, nforked, ncollected);

    
    if(m_isdir || check_headflag(PAX_HEADFLAGS_TO_BE_CONTINUED, m_paxrecs)) {
        if(curphase == bpo_exportstream_metafile) {
            if(m_delist_sp->size() > 0) {
                
                const DIRELEMp dep((*m_delist_sp)[m_delist_sp->size() - 1]);

                
                DB->msg("backavpaxobj::childdone() bpo_exportstream_metafile %d %s %s", dep.isnull(), *dep->name(), *dep->file_size().image());
            }
            curphase = bpo_dirdata;
        } else if(curphase == bpo_objdata || curphase == bpo_dirlist) {
            
            m_basehash = hash;
        } else if(curphase == bpo_metadata) {
            
            assert(check_headflag(PAX_HEADFLAGS_METADATA, last_paxrecs));

            
            ustring metaty;
            if(last_paxrecs.get_str(PAXKEY_METADATA, metaty)) {
                ubigint64 metadatanum(0);
                
                if(last_paxrecs.get_u64(PAXKEY_METADATANUM, metadatanum)) {
                    const ustring key(tostr(metadatanum));
                    if(dephashes.defined(key)) {
                        Out->msg(WARN, "<12538>A dependent hash for '%s' index %s is already defined",
                                 *info->direlemp->fullpath().image(), *key);
                    } else {
                        dephashes.enter(key, hash);
                    }
                }
            }
        } else if(curphase == bpo_dirdata) {
            assert(m_isdir);
#if 0
            
            
            if(child) {
                if(backavpaxobj* cp = reinterpret_cast<backavpaxobj*>(child)) {
                    if(cp->info) {
                        m_delist_sp->push_back(cp->info->direlemp);
                    }
                }
            }
#endif
        }

        if(curphase != bpo_dirlist) {
            
            DIRELEMp obj_direlemp;
            fileref altdata, stubdata;
            altdata = fileref::empty;
            stubdata = fileref::empty;
            if(parser->getentry(obj_direlemp, altdata, stubdata)) {
                if(!obj_direlemp.isnull()) {
                    
                    if(altdata.size() > 0) {
                        if (!last_paxrecs.parse(altdata)) {
                            DB->msg("backavpaxobj::backavpaxobj(): Unable to parse paxrecs");
                        } else {
                            
                            if(check_headflag(PAX_HEADFLAGS_DESCEND, last_paxrecs)) {
                                obj_direlemp->set_fullpath(info->direlemp->fullpath() / obj_direlemp->name());

                                
                                

                                
                                
                                if(backavpaxobj* op = dynamic_cast<backavpaxobj *>(child)) {
                                    if(op->is_ddrfiles_xml) {
                                        
                                        m_delist_sp->pop_back();
                                    }
                                }
                            }

                            
                            if(flags.dtoexportstream && !metainfop.isnull() && is_system_info && !already_output_exportstream_metadata) {
                                const ustring curobj(obj_direlemp->name());
                                const ustring metaobj(EXPORTSTREAM_METADATA_FILENAME);

                                
                                if(metaobj < curobj) {
                                    

                                    
                                    DIRELEMp dep = new DIRELEM();
                                    const xml_messagep metaxmlp(metainfop->to_xmlp());
                                    if(!dep.isnull() && !metaxmlp.isnull()) {
                                        
                                        
                                        parser->push_entry(obj_direlemp, altdata, stubdata);

                                        fileref exportstream_metadata(metaxmlp->fimage());

                                        dep->zero();

                                        dep->initialize( hashcode::zero, obj_direlemp->mtime(), obj_direlemp->mtime(), obj_direlemp->mtime(),
                                                         exportstream_metadata.size64(), ATTR_INTERNAL, metaobj);
                                        dep->set_name(metaobj);
                                        dep->set_file_size(exportstream_metadata.size64());

                                        
                                        workelem *w = new workelem(info, (upath)dep->name(), dep, info->fstats, exportstream_metadata);
                                        cycle *meta = new nbackdata(this, w, fileoffset(0), false  );
                                        meta->noop();
                                        m_delist_sp->push_back(dep);
                                        nforked++;

                                        
                                        already_output_exportstream_metadata = true;

                                        curphase = bpo_exportstream_metafile;

                                        
                                        return;
                                    } else {
                                        
                                        already_output_exportstream_metadata = true;
                                    }
                                }
                            }

                            if(check_headflag(PAX_HEADFLAGS_DESCEND, last_paxrecs)) {
                                if(msg1) DB->msg(DBTXT("backavpaxobj::childdone descend into another object"));

                                obj_direlemp->set_stdin();       

                                workelem *w = new workelem(info, obj_direlemp->fullpath(), obj_direlemp);
                                w->streamslice = parser->datasize(obj_direlemp, obj_direlemp->file_size()); 

                                
                                
                                unsigned int newobjflags(objflags & flag_subcycle_mask); 

                                
                                
                                if(is_system_info)
                                    newobjflags |= flag_is_system_info_contents;

                                backavpaxobj *nondir = new backavpaxobj(this, main, w, parser, traverse_depth+1, altdata, metainfop, newobjflags);
                                nondir->noop();
                                nforked++;

                                curphase = check_headflag(PAX_HEADFLAGS_METADATA, last_paxrecs) ? bpo_metadata : (m_isdir ? bpo_dirdata : bpo_objdata);
                                if(curphase == bpo_metadata) {
                                    had_metadata = true;
                                } else if(curphase == bpo_dirdata) {
                                    assert(m_isdir);

                                    
                                    m_delist_sp->push_back(obj_direlemp);
                                }
                            } else if(check_headflag(PAX_HEADFLAGS_ASCEND, last_paxrecs)) {
                                if(msg1) DB->msg(DBTXT("backavpaxobj::childdone ascending out of '%s'"), *m_objname);

                                
                                ubigint64 code;
                                if(last_paxrecs.get_u64(PAXKEY_ENDOBJ_RESULT, code)) {
                                    if(code != udirelem::peo_null || code != udirelem::peo_success) {
                                        Out->msg(ERR, "<12539>Stream object '%s' has error indication (%s). Data may not be restored for this object.", *obj_direlemp->fullpath().image(), *tostr(code));
                                    }
                                }

                                
                                ustring objname;
                                if(last_paxrecs.get_str(PAXKEY_OBJECTNAME, objname)) {
                                    
                                    if(m_objname != DIRELEM_ROOT || obj_direlemp->name() != DIRELEM_ROOT || traverse_depth != 1) {
                                        if(objname != m_objname) {
                                            Out->msg(WARN, "<12540>Ascend object name '%s' does not match stored object name '%s'",
                                                     *objname, *m_objname);
                                            DB->msg("backavpaxobj::childdone(): root object '%s' '%s' '%s' %d", *obj_direlemp->fullpath().image(), *obj_direlemp->name(), *m_objname, traverse_depth);
                                        }
                                    } else {
                                        
                                        is_root_direlem = true;
                                    }
                                } else {
                                    if(msg1) DB->msg(DBTXT("backavpaxobj::childdone no object name for ascend?"));
                                }

                                
                            }
                        }
                    }
                }
            }

            
            if(m_isdir && nforked == ncollected) {
                fileoffset listingsize(0);
                const fileref listing(build_listing(listingsize, flags.inode));

                workelem *w = new workelem(NULL, listing);
                cycle *datachild = new nbackdata(this, w, fileoffset(0), true   );
                datachild->noop();

                nforked++;
                curphase = bpo_dirlist;
            }
        }
    }

    if(nforked == ncollected) {
        if(had_metadata) {
            

            

            
            assert(!check_headflag(PAX_HEADFLAGS_METADATA, m_paxrecs));
            assert(!check_headflag(PAX_HEADFLAGS_METADATA, last_paxrecs));

#if 0
            if(msg1) DB->msg("backavpaxobj::childdone basehash '%s', dephash count %d", *m_basehash.partialimage(), dephashes.size());
            const undoo::vector<ustring> keys(dephashes.keys());
            for(size_t i = 0; i < keys.size(); i++) {
                if(msg1) DB->msg("     backavpaxobj::childdone dephash count %s %s", *keys[i], *dephashes.lookup(keys[i]).image());
            }

            
            fileref flatten;
            if(last_paxrecs.get_fr(PAXKEY_FLATTENED_DIRELEM, flatten) && flatten.size() > 0) {
                DIRELEM de;

                int off(0);
                if(!de.initialize(flatten, off)) {
                    DB->msg("backavpaxobj::childdone(): Unable to initialize direlem with flatten data");
                } else {
                    hashvect hashes;
                    de.getdephashes(hashes);

                    DB->msg("backavpaxobj::childdone(): original basehash %s", *de.file_hash().partialimage());
                    for(hashvect::size_type i = 0; i < hashes.size(); i++) {
                        DB->msg("backavpaxobj::childdone(): original hash %s %s", *tostr((int)i - 1), *hashes[i].image());
                    }
                }
            }
#endif
        }

        
        
        
        if(check_headflag(PAX_HEADFLAGS_ASCEND, last_paxrecs) && !check_headflag(PAX_HEADFLAGS_METADATA, last_paxrecs)) {
            location cycles_loc(info->direlemp->get_location());

            
            DIRELEMp dep(info->direlemp);

            
            fileref flatten;
            if(last_paxrecs.get_fr(PAXKEY_FLATTENED_DIRELEM, flatten) && flatten.size() > 0) {
                int off(0);
                if(!dep->populate(flatten, off)) {
                    DB->msg("backavpaxobj::childdone(): failed to restore original direlem %s", *dep->fullpath().image());
                } else {
                    if(is_backuptag_object) {
                        ustring tag;
                        const bool res(info->direlemp->get_backuptag(tag));
                        if(res && !metainfop.isnull()) {
                            metainfop->set_sysinfo_backuptag_value(tag);
                        }
                    }

                    
                    if(is_root_direlem) {
                        assert(traverse_depth == 1);
                        assert(dep->name().isempty());
                        dep->set_name(DIRELEM_ROOT);
                    }

                    
                    
                    

                    
                    hashvect hashes;
                    dep->getdephashes(hashes);

                    
                    const hashcode basehash(hashes[0]);
                    if(basehash != m_basehash) {
                        const bool is_reparsepoint(dep->is_dirrec_present(KIND_REPARSEPOINT));

                        if(dep->is_directory() || (!dep->is_device_file() && !is_reparsepoint)) {
                            DB->msg("backavpaxobj::childdone(): basehash mismatch for object '%s' '%s' '%s' %d", *dep->fullpath().image(), *dep->name(), *m_objname, traverse_depth);
                            
                            
                            if(!(basehash == hashcode::zero && m_basehash == hashcode::empty)) {
                                dep->set_hash(m_basehash);
                            }
                        } else {
                            
                            
                            
                            
                            
                            
                            
                            if(!metainfop.isnull() &&
                               ((metainfop->get_pid() == pidtype(pidtype::os_netapp + pidtype::ndmp)) ||
                                (metainfop->get_pid() == pidtype(pidtype::os_celerra + pidtype::ndmp)) ||
                                (metainfop->get_pid() == pidtype(pidtype::os_isilon + pidtype::ndmp)))) {
                                const location original_loc(dep->get_location());
                                if(original_loc.getMedia() > location::media::gsan || basehash != hashcode::zero) {
                                    dep->set_hash(m_basehash);
                                }
                            } else {
			      
			      
			      
			      if(is_reparsepoint && basehash != hashcode::zero) {
				dep->set_hash(m_basehash);
			      } else {
                                
                                
                                assert(basehash == hashcode::zero);
			      }
                            }
                        }
                    }

                    
                    if(hashes.size() - 1 != dephashes.size()) {
                        Out->msg(WARN, "<12541>Count of restored dephashes (%s) doesn't match direlem count (%s) for '%s'", *tostr(dephashes.size()), *tostr(hashes.size() - 1), *dep->fullpath().image());
                    }

                    
                    bool hasmismatch(false);
                    for(hashvect::size_type i = 1; i < hashes.size(); i++) {
                        const hashcode de_dephash(hashes[i]);

                        const ustring key(tostr(i - 1));
                        if(dephashes.defined(key)) {
                            const hashcode dephash(dephashes.lookup(key));

                            if(de_dephash != dephash) {
                                DB->msg("backavpaxobj::childdone(): dephash[%s] mismatch for object '%s'", *tostr(i - 1), *dep->fullpath().image());
                                hasmismatch = true;
                            }
                        } else {
                            hasmismatch = true;
                        }
                    }

                    
                    if(hasmismatch) {
                        DB->msg("backavpaxobj::childdone(): Correcting dephash mismatches for object '%s'", *dep->fullpath().image());

                        
                        assert(dep->is_dirrec_present(KIND_DEPHASH));
                        dep->clrdephashes();
                        assert(!dep->is_dirrec_present(KIND_DEPHASH));

                        
                        
                        for(hashvect::size_type i = 1; i < hashes.size(); i++) {
                            const ustring key(tostr(i - 1));
                            if(dephashes.defined(key)) {
                                const hashcode dephash(dephashes.lookup(key));
                                const int idephash(dep->adddephash(dephash));
                                if(idephash != static_cast<int>(i) - 1) {
                                    DB->msg("backavpaxobj::childdone(): dephash[%s] index changed to %d for object '%s'", *key, idephash, *dep->fullpath().image());
                                }
                            } else {
                                DB->msg("backavpaxobj::childdone(): dephash[%s] is missing for object '%s'", *key, *dep->fullpath().image());
                            }
                        }
                    }


                    
                    
                    
                    if(!flags.ddrenabled || flags.nemoresurrect) {
                        if(synthesized_file) {
                            
                            
                            if(!is_backup_indio_or_greater) {
                                fileref flatten;
                                if(m_paxrecs.get_fr(PAXKEY_FLATTENED_DIRELEM, flatten) && flatten.size() > 0) {
                                    int off(0);
                                    if(!dep->populate(flatten, off)) {
                                        DB->msg("backavpaxobj::childdone(): failed to restore original direlem for synthesized file %s", *dep->fullpath().image());
                                    } else {
                                        if(flags.nemoresurrect) {
                                            
                                            
                                            
                                            dep->clear_location();
                                        }

                                        
                                        dirrec_pack::deprecated_ddr_altdata direlemRec(dep.getimpl());
                                        
                                        direlemRec.set(synthesized_containerid, 0, synthesized_size);

                                        
                                        (void)dep->del_dirrec(KIND_LOCATION_INFO);
                                    }
                                }
                            }
                        } else {
                            if(is_backup_indio_or_greater && flags.nemoresurrect) {
                                
                                
                                ;
                            } else {
                                const location original_loc(dep->get_location());

                                
                                
                                if(!metainfop.isnull() && metainfop->get_pid() == pidtype(pidtype::os_celerra + pidtype::ndmp) &&
                                   original_loc.getMedia() == location::media::gsan && original_loc.get_format() == location::tformat::gsan) {
                                    DB->msg("backavpaxobj::childdone not deleting celerra LOCATION dirrec for %s", *dep->fullpath().image());
                                } else {
                                    
                                    
                                    dep->clear_location();
                                }
                            }

                            
                            const bool foundddr(dep->del_dirrec(KIND_deprecated_DDR_ALTDATA));
                            if(foundddr) {
                                DB->msg("backavpaxobj::childdone deleted DDR ALTDATA dirrec for %s", *dep->fullpath().image());
                                dep->set_hash(m_basehash);
                            }
                        }
                    } else if(flags.ddrenabled) {
                        if(!info->use_container) {
                            
                            
                            dep->clear_location();
                        } else if((objflags & flag_use_cycles_location) != 0) {
                            cycles_loc.setMedia(location::media::ddr);

                            dep->set_location(cycles_loc);
                        }
                    }
                }
            }
        }

    } else {
        if(msg1) DB->msg(DBTXT("   leaving backavpaxobj::childdone parent:%p this:%p curphase:%d wait_for_ascend:%d child:%p nforked=%d ncollected=%d"), parent, this, curphase, check_headflag(PAX_HEADFLAGS_TO_BE_CONTINUED, m_paxrecs), child, nforked, ncollected);
        return;
    }

    
    notifyparent();

    
    
    return;
}

fileref backavpaxobj::nextdatablock(bool& suppress_requeue)
{
    if(msg1) DB->msg(DBTXT("backavpaxobj::nextdatablock"));
    return fileref();
}





















#include "common.h"
#include "debug.h"
#include "backdump.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"

#include "backappend.h"
#include "backdumpdir.h"
#include "utar_flags_info.h"
#include "direlem_netapp.h"
#include "runstage.h"

#define bdmsg1              ((xflag[2]&8192)!=0)     
#define bdmsg2              ((xflag[2]&16384)!=0)    
#define streamdump_msg      ((xflag[1]&128)!=0)      

#define do_fullpath         ((xflag[1]&512)!=0)
#define call_traverse       ((xflag[13]&16)!=0)

#define dowfs               ((xflag[15]&2)==0)   

enum phases { phase_init        = 0,  
              phase_read_tables = 1,  
              phase_read_dirs   = 2,  
              phase_read_files  = 3,  
              phase_read_acls   = 4,  
              phase_stream_done = 5,  
              phase_write_dirs  = 6,  
              phase_wait_dirs   = 7   
            };


backdump::backdump(BackCycle* parent_, workelem *info_, fileoffset offset_,
                       fileref f_, utar_flags_info& flags_
                   ) : BackCycle(parent_, info_),
                       f(f_), flags(flags_),
                       inodeinfo(10000, false),  
                       acltab(10000, false),     
                       phase(0), 
                       indoubleslash_mode(false),
                       LARA_count(0)
{
    if(bdmsg1) DB->msg(DBTXT("backdump::backdump constructor (parent:%p) (this:%p)"), parent, this);
    cycle::offset = offset_;
    assert(parent != NULL);
    
    set_phase(phase_init);

    todoEnqueue(TODO_DIR, this);  

    DB->msg(DBTXT("\n\n\nbackdump::readstream BEGIN, \n\n\n"));
    assert(sizeof(s_spcl) == TP_BSIZE);
    DB->msg("sizeof  s_spcl:%d  dinode:%d\n\n", (int)sizeof(s_spcl), (int)sizeof(dinode));
}


backdump::~backdump() {
  
  if(bdmsg1)DB->msg("backdump::~backdump (parent:%p) (this:%p)", parent, this);
  if(bdmsg2)DB->msg("backdump::~backdump inodeinfo.size:%d", inodeinfo.size());

  











}














void backdump::init() {
  if(bdmsg1) DB->msg("backdump::init (parent:%p) (this:%p)", parent, this);

  if (!readstream()) {
      if (!uapp::staging().canRun()) {
          Out->msg(FATAL, "<6508>Stream processing aborted");
      } else {
          Out->msg(FATAL, "<5752>Unable to read stream");
          set_error(true, DBTXT("Unable to read stream"));
          uapp::staging().startTermination(EXIT_DUMPSTREAM, "stream processing aborted");
          DB->msg("backdump::init termination = %s", *uapp::staging().getRunStageImage());
      }
      notifyparent();
      return;
  }

  
  if (phase < phase_stream_done) {
      
      todoEnqueue(TODO_DIR, this);  
  } else {
      Out->msg(INFO, "<7519>Done reading stream.");
      DB->msg(DBTXT("backdump::init done with init"));
  }
}




void backdump::childdone(cycle *child) {
    if(bdmsg1)DB->msg("backdump::childdone (parent:%p) (this:%p) (child:%p) phase:%d, nforked:%d ncollected:%d",
                      parent, this, child, phase, nforked, ncollected);

    switch (phase) {
         
      case phase_init:
      case phase_read_tables:
      case phase_read_dirs:
      {
          assert(false);
          DB->error(DBTXT("backdump::childdone called in incorrect phase %d"), phase);
          break;
      }

         
      case phase_read_files:
      case phase_read_acls:
      case phase_stream_done:
      {
          if (child==NULL) { break; }  
          ncollected++;
          dumpDIRELEM *elemp = inodeinfo.lookup(child->offset.ivalue()).getdd();
          if(elemp == NULL) {
              DB->error(DBTXT("backdump::childdone cannot find elemp for inode:%d"), child->offset.ivalue());
              return;
          }
          elemp->set_hash(child->hash);
          main->getstatsobj(context::backupstats)->add_filecount(1);   
          if(bdmsg1)DB->msg("backdump::childdone name:%s inode:%d hash:%s",
                                  *elemp->name(), elemp->inode_number(), *elemp->file_hash().partialimage());
          break;
      }

         
      case phase_wait_dirs:
      {
          this->size = child->size;
          Out->msg(INFO, "<7520>Directories backed up successfully");
          if(bdmsg1)DB->msg("backdump::childdone child->hash:%s this:%s", *child->hash.partialimage(), *hash.partialimage());
          notifyparent(); 
          return;
          break;
      }

      default: assert(false);
    }

    
    if (phase == phase_stream_done && ncollected == nforked) {
        DB->msg(DBTXT("backdump::childdone all children done"));
        set_phase(phase_write_dirs);
        if (!snapup_directory_tree()) {
          set_error(true, DBTXT("Unable to backup directory information"));
          uapp::staging().startTermination(EXIT_DUMPSTREAM, "unable to backup directory information");
          notifyparent();
          return;
        }
        set_phase(phase_wait_dirs);
    }
}

void backdump::response(message& outargs) {
  assert(false);
  DB->msg("backdump::response (parent:%p) (this:%p)", parent, this);
}

void backdump::notifyparent() {
    if(bdmsg1) DB->msg("backdump::notifyparent (parent:%p) (this:%p)", parent, this);
    BackCycle::notifyparent();
    
}




bool backdump::getroot(DIRELEM& direlem) {
  if ( !inodeinfo.defined(2) ) return false;
  direlem = *inodeinfo.lookup(2);
  return true;
}

int backdump::read_stuff(void *buff, int size) {
    if (size <= 0) return 0;
    int read = 0;
    while(read < size) {
        
        int bytes_read = ::read(0, (char *)buff+read, size-read);
        if (bytes_read < 0) {
            uapp::staging().startTermination(EXIT_DUMPSTREAM, "stdin read error");
            return bytes_read;
        }
        if (bytes_read == 0) break;  
        read += bytes_read;
    }
    
    return read;
}

bool backdump::read_header(dump_header& header) {
    int readsize = read_stuff(&header, TP_BSIZE);
    if (streamdump_msg) DB->msg(DBTXT("\nheader: -----------------------------------------------------------------------\n%s\n"), *header_image(header));
    return readsize == TP_BSIZE;
}

int backdump::count_sparse(dump_header& header) {
    int count=0;
    for (int i=0; i<+header.c_count; i++)
      count += +header.c_data.s_addrs[i];
    return +header.c_count - count;
}




bool backdump::restore_prev_dump() {
    if(! flags.incremental)
        return true;
    return main->restore_prev_dump(this);
}

bool backdump::check_magic(swapint magic) {
  if (magic == NFS_MAGIC) { return true; }
  if (magic == OFS_MAGIC) { Out->msg(WARN, "<5753>Using OFS MAGIC???"); return true; }

  swap_use_little_endian = false;
  if (magic == NFS_MAGIC) { Out->msg(INFO, "<5765>Swapping bytes");  return true; }
  if (magic == OFS_MAGIC) { Out->msg(WARN, "<5755>Swapping bytes - Using OFS MAGIC???"); return true; }

  Out->msg(FATAL, "<5756>Bad magic number (%d) in dump stream.", +magic);
  return false;
}


bool backdump::readstream() {



    if (!uapp::staging().canRun()) return false;
    if (bdmsg1) DB->msg("--------------------------------------------------------------------------------------------------\n");

    if(! read_header(header)) {
        DB->msg(DBTXT("backdump::readstream unable to read header"));
        if (!uapp::staging().canRun()) return false; 
        set_phase(phase_stream_done);
        childdone(NULL);
        return true;  
    }

    if (!check_magic(header.c_magic)) {
        Out->msg(FATAL, "<5757>Cannot decode stream, magic number invalid %d", +header.c_magic);
        set_error(true, DBTXT("Bad magic number in dump stream."));
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "invalid magic number in dump stream");
        return false;
    }

    int type = +header.c_type;

    int read_size = header.c_count * TP_BSIZE;
    fileref data;
    if (type == TS_BITS || type == TS_CLRI || type == TS_EOM) {
        if (streamdump_msg) DB->msg("\n -- read_size %10d\n", read_size);
        set_phase(phase_read_tables);
        data.initmem(read_size);
        read_stuff(data.start(), read_size);
    }

    switch (header.c_type) {
        case TS_TAPE  : if (streamdump_msg) DB->msg("--> TS_TAPE  \n");
            break;

        case TS_INODE : if (streamdump_msg) DB->msg("--> TS_INODE \n");
            indoubleslash_mode = false;
            parse_inode(header, read_size, false, indoubleslash_mode);
            break;

        case TS_ADDR  : if (streamdump_msg) DB->msg("--> TS_ADDR  \n");
            parse_inode(header, read_size, true, indoubleslash_mode);
            break;

        case TS_BITS  : if (streamdump_msg) DB->msg("--> TS_BITS  \n");
            bits_map.init(data);
            if(!restore_prev_dump()) {
               DB->msg(DBTXT("backdump::readstream aborting because restore_prev_dump failed"));
               Out->msg(FATAL, "<5938>Unable to read previous dump to merge with incremental.");
               return false;
            }
            break;

        case TS_CLRI  : if (streamdump_msg) DB->msg("--> TS_CLRI  \n");
            clri_map.init(data);
            break;

        case TS_END   : if (streamdump_msg) DB->msg("--> TS_END   \n");
             
             
            break;

        case TS_EOM   : if (streamdump_msg) DB->msg("--> TS_EOM   \n");
            DB->msg(DBTXT("reading netapp acl bitmap"));
            Out->msg(INFO, "<5904>Initializing Netapp acl bitmap");
            set_phase(phase_read_acls);
            acl_map.init(data);
            break;

        default:
            Out->msg(FATAL, "<5758>Unknown record type (%d) in ndmp dump stream, aborting.", type);
            return false;
    }
    if (streamdump_msg) DB->msg( "\n\n\n");
    return true;
}

bool backdump::snapup_directory_tree() {
  assert(phase==phase_write_dirs);
  if (bdmsg2 || streamdump_msg) {
      DB->msg("\n\n\n");
      DB->msg("--------------------------------------------------------------------------------------------------\n");
      DB->msg("--------------------------------------------------------------------------------------------------\n");
      DB->msg(DBTXT(" tables! "));
      DB->msg("--------------------------------------------------------------------------------------------------\n");
      DB->msg("--------------------------------------------------------------------------------------------------\n");
      DB->msg("\n\n\n");
  }

  dumpDIRELEM *rootelemp = inodeinfo.lookup(2).getdd();   
  if (rootelemp == NULL) { Out->msg(ERR, "<5759>Ack! no root!"); return false; }
  rootelemp->set_name("/");  
  if(do_fullpath) rootelemp->set_fullpath("/");  

  if (call_traverse) {   
      memman::allocreport();
      DB->msg(DBTXT("backdump::snapup_directory_tree calling traverse"));
      traverse(inodeinfo, 2, "", "/");  
      memman::allocreport();
      int num_orphans(check_for_orphaned_inodes(inodeinfo));
      if (num_orphans > 0) {
        Out->msg(ERR, "<6631>Found %d orphaned  in the dump stream", num_orphans);
      }
      Out->msg(INFO, "<6632>After traverse %d", call_traverse);
  }

  DB->msg("--------------------------------------------------------------------------------------------------\n");
  if (streamdump_msg) {
    DB->msg("--------------------------------------------------------------------------------------------------\n");
    undoo::vector<intobj> inodes(inodeinfo.keys());
    for(unsigned int i=0; i<inodes.size(); i++) {
      dumpDIRELEM *tmp = inodeinfo.lookup(inodes[i]).getdd();
      if (tmp != NULL) {
        DB->msg("%3d %13d  %20s %-70s             %s\n", i, +inodes[i], *tmp->file_hash().partialimage(), *tmp->fullpath(), *tmp->name());
      } else {
        DB->msg(DBTXT("%3d %13d  strange NULL direlem\n"), i, +inodes[i]);
      }
    }
    DB->msg("--------------------------------------------------------------------------------------------------\n");
    DB->msg("--------------------------------------------------------------------------------------------------\n");
  }

  dumpDIRELEM * rootdirelemp = inodeinfo.lookup(2).getdd();
  if (rootdirelemp == NULL) {
      if(!uapp::staging().canRun()) return false;
      Out->msg(FATAL, "<5766>Unable to find inode 2(root) in dump stream, aborting");
      uapp::staging().startTermination(EXIT_DUMPSTREAM, "can't find inode 2 in dump stream");
      return false;
  }
  DB->msg(DBTXT("backdump::snapup_directory_tree after lookup rootdirelemp:%p parent:%p  name:%s mode:%u"), rootdirelemp, parent, *rootdirelemp->name(), rootdirelemp->unix_mode());

  if (info == NULL) {
    DB->msg(DBTXT("backdump::snapup_directory_tree info is NULL"));
    
    info = new workelem(NULL, upath("TOP"));
  }

  if (!uapp::staging().canRun()) return false;
  backdumpdir * dumpdir_cycle = new backdumpdir(this, main, info, rootdirelemp, inodeinfo, 0);
  dumpdir_cycle->noop();

  if (streamdump_msg) DB->msg( "\n\n\n");
  return true;
}

bool backdump::parse_inode(const dump_header& header, int read_size,
                           bool continuation, bool &indoubleslash_mode
) {
  int inodenum = header.c_inumber;
  if(bdmsg2) DB->msg("backdump::parse_inode inum=%d continuation=%d", inodenum, continuation);

  
  
  int aclinode = header.c_spare[NETAPP_ACLINX];
  if(aclinode == 1) {
      
      
      set_phase(phase_read_acls);

      fileref acldata;
      acldata.initmem(read_size);
      read_stuff(acldata.start(), read_size);

      if(flags.dumpnetapp) {
          aclinode = inodenum;
          int fileinode = acltab.lookup(aclinode);
          if(streamdump_msg) DB->msg(" netapp ACL fileinode:%d aclinode:%d", fileinode, aclinode);

          int aclsize = (int)header.c_dinode.di_size; 
          acldata = acldata.makeslice(0, aclsize);

          DIRELEM_netapp *d = (DIRELEM_netapp *)inodeinfo.lookup(fileinode).getdd();
          
          if(d != NULL)
              d->add_netapp_acl(aclinode, acldata);
          else
              if(streamdump_msg) DB->msg(" unable to find  direlem for netapp ACL fileinode:%d aclinode:%d", fileinode, aclinode);

      }

      return true;

  } else if(aclinode != 0 && flags.dumpnetapp) {
      
      
      int fileinode = inodenum;
      acltab.enter(aclinode, fileinode);
      if(bdmsg2) DB->msg("backdump::parse_inode acltab.enter(%d, %d)", aclinode, fileinode);
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  dumpDIRELEM *elemp = inodeinfo.lookup(inodenum).getdd();
  if(continuation) {
      if(elemp == NULL) {
          if(bdmsg1) DB->msg(DBTXT("empty inodeinfo for %d continuation"), inodenum);
          return false;
      }
      if(! elemp->is_directory()) {
          if(bdmsg1) DB->msg(DBTXT("non-dir inodeinfo for %d continuation"), inodenum);
          return false;
      }
      if (+header.c_dinode.di_size > 512*1024)
          Out->msg(INFO, "<6481>Handling huge directory: inode=%d, %d bytes", inodenum, (int)+header.c_dinode.di_size);
  } else {
      
      if (!inodeinfo.defined(inodenum)) {  
          DB->msg(DBTXT("backdump::parse_inode no inode:%d in table"), inodenum);
          elemp = new dumpDIRELEM;
          inodeinfo.enter(inodenum, elemp);  
          if(bdmsg2) DB->msg("backdump::parse_inode inodeinfo.enter(%d, %p)", inodenum, elemp);
      }
      if (elemp == NULL) {
          DB->msg("backdump::parse_inode strange null dumpdirelem %d", inodenum);
          return false;
      }
      elemp->initialize(header, ATTR_EXTENDED); 
      elemp->set_file_size(fileoffset(0));  
      elemp->set_found_in_stream(true);
      de_LARA = NULL;  
  }
  
  if(aclinode>1&&flags.dumpnetapp) elemp->add_acl_ref(aclinode);

  bool isdir(elemp->is_directory());
  if(bdmsg2) DB->msg("backdump::parse_inode num:%d isdir:%d", inodenum, isdir);





  if (isdir) {
      set_phase(phase_read_dirs);

       
       
      if (elemp->is_symlink()) {
        Out->msg(ERR, "<5943>Strange inode found - is directory and symlink\n%s\n--------", *header_image(header, true));
        elemp->convert_symlink(false);
      }

      elemp->set_is_directory();
      parse_direntries(read_size, inodenum, elemp);

  } else {  
      set_phase(phase_read_files);
      if (streamdump_msg) DB->msg(DBTXT("\n\n      ***** FILE DATA *****      \n\n"));

      
      elemp->set_file_size(fileoffset(header.c_dinode.di_size));  
      if(bdmsg2) DB->msg("backdump::parse_inode read_size:%d file_size:%s", read_size, *elemp->file_size().image());

      backappend *cycle_chunk = new backappend( this, main, info, f, false, fileoffset(0), af_dumpstream, &header);
      nforked++;
      cycle_chunk->noop();
  }

  return true;
}

bool backdump::parse_direntries(int read_size, int parent_inodenum, dumpDIRELEM *elemp) {
    
    
    
    

    fileref data;
    data.initmem(read_size);
    read_stuff(data.start(), read_size); 

    char * loc = data.start();
    char * last = data.start() + read_size;
    if (streamdump_msg) { DB->msg(" loc:%p + read_size:%d == last:%p ?", loc, read_size, last);
                          DB->msg(" %13s %13s %13s %13s  %s", " d_ino    "," d_reclen "," d_type   ","d_namlen "," d_name   ");
                          DB->msg(" %13s %13s %13s %13s  %s", "----------","----------","----------","---------","----------"); }

    int previno = 0;  

    while (loc < last) {
        
        
        
        struct ndmp_direct& entry = *(struct ndmp_direct *)loc;

        if (entry.d_namlen == 0 && entry.d_type != 0) {
            entry.d_namlen= entry.d_type;
        }
        entry.d_type = DT_UNKNOWN;
        loc += entry.d_reclen;
        if (entry.d_reclen == 0) break;

        int ino_num(entry.d_ino);
        ustring name(entry.d_name, entry.d_namlen);
        if(name.bytelength() != entry.d_namlen) {
            DB->msg("name.length():%d != entry.d_namlen:%d '%s'", name.bytelength(), entry.d_namlen, *name);
        }
        if(streamdump_msg){ustring arraystr; for(int i=0; i<entry.d_namlen; i++) arraystr += ustring::sprintf("%3d,", (int)entry.d_name[i]);
                           DB->msg("%s (%d) %s\n", *direct_image(entry), indoubleslash_mode, *arraystr);}

        
        if (ino_num == 0 && dowfs) {
          
            if (name == "/") {
                indoubleslash_mode = true;

          
            } else if (!indoubleslash_mode) {
                
                if(inodeinfo.defined(previno)) {
                  DIRELEM_netapp* den = (DIRELEM_netapp*) inodeinfo.lookup(previno).getdd();
                  den->set_8dot3_name(name);
                } else { Out->msg(WARN, "<7199>backdump::parse_direntries unable to find direlem for %d", previno); }
                previno=0;  

          
          
          
	  
            } else {
                assert(indoubleslash_mode);
                if (entry.d_namlen>4 && name.substr(0,4)=="LARA" &&
			(!de_LARA || inodeinfo.lookup(elemp->lookup(*name)).getdd() != de_LARA)) {
                    

                    struct LARA_struct& ls = *(struct LARA_struct *)entry.d_name;
                    if(bdmsg2)DB->msg("backdump::parse_direntries ls name:%s num:%d", ls.LARA_name, +ls.LARA_inode);

                    if(inodeinfo.defined(+ls.LARA_inode)) {
                        de_LARA = (DIRELEM_netapp*) inodeinfo.lookup(+ls.LARA_inode).getdd();
                        de_LARA->reset_netapp_LARA(entry.d_namlen);
                    } else {
			Out->msg(WARN, "<8011>backdump::parse_direntries unable to find direlem for LARA %d, name = %s", +ls.LARA_inode, *name);
		    }
                }
                if (de_LARA) {
                    fileref name_data;  
                    name_data.initmem(entry.d_name, entry.d_namlen);
                    de_LARA->add_netapp_LARA(entry.d_namlen, name_data);
                    LARA_count++;
                } else
                    
                    Out->msg(ERR, "<7201>Unknown string in stream '%s'", entry.d_name);
            }
        }

        if (entry.d_ino <= 0) continue;

        
        dumpDIRELEM* den;
        if (!inodeinfo.defined(ino_num)) {  
            den = new dumpDIRELEM;
            inodeinfo.enter(ino_num, den);  
            if(bdmsg2) DB->msg("backdump::parse_direntries inodeinfo.enter(%d, %p) parent:%p", ino_num, den, elemp);




        }









        elemp->enter(name, +entry.d_ino);  
        previno = ino_num;
    }
    return true;
}


void backdump::set_phase(int phasenum) {
    if (phasenum <= phase) return; 
    DB->msg(DBTXT("backdump::set_phase setting phase to %d"), phasenum);

    phase = phasenum;
    switch (phase) {
      case phase_read_tables: Out->msg(INFO, "<6850>Reading tables");                 break;
      case phase_read_dirs:   Out->msg(INFO, "<5942>Reading directories");            break;
      case phase_read_files:  Out->msg(INFO, "<6634>Reading/Writing files");          break;
      case phase_read_acls:   Out->msg(INFO, "<6633>Reading ACLS");                   break;
      case phase_stream_done: Out->msg(INFO, "<5939>End of dump stream reached");     break;
      case phase_write_dirs:  Out->msg(INFO, "<7521>Backing up directories");        break;
      case phase_wait_dirs:   DB->msg(DBTXT("Waiting on nbackdumpdir"));               break;
    }
}







bool backdump::traverse(direlem_assoc_type& inodeinfo, int inodenum, ustring indent, ustring fulldir) {

    if (!inodeinfo.defined(inodenum)) return false;

    if (bdmsg1) DB->msg("%s| %d: %s ------------------------------------\n", *indent, inodenum, *fulldir);

    dumpDIRELEM *elemp = inodeinfo.lookup(inodenum).getdd();   

    if (elemp == NULL) return false;
    if (elemp->was_visited()) {
        Out->msg(FATAL, "<6635>Inode revisited %d", inodenum);
        xflag[2] &= 8192; 
        return false;
    }
    elemp->set_visited(true);
    

    undoo::vector<ustring> names;
    elemp->keys(names);
    for(unsigned int i=0; i<names.size(); i++) {
        ustring name(names[i]);
        int inum(elemp->lookup(name));

        dumpDIRELEM *subelemp = inodeinfo.lookup(inum).getdd();
        if (!inodeinfo.defined(inum) || subelemp == NULL) {
            if (bdmsg1) DB->msg("%s| %13d %s\n", *indent, inum, *name);
            continue;
        }

        if (bdmsg1) DB->msg("%s| %13d %s  %s", *indent, inum, *name, *subelemp->file_hash().partialimage());

        if (name.is_dot_or_dot_dot()) { if (bdmsg1) DB->msg("\n"); continue; }

        
        
        

      
        if (do_fullpath) {
            ustring fullpath(fulldir/name);
            subelemp->set_fullpath(fullpath);  
            traverse(inodeinfo, inum, indent + "  ", fullpath);
        } else {
            traverse(inodeinfo, inum, "", "");
        }
    }
    return true;
}

void backdump::add_directory(DIRELEM& owner, fileref& data) {  
    int ownerinode = owner.inode_number();
    if(ownerinode != 0 && ! clri_map.inuse(ownerinode)) {  
        DB->msg(DBTXT("backdump::add_directory skip dir %d %s"), ownerinode, *owner.name());
        return;
    }
    if(bdmsg2)DB->msg(DBTXT("backdump::add_directory in map %d %s"), ownerinode, *owner.name());
    dumpDIRELEM *dir = inodeinfo.lookup(ownerinode).getdd();
    if(dir == NULL) {
        dir = new dumpDIRELEM(owner);
        inodeinfo.enter(ownerinode, dir);
    }
    DIRELEM::diriterator dit(data);
    DIRELEM de;
    while(dit.next(de)) {
        int inode = de.inode_number();
        if(! clri_map.inuse(inode)) {  
            DB->msg(DBTXT("backdump::add_directory skip %d %s"), inode, *de.name());
            continue;
        }
        dir->enter(de.name(), inode);

        
        if(! inodeinfo.defined(inode)) {
          dumpDIRELEM *e = new dumpDIRELEM(de);
          inodeinfo.enter(inode, e);
        }
    }
}

int backdump::check_for_orphaned_inodes(direlem_assoc_type& inodeinfo)
{
  DB->msg("backdump::check_for_orphaned_inodes");
  int orphans(0);

  undoo::vector<intobj> inodes(inodeinfo.keys());
  for(unsigned int i=0; i<inodes.size(); i++) {
      dumpDIRELEM *tmp = inodeinfo.lookup(inodes[i]).getdd();
      if (tmp != NULL && !tmp->was_visited() && inodes[i] != 0) {
          DB->msg("%3d %13d  %20s %-70s             %s\n", i, +inodes[i], *tmp->file_hash().partialimage(), *tmp->fullpath(), *tmp->name());
          Out->msg(ERR, "<6636>Found orphaned inode in dump stream inode:%d name:'%s'(%s) filesize:%s hash:%s",
                        +inodes[i], *tmp->fullpath(), *tmp->name(), *tmp->file_size().image(), *tmp->file_hash().image());
          orphans++;
      }
  }

  return orphans;
}















#include <algorithm>

#include "common.h"
#include "debug.h"



#include "filenames.h"
#include "restdirlist.h"
#include "inode_table.h"
#include "workelem.h"
#include "backemctarinode2hash.h"
#include "backappend.h"
#include "nbackdata.h"
#include "roothashlist.h"
#include "utar_commands.h"
#include "timer.h"
#include "backhidden.h"
#include "version.h"
#include "context.h"
#include "infofile_info.h"
#if !SYSTEM_WINDOWS
#include "processlock.h"
#endif

using namespace backupboost;


#define db_i2h      ((xflag[02]&33554432)!=0)


backemctar_i2h_hashes::backemctar_i2h_hashes(BackCycle* parent_, workelem* we, hashcode i2h_hash, fileoffset i2h_tablesize)
    : BackCycle(parent_, 0, we),
      m_phase(phase_h_startvolume),
      m_i2h_hash(i2h_hash),
      m_tablesize(i2h_tablesize),
      m_inodetab(NULL)
{
    if (db_i2h) DB->msg("... backemctar_i2h_hashes constructor");
    todoEnqueue(TODO_DIR, this);
}

backemctar_i2h_hashes::backemctar_i2h_hashes(BackCycle* parent_, workelem* we, inode_table* inodetab)
    : BackCycle(parent_, 0, we),
      m_phase(phase_h_startvolume),
      m_inodetab(inodetab)
{
    if (db_i2h) DB->msg("... backemctar_i2h_hashes constructor");
    todoEnqueue(TODO_DIR, this);
}

backemctar_i2h_hashes::~backemctar_i2h_hashes()
{
    if (info != NULL) { 
        if (db_i2h) DB->msg("... backemctar_i2h_hashes::~backemctar_i2h_hashes, delete info");
        delete info;
        info = NULL;
    }
}

void backemctar_i2h_hashes::init() {  
    if (db_i2h) DB->msg("... backemctar_i2h_hashes init for volume '%s'", *info->direlemp->fullpath().image());

    if(cycle *child = new restdirlistproducer(this,
                                              this, 
                                              location(location::media::gsan, info->direlemp->file_hash()),
                                              info->direlemp->get_location(),
                                              ustring::sprintf("backemctar_i2h_hashes of %s", *info->path.image()),
                                              info->dpninx)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
}

void backemctar_i2h_hashes::childdone(cycle *child) {
    if (child) ncollected++;
    if (db_i2h) DB->msg("... backemctar_i2h_hashes: top of childdone for '%s' (phase:%d, nforked:%d, ncollected:%d)",
                        *info->direlemp->fullpath().image(), m_phase, nforked, ncollected);

    switch (m_phase) {
        case phase_h_startvolume : {
            if (nforked == ncollected) {
                
                if (db_i2h) DB->msg("... backemctar_i2h_hashes::childdone, phase_h_startvolume: listing read for volume '%s'", *info->direlemp->fullpath().image());

                
                
                bool found(false);
                direlemp_list_type::const_iterator deiter = m_volume_contents.end();
                while (deiter != m_volume_contents.begin()) {
                    deiter--;
                    DIRELEMp de = *deiter;
                    if (de->name().equal(UNDOO_DIRECTORY_NAME)) {
                        
                        if(cycle *child = new restdirlistproducer(this,
                                                                  this, 
                                                                  location(location::media::gsan, de->file_hash()),
                                                                  de->get_location(),
                                                                  ustring::sprintf("backemctar_i2h_hashes of '.system_info'"),
                                                                  info->dpninx)) {
                            nforked++;
                            child->noop();
                        } else {
                            assert("Could not allocate restdirlistproducer object (with location)" == 0);
                        }
                        child->noop();
                        found = true;
                        break; 
                    }
                }

                if (!found) {
                    if (flags.backupboost_convert) {
                        
                        location parent_loc(info->direlemp->get_location());

                        

                        fileoffset vol_offset(parent_loc.get_abs_offset_in_container() + parent_loc.get_header_size());

                        ucontainer::errortype errcode;
                        
                        if ((errcode = info->container->begindir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                            Out->Abort("Problem creating container begindir for %s (%s)", *info->direlemp->fullpath().image(), *errdesc);
                            return;
                        }
                        
                        if ((errcode = info->container->begindircontent(info->direlemp.getimpl())) != ucontainer::pce__success) {
                            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                            Out->Abort("Problem creating container begindircontent for %s (%s)", *info->direlemp->fullpath().image(), *errdesc);
                            return;
                        }

                        ustring staging_name;
                        main->getAdeMgr()->getStagingPath(staging_name);
                        
                        
                        
                        upath staging_path(upath(staging_name) / ustring::sprintf(CDSF_CONTAINER_TEMPLATE, 2));

                        direlemp_list_type::const_iterator deiter = m_volume_contents.begin();
                        while (deiter != m_volume_contents.end()) {
                            DIRELEMp child_de(*deiter);
                            if (child_de->name().equal(UNDOO_DIRECTORY_NAME)) {
                                child_de->set_hash(hash);
                            } else if (child_de->is_symlink() || child_de->is_device_file()) {
                                
                                
                                
                            } else {
                                udirelemp dest_ude;

                                
                                location child_loc(child_de->get_location());

                                
                                
                                fileoffset offset(vol_offset + child_loc.get_abs_offset_in_container());
                                child_loc.set_abs_offset_in_container(offset);
                                child_de->set_location(child_loc);

                                
                                
                                
                                if ((errcode = info->container->synthobj(child_de.getimpl(), dest_ude, staging_path.image(), false)) != ucontainer::pce__success) {
                                    ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                                    Out->Abort("Problem synthesizing data in container; error: (%s)", *errdesc);
                                    return;
                                }

                                if (child_de->is_directory()) {
                                    
                                    
                                    
                                    fileoffset new_abs_offset(dest_ude->get_location().get_abs_offset_in_container());

                                    
                                    
                                    new_abs_offset += dest_ude->get_location().get_header_size();

                                    if (m_inodetab == NULL) {
                                        Out->Abort("Inode to hash table does not exist, failed to write inode entry for '%s'.", *child_de->fullpath().image());
                                        return;
                                    }

                                    
                                    
                                    
                                    m_inodetab->update_dir_offset(child_de->inode_number64(),
                                                                  new_abs_offset.value(),
                                                                  true,      
                                                                  true,      
                                                                  true       
                                                                  );
                                } else if (child_de->hard_links() > 1 || child_de->is_tar_hardlink()) {
                                    if (m_inodetab == NULL) {
                                        Out->Abort("Inode to hash table does not exist, failed to write inode entry for '%s'.", *child_de->fullpath().image());
                                        return;
                                    }

                                    
                                    
                                    
                                    
                                    m_inodetab->update_dir_offset(child_de->inode_number64(),
                                                                  0,         
                                                                  false      
                                                                  );
                                }
                            }
                            deiter++;
                        }
                        
                        if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
                            Out->Abort("Problem creating container enddir for %s (%s)", *info->direlemp->fullpath().image(), *errdesc);
                            return;
                        }

                        if (m_inodetab == NULL) {
                            Out->Abort("Inode to hash table does not exist, failed to create image.");
                            return;
                        }

                        
                        fileref table_data;
                        table_data.initlist();
                        m_inodetab->image(table_data, m_inodetab->currentversion());

                        
                        
                        main->target_sysinfo_files_and_data.set(info->path.image(), INODE2HASH_TABLE_FILENAME, table_data);

                        
                        DIRELEMp sysinfo_de(new DIRELEM);
                        const epoch_t now((epoch_t)timer::now());
                        sysinfo_de->initialize(hashcode::zero, now, now, now, fileoffset(0), ATTR_DIRECTORY | ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);
                        workelem* w = new workelem(info, sysinfo_de);
                        w->use_container = false;

                        
                        backhidden* hidden = new backhidden(this, w, fileoffset(0), 0, false, false, NULL);
                        nforked++;
                        
                        
                        hidden->set_target_path(info->path.image());

                        m_volume_contents.push_back(sysinfo_de);
                        m_phase = phase_h_volume;
                        return;
                    }
                    Out->msg(ERR,"Problem locating .system_info directory for volume '%s'", *info->direlemp->fullpath().image());
                } else {
                    m_phase = phase_h_sysinfo;
                    childdone(NULL);
                }
            }
            break;
        }

        case phase_h_sysinfo : {
            if (nforked == ncollected) {
                
                if (db_i2h) DB->msg("... backemctar_i2h_hashes childdone, phase_h_sysinfo for volume '%s'", *info->direlemp->fullpath().image());

                
                
                
                direlemp_list_type::const_iterator deiter = m_sysinfo_contents.end();
                while (deiter != m_sysinfo_contents.begin()) {
                    deiter--;
                    if ((*deiter)->name().equal(INODE2HASH_TABLE_FILENAME)) {
                        (*deiter)->set_hash(m_i2h_hash);
                        (*deiter)->set_file_size(m_tablesize);
                        break; 
                    }
                }

                
                fileoffset size = 0;
                m_newhiddendir.initlist(1024);
                m_newhiddendir = build_diratomic(m_sysinfo_contents, size, false, main->getmaxdpncompchunksize(info->dpninx));
                workelem *w = new workelem(NULL, m_newhiddendir);
                w->dpninx = info->dpninx;
                cycle* ch = new nbackdata(this, w, 0, true);
                nforked++;
                ch->noop();
                m_phase = phase_h_volume;
            }
            break;
        }

        case phase_h_volume: { 
            if (db_i2h) DB->msg("... backemctar_i2h_hashes childdone, phase_h_volume for volume '%s'", *info->direlemp->fullpath().image());

            
            
            
            direlemp_list_type::const_iterator deiter = m_volume_contents.end();
            while (deiter != m_volume_contents.begin()) {
                deiter--;
                if ((*deiter)->name().equal(UNDOO_DIRECTORY_NAME)) {
                    (*deiter)->set_hash(hash);
                    break; 
                }
            }

            
            fileoffset size = 0;
            m_newhiddendir.initlist(1024);
            m_newhiddendir = build_diratomic(m_volume_contents, size, false, main->getmaxdpncompchunksize(info->dpninx));
            workelem *w = new workelem(NULL, m_newhiddendir);
            w->dpninx = info->dpninx;
            cycle* ch = new nbackdata(this, w, 0, true);
            nforked++;
            ch->noop();
            m_phase = phase_h_volumedone;
            break;
        }

        case phase_h_volumedone : {  
            if (db_i2h) DB->msg("... backemctar_i2h_hashes::childdone, phase_h_volumedone");
            notifyparent();
            break;
        }
    }  
}



void backemctar_i2h_hashes::rdlpconsume(const direlemp_list_type_sp& direlems, restdirlistproducer * const producer)
{
    assert ((m_phase == phase_h_startvolume) || (m_phase == phase_h_sysinfo));

    if (db_i2h) DB->msg("backemctar_i2h_hashes::consume processing %s direlems in top-level listing for '%s'",
                        *::tostr(direlems->size()), *info->direlemp->fullpath().image());

    if (m_phase == phase_h_startvolume) {
        
        
        if (m_volume_contents.size() == 0) {
            m_volume_contents = *direlems;
        } else {
            direlemp_list_type::const_iterator deiter = direlems->begin();
            while (deiter != direlems->end()) {
                m_volume_contents.push_back(*deiter);
                deiter++;
            }
        }

    } else if (m_phase == phase_h_sysinfo) {
        
        
        
        
        if (m_sysinfo_contents.size() == 0) {
            m_sysinfo_contents = *direlems;
        } else {
            direlemp_list_type::const_iterator deiter = direlems->begin();
            while (deiter != direlems->end()) {
                m_sysinfo_contents.push_back(*deiter);
                deiter++;
            }
        }
    }
}














backemctar_i2h_volume::backemctar_i2h_volume(BackCycle* parent_, workelem* info_, const bool useddr_, const bool is_zfs_backup_)
    : BackCycle(parent_, 0, info_),
      m_phase(phase_vol_init),
      m_inodetab(new inode_table),
      m_hl2pathtab(flags.backupboost_convert ? new hardlink_path_tab : NULL),
      useddr(useddr_),
      is_zfs(is_zfs_backup_),
      target_top_dir(true)
{
    if (db_i2h) DB->msg(">>> backemctar_i2h_volume constructor (volume), path=%s", *info->path.image());
    main->add_insert(TODO_DIR, this, -getDepth());

    m_inodetab->is_zfs_backup = is_zfs;

    
    
    if (useddr){
        DB->msg(">>> backemctar_i2h_volume::backemctar_i2h_volume Setting inodetab.use_inode_tree = true");
        m_inodetab->use_inode_tree = true;

        
        
        if (flags.backupboost_convert) {
            
            
            
            
            
            m_hl2pathtab->set_mount_path_numelems(info->path.numelems());
            return;
        }

        
        
        location loc(info->direlemp->get_location());
        if (db_i2h) DB->msg(">>> backemctar_i2h_volume::backemctar_i2h_volume Resetting offset to '0' (old offset:%s)",
                         *tostr(loc.get_abs_offset_in_container().value()));
        loc.set_abs_offset_in_container(0);
        info->direlemp->set_location(loc, false);
    } else {
        DB->msg(">>> backemctar_i2h_volume::backemctar_i2h_volume Setting inodetab.use_inode_tree = false");
        m_inodetab->use_inode_tree = false;
    }
}



backemctar_i2h_volume::backemctar_i2h_volume(BackCycle* parent_, workelem* info_, inode_table* inodetab_, hardlink_path_tab* hl2pathtab_, const bool useddr_, const bool is_zfs_backup_)
    : BackCycle(parent_, 0, info_),
      m_phase(phase_vol_init),
      m_inodetab(inodetab_),
      m_hl2pathtab(hl2pathtab_),
      useddr(useddr_),
      is_zfs(is_zfs_backup_),
      target_top_dir(false)
{
    if (db_i2h) DB->msg(">>> backemctar_i2h_volume constructor (dir), path=%s, depth=%d", *info->path.image(), getDepth());
    main->add_insert(TODO_DIR, this, -getDepth());
}

backemctar_i2h_volume::~backemctar_i2h_volume()
{
    if (info != NULL) { 
        if (db_i2h) DB->msg(">>> backemctar_i2h_volume::~backemctar_i2_volume, delete info");
        delete info;
        info = NULL;
    }
}

void backemctar_i2h_volume::init()
{
    if (db_i2h) DB->msg(">>> backemctar_i2h_volume::init path:%s", *info->path.image());

    if(cycle *child = new restdirlistproducer(this,
                                              this, 
                                              location(location::media::gsan, info->direlemp->file_hash()),
                                              info->direlemp->get_location(),
                                              ustring::sprintf("backemctar_i2h_volume of %s", *info->path.image()),
                                              info->dpninx)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
    m_phase = phase_vol_read;
}



void backemctar_i2h_volume::childdone(cycle *child)
{
    if (child) ncollected++;
    if (db_i2h) DB->msg(">>> backemctar_i2h_volume: top of childdone for '%s' (phase:%d, nforked:%d, ncollected:%d)",
                        *info->direlemp->fullpath().image(), m_phase, nforked, ncollected);

    
    
    
    
    
    
    
    const bool is_top_level(flags.backupboost_convert ? target_top_dir : !m_vol_sysinfo.isnull());

    switch (m_phase) {
        case phase_vol_read : {
            if (nforked == ncollected) {
                
                
                
                
                if (!is_top_level) {
                    baselocation_sp blp(info->direlemp->get_metadataLocation());
                    const bool metadataId_populated(blp && blp->isFromCatalog());
                    const MetadataId metadataid(metadataId_populated ? blp->getMetadataId() : (MetadataId)info->direlemp->file_hash());

                    ubigint64 hdroffset(0), dataoffset(0), padoffset(0), extattroffset(0);
                    if (is_zfs) {
                        
                        get_end_offsets(info->direlemp, hdroffset, dataoffset, padoffset, extattroffset);
                    }

                    if (m_inodetab->use_inode_tree) {
                        
                        
                        
                        location loc(info->direlemp->get_location());
                        ubigint64 new_dir_offset((ubigint64)(loc.get_header_size() + loc.get_abs_offset_in_container()).value());

                        
                        m_inodetab->add_entry(info->direlemp->inode_number64(), metadataid, info->direlemp->file_size(), true, true,
                                              new_dir_offset, &childlist, 0, 0, hdroffset, dataoffset, padoffset, extattroffset);

                    } else {
                        
                        m_inodetab->add_entry(info->direlemp->inode_number64(), metadataid, info->direlemp->file_size(), true, true,
                                              0, 0, 0, 0, hdroffset, dataoffset, padoffset, extattroffset);
                    }

                    if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume Added directory to inode table: path=%s inode=%s hash=%s size=%s",
                                        *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
                                        *metadataid.partialimage(), *info->direlemp->file_size().image());
                }

                if (db_i2h) DB->msg(">>> backemctar_i2h_volume: at end of phase_vol_read for directory '%s'", *info->direlemp->fullpath().image());
                if (flags.backupboost_convert)
                    m_phase = phase_vol_backupboost;
                else
                    m_phase = phase_vol_write_i2h;
                childdone(NULL);
            }
            break;
        }

        case phase_vol_write_i2h : {   
            if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_write_i2h, file=%s nforked=%d ncollected=%d",
                                *info->direlemp->fullpath().image(), nforked, ncollected);
            if (ncollected == nforked) {
                if (is_top_level) {
                    
                    if (db_i2h) DB->msg(">>> phase_vol_write_i2h: saving inode2hash");
                    if (db_i2h) m_inodetab->debug_dump();
                    fileref table_data;
                    table_data.initlist();
                    m_inodetab->image(table_data, m_inodetab->currentversion()); 
                    m_tablesize = table_data.size64();

                    workelem* w = new workelem(NULL, table_data);
                    w->dpninx = info->dpninx;
                    child = new backappend(this, main, w, table_data, false, 0, af_none, NULL, NULL, true);

                    child->noop();
                    nforked++;
                    m_phase = phase_vol_writehashes;
                    return;

                } else {
                    if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_write_i2h: no children for %s. Done.", *info->direlemp->fullpath().image());
                    notifyparent();
                    return;
                }

            } else {
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume: End of phase_vol_write_i2h, ncollected=%d nforked=%d", ncollected, nforked);
            }
            break;
        }

        case phase_vol_backupboost : {
            if (ncollected == nforked) {
                if (is_top_level) {
                    fileref hl2pathtab_data;
                    hl2pathtab_data.initlist();
                    m_hl2pathtab->image(hl2pathtab_data, m_hl2pathtab->current_version());
                    
                    
                    
                    main->target_sysinfo_files_and_data.set(info->path.image(), HARDLINK_PATH_TABLE_FILENAME, hl2pathtab_data);
                    workelem* w = new workelem(NULL, info->direlemp);
                    w->dpninx = info->dpninx;
                    w->container = info->container;
                    
                    
                    cycle* cptr = new backemctar_i2h_hashes(this, w, m_inodetab);
                    cptr->noop();
                    nforked++;
                    m_phase = phase_vol_done;
                } else {
                    notifyparent();
                    return;
                }
            }
            break;
        }

        case phase_vol_writehashes : { 
            if (ncollected == nforked) {
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_writehashes, file=%s new inode2hash=%s",
                                *info->direlemp->fullpath().image(), *hash.partialimage());
                workelem* w = new workelem(NULL, info->direlemp);
                w->dpninx = info->dpninx;
                cycle* cptr = new backemctar_i2h_hashes(this, w, hash, m_tablesize);  
                cptr->noop();
                nforked++;
            }
            m_phase = phase_vol_done;
            break;
        }

        case phase_vol_done :  {
            if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_done '%s'", *info->direlemp->fullpath().image());
            if (ncollected == nforked) {
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_done, Updating hash for '%s' to %s (old hash: %s)",
                                    *info->direlemp->fullpath().image(), *hash.partialimage(), *info->direlemp->file_hash().partialimage());
                baselocation_sp blp(info->direlemp->get_metadataLocation());
                info->direlemp->set_hash(hash, blp );

                if (is_top_level && NULL != m_inodetab) {
                    if (db_i2h) DB->msg(">>> backemctar_i2h_volume: phase_vol_done, free inode table in top level.");
                    delete m_inodetab;
                    m_inodetab = NULL;
                }
            }
            notifyparent();
            break;
        }

        default : {
            if (db_i2h) DB->msg("backemctar_i2h_volume::childdone: unexpected phase %d", m_phase);
            break;
        }
    }
}


void backemctar_i2h_volume::rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer)
{
    assert (m_phase == phase_vol_read);

    if (db_i2h) DB->msg("backemctar_i2h_volume::consume processing %s direlems of listing data for '%s'",
                        *::tostr(direlems->size()), *info->direlemp->fullpath().image());
    
    direlemp_list_type::const_iterator deiter = direlems->begin();
    while (deiter != direlems->end()) {
        DIRELEMp de = *deiter;
        
        if ((de->is_internal()) && (de->name().equal(UNDOO_DIRECTORY_NAME))) {
            if (db_i2h) DB->msg(">>> backemctar_i2h_volume: Inside check for sysinfo");
            m_vol_sysinfo = de;
            deiter++;
            continue;
        }

        
        if (de->is_directory()) {
            if (m_inodetab->use_inode_tree) {
                
                childlist.add_child(de->inode_number64());
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume: Added inode %s (directory) to childlist. List size=%s",
                                  *tostr(de->inode_number64()), *tostr(childlist.list_size()));
            }

            
            if (de->file_hash() != hashcode::empty) {
                
                workelem* w = new workelem(NULL, de);
                w->dpninx = info->dpninx;
                if (flags.backupboost_convert) {
                    
                    
                    upath full_path = info->direlemp->fullpath() / de->name();
                    w->direlemp->set_fullpath(full_path);
                    
                    
                    
                    w->container = info->container;
                }
                cycle *child = new backemctar_i2h_volume(this, w, m_inodetab, m_hl2pathtab, useddr, is_zfs);    
                child->noop();
                nforked++;

            } else {
                
                
                
                baselocation_sp blp(de->get_metadataLocation());
                const bool metadataId_populated(blp && blp->isFromCatalog());
                const MetadataId metadataid(metadataId_populated ? blp->getMetadataId() : (MetadataId)de->file_hash());

                ubigint64 hdroffset(0), dataoffset(0), padoffset(0), extattroffset(0);
                if (is_zfs) {
                    
                    get_end_offsets(de, hdroffset, dataoffset, padoffset, extattroffset);
                }

                if (m_inodetab->use_inode_tree) {
                    
                    
                    
                    location loc(de->get_location());
                    ubigint64 new_dir_offset((ubigint64)(loc.get_header_size() + loc.get_abs_offset_in_container()).value());

                    
                    m_inodetab->add_entry(de->inode_number64(), metadataid, 0, true, true, new_dir_offset,
                                          0, 0, 0, hdroffset, dataoffset, padoffset, extattroffset);

                } else {
                    
                    m_inodetab->add_entry(de->inode_number64(), metadataid, 0, true, true,
                                          0, 0, 0, 0, hdroffset, dataoffset, padoffset, extattroffset);
                }

                if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume Added empty directory to inode table: path=%s inode=%s hash=%s size=%s",
                                    *de->fullpath().image(), *tostr(de->inode_number64()),
                                    *metadataid.partialimage(), *de->file_size().image());
            }

        } else if ((de->hard_links() > 1)  && (!de->is_tar_hardlink())) {
            
            baselocation_sp blp(de->get_metadataLocation());
            const bool metadataId_populated(blp && blp->isFromCatalog());
            const MetadataId metadataid(metadataId_populated ? blp->getMetadataId() : (MetadataId)de->file_hash());

            ubigint64 hdroffset(0), dataoffset(0), padoffset(0), extattroffset(0);
            if (is_zfs) {
                
                get_end_offsets(de, hdroffset, dataoffset, padoffset, extattroffset);
            }

            if (m_inodetab->use_inode_tree) {
                
                m_inodetab->add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false,
                                      de->get_location().get_abs_offset_in_container().value(), 0, 0, 0,
                                      hdroffset, dataoffset, padoffset, extattroffset);

                
                childlist.add_child(de->inode_number64());
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume: Added inode %s (hardlink) to childlist. List size=%s",
                                    *tostr(de->inode_number64()), *tostr(childlist.list_size()));

            } else {
                
                m_inodetab->add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false,
                                       0, 0, 0, 0, hdroffset, dataoffset, padoffset, extattroffset);
            }

            if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume Added hardlink to inode table: path=%s inode=%s hash=%s size=%s",
                                *de->fullpath().image(), *tostr(de->inode_number64()),
                                *metadataid.partialimage(), *de->file_size().image());

            if (m_hl2pathtab) {
                
                upath hardlink_path(info->direlemp->fullpath() / de->name());
                if (db_i2h) DB->msg(">>> backemctar_i2h_volume::consume Added hardlink to hardlink inode to path table: inode=%s path=%s", *tostr(de->inode_number64()), *hardlink_path.image());
                
                
                
                
                
                m_hl2pathtab->add_path_entry(de->inode_number64(),
                                             hardlink_path,
                                             bbevent::subtype_none,
                                             true,    
                                             true     
                                             );
            }
        }

        deiter++;
    }

    
    childdone(NULL);
}




fileoffset backemctar_i2h_volume::emctar_file_hash_size(const DIRELEM &de)
{
    if (!de.is_stream_slice())
        return de.file_size();

    data_regions::endoffsets_t eoff;
    dirrec_pack::regions rr(&de);
    if (!rr.get(eoff)) {
        
        return fileoffset(0);
    }

    if (eoff.size() == 0) {
        
        return fileoffset(0);
    }

    return eoff.rbegin()->second;
}

void backemctar_i2h_volume::get_end_offsets(DIRELEMp& de, ubigint64 &hdroffset, ubigint64 &dataoffset, ubigint64 &padoffset, ubigint64 &extattroffset)
{
    if (!de->is_dirrec_present(KIND_REGIONS))
        return;

    dirrec_pack::regions drr(de.getimpl());
    data_regions::endoffsets_t eoff;
    if (!drr.get(eoff) || eoff.size() == 0)
        return;

    hdroffset = dataoffset = padoffset = extattroffset = 0;
    for (data_regions::endoffsets_t::iterator itr = eoff.begin(); itr != eoff.end(); itr++) {
        if (itr->first == data_regions::header) hdroffset = itr->second.value();
        else if (itr->first == data_regions::primarydata) dataoffset = itr->second.value();
        else if (itr->first == data_regions::padding) padoffset = itr->second.value();
        else if (itr->first == data_regions::ads) extattroffset = itr->second.value();
    }
}









backemctarinode2hash::backemctarinode2hash(BackCycle* parent_, workelem* info_, location::tbackupid prev_backupid_, const bool useddr_, const bool destroy_workelem_, ubigint64 backupboost_session_id_, const bool is_zfs_backup_)
    : BackCycle(parent_, 0, info_),
      m_phase(phase_top_startvolumes),
      prev_backupid(prev_backupid_),
      useddr(useddr_),
      destroy_workelem(destroy_workelem_),
      is_zfs(is_zfs_backup_),
      backupboost_session_id(backupboost_session_id_)
{
    if (db_i2h) DB->msg(">>> backemctarinode2hash: constructor,  dpn = %d, top hash %s", info->dpninx, *info->direlemp->file_hash().partialimage());
    main->add_insert(TODO_DIR, this, -getDepth());
}

backemctarinode2hash::~backemctarinode2hash()
{
    if (info && destroy_workelem) {    
        delete info;
        info = NULL;
    }
}

void backemctarinode2hash::init()
{
    if (db_i2h) DB->msg(">>> backemctarinode2hash::init path:%s, dpn = %d", *info->path.image(), info->dpninx);
    if(cycle *child = new restdirlistproducer(this,
                                              this, 
                                              location(location::media::gsan, info->direlemp->file_hash()),
                                              info->direlemp->get_location(),
                                              ustring::sprintf("backemctarinode2hash of %s", *info->path.image()),
                                              info->dpninx)) {
        nforked++;
        child->noop();
    } else {
        assert("Could not allocate restdirlistproducer object (with location)" == 0);
    }
    if (flags.backupboost_convert)
        m_phase = phase_backupboost_convert;
    else
        m_phase = phase_top_startvolumes;
}

void backemctarinode2hash::childdone(cycle *child)
{
    if (child) ncollected++;
    if (db_i2h) DB->msg("--- backemctarinode2hash: top of childdone (phase:%d, nforked:%d, ncollected:%d)",
                        m_phase, nforked, ncollected);

    switch (m_phase) {
        case phase_top_startvolumes : {
            if (nforked == ncollected) {
                
                
                
                
                
                if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_startvolumes");

                if (!useddr ||
                    flags.destination_data != client_config_flags::same_destination) {  
                    
                    
                    
                    m_phase = phase_top_write;
                    childdone(NULL);

                } else if (flags.backupboost_convert) {
                    
                    
                    
                    target_work_results work_results;
                    work_results.set_avtar_version(CLIENT_VERSION);
                    work_results.set_ddr_index(flags.ddrindex);
                    target_session_result session_result;
                    session_result.target = info->path.image();
                    session_result.backup_mode = tbackuptype::level0_full.image();
                    session_result.session_id = backupboost_session_id;

                    
                    
                    prectime cur_prec_time(prectime::now());
                    backupboost_backup_time = cur_prec_time.toUnixTime64();
                    session_result.backup_time = backupboost_backup_time;

                    session_result.exit_code = 0;
                    work_results.add_result(session_result);
                    fileref work_results_fref;
                    work_results_fref.initlist(10 * 1024);
                    work_results_fref.append(work_results.image());
                    m_work_results_size = work_results_fref.size64();
                    
                    DIRELEMp work_results_de(new DIRELEM);
                    const epoch_t now((epoch_t)timer::now());
                    work_results_de->initialize(now, now, now, m_work_results_size, ATTR_INTERNAL, WORKRESULTS_FILENAME);
                    m_sysinfo_contents.push_back(work_results_de);
                    workelem* w = new workelem(NULL, work_results_fref);
                    w->dpninx = info->dpninx;
                    
                    cycle* child = new backappend(this, main, w, work_results_fref, false, 0, af_none, NULL, NULL, true); 
                    child->noop();
                    nforked++;

                    
                    
                    const ustring session_id_time_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILENAME);
#if !SYSTEM_WINDOWS
                    const ustring lock_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILELOCK);
                    processlock lock_obj(lock_file);

                    
                    
                    
                    const int max_tries(60);
                    int tries(0);
                    while (!lock_obj.checkandobtainlock()) {
                        if (++tries > max_tries) {
                            Out->msg(WARN, "Unable to get access to file '%s' for mapping session IDs to session times of mount '%s'",
                                       *session_id_time_file, *info->path.image());
                            Out->msg(WARN, "Previous session id and time entries for mount '%s' are overwritten.",
                                       *info->path.image());
                        }
                        Out->msg(INFO, "File '%s' for mapping session IDs to session times of mount '%s' is locked, waiting for "
                                       "release with '%d' tries remaining.",
                                       *session_id_time_file, *info->path.image(), max_tries - tries);
                        uapp::sleep(1000);
                    }
#endif

                    
                    
                    if (!main->session_id_time_table.parse(session_id_time_file))
                        Out->msg(INFO, "Unable to parse file '%s' for mapping session IDs to session times", *session_id_time_file);

                    
                    
                    
                    main->session_id_time_table.remove_target_entry(upath(info->path.image()));

                    
                    
                    
                    main->session_id_time_table.add_session_entry(upath(info->path.image()),
                                                                  backupboost_session_id,
                                                                  backupboost_backup_time);

                    if (main->session_id_time_table.image(session_id_time_file)) {
                        Out->msg(INFO, "BackupBoost backup added session ID: %s and session time: %s of "
                                       "mount path: %s to file '%s' for mapping session IDs to session times",
                                       *tostr(backupboost_session_id),
                                       *tostr(backupboost_backup_time),
                                       *info->path.image(),
                                       *session_id_time_file);
                    } else {
                        Out->msg(ERR, "Unable to write file '%s' for mapping session IDs to session times", *session_id_time_file);
                    }


                    m_phase = phase_work_results;
                } else {
                    
                    
                    if (db_i2h) DB->msg("--- backemctarinode2hash: Attempt to copy DDR files");

                    
                    DIRELEMp de(info->direlemp);
                    de->set_name(CDSF_CONTAINER_1_FILENAME);
                    
                    location loc(de->get_location());
                    loc.set_backupid(prev_backupid);
                    loc.set_containerid(1);
                    loc.setMedia(location::media::ddr);
                    de->set_location(loc, false);

                    
                    
                    const upath objfullpath(upath(de->name()));
                    
                    
                    flags.streamformat_out = utar_flags_enums::streamformat_raw;
                    if(!main->copy_whole_container(NULL, de, objfullpath)) {
                        Out->msg(ERR, "Unable to copy a new container for '%s' using container object '%s' with location '%s'", *objfullpath.image(), *de->fullpath().image(), *loc.image());
                    }

                    
                    DataDomainSysInfo ddrSysInfo;
                    const bool resultOK = main->getAdeMgr()->write_ddrfilesxml(&ddrSysInfo);
                    if(!resultOK) {
                        Out->msg(ERR, "<9918>Internal Error: Cannot obtain DDR files information from Data Domain -- Backup incomplete");
                    } else {
                        
                        
                        
                        m_ddrfiles_name = ddrSysInfo.fileName;
                        m_ddrfiles_size = ddrSysInfo.ddrfilesData.size64();

                        workelem* w = new workelem(NULL, ddrSysInfo.ddrfilesData);
                        w->dpninx = info->dpninx;
                        child = new backappend(this, main, w, ddrSysInfo.ddrfilesData, false, 0, af_none, NULL, NULL, true); 

                        child->noop();
                        nforked++;
                    }
                    m_phase = phase_top_ddrfiles;
                } 
            }

            break;
        } 

        
        case phase_backupboost_convert : {
            if (nforked == ncollected) {
                ustring err_desc;
                DIRELEMp target_de(new DIRELEM);
                const location meta_loc(location::media::gsan, info->direlemp->file_hash());
                hfs_info_struct& hfsInfo = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
                
                
                if (!utar_commands::get_direlem(hfsInfo, cycle::main->get_flags(), meta_loc, info->path, *target_de, err_desc)) {
                    Out->Abort("Failed to perform BackupBoost conversion for %s: %s", *info->path.image(), *err_desc);
                    return;
                }
                DIRELEMp sysinfo_de(new DIRELEM);
                
                
                if (!utar_commands::get_direlem(hfsInfo, cycle::main->get_flags(), meta_loc, upath(UNDOO_DIRECTORY_NAME), *sysinfo_de, err_desc)) {
                    Out->Abort("Failed to perform BackupBoost conversion for %s: %s", *info->path.image(), *err_desc);
                    return;
                }
                
                
                
                
                ustring entified_target(ndmp_entify_volume(info->path.image()));
                target_de->set_name(entified_target);
                m_top_contents.push_back(target_de);
                if (target_de->is_directory() && target_de->file_hash() != hashcode::empty) {
                    workelem* w = new workelem(NULL, target_de);
                    w->dpninx = info->dpninx;
                    w->container = info->container;
                    
                    
                    cycle* child = new backemctar_i2h_volume(this, w, useddr);
                    child->noop();
                    nforked++;
                }
                m_top_contents.push_back(sysinfo_de);
                m_phase = phase_top_startvolumes;
            }
            break;
        }

        
        case phase_work_results : {
            if (nforked == ncollected) {
                main->finalizeucontainer(info->container);
                
                m_work_results_hash = hash;
                DataDomainSysInfo ddrSysInfo;
                const bool resultOK = main->getAdeMgr()->write_ddrfilesxml(&ddrSysInfo);
                if (resultOK) {
                    
                    m_ddrfiles_name = ddrSysInfo.fileName;
                    m_ddrfiles_size = ddrSysInfo.ddrfilesData.size64();
                    DIRELEMp ddr_files_de(new DIRELEM);
                    const epoch_t now((epoch_t)timer::now());
                    ddr_files_de->initialize(now, now, now, ddrSysInfo.ddrfilesData.size64(), ATTR_INTERNAL, m_ddrfiles_name);
                    m_sysinfo_contents.push_back(ddr_files_de);
                    workelem* w = new workelem(NULL, ddrSysInfo.ddrfilesData);
                    w->dpninx = info->dpninx;
                    
                    if (db_i2h) DB->msg("backemctarinode2hash::childdone: phase_work_results, spawn backappend");
                    cycle* child = new backappend(this, main, w, ddrSysInfo.ddrfilesData, false, 0, af_none, NULL, NULL, true);
                    child->noop();
                    nforked++;
                } else {
                    Out->msg(ERR, "Cannot write DDR files information to Data Domain -- Backup incomplete");
                }
                m_phase = phase_top_ddrfiles;
            }
            break;
        }

        case phase_top_ddrfiles : {
            
            assert (useddr);
            if (nforked == ncollected) {
                
                
                if (db_i2h) DB->msg("--- backemctarinode2hash childdone, phase_top_ddrfiles");

                m_ddrfiles_hash = hash;
                if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_ddrfiles, new ddrfiles_hash=%s",
                                    *hash.partialimage());

                
                if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_ddrfiles: Retrieving .system_info contents for snapview");

                
                
                bool found(false);
                direlemp_list_type::const_iterator deiter = m_top_contents.end();
                while (deiter != m_top_contents.begin()) {
                    deiter--;
                    DIRELEMp de = *deiter;
                    if (de->name().equal(UNDOO_DIRECTORY_NAME)) {
                        
                        if(cycle *child = new restdirlistproducer(this,
                                                                  this, 
                                                                  location(location::media::gsan, de->file_hash()),
                                                                  de->get_location(),
                                                                  ustring::sprintf("backemctarinode2hash of '.system_info'"),
                                                                  info->dpninx)) {
                            nforked++;
                            child->noop();
                        } else {
                            assert("Could not allocate restdirlistproducer object (with location)" == 0);
                        }
                        child->noop();
                        found = true;
                        m_snapview_sysinfo = *deiter;  
                        break; 
                    }
                }

                if (!found) {
                    Out->msg(ERR,"Problem locating .system_info directory for snapview");
                } else {
                    m_phase = phase_top_sysinfo;
                    childdone(NULL);
                }
            }
            break;
        } 

        case phase_top_sysinfo : {
            
            assert (useddr);

            if (nforked == ncollected) {
                
                
                if (db_i2h) DB->msg("--- backemctarinode2hash childdone, phase_top_sysinfo");

                
                
                
                if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_sysinfo: Searching for direlem with name: '%s'", *m_ddrfiles_name);
                direlemp_list_type::const_iterator deiter = m_sysinfo_contents.begin();
                while (deiter != m_sysinfo_contents.end()) {
                    DIRELEMp tmp_de(*deiter);
                    if (tmp_de->name().equal(m_ddrfiles_name)) {
                        if (db_i2h) DB->msg("---     Found it: new size:%s, new hash:%s (old hash:%s)",
                                            *tostr(m_ddrfiles_size.value()), *m_ddrfiles_hash.partialimage(), *tmp_de->file_hash().partialimage());
                        tmp_de->set_hash(m_ddrfiles_hash);
                        tmp_de->set_file_size(m_ddrfiles_size);
                    }
                    if (flags.backupboost_convert) {
                        if (tmp_de->name().equal(WORKRESULTS_FILENAME)) {
                            tmp_de->set_hash(m_work_results_hash);
                            tmp_de->set_file_size(m_work_results_size);
                        }
                        if (tmp_de->name().equal(ARCHIVE_INFO_FILENAME)) {
                            infofile_de = tmp_de;
                        }
                        if (tmp_de->name().equal(ARCHIVE_INFO_XML_FILENAME)) {
                            infofile_xml_de = tmp_de;
                        }
                    }
                    deiter++;
                }
                if (flags.backupboost_convert) {
                    
                    
                    
                    utar_commands uc(flags, main->getAdeMgr()->getHfsInfo(dpn0), *main->get_dstflags());
                    uc.get_infofile_obj(*infofile_de, infofile);
                    pidtype pid(pidtype::os_linux, pidtype::backupboost);
                    infofile.pid = pid.name();
                    infofile.pidnum = pid.number();
                    fileref infofile_data;
                    infofile.print_file(infofile_data, NULL);
                    infofile_size = infofile_data.size64();
                    workelem* w = new workelem(NULL, infofile_data);
                    w->dpninx = info->dpninx;
                    
                    cycle* child = new nbackdata(this, w, 0, false);
                    nforked++;
                    child->noop();
                    m_phase = phase_archive_info;
                } else {
                    m_phase = phase_top_write_sysinfo;
                    childdone(NULL);
                }
            }
            break;
        } 

        case phase_archive_info : {
            if (nforked == ncollected) {
                
                infofile_de->set_hash(hash);
                fileref infofile_xml_data;
                infofile.print_file(infofile_xml_data, ARCHIVE_INFO_FILENAME);
                infofile_xml_size = infofile_xml_data.size64();
                workelem* w = new workelem(NULL, infofile_xml_data);
                w->dpninx = info->dpninx;
                
                cycle* child = new nbackdata(this, w, 0, false);
                nforked++;
                child->noop();
                m_phase = phase_top_write_sysinfo;
            }
            break;
        }

        case phase_top_write_sysinfo : {
            if (nforked == ncollected) {
                if (flags.backupboost_convert) {
                    
                    infofile_xml_de->set_hash(hash);
                    infofile_xml_de->set_file_size(infofile_xml_size);
                }
                
                fileoffset size = 0;
                m_newhiddendir.initlist(1024);
                m_newhiddendir = build_diratomic(m_sysinfo_contents, size, false, main->getmaxdpncompchunksize(info->dpninx));
                workelem *w = new workelem(NULL, m_newhiddendir);
                w->dpninx = info->dpninx;
                cycle* ch = new nbackdata(this, w, 0, true);
                nforked++;
                ch->noop();
                m_phase = phase_top_write;
            }
            break;
        }

        case phase_top_write : {  
            if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_write");
            if (nforked == ncollected) {
                if (useddr && !m_snapview_sysinfo.isnull()) {
                    
                    
                    m_snapview_sysinfo->set_hash(hash);
                }

                
                fileoffset size = 0;
                fileref toplevel;
                toplevel.initlist(1024);
                toplevel = build_diratomic(m_top_contents, size, false, main->getmaxdpncompchunksize(info->dpninx));
                workelem *w = new workelem(NULL, toplevel);
                w->dpninx = info->dpninx;
                if (db_i2h) DB->msg("toplevel fileref has %d bytes in it", toplevel.size());
                cycle* ch = new nbackdata(this, w, 0, true);
                nforked++;
                ch->noop();
                m_phase = phase_top_alldone;
            }
            break;
        }

        case phase_top_alldone : {
            if (db_i2h) DB->msg("--- backemctarinode2hash: phase_top_alldone");
            notifyparent();
            return;
            break;
        }
    } 
}



void backemctarinode2hash::rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer)
{
    assert ((m_phase == phase_top_startvolumes) || (m_phase == phase_top_sysinfo) || (m_phase == phase_backupboost_convert));

    if (db_i2h) DB->msg("backemctarinode2hash::consume processing %s direlems in volume list", *::tostr(direlems->size()));

    if (m_phase == phase_top_startvolumes) {
        
        direlemp_list_type::const_iterator deiter = direlems->begin();
        while (deiter != direlems->end()) {
            DIRELEMp de = *deiter;

            
            if (de->is_directory()) {
                if ((de->file_hash() != hashcode::empty) && !(de->name().equal(UNDOO_DIRECTORY_NAME))) {
                    workelem* w = new workelem(NULL, de);
                    w->dpninx = info->dpninx;
                    cycle *child = new backemctar_i2h_volume(this, w, useddr, is_zfs);
                    child->noop();
                    nforked++;
                }

            } else {
                Out->msg(INFO, LOCTXT("Found file [%s] at the volume level, that is not a directory."), *de->name());
            }

            
            
            m_top_contents.push_back(de);

            deiter++;
        }

    } else if (m_phase == phase_top_sysinfo) {
        
        
        
        
        if (m_sysinfo_contents.size() == 0) {
            m_sysinfo_contents = *direlems;
        } else {
            direlemp_list_type::const_iterator deiter = direlems->begin();
            while (deiter != direlems->end()) {
                m_sysinfo_contents.push_back(*deiter);
                deiter++;
            }
        }
    }
}

#if !defined(RESTORE_PREFETCHTHREAD_H_INCLUDED)
#define RESTORE_PREFETCHTHREAD_H_INCLUDED












#include "hashcode.h"
#include "fileref.h"
#include "fileoffset.h"
#include "threadbase.h"
#include "usemaphore.h"
#include "component.h"
#include "queue.h"
#include "context.h"
#include "ringbuffer.h"
#include "ustring.h"
#include "dpnobject.h"
#include "restore_prefetchmanager.h"


class restore_prefetchthread;
struct tprefetchblock;
class prefetchmanager;


class tprefetchwork : public component {
 public:
    tprefetchwork(fileref &result_, const hashcode &h_, bool &isdir_,
                  fileoffset startoff_, fileoffset endoff_)
        : result(result_), h(h_), isdir(isdir_), 
        startoff(startoff_), endoff(endoff_), nexttofill(startoff_),
        resultcode(false) {}
    ~tprefetchwork() {}

    ustring image() const;
    ustring ntfdump() const;
    bool isapplicable(const tprefetchblock &pb) const;
    bool isfull() const { return nexttofill > endoff; }

    void setfull() { nexttofill = endoff + 1; }

    fileref &result;
    const hashcode &h;
    bool &isdir;
    fileoffset startoff, endoff;
    fileoffset nexttofill;
    bool resultcode;

    SAFEALLOC(tprefetchwork);
};


struct tprefetchblock {
    tprefetchblock();
    tprefetchblock(bool initmem);
    ustring image() const;

    hashcode h;
    fileoffset startoff, endoff;
    fileref result;

    SAFEALLOC(tprefetchblock);
};




class restore_prefetchcache {
public:
    restore_prefetchcache(context *main_, 
                          size_t blockcount = 64, 
                          size_t blocksize = 63 * 1024,
                          bool debugmsgs = false);

    
    void fill(tprefetchwork &work);

    
    void prefetch(const undoo::queue &workqueue);

    size_t getblocksize() const { return ringblocksize.ivalue(); }

    SAFEALLOC(restore_prefetchcache);

private:
    friend class restore_prefetchthread;

    
    

    
    

    
    bool apply(const tprefetchblock &block, tprefetchwork &work) const;

    context *main;

    ringbuffer<tprefetchblock> ringbuf;
    const fileoffset ringblocksize; 

    restore_prefetchmanager *cm;
};




class restore_prefetchthread : public threadbase {
public:
    restore_prefetchthread(context *main_, bool debugmsgs = false)
        : threadbase(ustring("prefetcher")), cache(main_),
        workqueue(true), resultqueue(true) 
    {}

    
    void terminate();

    
    virtual void body();

    
    bool read(fileref &data, const hashcode &h, bool &isdir, 
              fileoffset sizehint,
              fileoffset startoff, fileoffset endoff);

    

    
    void hint(const dpnobj *obj);

    SAFEALLOC(restore_prefetchthread);

protected:
    restore_prefetchcache cache;
    undoo::queue workqueue;
    undoo::queue resultqueue;
    semaphore worksem;
    semaphore resultsem;
    semaphore termsem;
};


#endif 
#if !defined(DUMPPIPE_H_INCLUDED)
#define DUMPPIPE_H_INCLUDED












#include "fileref.h"
#include "direlem.h"
#include "ustring.h"
#include "pipe_control.h"

class dumpcontext;



class dumppipe : public pipe_control {
public:
    
    
    dumppipe(fileref& data_, dumpcontext* dumpctx_);

    SAFEALLOC(dumppipe);

protected:

    
    
    
    
    
    bool fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                    const DIRELEM& elem,  const ustring& path,
                    const filetype ftype, const ustring& linkname,
                    const fileoffset startoff=fileoffset(0));

private:
    dumpcontext* dumpctx;

    void do_zero_length_file(const DIRELEM& de, fileref& header);
};

#endif










#include "cycle_test.h"
#include "restdata.h"

fileref rdp_answer;
direlemp_list_type rdlp_answer;











































void cycletest_root::childdone(cycle *child) {
    Out->msg(INFO, "cycletest_root childdone: %s at %p, terminating context::loop via TODO_DONE", typeid(*child).name(), child);
    if (activetest != NULL) {
        activetest->childdone(child);
    }
    main->add(TODO_DONE, NULL);
}


restdata1::restdata1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_)
{
}

cycle * restdata1::spawn ()
{
    assert(!flags.rc_hash.isempty());       
    hashcode hash(flags.rc_hash);

    de.set_hash(hash);
    answer.initlist(1024);
    info = restelem(upath(""), de, filestatsref(), answer);
    cycle *c = new restdata(root, hash, &ctype, false , info, false );
    Out->msg(INFO, "restdata1: Created restdata cycle %p for hashcode %s", c, *hash.image());
    return c;
}

void restdata1::childdone(cycle * child) {
    
}

bool restdata1::check_result(cycle *c)
{
    Out->msg(INFO, "restdata1::check_result fileref answer (%s bytes). Data being dumped to DB", *answer.size64().image());
    answer.hexdump(true);

    
    return true;
}








restdataproducer1::restdataproducer1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_), consume_count(0), byte_count(0)
{
}

cycle * restdataproducer1::spawn ()
{
    assert(!flags.rc_hash.isempty());          
    hashcode hash(flags.rc_hash);

    cycle *c = new restdataproducer(root, hash, fileoffset::unknown, this, true, ustring());
    Out->msg(INFO, "restdataproducer1: Created restdata cycle %p for hashcode %s", c, *hash.image());
    return c;
}

bool restdataproducer1::check_result(cycle *c)
{
    Out->msg(INFO, "restdataproducer1::check_result doesn't know what to check, processed %d buffers for %s bytes total",
             consume_count, *byte_count.image());

    rdp_answer.hexdump(true);
    rdp_answer.free();

    
    return true;
}

void restdataproducer1::rdpconsume(const fileref& buf, const fileoffset& startoff, restdataproducer * const producer)
{
    timer::timerscope ts(testtimes, "rdpconsume");

    Out->msg(INFO, "restdataproducer1::rdpconsume with %s bytes of data at startoff %s:", *buf.size64().image(), *startoff.image());
    if (rdp_answer.isnull()) {
        rdp_answer.initlist(2048);
    }
    rdp_answer.append(buf);
    consume_count++;
    byte_count += buf.size64();
}







restdirlistproducer1::restdirlistproducer1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_), inorder(true), consume_count(0), direlem_count(0)
{
}

cycle * restdirlistproducer1::spawn ()
{
    location fromwhere;

    if (!flags.rc_hash.isempty()) {
        fromwhere = location(location::media::gsan, hashcode(flags.rc_hash));
    }
    else if (!flags.rc_metadataid.isempty()) {
        fromwhere = location(location::media::catalog, MetadataId(flags.rc_metadataid));
    }

    cycle *c = new restdirlistproducer(root, this, fromwhere, location());
    Out->msg(INFO, "%s: Created restdirlistproducer cycle %p for location %s with in-order processing %d",
             typeid(*this).name(), c, *fromwhere.image(), inorder);
    return c;
}

void restdirlistproducer1::rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer)
{
    timer::timerscope ts(testtimes, "rdlpconsume");

    consume_count++;
    direlem_count += direlems->size();

    Out->msg(INFO, "restdirlistproducer1::rdlpconsume call #%d with %s direlems",
             consume_count, *::tostr(direlems->size()));

    
    if (false) {
        int i = 0;
        for (direlemp_list_type::const_iterator it = direlems->begin(); it != direlems->end(); it++) {
            DIRELEMp dep = *it;
            Out->msg(INFO, "DIRELEM %d: %s", i++, *dep->print(dep->fullpath(), false, NULL, NULL, false, 0));
        }
    }

    rdlp_answer.insert(rdlp_answer.end(), direlems->begin(), direlems->end());

}

bool restdirlistproducer1::check_result(cycle *c)
{
    Out->msg(INFO, "%s::check_result doesn't know what to check, processed total of %s direlems in %d consume calls",
             typeid(*this).name(), *::tostr(direlem_count), consume_count);

    int i = 0;
    fileoffset lastdataoffset = fileoffset::unknown;
    for (direlemp_list_type::const_iterator it = rdlp_answer.begin(); it != rdlp_answer.end(); it++) {
        DIRELEMp dep = *it;
        Out->msg(INFO, "DIRELEM %d: %s", ++i, *dep->print(dep->fullpath(), false, NULL, NULL, false, 0));

        
        if (inorder) {
            const location data_loc = dep->get_location();
            if (lastdataoffset == fileoffset::unknown || data_loc.get_abs_offset_in_container() > lastdataoffset) {
                
            }
            else {
                
                assert(!"Data not in order!");
            }
            lastdataoffset = data_loc.get_abs_offset_in_container();
        }
    }
    return true;
}













restdirlist1::restdirlist1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_), consume_count(0), direlem_count(0)  
{
}

cycle * restdirlist1::spawn ()
{
    upath path((flags.args.size() > 1) ? flags.args[1] : "");
    
    fileoffset abscontaineroff((flags.args.size() > 2) ? atol(*flags.args[2]) : 0);

    
    
    
    
    
    
    location parent_loc;
    parent_loc.get_abs_offset_in_container() = abscontaineroff;
    location fromwhere;
    if (!flags.rc_hash.isempty()) {
        fromwhere = location(location::media::gsan, hashcode(flags.rc_hash));
    }
    else if (!flags.rc_metadataid.isempty()) {
        fromwhere = location(location::media::catalog, MetadataId(flags.rc_metadataid));
    }
    cycle *c = new restdirlist(root, fromwhere, path, parent_loc, listing);
    
    
    Out->msg(INFO, "%s: Created restdirlist cycle %p for location %s, path '%s'",
             typeid(*this).name(), c, *fromwhere.image(), *path.image());
    return c;
}

bool restdirlist1::check_result(cycle *c)
{
    Out->msg(INFO, "%s::check_result doesn't know what to check. listing has %d entries",
             typeid(*this).name(), listing.size());

    csustring key;
    DIRELEMp val;
    int num = 0;
    while (++num < 1000 && listing.pop_front(key, val)) {
        Out->msg(INFO, "    %s -> direlemp with addr (%p) and image '%s'", *key, val.getimpl(), *val->name());
    }

    return true;
}






restdirelem1::restdirelem1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_), consume_count(0), casing(CASEUNDETERMINED)
{
}

cycle * restdirelem1::spawn ()
{
    upath path((flags.args.size() > 1) ? flags.args[1] : "");
    
    fileoffset abscontaineroff((flags.args.size() > 2) ? atol(*flags.args[2]) : 0);

    
    
    
    
    
    
    location parent_loc;
    parent_loc.set_abs_offset_in_container(abscontaineroff);
    location fromwhere;
    if (!flags.rc_hash.isempty()) {
        fromwhere = location(location::media::gsan, hashcode(flags.rc_hash));
    }
    else if (!flags.rc_metadataid.isempty()) {
        fromwhere = location(location::media::catalog, MetadataId(flags.rc_metadataid));
    }
    de.set_location(parent_loc);
    de.set_metadataLocation(fromwhere);
    cycle *c = new restdirelem(root, de, path, casing);
    
    
    Out->msg(INFO, "%s: Created restdirelem cycle %p for location %s, path '%s'",
             typeid(*this).name(), c, *fromwhere.image(), *path.image());
    return c;
}


void restdirelem1::childdone(cycle * child) {
    const restdirelem * rde = dynamic_cast<restdirelem *>(child);
    if (rde != NULL) {
        answers = rde->answers;
    }
}

bool restdirelem1::check_result(cycle *c)
{
    DB->msg("restdirelem1 cycle_test results:");
    
    int i = 0;
    direlemp_list_type::iterator it = answers.begin();
    for (; it != answers.end(); it++) {
        DIRELEMp dep = *it;
        DB->msg("%d: %s", i++, *dep->print(dep->fullpath(), false, NULL, NULL, false, false));
    }

    return true;
}


#include <stdlib.h>
persistentlock1::persistentlock1(const utar_flags_info& flags, context *main_, timer *testtimes_)
    : cycle_test(flags, main_, testtimes_), pl(main, flags.path, atol(*flags.args[2]))
{
    Out->msg(INFO, "%s: Created persistent lock with lockid:%s%s", typeid(*this).name(), *flags.path, *flags.args[2]);
    pl.lockit();
    pl.unlock();
}

cycle *persistentlock1::spawn()
{
    Out->msg(INFO, "persistentlock1 doesn't actually spawn a cycle");
    return NULL;
}

bool persistentlock1::check_result(cycle *c)
{
    Out->msg(INFO, "persistentlock1 doesn't know how to check it's results");
    return true;
}





























#include "common.h"
#include "debug.h"
#include "tassoc.h"   
#include "context.h"
#include "restroot.h"
#include "restfile.h"
#include "restonefile.h"
#include "filenames.h"
#include "message.h"
#include "mulqueue.h"
#include "msgqueue.h"
#include "univ.h"
#include "timer.h"
#include "filemap.h"
#include "utar_flags_enums.h"
#include "tarpipe.h"
#include "emctarpipe.h"
#include "isilontarpipe.h"
#include "zfstarpipe.h"
#include "ndmp_volume_entification.h"
#include "pax_container.h"
#include "cdsf_container.h"
#include "raw_container.h"
#include "avpaxpipe.h"
#include "exportstream_xml.h"
#if !defined(AVOID_NETWORKER_INTERFACE)
    #include "legato_interface/savestreampipe.h"
#endif
#include "dumpcontext.h"
#include "restdumpstream.h"
#if SYSTEM_WINDOWS
#include "resource.h"
#endif
#include "utar_commands.h"
#include "msgpack_c.h"
#include "output.h"
#include "memman.h"
#include "synccall.h"   
#include "runstage.h"
#include "userid.h"
#include "workelem.h"    
#include "nbackroot.h"   
#include "backappend.h"  
#include "compelem.h"    
#include "hashserver.h"
#include "ndmp_history.h"
#include "backdump.h"
#include "posixtime.h"
#include "hostinfo.h"
#include "fassoc.h"
#include "backchunk.h"
#include "nbackdir.h"
#include "nbackfile.h"

#include "backstate.h"

#include "ctl_translate.h"
#include "ctl_message.h"
#include "utar_ctl_sup.h"
#include "dumppipe.h"
#include "dpnobj_types.h"
#include "filerefx.h"
#include "ddr_interface.h"
#include "mediadesc.h"
#include "sessionprofile.h"

#include "univ.h"




#include "auto_ptr.h"

#include "restdirpart.h" 
#include "data_regions.h"  
#include "filenames.h"     
#include "acntmngr.h"

#include "location_checker.h"
#include "location.h"

#define KEEP_ALIVE_TIMER (30*60)

#define dbgmsgs                 ((xflag[1]&8)!=0)
#define show_delay_msg          ((xflag[11]&8)!=0)

#define dbg_24121 ((xflag[1]&2097152)!=0)


#define use_async_errorinjector ((xflag[12]&131072)!=0)


#define set_location_info_msg   ((xflag[1]&524288)!=0)

bool operator== (const message &lhs, const message &rhs) {
    return lhs.base == rhs.base;
}







class watchdog_thread : public threadbase {
public:
    watchdog_thread(int cancel_timer_secs_) : cancel_timer_secs(cancel_timer_secs_) { setdesc("watchdog"); }
    ~watchdog_thread();
    SAFEALLOC(watchdog_thread);
private:
    const int cancel_timer_secs;
    semaphore sem;
    semaphore term;
    void body();
};

watchdog_thread::~watchdog_thread()
{
    sem.signal();       
    term.wait(1000);    
}

void watchdog_thread::body()
{
    const int pollrate = 10;                                    

    DB->msg("watchdog thread: cancel_timer_secs=%d, pollrate=%d", cancel_timer_secs, pollrate);

    
    
    epoch_t canceltimeout = 0;
    while(sem.wait(pollrate*1000)) {
        const epoch_t now = TIME32(0);                          

        if ((xflag[27]&256)!=0 || uapp::staging().canRun()) {    
            canceltimeout = 0;
            continue;
        }

        
        if (canceltimeout == 0) {
            canceltimeout = now + cancel_timer_secs;
            DB->msg("watchdog detected cancellation (code=%d) timer set for %d seconds = %s", uapp::staging().getExitCode(), cancel_timer_secs, *tostr(canceltimeout));
        }

        
        
        if (now > canceltimeout) {
            Out->msg(FATAL, "<12477>WATCHDOG TIMEOUT (cancellation exceeded %d secs): Exiting with code=%d", cancel_timer_secs, uapp::staging().getExitCode());
            ::exit(uapp::staging().getExitCode());
        }
    }

    DB->msg("watchdog thread terminating");
    term.signal();
}

void context::start_watchdog(int cancel_timer_secs) {
    if (watchdog == NULL) {
        DB->msg("starting watchdog thread");
        watchdog = new watchdog_thread(cancel_timer_secs);
        watchdog->start();
    }
}



class context::restorecache : public fassoc<hashcode, message, std::equal_to<hashcode> > {
public:
    restorecache(int n, bool cache_atomics_) : fassoc<hashcode, message, std::equal_to<hashcode> >(n), cache_atomics(cache_atomics_) {}
    bool cache_atomics;
    SAFEALLOC(restorecache);
};

context::context(utar_flags_info& flags_)
  : client_ctl_statep(NULL),
    tomato(NULL),
    dto_supp(0),
    state(NULL),
    need_rebuild(false),
    signposts_p(0),
    character_encodings(encodings::filesystem),
    todo_queue(NULL),
    flags(flags_),
    dstflags(NULL),
    location_info_required(true),
    ddr_loc_info_ignored(false),
    syslog(flags.syslog),
    in_async_mode(false),
    cycles_running(false),
    adeMgr(NULL),
    dpn1flags(NULL),
    loop_activelimit(TODO_MAX),
    use_container_cache(false),
    use_container_objcache(false),
    update_file_cache(true),
    backupboost_threaded_backup(false),
    ucontainer_streamindex(1),
    checkinfo(NULL)              
{
    
    

    for (int i=0; i<maxdpns; i++) {
        dpn_stats_type[i] = backupstats; 
        maxdirelemsize[i] = 0;
    }

    sendthread = NULL;
    recvqueue = NULL;
    sendqueue = NULL;
    hashsrv = NULL;
    histsrv = NULL;
    files_in_process = 0;
    num_open_files = 0;
    num_open_dirs = 0;

    my_clientid = cidtype::none;
    contextopened = false;
    numthreads = 0;
    watchdog = NULL;
    ppipe_control = NULL;
    pdumpcontext = NULL;
    pbackdump = NULL;
    pbackview = NULL;
    shuttingdown = false;
    asyncthread = NULL;
    retrythread = NULL;
    nextserial = 0;
    tunecounter = 0;
    sendcount = 0;
    pendcount = 0;
    outputthrottles = 0;
    keep_alive_timer = KEEP_ALIVE_TIMER;
    system_info_files = false;
    syslog = false;
    numfileACLstripped = 0;
    numdirACLstripped = 0;
    for(int i = 0; i < 2; i++) {
        prefetch_bytes[i] = 0;
        prefetch_count[i] = 0;
    }
    curtime = TIME32(0);
    warntime = TIME32(0);
    curfile = upath();  
    curisdir = false;
    dolocalstats = false;
    wasted_cpu_throttling_ms = 0;
    encmode = fileref::encmode_none;
    backupconfighash = hashcode::empty;
    encrypthash = hashcode::empty;
}

SAFEBODY(context);








void context::set_backupconfighash() {
    backupconfighash = hashcode::empty;
    encrypthash      = hashcode::empty;

    
    

    if(encmode != fileref::encmode_none) {
        assert(enckey.size() > 0);              

        fileref backupconfig;
        backupconfig.initlist(256);             
        backupconfig.append(encmode);           
        backupconfig.append(enckey);            
        backupconfig.binhash(encrypthash);      

        

        backupconfig.binhash(backupconfighash);
        DB->msg("Backupconfighash=%s", *backupconfighash.partialimage());
    }
}


#if SYSTEM_WINDOWS
    #define SAAS_LIB "SaasCLib.dll"
#elif SYSTEM_UNIX_HPUX
    #define SAAS_LIB "libSaasCLib.sl"
#else
    #define SAAS_LIB "libSaasCLib.so"
#endif






void context::get_data_at_rest_encryption_key(const ustring path)
{
    encmode = fileref::encmode_none;

    
    if(!load_and_use_saas_library(path, SAAS_LIB))
        Out->msg(ERR, "<7357>Initialization failure");        

    
    assert(encmode == fileref::encmode_none || enckey.size() == fileref::enckeysize[encmode]);

    if(encmode != fileref::encmode_none)
        Out->msg(INFO, "<7358>Using %s encryption for user data", *fileref::encmode_image(encmode));

}





bool context::engageADE(utar_flags_info* dpn1flags)
{
    if(adeMgr != NULL) {      
        DB->msg("context::engageADE AdeMgr already enabled");
        return(true);
    }

    
    
    if (flags.ddrenabled) {
        
        
        
        
        
        
        if ((flags.create && !flags.makeview) &&
            (flags.pluginid.kind() == pidtype::ostackimage || flags.pluginid.kind() == pidtype::hypervvss) &&
            flags.isexplicit("streamformat-out") && flags.streamformat_out == utar_flags_enums::streamformat_raw) {
            Out->msg(INFO, "EngageADE enabling ADEChunker for %s backup, create:%d streamformat_out:%d extract:%d pluginid:%s replicate:%d",
                     *flags.pluginid.imagex(), flags.create, flags.streamformat_out, flags.extract, *flags.pluginid.imagex(), flags.replicate);
            flags.adechunker = true;
        } else if (((flags.create && !flags.makeview) || flags.extract) && (flags.pluginid.kind() == pidtype::vcbimage)) 
        {
            Out->msg(INFO, "EngageADE enabling ADEChunker, create:%d streamformat_out:%d extract:%d pluginid:%s replicate:%d",
                         flags.create, flags.streamformat_out, flags.extract, *flags.pluginid.imagex(), flags.replicate);
            flags.adechunker = true;

            if(flags.extract) flags.streamformat_in=utar_flags_enums::streamformat_raw;
        } else if (!flags.isexplicit("adechunker")) {   
            Out->msg(INFO, "EngageADE disabling ADEChunker, create:%d streamformat_out:%d extract:%d pluginid:%s replicate:%d",
                     flags.create, flags.streamformat_out, flags.extract, *flags.pluginid.imagex(), flags.replicate);
            flags.adechunker = false;
        }
    }
    DB->msg("context::engageAde setting adechunker to %d", flags.adechunker);

    
    
    
    if(dpn1flags != NULL) Out->msg(INFO, "<9931>Secondary flags: %s", *dpn1flags->parsed_flags);
    if(! flags.logfilename.isempty()) Out->msg(INFO, 2, "<8474>Log file path: %s", *flags.logfilename);
    adeMgr = new ADEMgrX(this, flags, dpn1flags);
    int result = 0;
    if(flags.adechunker) {
        Out->msg(INFO, "<8475>Initializing connections with chunker");
        result = adeMgr->sendFlagsToADE(true, dpn1flags);
        assert(adeMgr->ADEChunkerEnabled());
    } else {
        Out->msg(INFO, "<6555>Initializing connection");
        result = adeMgr->sendFlagsToADE(false, dpn1flags);      
        assert(!adeMgr->ADEChunkerEnabled());
    }

    adeMgr->setGlobalContext(this); 

    if(result != EXIT_OK) {  
        DB->msg("context::engageADE: sendFlagsToADE failed");
        disengageADE();
        return(false);
    }
    result = adeMgr->startupADE();
    if(result != EXIT_OK) {  
        DB->msg("context::engageADE: adeMgr->startupADE() failed");
        disengageADE();
        return(false);
    }

    this->dpn1flags = dpn1flags;        
    DB->msg("New adeMgr=%p", adeMgr);

    assert(!flags.adechunker || ADEChunkerEnabled());
    return(true);   
}

bool context::ADEChunkerEnabled()
{
    if (adeMgr) return adeMgr->ADEChunkerEnabled();
    return false;
}



bool context::enableADEChunker(hfs_info_struct &hfs_info)
{
    if(adeMgr != NULL && adeMgr->ADEChunkerEnabled()) {
        DB->msg("context::enableADEChunker: ADE chunker already enabled, doing nothing");
        return true;
    }

    assert(!flags.adechunker);  
    flags.adechunker = true;

    if (adeMgr != NULL) {
        DB->msg("context::enableADEChunker: Shutting down ADE");
        disengageADE();
    }

    DB->msg("context::enableADEChunker: Restarting ADE with Chunker enabled");
    if (!engageADE(dpn1flags)) {
        DB->msg("context::enableADEChunker failed!");
        return false;
    }
    hfs_info = adeMgr->getHfsInfo(dpn0);
    return true;
}




void context::disengageADE()
{
    if(containercache.initialized())
        containercache.clear();
    if(adeMgr != NULL) {
        DB->msg("context::disengageADE: Shutting down adeMgr=%p", adeMgr);
        adeMgr->shutdownADE();
        delete adeMgr;
        adeMgr = NULL;
    }
}

static void show_type_sizes()   
{
    int  intval=0x44434241;     
    char chrval[5];             
    memset(&chrval, 0, sizeof(chrval));
    memcpy(&chrval, &intval, 4);

    DB->msg("sizeof(univbool)=%"Z"d, sizeof(char)=%"Z"d, sizeof(int)=%"Z"d, sizeof(long)=%"Z"d, sizeof(long long)=%"Z"d, sizeof(double)=%"Z"d, sizeof(void*)=%"Z"d, sizeof(size_t)=%"Z"d, byteorder=%s",
            sizeof(univbool), sizeof(char), sizeof(int), sizeof(long), sizeof(long long), sizeof(double), sizeof(void*), sizeof(size_t), chrval);
    DB->msg("sizeof(context)=%"Z"d, sizeof(msg)=%"Z"d, sizeof(DIRELEM)=%"Z"d, sizeof(mtex)=%"Z"d, sizeof(safeint)=%"Z"d, sizeof(countptr)=%"Z"d",
            sizeof(context), sizeof(msg), sizeof(DIRELEM), sizeof(mtex), sizeof(safeint), sizeof(countptr));
    DB->msg("sizeof(univbool)=%"Z"d, sizeof(univint16)=%"Z"d, sizeof(univuns16)=%"Z"d, sizeof(univuns24)=%"Z"d, sizeof(univint)=%"Z"d, sizeof(univuns)=%"Z"d",
            sizeof(univbool), sizeof(univint16), sizeof(univuns16), sizeof(univuns24), sizeof(univint), sizeof(univuns));
    DB->msg("sizeof(univuns40)=%"Z"d, sizeof(univuns48)=%"Z"d, sizeof(univuns56)=%"Z"d, sizeof(univint64)=%"Z"d, sizeof(univdbl)=%"Z"d",
            sizeof(univuns40), sizeof(univuns48), sizeof(univuns56), sizeof(univint64), sizeof(univdbl));
    DB->msg("sizeof(cycle)=%"Z"d, sizeof(backchunk)=%"Z"d, sizeof(nbackdir)=%"Z"d, sizeof(nbackfile)=%"Z"d, sizeof(backstate)=%"Z"d, sizeof(workelem)=%"Z"d, sizeof(backstats)=%"Z"d",
            sizeof(cycle), sizeof(backchunk), sizeof(nbackdir), sizeof(nbackfile), sizeof(backstate), sizeof(workelem), sizeof(backstats));

    assert(sizeof(bool)==1 || sizeof(bool)==4); 
    assert(sizeof(char)==1);
    assert(sizeof(int)==4);
    assert(sizeof(long)==4 || sizeof(long)==8);
    assert(sizeof(double)==8);

    assert(sizeof(univbool)==1);
    assert(sizeof(univint16)==2);
    assert(sizeof(univuns16)==2);
    assert(sizeof(univuns24)==3);
    assert(sizeof(univint)==4);
    assert(sizeof(univuns)==4);
    assert(sizeof(univuns40)==5);
    assert(sizeof(univuns48)==6);
    assert(sizeof(univuns56)==7);
    assert(sizeof(univint64)==8);
    assert(sizeof(univdbl)==8);
}





bool context::init(cidtype clientid)
{
    
    if (todo_queue != NULL)
        return true;

    syslog = flags.syslog;

    this->contextopened = true;
    this->my_clientid   = clientid;
    this->numthreads = -1;

    todo_queue = new mulqueue(TODO_MAX);

    if(!flags.adechunker) {
        if(flags.hashthreads != 0)
            hashsrv = new hashserver(flags.hashthreads, this);
    }



#ifdef FORTRESS
    
    get_data_at_rest_encryption_key(flags.sysdir);
#endif

    
    
    set_backupconfighash();

    show_type_sizes();          

    return true;
}


void context::initializeavtarwork(const int streamindex)
{
    
    assert(false);
}

const ustring context::create_gsanfullpath(const bool honorobjpath, const ustring& prefix, const ustring& objpath) const
{
    
    if(honorobjpath) {
        const upath prefixupath(prefix, upath::kind_gsan);
        upath objupath(objpath, upath::kind_gsan);
        if(!prefixupath.isempty()) {
            objupath.set_begin_dirsep(false);
        }
        return (prefixupath / objupath).imagexml().chop();
    }
    
    
    
    
    return "";
}

ucontainer::basep context::initnextucontainer(const DIRELEMp& containerobj,
                                              bool honorcontainerpath,
                                              bool add_to_ddrfilesxml )
{
    DB->msg("context::initnextucontainer '%s' with honorpath:%d called while ucontainer_streamindex:%d",
            *containerobj->fullpath().imagexml(), honorcontainerpath, +ucontainer_streamindex);
    ucontainer::basep result;

    

        const location::tcontainerid ucontainerid(allocate_ucontainer_streamindex());

        switch (flags.streamformat_out) {

        case utar_flags_enums::streamformat_avpax: {
            int paxflags = ucontainer::base::flags_generate_stream | ucontainer::base::flags_nondir_is_file;
            
            Out->msg(INFO, 2, "Creating pax format container on %s", *flags.media_out);
            result = new pax_container(flags.media_out, paxflags, location::media::pipe, ucontainerid); 
            break;
        }

        case utar_flags_enums::streamformat_cdsf: {
            long paxflags = ucontainer::base::flags_generate_stream | ucontainer::base::flags_nondir_is_file;

            if(flags.ddrenabled || (dstflags && dstflags->ddrenabled)) {
                assert(flags.create || flags.replicate);

                
                
                bool is_ndmp = false;
                
                
                
                bool creating_ndmp_temp_container = false;

                if (flags.pluginid.kind() == pidtype::ndmp) {
                    is_ndmp = true;
                    if ((ucontainerid==1) && flags.incremental &&
                        
                        
                        flags.streamformat_in != utar_flags_enums::streamformat_dump) {
                        creating_ndmp_temp_container = true;
                    }
                }

                const mediadesc mediad(flags.media_out);

                ustring lsu;
                ustring containerpath;
                ustring containername;

                
                
                if (!mediad.getpath().isempty()) {

                    lsu = mediad.get_lsu();

                    if (lsu.isempty())
                    {
                        lsu = ddr_interface::default_lsu;
                    }

                    if (mediad.getmedia() == location::media::ddr)
                    {

                        if (!mediad.get_ddr_parts(containerpath, containername))
                        {
                            
                            break;
                        }

                        
                    }
                    else { 
                        this->getAdeMgr()->getStagingPath(containerpath);
                        containername = mediad.getpath();
                    }
                }
                else {

                    lsu = ddr_interface::default_lsu;

                    
                    this->getAdeMgr()->getStagingPath(containerpath);

                    
                    containername = ustring::sprintf(CDSF_CONTAINER_TEMPLATE, ucontainerid);
                }

                assert(!containerpath.isempty() && !containername.isempty());

                
                
                int ddrHandle = 0;
                this->getAdeMgr()->get_ddrhandle( ddrHandle );

                
                
                
                
                
                if (creating_ndmp_temp_container) {
                    containername = TEMP_CONTAINER_FILENAME;
                }

                
                fileref cdsffr;
                DB->msg("context::initnextucontainer calling initddrwrite(frf, %d, %s, %s, %s) for new container",
                        ddrHandle, *lsu, *containerpath, *containername);
                ddr_interface::initddrwrite(cdsffr, ddrHandle, lsu, containerpath, containername);

                Out->msg(INFO, 2, "Creating cdsf format container '%s' on media type '%s'", *containername, *location::media::image(mediad.getmedia()));

                
                const hfs_info_struct& tmpHfsInfo = adeMgr->getHfsInfo(dpn0);  

                
                
                result = new cdsf_container(cdsffr, paxflags, location::media::ddr, ucontainerid,
                                            (is_ndmp ? NULL : tmpHfsInfo.metaStore));
                result->set_ddrhandle(ddrHandle);  

                
                dpns dpninx = (flags.destination_data == client_config_flags::gsan_to_ddr)? dpn1:dpn0;
                const hfs_info_struct& hfsInfo = adeMgr->getHfsInfo(dpninx);  
                DB->msg("context::initnextucontainer dpn=%d hfsInfo.clientid=%s hfsInfo.location=%s", dpninx, *hfsInfo.clientid.image(), *hfsInfo.clientidhash.image());

                
                result->set_clientid(hfsInfo.clientidhash.image());  

                if (!hfsInfo.clientidhash.image().ishexstring()) Out->msg(ERR, "Invalid client id '%s'", *hfsInfo.clientid.image());
                

                
                
                
                
                if (add_to_ddrfilesxml && !creating_ndmp_temp_container) {
                    scope s(ddrfiles_xml_mutex);

                    
                    

                    const ustring gsanfullpath(create_gsanfullpath(honorcontainerpath, flags.backup_prefix, containerobj->fullpath().imagexml()));
                    exitcodes_t res = this->getAdeMgr()->add_ddrfilesxml_entry(location::tformat::cdsf, *containername, ucontainerid, *gsanfullpath);
                    DB->msg("context::initnextucontainer did add_ddrfilesxml_entry(CDSF, %s, %d, %s), got %d",
                            *containername, ucontainerid, *gsanfullpath, res);
                } else {
                    DB->msg("context::initnextucontainer not calling add_ddrfilesxml_entry for '%s'",
                            *containername);
                    result->set_finalized();  
                }

            } else {
                Out->msg(INFO, LOCTXT("Creating cdsf_container for non-ddr backup use with stream descriptor --media-out == '%s'"),
                         *flags.media_out);

                
                result = new cdsf_container(flags.media_out, paxflags, location::media::disk, ucontainerid);

                if (flags.incremental) {
                    stringlist prevbackups;
                    ucontainer::errortype errcode;
                    
                    prevbackups.push_back("/usr/local/avamar/base.cdsf");
                    if ((errcode = ucontainerp_yucky_global->set_diskmedia_container_list(prevbackups)) != ucontainer::pce__success) {
                        Out->Abort("context::initnextucontainer: Problem calling set_diskmedia_container_list (%s)",
                                *ucontainer::error_description(errcode));
                        break;
                    }
                }
            }

            break;
        }

        case utar_flags_enums::streamformat_raw:
            if(!flags.ddrenabled && !(dstflags && dstflags->ddrenabled) && !flags.makeview) {
                flags.streamformat_out = utar_flags_enums::streamformat_none;
                Out->msg(WARN, "Changed streamformat-out to %s since raw format is only for DDR use", *utar_flags_info::streamformat_image(flags.streamformat_out));
                break;
            }
            

            
            
            
            
            
            
            
            
            
            
        default:
            Out->msg(INFO, "During %s, --streamformat-out == %d, no ucontainer object created.",
                     flags.create?"backup":flags.replicate?"replication":"restore", flags.streamformat_out); 
            break;
        }



    return result;
}






void context::finalizeucontainer(ucontainer::basep container, bool writeddrfilesxml)
{
    
    if(!container.isnull()) {
        const int streamindex(container->containerid);
        DB->msg("context::finalizeucontainer ucontainer:%p, containerid:%d writeddrfilesxml:%d isbackup?%d ddrenabled:%d",
                container.getimpl(), streamindex, writeddrfilesxml, flags.create, flags.ddrenabled);

        
        
        
        
        bool ndmp_tar_backup = (flags.streamformat_in == utar_flags_enums::streamformat_emctar) ||
                               (flags.streamformat_in == utar_flags_enums::streamformat_isilon) ||
                               (flags.streamformat_in == utar_flags_enums::streamformat_zfs);
        if(flags.destination_data == client_config_flags::gsan_to_ddr)
            add_ddr_stats(context::restorestats, container->transport);
        else if (!ndmp_tar_backup || !flags.incremental) {
            add_ddr_stats(context::backupstats, container->transport);
        }

        container->close_container(); 

        if(!container->is_finalized()) {
            scope s(ddrfiles_xml_mutex);

            this->getAdeMgr()->finalize_ddrfilesxml_entry( streamindex );
            container->set_finalized();  
        }
    }

    
    
    
    
    if ((flags.ddrenabled || (dstflags && dstflags->ddrenabled)) && (NULL != adeMgr) && writeddrfilesxml) {
        DB->msg("context::finalizeucontainer is writing ddrfiles.xml");

        
        
        DataDomainSysInfo ddrSysInfo;
        const bool resultOK = this->getAdeMgr()->write_ddrfilesxml(&ddrSysInfo);
        if(!resultOK) {
            Out->msg(ERR, "<9918>Internal Error: Cannot obtain DDR files information from Data Domain -- Backup incomplete");
        }
    }
}





void context::switchcontainers(BackCycle *cy, cycle *child) {
    
    
    assert(ucontainerp_yucky_global.isnull());
    assert(cy);
    assert(cy->getInfo());
    assert(!cy->getInfo()->container.isnull());

    
    assert (flags.create && (flags.streamformat_out == utar_flags_enums::streamformat_cdsf));

    
    location::tbackupid  saved_backupid = cy->getInfo()->container->get_previous_backupid();

    
    BackCycle *p = cy;
    workelem *pi = p->getInfo();

    
    
    
    
    if (pi && (!pi->container.isnull())) {
        add_ddr_stats(context::backupstats, pi->container->transport);
    }

    int cnt=0;
    DB->msg("context::switchcontainer for cycle:%p from childdone for child:%p, starting w/ cy->getInfo()->container->getrefcount():%d, deleting ucontainer pointers from cycle stack workelems:",
            p, child, (cy->getInfo()->container.isnull() ? -1 : cy->getInfo()->container.getimpl()->getrefcount()));
    {
        BackCycle *cp = dynamic_cast<BackCycle*>(child);
        if (cp) {
            workelem *cpi = cp->getInfo();
            DB->msg("%p %s, info %p, cont:%p",
                    cp, NAMEOF(*cp), cpi, (cpi ? cpi->container.getimpl() : NULL));
            if (cpi) {
                if (cpi->container == cy->getInfo()->container) {
                    DB->msg("    closing ucontainer from child workelem");
                    cpi->container->close_container();
                    DB->msg("    deleting container from child workelem");
                    cpi->container = NULL;
                } else {
                    if (cpi->container != NULL) {
                        Out->msg(ERR, "Attempting to switch to final ucontainer DDR file, child cycle container does not match parent cycle container!");
                    } else {
                        
                        
                        DB->msg("context::switchcontainer  No child container to close.  This is likely an incremental backup with no data change.");
                    }
                }
                
            }
        }
    }

    while (p) {
        DB->msg("%d %p %s, info %p, info->use_container:%d info->container:%p",
                cnt, p, NAMEOF(*p), pi, (pi?pi->use_container:-1), (pi?pi->container.getimpl():NULL));
        if (pi && (!pi->container.isnull())) {
            DB->msg("    deleting pi->container");
            pi->container = NULL;
            cnt++;
        }
        p = dynamic_cast<BackCycle*>(p->parent);
        pi = (p ? p->getInfo() : NULL);
    }

    
    
    

    
    ustring location;
    this->getAdeMgr()->getStagingPath(location);

    
    
    int ddrHandle = 0;
    this->getAdeMgr()->get_ddrhandle( ddrHandle );

    const ustring containername(flags.media_out.isempty() ? CDSF_CONTAINER_1_FILENAME : flags.media_out);

    
    fileref temp_cdsffr;
    ddr_interface::initddrwrite(temp_cdsffr, ddrHandle, location, containername);

    
    long paxflags = ucontainer::base::flags_generate_stream | ucontainer::base::flags_nondir_is_file;
    int streamindex(1);  
    ucontainer::basep newcontainer = new cdsf_container(temp_cdsffr, paxflags, location::media::ddr, streamindex);
    newcontainer->set_ddrhandle(ddrHandle);  

    
    hfs_info_struct& hfsInfo = adeMgr->getHfsInfo(dpn0);  
    newcontainer->set_clientid(hfsInfo.clientidhash.image());  
    if (!hfsInfo.clientidhash.image().ishexstring()) Out->msg(ERR, "Invalid client id '%s'", *hfsInfo.clientidhash.image());

    
    
    if (flags.backupstate != utar_flags_enums::backstate_partial) {
        scope s(ddrfiles_xml_mutex);

        const ustring gsanfullpath("");
        exitcodes_t res = this->getAdeMgr()->add_ddrfilesxml_entry(location::tformat::cdsf, *containername, streamindex, *gsanfullpath);
        DB->msg("context::switchcontainer did add_ddrfilesxml_entry(CDSF, %s, %d, %s), got %d",
                *containername, streamindex, *gsanfullpath, res);
    } else {
        DB->msg("context::switchcontainer not calling add_ddrfilesxml_entry for '%s'",
                *containername);
        newcontainer->set_finalized();  
    }

    
    newcontainer->set_previous_backupid(saved_backupid);

    
    p = cy;
    int reset_cnt=0;
    while (p && reset_cnt < cnt) {
        workelem* pi = p->getInfo();
        assert(NULL != pi);
        Out->msg(INFO, "%d %p, info %p, info->use_container:%d setting info->container:%p to %p",
                 reset_cnt, p, pi, pi->use_container, pi->container.getimpl(), newcontainer.getimpl());
        pi->container = newcontainer;
        p = dynamic_cast<BackCycle*>(p->parent);
        reset_cnt++;
    }
    
}

void context::print_path(DIRELEM& direlem) {
    if( Out->is_enabled(VERBOSE) && uapp::staging().canRun()) {
        if( Out->is_enabled(VERBOSE, 2) ) {
            Out->msg(VERBOSE, "%s", *direlem.print(direlem.fullpath(), true, userid::instance(), groupid::instance(), false, false ));
        } else {
            Out->msg(VERBOSE, "%s", *direlem.fullpath().image());
        }
    }
}


void context::print_path_and_hash(DIRELEM& direlem, hashcode hash) {
    if( Out->is_enabled(VERBOSE) && uapp::staging().canRun()) {
        
        
        ustring hash_and_name(ustring::sprintf("[%s] %s", *hash.image().substr(0, BYTES_IN_HASH), *direlem.fullpath().image()));
        if( Out->is_enabled(VERBOSE, 2) ) {
            Out->msg(VERBOSE, "%s", *direlem.print((upath)hash_and_name, true, userid::instance(), groupid::instance(), false, false ));
        } else {
            Out->msg(VERBOSE, "%s", *hash_and_name);
        }
    }
}

xml_messagep context::get_errorsummary_xml(const int exitcode)
{
    return Out->get_errorsummary_xml(exitcode);
}

void testreport(todo_kind k, todoelem *t) {
    if (t && (k == TODO_DONE || k == TODO_DONE_SYNC)) {
        DB->msg (DBTXT("context::add queueing           %p %s"), t, *t->ximage());
    }
}




void context::add(todo_kind kind, cycle *cy, bool error) {
    
    assert(cy == NULL || cy->getThreadNbr() == -1);
    todoelem *t = new todoelem(kind, error, cy);
    todo_queue->enqueue(kind, t);
}




void context::add(todo_kind kind, cycle *cy, message& outargs, bool error) {
    
    assert(cy == NULL || cy->getThreadNbr() == -1);
    
    todoelem *t = new todoelem(kind, error, cy);
    t->outargs = outargs;
    assert(kind <= TODO_CHUNK);           
    todo_queue->enqueue(kind, t);
}


void context::add_insert(todo_kind kind, cycle *cy, bigint64 ordinal, bool error) {
    
    assert(cy == NULL || cy->getThreadNbr() == -1);
    todoelem *t = new todoelem(kind, error, cy);
    t->cycle_priority = ordinal;

    if(xflag[11]&16) DB->msg( "context::add_insert kind=%d, cycle=%p, ordinal=%"LL"d", kind, cy, ordinal);
    todo_queue->insert(kind, t);
}






void context::safesetactivelimit(int n, const ustring& debug_append , const bool set_loop_limit ) {
    const bool debug((xflag[1]&8) > 0);

    
    if(n < 0 || n >= TODO_MAX) {
        if(debug) DB->msg( "resetactivelimit %s", *debug_append );
        todo_queue->resetactivelimit();
    } else {
        if(debug) DB->msg( "setactivelimit %s %s", *todoelem::image(n), *debug_append );
        todo_queue->setactivelimit(n);
    }
    if(set_loop_limit) {
        loop_activelimit = n;
    }
}










backstats *context::getstatsobj(context::statstype st) {
    assert(st >= 0 && st < statstypenum);
    
    
    
    return &ctx_stats[st >= 0 && st < statstypenum ? st : statstypenum];
}

void context::set_dpn_statstype(dpns dpninx, statstype st) {
    assert(st >= 0 && st < statstypenum);
    assert(dpninx >= 0 && dpninx < maxdpns);
    dpn_stats_type[dpninx] = st;
}

context::statstype context::get_dpn_statstype(dpns dpninx) {
    assert(dpninx >= 0 && dpninx < maxdpns);
    return dpninx >= 0 && dpninx < maxdpns ? dpn_stats_type[dpninx] : backupstats;
}

void context::byteprogress(statstype st, backstats::reason why, double size,
                           const filestatsref& fstats ,
                           chunktype kind ) {
    getstatsobj(st)->byteprogress(why, size, fstats, kind, system_info_files);
}

void context::add_ddr_stats(statstype st, const fileref& transport) {
    
    ubigint64 postcompbytes = 0, redundantbytes = 0;
    
    transport.ddrstats(filebase::DDR_POST_COMPRESSION_BYTES, postcompbytes, filebase::DDRSTAT_PRIORITY_NOW);
    
    transport.ddrstats(filebase::DDR_REDUNDANT_BYTES, redundantbytes, filebase::DDRSTAT_PRIORITY_NOW);

    
    getstatsobj(st)->update(stats::ddsent, static_cast<double> (postcompbytes), chunktype::atomic, system_info_files);
    getstatsobj(st)->update(stats::ddpresent, static_cast<double> (redundantbytes), chunktype::atomic, system_info_files);
}

void context::addfilebytes(statstype st, double size) {
    if (!system_info_files) {
        if (dbgmsgs) DB->msg("context::addfilebytes type %d bytes %.0f", st,  size);
        getstatsobj(st)->add_filebytes_primary(size);
    }
}

void context::addprogbytes(statstype st, double size) {
    if (!system_info_files) {
        if (dbgmsgs) DB->msg("context::addprogbytes type %d bytes %.0f", st,  size);
        getstatsobj(st)->add_filebytes_prog(size);
    }
}

void context::addfilecount(statstype st, double n) {
    if(! system_info_files)
        getstatsobj(st)->add_filecount(n);
}

void context::addfilepercentnew(statstype st, double sz, double n) {
    if(! system_info_files)
        getstatsobj(st)->add_filepercentnew(sz, n);
}

void context::remotecall(cycle *cy, message& inargs, int connection) {
    assert(adeMgr);
    if(!adeMgr->ADEChunkerEnabled()) {
        
        
        if (inargs.isclientinternalmessage(false)) {
            if(hashsrv != NULL && inargs.requestcode() == CLIENTONLY_COMPUTEHASH)
                hashsrv->send(inargs);
            else {
                
                DB->error(DBTXT("context::remotecall: Cannot process internal client message: %s"), *inargs.ximage());
            }
            return;
        }
    } else assert(inargs.requestcode() != CLIENTONLY_COMPUTEHASH);

    if(connection == -1) 
        connection = dpn0;
    adeMgr->remoteAsyncCall(inargs, cy, (dpns)connection);
}






bool context::open_progresslog() {
    if(flags.progresslog.isempty()) {
        DB->msg(DBTXT("No log file name given for progress log."));
        if(!this->progresslog.isnull())
            this->progresslog.free();
        return false;
    }
    else {
        if(this->progresslog.isnull()) {
            this->progresslog.initdisk(flags.progresslog, fileoffset(-1), filemap::write, true, true);
            if(this->progresslog.iserror()){
            DB->msg(DBTXT("Could not open \"%s\" as progress log file"), *flags.progresslog);
            this->progresslog.free();
                return false;
            }
        }
        return true;
    }
}





#define CPU_THROTTLE_SECS 1.0

class cpu_throttle {
public:
    cpu_throttle(int goal);     
    int check_cputime();        

private:
    int pollcnt;                
    int pollinterval;           
    int polls;                  
    double lastpoll;            
    double m_dTimeOfLastCpuSample; 
    double m_dCumulativeCpuTimeAtLastPoll; 
    double m_dPrevDelay;          
    int cpu_goal;               
    sum_timer sumt;             
};

cpu_throttle::cpu_throttle(int goal)
    : pollcnt(0), pollinterval(1000), polls(0), lastpoll(timer::now()), cpu_goal(goal)
{
    m_dCumulativeCpuTimeAtLastPoll = sumt.total_cputime();
    m_dTimeOfLastCpuSample = sumt.elapsed();
    m_dPrevDelay = 0;
    sumt.request_update();      
}







int cpu_throttle::check_cputime() {
    sumt.check_cputime_update("check_cputime"); 

    
    if(cpu_goal < 1 || (++pollcnt) % pollinterval != 0) return 0;

    
    int delms = 0;
    const double nowtime = timer::now();
    const double actualpoll = nowtime - lastpoll;
    polls++;
    if(actualpoll >= CPU_THROTTLE_SECS) {
        

        
        pollinterval = pollcnt;
        if(actualpoll/CPU_THROTTLE_SECS > 2) pollinterval = (int)(pollcnt/(actualpoll/CPU_THROTTLE_SECS));
        if(pollinterval <= 0) pollinterval = 1;

        const double wallclock = timer::elapsed();      

#if SYSTEM_WINDOWS
        
        double dCpuPercentDuringLastPeriod = sumt.getCpuUsage();
        const double dNow = sumt.elapsed();
        const double dSampleInterval = (dNow - m_dTimeOfLastCpuSample); 

#else
        const double cpu = sumt.total_cputime();        
        const double dNow = sumt.elapsed();
        const double dSampleInterval = (dNow - m_dTimeOfLastCpuSample); 
        double dCpuPercentDuringLastPeriod = 1.0;
        if( dSampleInterval > 0.09) { 
            
            dCpuPercentDuringLastPeriod = (cpu - m_dCumulativeCpuTimeAtLastPoll) / dSampleInterval * 100.0;
        }
        m_dCumulativeCpuTimeAtLastPoll = cpu; 
#endif
        m_dTimeOfLastCpuSample = dNow; 

        sumt.request_update(); 

        const double dPrevRunTime = dSampleInterval - m_dPrevDelay;
        double dDesiredRunTime = dPrevRunTime;
        if(dCpuPercentDuringLastPeriod > 0)
            dDesiredRunTime = dPrevRunTime * ((double)cpu_goal / dCpuPercentDuringLastPeriod);
        const double raw_delay = dSampleInterval - dDesiredRunTime;
        const double MAX_DELAY = 60.0; 
        const double delay = (raw_delay > MAX_DELAY) ? MAX_DELAY : ((raw_delay > 0) ? raw_delay : 0);

        if(delay > 0) {
            delms = static_cast<int>(delay) * 1000;
            if(show_delay_msg) {
                DB->msg("cpu_throttle::check_cputime: dPrevRunTime=%0.1f, dDesiredRunTime=%0.1f, dCpuPercentDuringLastPeriod=%0.1f, dSampleInterval=%0.1f, m_dPrevDelay=%0.1f, delay=%0.1f",
                        dPrevRunTime, dDesiredRunTime, dCpuPercentDuringLastPeriod, dSampleInterval, m_dPrevDelay, delay);
                Out->msg(INFO, "<6590>CPUTIME: pollinterval=%d, polls=%d, wallclock=%0.2f, elapsed=%0.2f cpu=%0.2f, usage=%0.1f%%, delaying %d ms",
                         pollinterval, polls, wallclock, dSampleInterval, m_dCumulativeCpuTimeAtLastPoll, dCpuPercentDuringLastPeriod, delms);
            }

            
            if (delms > 0) {
                uapp::sleep(delms);
                if (show_delay_msg) DB->msg("cpu_throttle::check_cputime: woke up");
            }
        }

        m_dPrevDelay = delay;           
        lastpoll = timer::now();        
        pollcnt = 0;
    }
    return delms;
}

bool context::process_pause_request(debug::pause_t *&pause_request)
{
     if (pause_request == NULL) return false;

     
     if (pause_request->changed()) {
         pause_request->reset_changed();
         if (pause_request->enabled()) {
             Out->msg(INFO, "<8644>External pause request received.");
         } else {
             Out->msg(INFO, "<8645>External resume request received.  Paused for %0.0f seconds.", pause_request->lifetime());
         }
     }

     
     if (!uapp::staging().canRun()) pause_request->request_disable();

     
     if (pause_request->expired()) {
         Out->msg(INFO, "<8646>Pause exceeded maxium of %0.0f seconds.  Automatically resuming.", pause_request->max_seconds());
         pause_request->request_disable();
     }

     if(!pause_request->enabled()) {
         DB->delete_pause_request();
         return false;
     }

     return true;
 }

int context::get_pending_size()
{
    assert(adeMgr != NULL);
    PendingQueueStats pendingstats;
    adeMgr->get_PendingQueueStats(pendingstats);
    return pendingstats.numExtMsgs;
}




void context::calculate_and_set_activelimit(const bool async_mode)
{
    const bool debug = (xflag[1]&8) > 0;

    assert(adeMgr != NULL);
    PendingQueueStats pendingstats;
    adeMgr->get_PendingQueueStats(pendingstats);

    const int GCOMMGR_QUEUE_LIMIT = 200;    

    const int maxpending = pendingstats.maxPending;
    const int gcom_queued = pendingstats.numGcomQueued;
    const int ext_msgs = pendingstats.numExtMsgs;
    const int int_msgs = pendingstats.numIntMsgs + (hashsrv==NULL?0:hashsrv->num_inprocess());
    const int all_msgs = gcom_queued + ext_msgs + int_msgs;



    
    int server_pending = ext_msgs;

    
    const bool output_pipe_full(isOutputPipeFull(server_pending > maxpending));

    

    const bool too_many_internal(int_msgs >= flags.maxintpending);

    if(debug)
        DB->msg(DBTXT("gcom_queued=%d, server_pending=%d, maxpending=%d, int_pending=%d, all_pending=%d, files_in_process=%d, num_open_files=%d, num_open_dirs=%d, output_full=%d, internal_full=%d"),
                      gcom_queued, server_pending, maxpending, int_msgs, all_msgs, files_in_process.value(), num_open_files.value(), num_open_dirs.value(), output_pipe_full, too_many_internal );

   
    todo_kind kindlimit = TODO_MAX;
    ustring append("");

    if( server_pending >= maxpending || output_pipe_full || too_many_internal || gcom_queued > GCOMMGR_QUEUE_LIMIT) {
        kindlimit = TODO_DONE_SYNC;
    } else if( need_rebuild ) {
        append = DBTXT(" because rebuild needed");
        kindlimit = TODO_DONE_SYNC;
    } else if( files_in_process.value() >  flags.maxparallelfiles ||                            
              (flags.maxopenfiles > 0 && num_open_files.value()  >= flags.maxopenfiles) ) {     
        
        
        
        
        
        
        kindlimit = TODO_FILE_CACHE;
    } else if(DB->pause_request != NULL && process_pause_request(DB->pause_request)) {
         kindlimit = TODO_FILE_CACHE;

    } else if( num_open_dirs.value() >= flags.maxopendirs && ext_msgs > 0) {     
        
        
        kindlimit = loop_activelimit.value();
        if(kindlimit < 0 || kindlimit > TODO_HARD_LINK) kindlimit = TODO_HARD_LINK;             

    } else {
        kindlimit = loop_activelimit.value();
        
    }

    
    safesetactivelimit(kindlimit, append);

    
    if(server_pending == 0 && todo_queue->length()==0 && !async_mode) {
        
        if(curtime >= warntime) {
            if(all_msgs > 0)
                DB->msg(DBTXT("context::loop: Nothing pending on server, only internal work (pending all=%d, ext=%d, int=%d)"), all_msgs, ext_msgs, int_msgs);
            else
                DB->msg(DBTXT("context::loop: Probable deadlock: No work to do and nothing pending on server."));
            warntime = curtime+5;
        }
    } else {
        warntime = curtime+5;
    }
}




























bool context::loop(bool async_mode, cycle* target_cycle) {
    bool done = false;
    bool error = false;
    bool debug = (xflag[1]&8) > 0;
    need_rebuild = false;

    if(adeMgr == NULL) return(false);
    
    if(in_async_mode) {
        DB->msg(DBTXT("ERROR: context::loop() called again while in async mode"));
        assert(false);
        return false;
    }
    if(async_mode) in_async_mode = true;

    cycles_running = true;
    
    
    
    
    mulqueue* previous_todo_queue = NULL;
    int queueIndex = adeMgr->registerQueue(true , todo_queue, &previous_todo_queue);
    if(debug) DB->msg("context::loop start, registered queue=%p, prevqueue=%p", todo_queue, previous_todo_queue);
    
    cpu_throttle throttle(flags.cpu_throttle);
    while(! done) {
        

        wasted_cpu_throttling_ms += (double)throttle.check_cputime();

        if(!uapp::staging().canRun(RSTAGE_WRAPUP)) {
            
            
            DB->msg("aborting context loop (%s)", *uapp::staging().getRunStageImage());
            done = true;
            
            break;
        }

        
        assert(adeMgr != NULL);
        if (adeMgr->ADEChunkerEnabled()) {
            
            
            
            
            adeMgr->throttleCheck(queueIndex, loop_activelimit.value());
        } else {
            
            calculate_and_set_activelimit(async_mode);
        }

        
        
        todoelem *t = (todoelem *)todo_queue->dequeue();
        if(t == NULL) {
            if(debug) DB->msg(DBTXT("Queue is empty"));
            continue;
        }

        const todo_kind k = t->kind;
        if( debug )
            DB->msg( DBTXT("context::loop kind:%s(%d) cycle:%p"), *t->image(), k, t->cy );

        
        if(k == TODO_RESPONSE) {
            message outargs = t->outargs;
            

            if(t->cy != NULL && t->cy != EMPTYCYCLE) {  
                if(debug) DB->msg(DBTXT("context::loop response serial=%d"), +outargs.head().serial);
                t->cy->response(outargs);
            }

        } else if(k == TODO_DONE || k == TODO_DONE_SYNC ) {
            
            
            
            if(async_mode) {
                if(t->cy != NULL && t->cy->cb != NULL) {
                  
                    assert(async_mode);
                    assert(t->cy->cb->notify((size_t)t->cy->size.value(), t->todo_error));
                    if(k == TODO_DONE) delete t->cy;  
                    delete t;
                    continue;
                }
            }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            if (backupboost_threaded_backup && target_cycle != NULL && target_cycle != t->cy) {
                todo_queue->insert(k, t);
                threadbase::yield();
                continue;
            } else {
                error = t->todo_error;
                done = true;
            }
        } else {
            assert(k == TODO_CHUNK || k == TODO_FILE || TODO_FILE_CACHE ||
                   k == TODO_HARD_LINK || k == TODO_DIR );
            

            
            
            threadbase::yield();

            if( t->cy != NULL ) {
                
                t->cy->init();
            } else {
                DB->msg( DBTXT("context::loop Tried to execute init of a NULL cycle") );
            }
        }

        delete t;
    }

    
    
    
    
    if (adeMgr != NULL) {
        
        if(previous_todo_queue != NULL) {
            if(debug) DB->msg(DBTXT("context::loop() -- re-registering main queue=%p"), previous_todo_queue);
            adeMgr->registerQueue(true , previous_todo_queue, NULL);
        }
        else {
            if(debug) DB->msg(DBTXT("context::loop() -- unregistering main queue"));
            adeMgr->unregisterQueue(queueIndex);
        }
    }
    cycles_running = false;

    location_checker_summary(); 

    if(debug)
        DB->msg(DBTXT("context::loop returning %d"), error);
    
    
    return error;
}




bool context::backup_orphaned_file(const fileref &data, hashcode &hash, bool isdir, fileoffset &size) {
    bool debug = (xflag[1]&8) > 0;

    if(debug) DB->msg ("context::backup_orphaned_file++");
    workelem *w = new workelem(NULL, data);
    w->isapi = true;
    w->isdir = isdir;

    BackCycle *empty_parent = new BackCycle((BackCycle*)NULL, this);
    empty_parent->setautodelete(false);

    
    backappend *b = new backappend(empty_parent, this, w, data, isdir, 0, af_axionfs);
    
    b->noop();
    bool error = loop();

    hash = empty_parent->hash;
    empty_parent->deleteself();
    size = w->size;
    delete w;

    if(debug) DB->msg(DBTXT("backup_orphaned_file returns %s error:%s"), *hash.partialimage(), error ? "true" : "false");
    return error;
}






bool context::restore_dir(const location& metadataLocation, const upath& target, const DIRELEM *de, const location parentloc ) {
    assert(!in_async_mode);     
    if(de!=NULL) {
        DB->msg("context::restore_dir name:%s parentloc:%s", *de->fullpath().image(), *parentloc.image());
        DB->msg("context::restore_dir de.loc_image:%s", *de->loc_image());
        DB->msg("context::restore_dir metadataloc:%s", *metadataLocation.image());
    }
    restroot *rst = new restroot(metadataLocation, *this, target, flags.mapi, de, parentloc);
    rst->noop();
    const bool error = loop();
    return !error;
}


xml_messagep context::retrieve_existing_backup_info_xml(const location& theLoc, const upath path)
{
    xml_messagep retp;

    const context::prep_for_sysinfo context_is_now_prepped(*this);

    DIRELEM de;
    ustring errstr;
    if(utar_commands::get_direlem(getAdeMgr()->getHfsInfo(dpn0),
                                  flags,
                                  theLoc,
                                  path,
                                  de,
                                  errstr)) {
        fileref xmldata;
        chunktype ctype;
        if(restore_gsanonly_file(xmldata, de.file_hash(), &ctype)) {
            const xml_messagep xmlp = new xml_message();
            if(!xmlp.isnull()) {
                
                if(xmlp->parse(xmldata) && xmlp->valid()) {
                    retp = xmlp;
                }
            }
        }

        if(retp.isnull()) {
            DB->msg("context::retrieve_existing_backup_info_xml Unable to retrieve '%s' as xml", *path.image());
        }
    }

    return retp;
}




xml_messagep context::gather_existing_backup_info_xml(const location& theLoc, const BackupRootInfo* brip,
                                                      fileref ddrwrite )
{
    exportstream_xmlp metainfop = new exportstream_xml();

    if(!metainfop.isnull()) {
        
        metainfop->add_section(exportstream_xml::section::archive_info,
                               retrieve_existing_backup_info_xml(theLoc,
                                                                 upath(ustring(UNDOO_DIRECTORY_NAME) / ustring(ARCHIVE_INFO_XML_FILENAME))));

        

        
        {
            const xml_messagep gsan_files_xml(retrieve_existing_backup_info_xml(theLoc,
                                                                                upath(ustring(UNDOO_DIRECTORY_NAME) / ustring(DATADOMAINFILES_FILENAME))));
            if(!gsan_files_xml.isnull()) {
                
                xml_messagep gsan_files_sectionp(new xml_message(exportstream_xml::section(exportstream_xml::section::ddr_files_xml_gsan).image()));
                if(!gsan_files_sectionp.isnull()) {
                    
                    gsan_files_sectionp->children.push_back(gsan_files_xml);

                    metainfop->add_section(exportstream_xml::section::ddr_files_xml_gsan, gsan_files_sectionp);
                }
            }
        }

        
        int ddrHandle = -1;
        this->getAdeMgr()->get_ddrhandle(ddrHandle);
        if(ddrHandle > 0) {
            
            DataDomainSysInfo ddrSysInfo;
            getAdeMgr()->getSysInfo(ddrSysInfo);

            const location::tbackupid ddr_backupid(ddrSysInfo.hexBackupTime);
            const hfs_info_struct& hfs_info(adeMgr->getHfsInfo(dpn0));
            const ddrfiles_xmlp ddrfiles(ddr_interface::get_ddr_files(ddrHandle, hfs_info.clientidhash.image(), ddr_backupid));
            if(!ddrfiles.isnull()) {
                
                xml_messagep ddr_files_sectionp(new xml_message(exportstream_xml::section(exportstream_xml::section::ddr_files_xml_ddr).image()));
                if(!ddr_files_sectionp.isnull()) {
                    const xml_messagep ddrxml(new xml_message(ddrfiles->simage(), true));

                    
                    ddr_files_sectionp->children.push_back(ddrxml);

                    metainfop->add_section(exportstream_xml::section::ddr_files_xml_ddr, ddr_files_sectionp);

                    
                    
                    
                    if((flags.dtoexportstream && flags.streamformat_out == utar_flags_enums::streamformat_cdsf) ||
                       flags.nemoresurrect) {
                        
                        if(ddrwrite.base()) {
                            record_basefiles(ddrHandle, hfs_info.clientidhash.image(), ddr_backupid,
                                             ddrfiles, flags.exportbasefilecount, ddrwrite);
                        }
                    }
                }
            }
        }

        
        metainfop->add_section(exportstream_xml::section::workorder,
                               retrieve_existing_backup_info_xml(theLoc,
                                                                 upath(ustring(UNDOO_DIRECTORY_NAME) / ustring(WORKORDER_FILENAME))));

        
        {
            hfs_info_struct& hfsinfo = getAdeMgr()->getHfsInfo(dpn0);
            utar_flags_info dstflags;  
            utar_commands utar(flags, hfsinfo, dstflags);
            if(!brip) {
                BackupRootInfo onebackup;
                (void)utar.pick_backup(onebackup);
                metainfop->add_section(exportstream_xml::section::backup,
                                       utar.backuprootinfo_to_xml(onebackup, true));
            } else {
                metainfop->add_section(exportstream_xml::section::backup,
                                       utar.backuprootinfo_to_xml(*brip, true));
            }
        }

        
        
        {
            xml_messagep locp = new xml_message(exportstream_xml::section(exportstream_xml::section::location).image());
            if(!locp.isnull()) {
                locp->enter("path", flags.path);
                locp->enter("hfsaddr", flags.hfsaddr);

                
                metainfop->add_section(exportstream_xml::section::location, locp);
            }
        }

        
        {
            const buildinfo build(AVTAR_EXENAME, buildinfo::client_version);
            const xml_messagep buildxmlp(build.xmlmess());

            
            metainfop->add_section(exportstream_xml::section::build,
                                   buildxmlp);
        }

        
        metainfop->add_section(exportstream_xml::section::flagsettings,
                               flags.printflags_xml(*exportstream_xml::section(exportstream_xml::section::flagsettings).image(), false));

        
        {
            const xml_messagep cmdlinexmlp(new xml_message(exportstream_xml::section(exportstream_xml::section::commandline).image()));
            if(!cmdlinexmlp.isnull()) {
                cmdlinexmlp->enter("progname", flags.progname);

                fileref cmdline;
                cmdline.initmem(flags.parsed_flags);
                cmdlinexmlp->entervalue(cmdline);

                
                metainfop->add_section(exportstream_xml::section::commandline, cmdlinexmlp);
            }
        }

        return metainfop->to_xmlp();
    }

    return 0;
}


void context::record_basefiles(const int ddrhandle, const ustring& clientid, const location::tbackupid backupid,
                               const ddrfiles_xmlp ddrfiles, const int file_count, fileref& ddrwrite) const
{
    if(!ddrfiles.isnull() && file_count > 0 && !ddrwrite.isnull()) {
        
        ddrfiles_xml::emd_elementv sorted(ddrfiles->queryFilesizeSortedEmds());

        if(!sorted.empty()) {
            
            std::reverse(sorted.begin(), sorted.end());

            size_t count(sorted.size() > static_cast<size_t>(file_count) ? file_count : sorted.size());

            undoo::vector<emd_elementp>::const_iterator it = sorted.begin();
            while(it != sorted.end() && count-- > 0 && (fileoffset((*it)->fileSize) >= fileoffset(flags.exportbasefileminsize*1024*1024))) {
                const location::tcontainerid containerid((*it)->streamIndex);

                Out->msg(INFO, "Recording previous backup DDR file %s, containerid %u, size %s as base file",
                         *(*it)->DDRFileName, containerid, *tostr((*it)->fileSize));

                fileref containerfr;
                ddr_interface::initddrread(containerfr,
                                           ddrhandle, ddrwrite,
                                           clientid,     
                                           +backupid, containerid, ddrfiles);
                ddrwrite.append(containerfr.makeslice64(fileoffset(0), fileoffset(0)));

                ++it;
            }
        }
    }
}

bool context::restore_tarpipe(const location& theLoc,
                              const userid  *uidmap,
                              const groupid *gidmap,
                              const ustring& filename,
                              const ustring& target,
                              const bool isdir
) {
    if (skipfifoonrestore) {
        Out->msg(INFO, "<12480>Skipping FIFO files during Celerra NDMP restore because of --x20=1024 flag.");
    }

    DB->msg("context::restore_tarpipe");
    assert(!in_async_mode);     

    
    
    fileref res;

    bool startedfilepipeasync = false;
    
    location::tbackupid ddr_backupid(0);
    int ddrHandle = -1;
    
    fileref ddrwrite;

    
    if (flags.streamformat_out == utar_flags_enums::streamformat_emctar) {
        ustring pathprefix(target);
        if (flags.ndmp_prefix.isempty() && MULTIPATH_RESTORE) {
            pathprefix = "";
        } else {
            
            
            
            pathprefix = ndmp_unentify_volume(flags.ndmp_prefix);
        }
        ppipe_control = new emctarpipe(res, uidmap, gidmap, pathprefix, flags.celerrai18n, flags.isexplicit("celerrai18n"), flags.ndmp_prefix);
    } else if (flags.streamformat_out == utar_flags_enums::streamformat_savestream) {
#if !defined(AVOID_NETWORKER_INTERFACE)
        ppipe_control = new savestreampipe(flags, res, uidmap, gidmap, target);
#else
        Out->msg(ERR, "<7525>Savestream format not supported on this platform");
#endif
    } else if (flags.streamformat_out == utar_flags_enums::streamformat_avpax ||
               flags.streamformat_out == utar_flags_enums::streamformat_cdsf) {
        
        ustring clientid;

        
        
        
        
        if(flags.streamformat_out == utar_flags_enums::streamformat_cdsf) {
            
            
            mediadesc mediad(flags.media_out);

            
            if(mediad.getmedia() == location::media::ddr) {
                ustring stagingPath;

                if (mediad.get_lsu().isempty())
                {
                    
                    this->getAdeMgr()->getStagingPath(stagingPath);
                }
                else
                {
                    
                    ustring path(mediad.getpath());

                    stagingPath = path.get_dotdot();
                }

                
                mediadesc::set_ddr_stagingdir(stagingPath);

                
                
                this->getAdeMgr()->get_ddrhandle(ddrHandle);

                mediad.ddrwritepipe(ddrHandle);

                
                const hfs_info_struct& hfsInfo = adeMgr->getHfsInfo(dpn0);  
                clientid = hfsInfo.clientid.image();

                
                
                if(flags.dtoexportstream) {
                    DataDomainSysInfo ddrSysInfo;

                    
                    getAdeMgr()->getSysInfo(ddrSysInfo);

                    
                    ddr_backupid = ddrSysInfo.hexBackupTime;

                    
                    clientid = ddrSysInfo.clientID;
                }
            }

            
            if(!mediad.init_fileref(res, true)) {
                Out->msg(ERR, "Unable to initialize transport '%s'", *flags.media_out);
            } else {
                
                ddrwrite = mediad.get_ddrwrite();
            }
        }

        
        ppipe_control = new avpaxpipe(res, flags.streamformat_out, flags.media_out,
                                      (ucontainer::base::flags_generate_stream |
                                       (flags.dtoexportstream ? (ucontainer::base::flags_nondir_is_file | ucontainer::base::flags_generate_flatten_direlem_on_descend) : ucontainer::base::flags_null) |
                                       (flags.archive_unfiltered_data ? ucontainer::base::flags_archive_unfiltered_data : 0) |
                                       ucontainer::base::flags_objnames_only),
                                      ddrHandle, clientid, ddr_backupid, ddrwrite,
                                      flags.restorebuffermb
                                      );
        startedfilepipeasync = (flags.restorebuffermb > 0);

        
        
        
        
        
        
        
        
        if(ppipe_control && flags.archive_unfiltered_data) {
            ppipe_control->set_archive_unfiltered_data();
        }
    } else if (flags.streamformat_out == utar_flags_enums::streamformat_isilon) {
        ppipe_control = new isilontarpipe(res);
    } else if (flags.streamformat_out == utar_flags_enums::streamformat_zfs) {
        ppipe_control = new zfstarpipe(res);
    } else {
        ppipe_control = new tarpipe(res, uidmap, gidmap, target,
                                    flags.streamformat_out, flags.stream_blocksize,
                                    flags.changeblockmap);
        if(ppipe_control && flags.archive_unfiltered_data) {
            ppipe_control->set_archive_unfiltered_data();
        }
    }

    assert(ppipe_control);

    if(!isdir) {
        
        
        
        
        Out->msg(FATAL, "<7540>Not-implemented: Restoring a single file to tar stream");
        return false;
    }

    
    
    bool ret(false);
    if(ppipe_control && ppipe_control->init_fileref(flags.media_out,
                                                    startedfilepipeasync?0:flags.restorebuffermb,
                                                    flags.stream_timeoutsecs,
                                                    false)) {
        
        if(!flags.teeoutstream.isempty() && !flags.xdrctl) ppipe_control->init_tee(flags.teeoutstream);

        
        if(flags.dtoexportstream) {
            
            xml_messagep infop(retrieve_existing_backup_info_xml(theLoc,
                                                                 upath(ustring(UNDOO_DIRECTORY_NAME) / ustring(EXPORTSTREAM_METADATA_FILENAME))));

            if(infop.isnull()) {
                infop = gather_existing_backup_info_xml(theLoc, NULL, ddrwrite);
            }

            if(!infop.isnull()) {
                ppipe_control->output_avamar_archive_info(infop);

                
                
                
                if(!infop.isnull() && !flags.nemoresurrect && (flags.streamformat_out == utar_flags_enums::streamformat_avpax)) {
                    const exportstream_xml metainfo(infop->fimage());

                    if(!metainfo.is_backup_supported()) {
                        Out->msg(FATAL, "The specified backup is not supported for AER export.");
                        return false;
                    }
                }
            }
        }

        
        ret = ppipe_control->perform_restore(this, theLoc);

        
        fileoffset size_of_stream;
        ppipe_control->padd_end(size_of_stream);

        
        
        if(size_of_stream != fileoffset::unknown) {
            backstats *statsp = getstatsobj(get_dpn_statstype(dpn0));
            statsp->streambyteprogress(static_cast<double> (size_of_stream.value()));
        }
    }

    
    
    
    {
        if(pipe_control *ppipec = ppipe_control) {
            ppipe_control = 0;
            delete ppipec;
        }

        
        res = fileref();
    }

    return ret;
}

bool context::restore_dumppipe(const location& fromloc, const ustring& filename, const stringlist& frompaths,
                               const bool isdir, DIRELEM& de, const bool is_inode_format
) {
    assert(frompaths.size() > 0); 

    DB->msg("context::restore_dumppipe fromloc=%s filename=%s frompaths=%s isdir=%d de=%s(%s)", *fromloc.image(), *filename, *frompaths.image(), isdir, *de.name(), *de.fullpath().image());
    assert(!in_async_mode);     

    fileref res;
    if (filename.isempty())
        
        filerefx::initpipe(res, stdout);
    else
        res.initdisk(filename, fileoffset(0), filemap::write, true, true);

    
    if (is_inode_format) {
        ppipe_control = new dumpstream::pipectrl(res);
        undoo::vector<upath> paths;
        for (int i = 0; i < frompaths.size(); i++) {
            ustring usepath(frompaths[i]);
            
            if (usepath.last() != '/') usepath += "/";
            
            
            if (usepath.contains("./") == 0) usepath = usepath.substr(2);
            
            if (!flags.ndmp_prefix.isempty() && usepath.contains(flags.ndmp_prefix + "/") == 0)
                usepath = usepath.substr(flags.ndmp_prefix.bytelength()+1);
            
            usepath = usepath.chop();
            if (usepath == "/") usepath = "";
            paths.push_back(upath(usepath));
        }

        assert(fromloc.isFromGsan());       
        cycle *child = new restdumpstream(*this, fromloc, de, upath(), paths);
        child->noop();
        return !loop();
    }

    bool ret = true;
    pdumpcontext = new dumpcontext(this, res, flags.dumplittle, frompaths[0]);
    if(isdir) {
        
        ret = restore_dir(fromloc, upath("/"), &de); 
        DB->msg("restore_dumppipe: isdir dir=%s", *de.name());
    } else {
        
        DIRELEM parent = de;
        parent.set_is_directory();

        
        fileref dirlist;
        dirlist.initlist(1024);
        de.dolayout(dirlist, false, true, true);  

        DB->msg("restore_dumppipe: file dir=%s", *de.name());
        pdumpcontext->add_directory(parent, dirlist, NULL);
    }
    DB->msg(DBTXT("context::restore_dumppipe finished restoring directories (target:%s)"), *flags.target);
    
    if(flags.target != "")
        pdumpcontext->insert_target(flags.target);
    pdumpcontext->do_bitmaps();        DB->msg(DBTXT("context::restore_dumppipe pdumpcontext->do_bitmaps     done"));  if(!uapp::staging().canRun()) return ret;
    pdumpcontext->do_directories();    DB->msg(DBTXT("context::restore_dumppipe pdumpcontext->do_directories done"));  if(!uapp::staging().canRun()) return ret;

    
    pdumpcontext->do_netapp_inode3_acls();    DB->msg(DBTXT("context::restore_dumppipe pdumpcontext->do_netapp_inode3_acls done"));

    ppipe_control = new dumppipe(res, pdumpcontext);
    pdumpcontext->do_files();          DB->msg(DBTXT("context::restore_dumppipe pdumpcontext->do_files       done"));  if(!uapp::staging().canRun()) return ret;

    pdumpcontext->do_netapp_acls();    DB->msg(DBTXT("context::restore_dumppipe pdumpcontext->do_netapp_acls done"));
    DB->msg(DBTXT("context::restore_dumppipe done"));

    return ret;
}




bool context::restore_gsanonly_file_cb(fileref& res, const hashcode& hash, chunktype *ctypep,
                                       async_callback *incb, fileoffset sizehint,
                                       fileoffset startoff, fileoffset endoff)
{
    
    
    
    long mysizehint;
    if( sizehint < fileoffset(4*1024*1024) )
        mysizehint = sizehint.ivalue();
    else mysizehint = 4*1024*1024;
    if(res.isnull())
        res.initlist(mysizehint);
    addfilecount(restorestats, 1);

    async_callback *cb = incb;
    if(in_async_mode && cb == NULL) {
        
        cb = new synccall_callback();
    } else {
        assert(in_async_mode || cb == NULL);    
    }

    restroot *rst = new restroot(hash, *this, res, ctypep, false, cb, startoff, endoff);
    assert(rst != NULL);        

    bool ok = true;
    if(cb == NULL) {
        assert(!in_async_mode);
        ok = !loop();
    } else {
        if(incb == NULL) {
            
            ok = (cb->wait()==0);
            delete cb;
            cb = NULL;
        }
    }
    return ok;
}

bool context::restore_gsanonly_file(fileref& res, const hashcode& hash, chunktype *ctypep, fileoffset sizehint,
                                    fileoffset startoff, fileoffset endoff)
{
    return restore_gsanonly_file_cb(res, hash, ctypep, NULL, sizehint, startoff, endoff);
}


bool context::restore_one_file(const hashcode& hash, DIRELEM& direlem,
                               fileoffset startoff, fileoffset endoff

) {
    DB->msg(DBTXT("context::restore_one_file calling restonefile"));
    assert(!in_async_mode);
    addfilecount(restorestats, 1);
    ucontainer::basep container(open_container_for_read(direlem.get_location()));
    restonefile *rst = new restonefile(hash, *this, direlem, container, startoff, endoff);
    rst->noop();
    bool error = loop();
    return !error;
}

bool context::restore_chunk(fileref& res, const hashcode& hash, chunktype &ctype) {
    if(res.isnull())
        res.initlist();
    synccall_callback *cb = NULL;
    if(in_async_mode) {
        cb = new synccall_callback();
      
    }

    restroot *rst = new restroot(hash, *this, res, &ctype, true, cb);
    assert(rst != NULL);        

    bool error = false;
    if(cb != NULL) {
      
        error = (cb->wait() != 0);
      
        delete cb;
        cb = NULL;
    } else {
        error = loop();
    }
    if(error) {
        DB->msg(DBTXT("restore_chunk: loop() returned error"));
        ctype = chunktype();
    }
    return !error;
}

bool context::get_hash_info(const hashcode& hash, fileoffset& size, bool& isdir) {
    synccall sync(*this);
    message m;
    msgpack_c::gethashdata ghd(m);

    int userid = 0;  
    time_t prefetchtime = 0;  
    hashcode thash = hash;  
    ghd.arg(PACK, thash, userid, prefetchtime);

    
    m = sync.call(m);
    

    if(m.iserrorresponse())
        return false;

    chunktype ckind;
    fileref outdata;
    int cachelevel;  
    ghd.res(UNPACK, ckind, outdata, cachelevel);

    
    if(ckind.is_dir()) {
        isdir = true;
        size = fileoffset(0);
        return true;
    }

    if(ckind.is_extatomic()) {

        bool res = outdata.uncompress(get_enckey());
        if (!res) {
            DB->error(DBTXT("\"%s\": INTERNAL uncompress/decrypt failure, data not restored correctly"), *hash.partialimage());
            return false;
        }
        ckind = chunktype::atomic;
    }

    
    if(ckind.is_atomic()) {
        isdir = false;
        size = fileoffset(outdata.size());
        return true;
    }

    
    
    isdir = false;
    compelem elem(ckind);
    int offset = outdata.size() - elem.getsize() - sizeof(hashcode);
    elem.init(outdata, offset);
    size = elem.getendoff();
    return true;
}

bool context::get_hash_ispresent(const hashcode& hash) {
    synccall sync(*this);

    message m;
    msgpack_c::hashispresent hip(m);
    hashcode lhash = hash;
    hip.arg(PACK, lhash);

    
    m = sync.call(m);
    

    if (m.isnull()) return false;
    return m.isgoodresponse();
}

bool context::get_dir_entry(const hashcode& hash, const ustring& name, DIRELEM& entry) {
    synccall sync(*this);

    
    message m;
    msgpack_c::lookup_path lp(m);
    ustring tname = name;   
    hashcode thash = hash;  
    lp.arg(PACK, tname, thash);

    
    m = sync.call(m);
    

    if(m.iserrorresponse())
        return false;

    fileref data;
    lp.res(UNPACK, data);

    int off=0;
    bool ret = entry.populate(data, off);
    
    return ret;
}

safeint r_enters;
safeint r_lookups;
safeint r_hits;
safeint r_zeros;

void context::restorecache_enable(int maxmessages, bool cache_atomics) {
    if ((xflag[15]&4) != 0) {           
        return;
    }

    if (restorecachep && maxmessages > 0) {
        
        DB->msg("ATTENTION: restore cache is being re-instantiated (previous entries will be lost)");
        restorecachep.reset();
    }

    if (maxmessages == 0) {
        
        return;
    }

    
    if (maxmessages < 0)
        maxmessages = DefaultRestoreCacheSize;

    if (maxmessages > MaxRestoreCacheSize)
        maxmessages = MaxRestoreCacheSize;

    DB->msg("context::restorecache_enable creating cache with maxmessages=%d", maxmessages);
    restorecachep = undoo::make_shared<restorecache>(maxmessages, cache_atomics);

    
    
    message aofzm;      
    aofzm.setrequestcode(GET_HASH_DATA);
    aofzm.setresponsecode(MSG_ERR_NONE);
    fileref zeroData;

    
    zeroData.initmem(NUM_ZEROS_IN_LARGEST_ATOMIC_OF_ZEROS);
    zeroData.clrdata();
    int cachelevel = 0;
    chunktype ac(chunktype::atomic);
    msgpack_c::gethashdata aofzghd(aofzm);  
    aofzghd.res(PACK, ac, zeroData, cachelevel);

    restorecachep->enter(hashcode::largestatomicofzeroes, aofzm, true);
}

bool context::restorecache_enabled() const {
    return restorecachep;
}

bool context::restorecache_cache_atomics() const {
    return restorecachep && restorecachep->cache_atomics;
}

bool context::restorecache_enter(const hashcode& hash, const message& m) {
    if (!restorecachep)
        return false;

    r_enters++;
    assert(m.requestcode()==GET_HASH_DATA || m.requestcode()==GETHASHDATAHINTS);
    restorecachep->enter(hash, m);
    return true;
}

bool context::restorecache_lookup(const hashcode& hash, message& m) const {
    if (!restorecachep)
        return false;

    r_lookups++;
    if (+r_lookups % 5000 == 0)
        DB->msg("context::restorecache_lookup %s", *restorecache_image());

    m = restorecachep->lookup(hash);
    if (!m.isnull()) {
        r_hits++;
        if (hash == hashcode::largestatomicofzeroes) {
            ++r_zeros;
        }
    }
    assert(m.isnull() || m.requestcode()==GET_HASH_DATA || m.requestcode()==GETHASHDATAHINTS);
    return !m.isnull();
}

bool context::restorecache_defined(const hashcode& hash) const {
    if (!restorecachep)
        return false;

    message m; 
    return restorecache_lookup(hash, m);
}

ustring context::restorecache_image() const {
    return ustring::sprintf("Enabled=%c Lookups=%d, Enters=%d, Hits=%d (of which, %d were zero-blocks)", restorecachep ? 'T' : 'F', +r_lookups, +r_enters, +r_hits, +r_zeros);
}

void context::restorecache_stats(int &enters, int &lookups, int &hits) const
{
    enters  = +r_enters;
    lookups = +r_lookups;
    hits    = +r_hits;
}

void context::smallfile_prefetcher_stats(fileoffset &totalbytes, fileoffset &runningbytes) {
    smallfile_prefetcher::getstats(totalbytes, runningbytes);
}

bool context::startsession(sessioninfo2 &sinfo,
                           dpns dpninx, const ustring& appname, const ustring& root, utar_flags_info& flags, cidtype cid, widtype wid,
                           dirstats *dstats, bool isbackup, const ustring& apptype, const ustring& label)
{
    if(flags.degenerate && (dpninx == dpn1))    
        return true;
    SessionProfile* sessionProfile = adeMgr->getSessionProfile();
    if(sessionProfile == NULL) return(false);       
    if(dpninx == dpn1)
        return( sessionProfile->startSession(sinfo, dpninx, appname, root, cid, wid, dstats, isbackup, apptype, label, &flags) );
    return( sessionProfile->startSession(sinfo, dpninx, appname, root, cid, wid, dstats, isbackup, apptype, label) );
}


bool context::restore_prev_dump(backdump *d) {
    
   if (!incflags.isexplicit("label") && !incflags.isexplicit("backuptag")) {        
       Out->msg(FATAL, "<5907>Missing --label:1=<label> flag.  A base backup must be specified for this incremental.");
       return false;
    }
    
    hfs_info_struct& hfs_info = getAdeMgr()->getHfsInfo(dpn0);
    utar_flags_info dstflags;  
    utar_commands utar(incflags, hfs_info, dstflags);
    
    BackupRootInfo backupInfo;
    (void)utar.pick_backup(backupInfo, !(incflags.restore_after.isempty()&&(0==incflags.restore_within_days)));
    assert(backupInfo.isFromGsan());
    hashcode hash = backupInfo.getRootLocation().getHash();
    assert(hash != hashcode::zero);
    pbackdump = d;
    Out->msg(INFO, "<5807>Reading previous backup to merge with incremental stream");
    utar.display_snapup_info(backupInfo, false);
    bool ret = restore_dir(backupInfo.getRootLocation(), upath(""));
    assert(ret);
    if (ret)  Out->msg(INFO, "<5808>Previous backup read successfully");
    else      Out->msg(ERR, "<5809>Unable to read previous backup to merge with incremental stream. Please do a full");
    return ret;
}




bool context::find_prev_backup(BackupRootInfo& prevBackup) {
    
    if (incflags.isexplicit("label") || incflags.isexplicit("backuptag")) {
        
        
    } else if (incflags.label.isempty() && incflags.backuptag.isempty() && incflags.labelnum==0) {
        
        Out->msg(FATAL, "<8476>Incremental mode requires a base backup be specified with --label:1, --backuptag:1 or --labelnum:1.");
        return false;
    }

    hfs_info_struct& hfs_info = getAdeMgr()->getHfsInfo(dpn0);
    utar_flags_info dstflags;  
    utar_commands utar(incflags, hfs_info, dstflags);
    
    if (prev_backup.getMedialoc() == location::media::unknown) {
        DB->msg(DBTXT("context::find_prev_backup finding previous backup"));

        BackupRootInfo one_backup;
        (void)utar.pick_backup(one_backup, !(incflags.restore_after.isempty()&&(0==incflags.restore_within_days)));
        if (one_backup.isNull()) {
            Out->msg(ERR, "<8477>No valid base backup specified for incremental backup.");
            return false;
        }

        const prectime snapuptime(one_backup.getBackupTime());
        const datetime date(snapuptime);
        Out->msg(INFO, "<8478>Using backup #%s timestamp %"AVDATE"s %s label \"%s\" as base for incremental backup", *one_backup.getSavesetId().image(), *date.image(), *datetime::TzDst.av_tzname, *one_backup.getLabelName());

        DB->msg(DBTXT("context::find_prev_backup after pick"));
        prev_backup = one_backup;
        DB->msg("context::find_prev_backup Snapup #%s loc:%s", *prev_backup.getSavesetId().image(), *prev_backup.image());

        
        
        if(flags.pluginid.kind() == pidtype::vcbimage ||
           (flags.streamformat_out == utar_flags_enums::streamformat_raw &&
            (flags.pluginid.kind() == pidtype::ostackimage ||
             flags.pluginid.kind() == pidtype::hypervvss))) {
            ADEMgr* adeMgr = getAdeMgr();
            if (adeMgr && flags.create && flags.ddrenabled) {
                DataDomainSysInfo si;

                
                si.labelnum      = prev_backup.isFromGsan() ? prev_backup.getSavesetId().image().toint() : 0;
                si.hexBackupTime = snapuptime;
                si.fileName = DATADOMAINFILES_FILENAME;
                

                
                const bool filePresent = utar.get_ddrfiles_xml(prev_backup, si.fileName, si.ddrfilesData);
                if(!filePresent) {
                    Out->msg(ERR, "<9938>A DDR restore was specified, but no '.system_info/%s' file was found inside backup!", *si.fileName);
                    return false;
                }

                
                adeMgr->setDDRSysInfo(si);
            }
        }
    }
    prevBackup = prev_backup;
    return true;
}







bool context::prepare_emctarstream_incremental(const BackupRootInfo& prevBackup) {

    if(prevBackup.isNull()) {
        DB->msg("context::prepare_emctarstream_incremental() Previous backup root %s.",
                prevBackup.isFromGsan() ? "hash is zero" : "is Null");
        return false;
    }

    utar_flags_info dstflags;  
    
    hfs_info_struct& hfs_info = getAdeMgr()->getHfsInfo(dpn0);
    utar_commands utar(flags, hfs_info, dstflags);
    return utar.set_celerrai18n(prevBackup);
}



bool context::restore_a_view(backview *d, int labelnum, ustring acnt) {

    if(adeMgr == NULL) {  
        DB->warn (DBTXT("context::restore_a_view() -- ADE was not initialized."));
        return false;
    }

    DB->msg("context::restore_a_view backview:%p", d);
    utar_flags_info fakeflags;
    fakeflags.labelnum = labelnum;
    fakeflags.path = acnt;
    
    
    fakeflags.incpartials = true;
    utar_flags_info dstflags;  
    
    hfs_info_struct& hfsinfo = getAdeMgr()->getHfsInfo(dpn0);
    
    DB->msg(DBTXT("context::restore_a_view old blk:%s"), *hfsinfo.blk.image());
    blkpath dpnacnt(acnt);
    blktraj new_blktraj(dpnacnt);
    hfsinfo.blk = new_blktraj;
    DB->msg(DBTXT("context::restore_a_view new blk:%s"), *hfsinfo.blk.image());

    utar_commands utar(fakeflags, hfsinfo, dstflags);
    BackupRootInfo onebackup;
    (void)utar.pick_backup(onebackup);

    assert(onebackup.isFromGsan());
    const hashcode hash = onebackup.getRootLocation().getHash();
    const int ddrIndex = (int)onebackup.getDDRIndex();
    if (hash == hashcode::zero) {
      Out->msg(WARN, "<6961>Unable to find account:%s labelnum:%d on server:%s",
               *acnt, labelnum, *flags.hfsaddr);
      return false;
    }

    
    if(!ADEChunkerEnabled() && ddrIndex != 0) {
        if (flags.makeview && !flags.makeview_pluginmerge)      
            Out->msg(ERR, "Non-plugin-merge snapviews to the DDR are not supported.");
        else
            Out->msg(ERR, "<9932>Backup #%d in \"%s\" contains DDR data, yet no DDR was specified in this makeview", labelnum, *acnt);
        return false;
    }

    pbackview = d;
    Out->msg(INFO, "<6962>Reading account '%s', backup#%d", *acnt, labelnum);
    utar.display_snapup_info(onebackup, false);
    bool ret = restore_dir(onebackup.getRootLocation(), upath(""));
    assert(ret);
    if (ret)  Out->msg(INFO, "<6963>Account '%s' backup#%d read successfully", *acnt, labelnum);
    else      Out->msg(ERR, "<6964>Unable to read account '%s' backup#%d", *acnt, labelnum);
    return ret;

}

void context::hardlinkable_file_ready( const DIRELEM &direlem ) {
    
    if(flags.dtoexportstream) {
        return;
    }

    
    bool is_emctar_restore = ((ppipe_control != NULL) && ppipe_control->is_emctar());
    bool emctar_hardlinks = false;
    if (is_emctar_restore) {
        
        
        
        
        
        
        
        
        
        
        
        dirrec_pack::regions drp(&direlem);
        data_regions::endoffsets_t endoffsets;
        if (drp.get(endoffsets)) {
            
            
            return;
        }

        MetadataId metadataid;
        fileoffset size;
        bool wasdir;
        ubigint64 dir_offset;
        
        if (inodetab.find_entry(direlem.inode_number64(), metadataid, size, wasdir, dir_offset)) {
            
            
            
            
            if (!wasdir) {
                emctar_hardlinks = true;
            }
        }
    }

    if (!emctar_hardlinks &&
        (direlem.hard_links() > 1) &&
        
        
        filesystem_mutex.islocked()
        ) {
        filesystem_mutex.unlock();
    }
}


bool
context::check_emctar_hardlinked_file(const DIRELEM &de,
                                      bool &isfirst, DIRELEMp &realde,
                                      MetadataId &metadataid, fileoffset &sz, ubigint64 &dir_offset, bool is_emctar)
{
    const ubigint64 inode_number = is_emctar ? de.emctar_inode_number64() : de.inode_number64();
    bool wasdir(false);
    
    bool intable = inodetab.find_entry(inode_number, metadataid, sz, wasdir, dir_offset);
    
    

    unsigned int nlinks = de.hard_links();

    if (!intable) {
        if (de.is_tar_hardlink() || (!de.is_directory() && (nlinks > 1))) {
            Out->msg(WARN, "During restore of '%s' our direlem indicates that there are multiple hardlinks to this object, but our %s/%s datastructure has no record for inode %s",
                     *de.fullpath().image(), UNDOO_DIRECTORY_NAME, INODE2HASH_TABLE_FILENAME, *::tostr(inode_number));
        }
        return false;
    }

    if (wasdir) {
        if (de.is_tar_hardlink() || (!de.is_directory() && (nlinks > 1))) {
            Out->msg(WARN, "During restore of '%s' our direlem indicates that there are multiple hardlinks to this non-directory object, but our %s/%s datastructure indicates inode %s is a directory",
                     *de.fullpath().image(), UNDOO_DIRECTORY_NAME, INODE2HASH_TABLE_FILENAME, *::tostr(inode_number));
        }
        return false;
    }

    if (intable && (nlinks <= 1) && !de.is_tar_hardlink()) {
        
        
        
        
        
        return false;
    }

    inode64_to_direlemp_t::const_iterator i = emctar_hardlinked_direlems.find(inode_number);
    if (i != emctar_hardlinked_direlems.end()) {
        realde = i->second.direlemp;
        
        
        
        isfirst = false;
    } else {
        
        isfirst = true;
    }

    return true;
}




bool context::check_zfstar_hardlinked_file(const DIRELEM &de, bool &isfirst, DIRELEMp &realde, MetadataId &metadataid, fileoffset &sz, ubigint64 &dir_offset, data_regions::endoffsets_t &endoffsets)
{
    bool wasdir(false);
    ubigint64 hdroffset, dataoffset, padoffset, extattroffset;
    hdroffset = dataoffset = padoffset = extattroffset = 0;
    bool intable = inodetab.find_entry(de.inode_number64(), metadataid, sz, wasdir, dir_offset,
                                       hdroffset, dataoffset, padoffset, extattroffset);

    unsigned int nlinks = de.hard_links();

    if (!intable) {
        if (de.is_tar_hardlink() || (!de.is_directory() && (nlinks > 1))) {
            Out->msg(WARN, "During restore of '%s' our direlem indicates that there are multiple hardlinks to this object, but our %s/%s datastructure has no record for inode %s",
                     *de.fullpath().image(), UNDOO_DIRECTORY_NAME, INODE2HASH_TABLE_FILENAME, *::tostr(de.inode_number64()));
        }
        return false;
    }

    if (wasdir) {
        if (de.is_tar_hardlink() || (!de.is_directory() && (nlinks > 1))) {
            Out->msg(WARN, "During restore of '%s' our direlem indicates that there are multiple hardlinks to this non-directory object, but our %s/%s datastructure indicates inode %s is a directory",
                     *de.fullpath().image(), UNDOO_DIRECTORY_NAME, INODE2HASH_TABLE_FILENAME, *::tostr(de.inode_number64()));
        }
        return false;
    }

    if (intable && (nlinks <= 1) && !de.is_tar_hardlink()) {
        return false;
    }

    if (hdroffset)
        endoffsets.push_back(std::make_pair(data_regions::header, hdroffset));
    if (dataoffset)
        endoffsets.push_back(std::make_pair(data_regions::primarydata, dataoffset));
    if (padoffset)
        endoffsets.push_back(std::make_pair(data_regions::padding, padoffset));
    if (extattroffset)
        endoffsets.push_back(std::make_pair(data_regions::ads, extattroffset));

    inode64_to_direlemp_t::const_iterator i = emctar_hardlinked_direlems.find(de.inode_number64());
    if (i != emctar_hardlinked_direlems.end()) {
        realde = i->second.direlemp;
        isfirst = false;
    } else {
        isfirst = true;
    }

    return true;
}

bool
context::record_hardlinked_file(const DIRELEM &de)
{
    
    
    if (de.hard_links() < 2) {
        if (dbgmsgs) DB->msg("Try to record hardlink file '%s' but its hardlink number is %d", *de.fullpath().image(), de.hard_links());
        return false;
    }
    inode64_to_direlemp_t::iterator i = emctar_hardlinked_direlems.find(de.inode_number64());
    if (i != emctar_hardlinked_direlems.end()) {
        Out->msg(ERR, "Restoring '%s' as the first instance of inode %"LL"u output, but context hardlink datastructure indicates that '%s' was already restored as an instance of that inode.",
                 *de.fullpath().image(), de.inode_number64(), *(i->second.direlemp)->fullpath().image());
        return false;
    }
    DIRELEMp realde(new DIRELEM);
    *realde = de;
    hardlink_direlem_record record;
    record.direlemp = realde;
    record.count_restore = 1;
    emctar_hardlinked_direlems[de.inode_number64()] = record;
    return true;
}



bool context::record_one_hardlink_restore(const DIRELEM &de) {
    inode64_to_direlemp_t::iterator i = emctar_hardlinked_direlems.find(de.inode_number64());
    if (i == emctar_hardlinked_direlems.end()) {
        if (dbgmsgs)
            DB->msg("Restore one instance of hardlink file '%s', but this hardlink isn't in the hardlink direlem record", *de.fullpath().image());
        return false;
    }
    hardlink_direlem_record &rec = i->second;
    rec.count_restore++;
    if (rec.count_restore >= rec.direlemp->hard_links()) {
        
        emctar_hardlinked_direlems.erase(i);
    }
    return true;
}












bool context::emctar_hardlinked_file(DIRELEM &de, bool &isfirst,
                                     ustring &realfullpath,
                                     MetadataId &metadataid, fileoffset &sz)
{
    if (de.is_directory()) {
        
        return false;
    }

    bool wasdir;
    ubigint64 dir_offset;
    
    bool intable = inodetab.find_entry(de.inode_number64(), metadataid, sz, wasdir, dir_offset);

    if (!intable) {
        
        return false;
    }

    if (wasdir) {
        
        return false;
    }

    emctarpipe *pemctarpipe = dynamic_cast<emctarpipe *>(ppipe_control);
    if (pemctarpipe == NULL) {  
        Out->Abort("Output data pipe has not been established.");
        return false;
    }

    hard_link_id hid(de);
    hard_link_to_file_name_t::iterator i = hard_link_to_file_name.find(hid);
    if (i == hard_link_to_file_name.end()) {
        isfirst = true;
        realfullpath = pemctarpipe->convert_path_to_hardlink_path(de.fullpath().image());
        hard_link_to_file_name[hid] = realfullpath;
        
        
    } else {
        realfullpath = i->second;
        
        
    }

    return true;
}








bool context::hardlinked_file( DIRELEM &direlem, hashcode &de_hash, fileref &altslice, fileref &stubslice ) {
    
    if(flags.dtoexportstream) {
        return false;
    }

    bool is_emctar_restore = ((ppipe_control != NULL) && ppipe_control->is_emctar());

    bool emctar_hardlink = false;
    MetadataId emcth_metadataid;
    fileoffset emcth_size;
    bool wasdir(false);
    ubigint64 dir_offset;
    if (is_emctar_restore) {
        
        bool intable = inodetab.find_entry(direlem.inode_number64(), emcth_metadataid, emcth_size, wasdir, dir_offset);
        if (direlem.is_tar_hardlink() && !intable) {
            Out->msg(ERR, "context::hardlinked_file direlem:%s is a tar_hardlink, but failed to find inode %"LL"u in inodetab",
                      *direlem.fullpath().image(), direlem.inode_number64());
            return false;
        }
        
        
        
        
        
        
        
        
        
        
        
        
        emctar_hardlink = (intable && (!wasdir));
    }


    
    
    
    
    
    
    
    if( emctar_hardlink || (direlem.hard_links() > 1)) {
        
        if (!emctar_hardlink) {
            DB->msg(DBTXT("hard_linked_file setting lock %s %d"), *direlem.fullpath().image(), direlem.hard_links());
            filesystem_mutex.lock();
        }
        hard_link_id hl(direlem);

        
        
        upath oldpath;
        hard_link_to_file_name_t::iterator i = hard_link_to_file_name.find(hl);
        if (i != hard_link_to_file_name.end()) { oldpath = upath(i->second); }

        upath newpath(direlem.fullpath());
        if(!oldpath.isempty()) {
            if(ppipe_control != NULL) {
                fileref dum, extentsdata;
                direlem.set_tar_hardlink(true);
                
                ppipe_control->addfile(direlem, newpath.image(), dum, altslice, stubslice, extentsdata, tarpipe::LNKTYPE, oldpath.image());
                if (!emctar_hardlink) filesystem_mutex.unlock();
                return true;
            } else if( flags.validate || pdumpcontext != NULL) {
                
                if (!emctar_hardlink) filesystem_mutex.unlock();
                return true;
#if SYSTEM_UNIX
            } else if( link(*oldpath.image(), *newpath.image()) != 0 ) {
                DB->msg(DBTXT("WARNING: Unable to link %s to %s: %s"),
                        *oldpath.image(), *newpath.image(), strerror(errno));
                
#elif (SYSTEM_WINDOWS && USEADE)
            } else if( false == CreateHardLink(*newpath.pathw("CreateHardLink"),
                *oldpath.pathw("CreateHardLink"), NULL)) {
                DB->msg(DBTXT("WARNING: Unable to link %s to %s: %d"),
                  *newpath.image(), *oldpath.image(),  GetLastError());
                
#endif
            } else {
                
                if (!emctar_hardlink) filesystem_mutex.unlock();
                return true;
            }
        } else {
            
            
            

            if (is_emctar_restore && direlem.is_tar_hardlink()) {
                
                
                
                
                
                
                
                
                
                baselocation_sp blp(direlem.get_metadataLocation());
                direlem.set_hash(emcth_metadataid.tohashcode(), blp );

                
                
                
                
                
                
                de_hash = emcth_metadataid.tohashcode();
                direlem.set_file_size(emcth_size);
                direlem.set_tar_hardlink(false);
            }
        }
        ustring realfullpath(direlem.fullpath().image());
        
        if (is_emctar_restore) {
            emctarpipe *pemctarpipe = dynamic_cast<emctarpipe *>(ppipe_control);
            assert(pemctarpipe);
            realfullpath = pemctarpipe->convert_path_to_hardlink_path(direlem.fullpath().image());
            
            
        }
        
        hard_link_to_file_name[hl] = realfullpath;
        if (!emctar_hardlink) filesystem_mutex.unlock();
    }
    return false;
}

const int context::nodeid_to_conn(dpns dpninx, tnodeid nodeid)
{
    if(adeMgr != NULL) {
        DB->warn (DBTXT("context::nodeid_to_conn() -- ADE was initialized and should be used!"));
        return 0; 
    }
    return 0;
}


pipe_control* context::getpipe_control(const restelem* re) const {
    if(re && re->ppipe_control) {
        return re->ppipe_control;
    }
    return ppipe_control;
}


context::~context() {
    DB->msg( "context::~context" );
    
    if (!contextopened) {
        DB->msg( DBTXT("context::~context - exiting, not opened") );
        DB->sender.free();
        if (getstatsobj(backupstats)->mainthread_hashed_bytes != 0)        
            Out->msg(STATS, "<6405>Synchronous hashing processed %s bytes\n", *commas(getstatsobj(backupstats)->mainthread_hashed_bytes));
        delete hashsrv;                                 
        return;
    }

    if ( ( sendqueue != NULL) && (sendqueue->length() != 0) ) {
        DB->msg(DBTXT("sendqueue->length == %d"), sendqueue->length());
    }





    
    
    
    
    
    
    

    if(ppipe_control != NULL) {
        delete ppipe_control;
        ppipe_control = NULL;
    }

    DB->msg ("context: about to check numthreads != -1");
    if(numthreads != -1) {
        if (getstatsobj(backupstats)->mainthread_hashed_bytes != 0)        
            Out->msg(STATS, "<6405>Synchronous hashing processed %s bytes\n", *commas(getstatsobj(backupstats)->mainthread_hashed_bytes));
        delete hashsrv;
        DB->msg(DBTXT("context: hashsrv done\n"));
    } else {
        DB->msg ("context: numthreads == -1");
    }

    if (wasted_cpu_throttling_ms > 0) {
        Out->msg(STATS, "<6591>Slept %.1f seconds for CPU throttling limit", wasted_cpu_throttling_ms/1000);
    }

    DB->msg (DBTXT("context: deleting todo_queue"));
    delete todo_queue;
    DB->msg (DBTXT("context: deleting todo_parallel_queue"));
    DB->msg (DBTXT("context: deleting pdumpcontext"));
    delete pdumpcontext;

    Out->msg(STATS, "Final Restore Cache Stats %s", *restorecache_image());

    if(checkinfo != NULL) delete checkinfo;

    if (!client_ctl_statep.isnull()) {
      DB->msg(DBTXT("context::~context has ctl_statep"));
    }

    if (watchdog) {
        DB->msg (DBTXT("context: shutting down watchdog"));
        delete watchdog;
    }

    DB->msg( DBTXT("context: Done with deletes"));
    DB->sender.free();

    DB->msg( "--context::~context" );
}


messagecodes context::getdpnmaxmessage(dpns dpninx) const
{
    if(adeMgr == NULL) return(NO_MESSAGE);
    return adeMgr->getDpnMaxMessage(dpninx);
}

unsigned int context::getmaxchunksize(dpns dpninx, chunktype ctype) const
{
    if(adeMgr != NULL) {
        if(ctype.is_data_atomic() || ctype.is_extatomic())  {
            
            
            return adeMgr->getMaxAtomChunkSize(dpninx);
        }
        else {
            
            return adeMgr->getMaxCompositeChunkSize(dpninx);
        }
    }
    return 0;
}




epoch_t context::acl_access_time(const DIRELEM& direlem) const {
    if (!flags.detect_acl_changes) return 0;    

    epoch_t ctime, atime;
    unsigned int tflag;
    direlem.get_ext_times(ctime, atime, tflag);
    return atime;                               
}



void context::set_cur_filename(const upath& filepath, bool isdir )
{
    
    scope s(curfile_mtex);
    curfile  = filepath;
    curisdir = isdir;
}






ustring context::get_cur_filename(int maxlen , bool from_end)
{
    scope s(curfile_mtex);
    const ustring curfilei(curfile.image());
    ustring ret;
    bool append_dirsep(curisdir);

    if(maxlen > 0 && curfilei.bytelength() > maxlen) {
        if(!from_end) {
            ret = curfilei.safe_substr(0, maxlen)+ustring("...");
        } else {
        append_dirsep = false;
        ret = ustring("...")+curfilei.safe_substr(curfilei.bytelength()-maxlen); 
        }
    } else {
        ret = curfilei;
    }
    if (append_dirsep) ret += DIRSEP;
    return ret;
}


tmessagesize context::getmaxdpnmessagedatasize(dpns dpninx) const
{
    if(adeMgr != NULL) {
        return adeMgr->getMaxDpnMessageDataSize(dpninx);
    }
    return 0;
}

unsigned int context::getmaxdpnatomchunksize(dpns dpninx) const
{
    if(adeMgr != NULL) {
        return adeMgr->getMaxAtomChunkSize(dpninx);
    }
    return 0;
}

unsigned int context::getmaxdpncompchunksize(dpns dpninx) const
{
    if(adeMgr != NULL) {
        return adeMgr->getMaxCompositeChunkSize(dpninx);
    }
    return 0;
}


tversion context::getserverversion(dpns dpninx) const
{
    if(adeMgr != NULL) {
        return adeMgr->getServerVersion(dpninx);
    }
    return tversion();  
}


unsigned int context::getmaxdirelemsize(dpns dpninx)
{
    assert(dpninx >= 0 && dpninx < maxdpns);

    
    if (maxdirelemsize[dpninx] <= 0) {
        
        
        
        
        
        unsigned int newsize = MAXDIRELEMLEN;
        const tversion svr = getserverversion(dpninx);
        if (svr.isvalid() && svr < tversion("6.0.1-1")) {
            newsize = getmaxdpncompchunksize(dpninx);
            if(newsize <= 0) newsize = MAXDIRELEMLEN;
        }
        DB->msg("context::getmaxdirelemsize(%d), serverversion=%s, maxdirelemsize=%u",
                (int)dpninx, *svr.image(), newsize);
        maxdirelemsize[dpninx] = newsize;
    }

    assert(maxdirelemsize[dpninx] > 0 && maxdirelemsize[dpninx] < 65536);
    return maxdirelemsize[dpninx];
}


bool context::isOutputPipeFull(const bool activelimit_condition )
{
    
    bool output_pipe_full(false);
    if(ppipe_control != NULL) {
        bigint64 filepipe_pending = ppipe_control->reserved_bytes_pending().value();
        assert(filepipe_pending >= 0);
        if( filepipe_pending > (bigint64)(flags.maxpipemb)*(1024*1024) && activelimit_condition ) {
            const bool debug = (xflag[1]&8) > 0;
            if(debug)
                DB->msg( "filepipe is full, pending=%"LL"d", filepipe_pending);
            output_pipe_full = true;
            outputthrottles++;
        }
    }
    return(output_pipe_full);
}

void context::layout_direlem(DIRELEM &de, fileref& data, bool computedsizeonly, bool newdir, bool inode)
{
    const int max_direlemsize = getmaxdirelemsize(dpn0);
    if(!de.dolayout(data, computedsizeonly, newdir, inode, max_direlemsize)) {
        DB->msg(DBTXT("WARNING: direlem chunker larger than %d, discarded security attributes from %s."),
                      max_direlemsize, *de.fullpath().image());
    }
}






#ifdef FORTRESS

#define FORT_NOT_SUPPORTED  -1  
#define FORT_KEY_TOO_LONG   -2  

#define FORT_ENCRYPT_NONE   0
#define FORT_ENCRYPT_AES128 1
#define FORT_ENCRYPT_AES256 2






















#define MAXPWSIZE 128




bool context::load_and_use_saas_library(const ustring shared_path, const ustring shared_object_name)
{
    DB->msg("SAAS: Loading");                   

    
    sharedlib libfile(upath(shared_path / shared_object_name));

    
    encmode = fileref::encmode_none;

    
    if (libfile.is_open()) {
        DB->msg("SAAS: Loaded");                

        
        typedef int (get_key_t)(char *, int);   

        get_key_t *get_key = (get_key_t *)libfile.get_entry_point("fortress_get_encryption_key");

        if (get_key == NULL) {
            DB->msg("load_saas_library(\"%s\", \"%s\"): Could not locate entrypoint", *shared_path, *shared_object_name);
            return false;                       
        }

        
        fileref buf;
        buf.initmem(MAXPWSIZE);                 
        int keymode = get_key(buf.start(), MAXPWSIZE);
        buf[MAXPWSIZE-1]=0;                     

        DB->msg("SAAS: get_encryption_key returned=%d, keylen=%"Z"d", keymode, strlen(buf.start()));

        
        if (keymode == FORT_NOT_SUPPORTED) {    
            DB->msg("SAAS: not supported");
        } else if (keymode == FORT_ENCRYPT_NONE) {
            DB->msg("SAAS: no encryption");
        } else if (keymode == FORT_ENCRYPT_AES128) {
            encmode = fileref::encmode_aes_128_cbc;
        } else if (keymode == FORT_ENCRYPT_AES256) {
            encmode = fileref::encmode_aes_256_cbc;
        } else if (keymode < 0) {
            DB->msg("load_saas_library(\"%s\", \"%s\") call failed with %d", *shared_path, *shared_object_name, keymode);
            return false;
        } else {
            DB->msg(DBTXT("load_saas_library: Unknown encryption mode (%d)"), keymode);
        }

        if (encmode != fileref::encmode_none) {
            
            if ((int)strlen(buf.start()) > fileref::enckeysize[encmode]) {
                buf[fileref::enckeysize[encmode]]=0;
                DB->msg(DBTXT("SAAS: Warning: key truncated to %"Z"d bytes"), strlen(buf.start()));
            }

            
            if ((int)strlen(buf.start()) == fileref::enckeysize[encmode]) {
                DB->msg(DBTXT("SAAS: Using %s encryption"), *fileref::encmode_image(encmode));
                enckey.initmem(buf.start());
                return true;                    
            } else {
                Out->msg(ERR, "<7359>Internal key error (len=%d)", (int)strlen(buf.start()));
            }
        }
    } else {
        DB->msg("SAAS: Not loaded");            
    }

    
    DB->msg(DBTXT("SAAS: Encryption/decryption not being used"));
    encmode = fileref::encmode_none;
    return true;                                
}

#else


bool context::load_and_use_saas_library(const ustring shared_path, const ustring shared_object_name)
{
    return false;
}

#endif 






ucontainer::basep context::getucontainer_yucky_global()
{
    
    
    
    
    return ucontainerp_yucky_global;
}

void context::closeucontainer_yucky_global()
{
    DB->msg("context::closeucontainer ucontainerp has %d refcounts",
            ucontainerp_yucky_global.isnull() ? 0 : ucontainerp_yucky_global.getimpl()->getrefcount());
    assert(ucontainerp_yucky_global.isnull() || (ucontainerp_yucky_global.getimpl()->getrefcount() == 1));
    ucontainerp_yucky_global = NULL;
}







ucontainer::basep context::open_container_for_read(const location& loc, bool ok_to_use_container_cache ) {
    DB->msg("context::open_container_for_read loc:%s, use_container_cache:%d", *loc.image(), use_container_cache);

    
    
    
    
    
    
    if(loc.getMedia() == location::media::gsan || loc.getMedia() == location::media::unknown )
         return NULL;

    
    fileref transport;
    ucontainer::basep new_container;
    location::tbackupid mybackupid(0);

    if(loc.getMedia() == location::media::ddr) {
        
        
        
        
        
#if DDRSUPPORTED
        if (loc.get_containerid() == 0) {
            
            
            Out->msg(ERR, "Unable to open container file for location %s", *loc.image());
            return NULL;
        }

        assert(flags.ddrenabled);
        
        
        int ddrHandle = 0;
        getAdeMgr()->get_ddrhandle(ddrHandle);  

        
        DataDomainSysInfo ddrSysInfo;
        getAdeMgr()->getSysInfo(ddrSysInfo);

        
        
        if (ddrSysInfo.clientID.isempty()) {
            ddrSysInfo.clientID = loc.get_clientid();
            assert(!loc.get_clientid().isempty());
        }

        const location::tbackupid idfromsysinfo(ddrSysInfo.hexBackupTime);
        DB->msg("context::open_container_for_read cid:'%s', backup id from sysinfo:'%s', loc.backupid:'%s'", *ddrSysInfo.clientID, idfromsysinfo.image().tostr(), loc.get_backupid().image().tostr());

        mybackupid = loc.get_backupid()==0? idfromsysinfo : loc.get_backupid();
        assert(mybackupid != 0);

        
        if(ok_to_use_container_cache && use_container_cache && containercache.initialized()) {
            
            
            new_container = containercache.lookup(mybackupid, loc.get_containerid());
            if(new_container.isdefined()) {
                DB->msg("context::open_container_for_read bid:%s, cid:%u, using cached container", mybackupid.image().tostr(), loc.get_containerid());
                return new_container;
            }
        }

        
        
        
        ddrfiles_xmlp xmlp(ddr_interface::get_ddr_files(0, ddrSysInfo.clientID, mybackupid));
        
        if(xmlp.isnull()) {
            
            if(idfromsysinfo == mybackupid && !ddrSysInfo.ddrfilesData.isnull() && ddrSysInfo.ddrfilesData.size64() > 0) {
                
                xmlp = new ddrfiles_xml();
                if(!xmlp.isnull() && xmlp->loadXmlBackupFileList(ddrSysInfo.ddrfilesData)) {
                    
                    ddr_interface::set_ddr_files(ddrSysInfo.clientID, mybackupid, xmlp);
                }
            }
        }

        
        ddr_interface::initddrread(transport, ddrHandle, ddr_interface::default_lsu, ddrSysInfo.clientID, mybackupid, loc.get_containerid(), xmlp);
        if(transport.iserror()) { 
            DB->msg("context::open_container_for_read transport.iserror");
            return NULL;
        }

#else
        Out->msg(ERR, "DataDomain integration is not supported on this platform");
        DB->error("Data Domain integration is not enabled in this binary");
        assert(false);
#endif
    } else if (loc.getMedia() == location::media::disk) {
      assert(false);
      Out->msg(ERR, "This is currently unimplemented");
      return NULL;






    } else {
        assert(false);
        Out->msg(ERR, "Unknown media '%s', unable to restore data", *location::media::image(loc.getMedia()));
        return NULL;
    }

    switch (loc.get_format()) {

    case location::tformat::pax: {
        DB->msg("context::open_container_for_read pax");
        int paxflags = ucontainer::base::flags_parse_stream;
        Out->msg(INFO, 2, "Opening pax_container #%sfor restore", *tostr(loc.get_containerid()));
        new_container = new pax_container(flags.media_in, paxflags, location::media::pipe, loc.get_containerid()); 
        break;
    }

    case location::tformat::cdsf: {
        DB->msg("context::open_container_for_read cdsf");
        int cdsfflags = ucontainer::base::flags_parse_stream;

        if(flags.ddrenabled == true) {
            assert(flags.extract);

            
            new_container = new cdsf_container(transport, cdsfflags, loc.getMedia(), loc.get_containerid(), NULL, use_container_objcache);

        } else {
            Out->msg(INFO, 2, "Opening cdsf_container #%s for restore", *tostr(loc.get_containerid()));
            new_container = new cdsf_container(flags.media_in, cdsfflags, location::media::disk, loc.get_containerid(), use_container_objcache); 
        }

        break;
    }

    case location::tformat::raw: {
        DB->msg("context::open_container_for_read raw");
        int flags = ucontainer::base::flags_parse_stream;
        new_container = new raw_container(transport, flags, loc.getMedia(), loc.get_containerid());
        break;
    }

    default: {
        DB->msg("context::open_container unknown format: %d", loc.get_format());
        assert(false);
        Out->msg(ERR, "Unknown format '%d', unable to restore data", loc.get_format() );
        return NULL;
    }

    } 

    
    
    if(ok_to_use_container_cache && use_container_cache && containercache.initialized() && mybackupid != 0) { 
        DB->msg("context::open_container_for_read caching %s-%u", mybackupid.image().tostr(), loc.get_containerid());
        containercache.add(mybackupid, loc.get_containerid(), new_container);
    }
    assert(new_container != NULL);
    return new_container;
}


ucontainer::basep context::open_raw_container_for_write(const upath filepath, location::tcontainerid& containerid, const location::tformat::type streamtype )
{
    scope s(ddrfiles_xml_mutex);

    const bool flag_ddgsan2dd(flags.ddgsan2dd.bytelength() > 0);

    
    containerid = !flag_ddgsan2dd ? allocate_ucontainer_streamindex() : 1;

    
    
    int ddrhandle = 0;
    getAdeMgr()->get_ddrhandle(ddrhandle);

    const ustring filepath_imagexml(filepath.imagexml());
    
    
    
    
    const ustring gsanfullpath(create_gsanfullpath(!flags.regenerate_inode2hash, flags.backup_prefix, filepath.imagexml()));

    
    
    if(flag_ddgsan2dd || (getAdeMgr()->add_ddrfilesxml_entry(streamtype, *filepath.imagexml(), containerid, *gsanfullpath) == EXIT_OK)) {
        
        
        ustring new_ddrfilename(filepath.stripdir());
        if(flag_ddgsan2dd || getAdeMgr()->ddrfilesxml_entry_ddrfilename(containerid, new_ddrfilename)) {
            
            ustring stagingpath;
            getAdeMgr()->getStagingPath(stagingpath);

            
            fileref ddrfile;
            ddr_interface::initddrwrite(ddrfile, ddrhandle, stagingpath, new_ddrfilename);

            
            if(raw_container* rcp = new raw_container(ddrfile, ucontainer::base::flags_generate_stream, location::media::ddr, containerid)) {
                rcp->set_ddrhandle(ddrhandle);

                const hfs_info_struct& hfsInfo = adeMgr->getHfsInfo(dpn0);  
                rcp->set_clientid(hfsInfo.clientidhash.image());  

                return rcp;
            }
        }
    }

    return 0;
}

bool context::close_raw_container_for_write(ucontainer::basep containerp)
{
    scope s(ddrfiles_xml_mutex);

    const bool flag_ddgsan2dd(flags.ddgsan2dd.bytelength() > 0);

    
    add_ddr_stats(context::backupstats, containerp->transport);

    
    return flag_ddgsan2dd || getAdeMgr()->finalize_ddrfilesxml_entry(containerp->containerid) == EXIT_OK;
}

void context::initializeContainerCache() {
    
    
    
    use_container_cache = true;
    if(!containercache.initialized() && flags.max_containercache_entries > 0 && !containercache.initialize(this))
        Out->msg(ERR, "Failed to initialize container cache");
}

void context::close_object_in_container(const location& loc) {
    if(loc.get_format() == location::tformat::cdsf && use_container_cache && containercache.initialized()) {
        const ucontainer::basep container(containercache.lookup(loc.get_backupid(), loc.get_containerid()));
        if(container.isdefined())
            container->close_obj(loc);
    }
}

hashcode context::get_metadata_roothash(const hfs_info_struct& hfs_info) const
{
    hashcode metahash;

    
    

    acntmngr acct_mgr(hfs_info.sync);
    const blktraj block_parent(hfs_info.blk);
    const authid auth_user(hfs_info.auth);

    
    roothashlist roothashes;
    msgerrors error = acct_mgr.getBackups(roothashes, block_parent, auth_user, 1, 0, 0, false, true, true,
                                          tretentiontype::all, tbackuptype::metadata.rawvalue());
    DB->msg("context::get_metadata_roothash: get metadata backups -- result %s/%d", *message::err_image(error), error);
    roothashlistrec roothash;
    (void)roothashes.get(roothash, 0);
    if (roothash.isUsed() && roothash.isPartial() && (roothash.getBackupType() == tbackuptype::metadata)) {
        metahash = roothash.getRoot();
    }
    DB->msg("context::get_metadata_roothash: metadata backups roothash --  %s", *metahash.partialimage());
    return metahash;
}








void context::remove_old_metadata(const hfs_info_struct& hfs_info, const hashcode& metahash)
{
    
    

    acntmngr acct_mgr(hfs_info.sync);
    const blktraj block_parent(hfs_info.blk);
    const authid auth_user(hfs_info.auth);

    
    
    

    roothashlist roothashes;
    msgerrors error = acct_mgr.getBackups(roothashes, block_parent, auth_user, 1, 0, 0, false, true, true,
                      tretentiontype::all, tbackuptype::metadata.rawvalue());
    DB->msg("context::remove_old_metadata: get metadata backups -- result %s/%d", *message::err_image(error), error);

    roothashlistrec roothash;
    (void)roothashes.get(roothash, 0);
    if (roothash.isUsed() && roothash.isPartial() && (roothash.getBackupType() == tbackuptype::metadata)) {
        const prectime snapuptime(roothash.getMtime());
        if(metahash != roothash.getRoot()) {
            
            
            

            msgerrors backup_result = acct_mgr.delBackup(block_parent, auth_user, snapuptime, false, true);

            const datetime date(snapuptime);
            DB->msg("context::remove_old_metadata: deleted metadata backup %s in %s -- result %s/%d, labelnum %d, timestamp %"AVDATE"s %s, label \"%s\"",
                    *snapuptime.image(), *roothash.image(),
                    *message::err_image(backup_result), backup_result,
                    roothash.getLabelnum(), *date.image(), *datetime::TzDst.av_tzname, *roothash.getLabel());
        } else {
            DB->msg("context::remove_old_metadata: metadata backup %s in %s is not deleted -- labelnum %d, label \"%s\"",
                    *snapuptime.image(),*roothash.image(),
                    roothash.getLabelnum(), *roothash.getLabel());
        }
    } else {
        DB->msg("context::remove_old_metadata: no existing metadata backup found, isUsed %d, backup type %s, isPartial %d",
            roothash.isUsed(), *roothash.getBackupType().image(), roothash.isPartial());
    }
}







bool context::copy_whole_container(ucontainer::basep containerp, DIRELEMp de, const upath& newgsanpath, const bool create_cdsf_containerid_name )
{
    bool ret(false);

    DB->msg("context::copy_whole_container() containerp.isnull():%d de->fullpath():%s, newgsanpath:%s create_cdsf_containerid_name:%d",
            containerp.isnull(), de.isnull() ? "(nul)" : *de->fullpath().image(), *newgsanpath.image(), create_cdsf_containerid_name);

    assert(!de.isnull());
    assert(!newgsanpath.isempty());

    
    const location loc(de->get_location());

    
    const emd_elementp emd(get_container_emd(true, de));

    if(!emd.isnull()) {
        
        assert(emd->streamIndex == loc.get_containerid());

        bool allocated_own_container(false);

        
        location::tcontainerid containerid(0);
        if(containerp.isnull()) {
            
            containerp = open_raw_container_for_write(newgsanpath, containerid, emd->streamType);
            allocated_own_container = true;
        } else {
            scope s(ddrfiles_xml_mutex);

            containerid = allocate_ucontainer_streamindex();
            const ustring containername(create_cdsf_containerid_name ?
                                        ustring::sprintf("container.%d.cdsf", containerid) :
                                        newgsanpath.image());

            if(getAdeMgr()->add_ddrfilesxml_entry(emd->streamType, *containername, containerid, *newgsanpath.imagexml()) != EXIT_OK) {
                DB->msg("Unable to allocate ddr_files.xml entry for container object for object '%s' with location '%s'", *de->fullpath().image(), *loc.image());
                
                containerp = 0;
            }
        }

        if(!containerp.isnull()) {
            
            ustring stagingpath;
            getAdeMgr()->getStagingPath(stagingpath);

            
            containerp->set_ddr_staging_path(stagingpath);

            
            ustring new_ddrfilename;
            if(getAdeMgr()->ddrfilesxml_entry_ddrfilename(containerid, new_ddrfilename)) {

                const ucontainer::errortype et(containerp->copyfile(de.getimpl(), emd->DDRFileName, new_ddrfilename));

                
                
                if(allocated_own_container) {
                    close_raw_container_for_write(containerp);
                } else {
                    scope s(ddrfiles_xml_mutex);

                    (void)getAdeMgr()->finalize_ddrfilesxml_entry(containerid);
                }
                containerp = 0;

                if(et == ucontainer::pce__success) {
                    location newloc(loc);

                    newloc.set_coverage_size(emd->fileSize);
                    newloc.set_containerid(containerid);
                    newloc.set_abs_offset_in_container(0);

                    de->set_location(newloc);

                    ret = true;
                } else {
                    DB->msg("Unable to copy file using container object for object '%s' with location '%s'", *de->fullpath().image(), *loc.image());
                }
            } else {
                DB->msg("Unable to retrieve new container ddr file name for container object for object '%s' with location '%s'", *de->fullpath().image(), *loc.image());
            }
        } else {
            DB->msg("Unable to allocate container object for object '%s' with location '%s'", *de->fullpath().image(), *loc.image());
        }
    } else {
        DB->msg("Unable to find meta information about container for object for object '%s' with location '%s'", *de->fullpath().image(), *loc.image());
    }

    return ret;
}







bool context::copy_all_subcontainers(ucontainer::basep containerp, DIRELEMp de, const upath& newgsanpath)
{
    bool all_succeeded(true);

    assert(!de.isnull());
    
    

    const upath parent_container_path(de->get_location().get_gsanpath());
    const ddrfiles_xml::emd_elementv emdv(get_subcontainer_list(de));

    for(ddrfiles_xml::emd_elementv::const_iterator it = emdv.begin(); it != emdv.end(); it++) {
        const upath subconpath((*it)->get_canonical_gsanpath());

        
        location loc(de->get_location());

        
        loc.set_coverage_size((*it)->fileSize);
        loc.set_containerid((*it)->streamIndex);
        loc.set_abs_offset_in_container(0);

        
        if((*it)->streamType == location::tformat::cdsf) {
            loc.set_format(location::tformat::cdsf);
        } else {
            
            loc.set_format(location::tformat::raw);
        }

        
        
        DIRELEMp tempde(new DIRELEM());
        tempde->set_fullpath(subconpath);
        tempde->set_name(subconpath.stripdir());
        tempde->set_location(loc);

        
        
        
        const upath tempnewgsanpath(newgsanpath.isempty() ? subconpath : (newgsanpath / subconpath.slice(parent_container_path.numelems())));

        
        if(!copy_whole_container(containerp, tempde, tempnewgsanpath, true)) {
            DB->msg("copy_whole_container(): Could not copy container for '%s' with location '%s'", *tempnewgsanpath.image(), *loc.image());
            all_succeeded = false;
        }
    }

    return all_succeeded;
}





const location context::fill_in_location_clientid_and_backupid(const location& loc) const
{
    assert(adeMgr != NULL);
    location retloc(loc);

    
    if(retloc.get_clientid().isempty() || retloc.get_backupid() == 0) {
        const hfs_info_struct& hfs_info(adeMgr->getHfsInfo(dpn0));

        if(adeMgr->isDDRenabled()) {
            
            DataDomainSysInfo ddrsysinfo;
            adeMgr->getSysInfo(ddrsysinfo);

            
            if(retloc.get_clientid().isempty()) {
                
                retloc.set_clientid(ddrsysinfo.clientID);
            }

            
            if (retloc.get_backupid() == 0) {
                retloc.set_backupid(location::tbackupid(ddrsysinfo.hexBackupTime));
            }
        }

        
        if(retloc.get_clientid().isempty()) {
            retloc.set_clientid(hfs_info.clientidhash.image());
        }

        
        if(retloc.get_backupid() == 0 && !prev_backup.isNull()) {
            retloc.set_backupid(+prev_backup.getBackupTime());
        }
    }

    if(retloc.get_clientid().isempty() && set_location_info_msg) DB->msg("context::fill_in_location_clientid_and_backupid clientid is empty");
    if(retloc.get_backupid()==0 && set_location_info_msg) DB->msg("context::fill_in_location_clientid_and_backupid backupid is zero");

    return retloc;
}


const ddrfiles_xmlp context::get_backup_ddrfiles_xmlp(const location &loc) const
{
    if (get_ddr_loc_info_ignored()) {
        
        return NULL;
    }

    ddrfiles_xmlp ret;

    if(set_location_info_msg) DB->msg("context::get_backup_ddrfiles_xmlp for loc:%s loc.clientid:%s adeMgr:%p",
                                      *loc.image(), *loc.get_clientid(), adeMgr);

    const location fillloc(fill_in_location_clientid_and_backupid(loc));

    
    
    
    int ddrHandle = 0;
    
    
    if (adeMgr && adeMgr->isDDRenabled()) {
        adeMgr->get_ddrhandle(ddrHandle);
    }

    
    
    if(!fillloc.get_clientid().isempty() && fillloc.get_backupid() != 0) {
        ret = ddr_interface::get_ddr_files(ddrHandle, fillloc.get_clientid(), fillloc.get_backupid());
    }

    
    
    if(ret.isnull() && loc.getMedia() == location::media::ddr && flags.backupstate != utar_flags_enums::backstate_final && get_location_info_required()) {
        Out->msg(WARN, "Unable to get %s for clientid %s and backupid %s", DATADOMAINFILES_FILENAME, *fillloc.get_clientid(), *fillloc.get_backupid().image());
    }

    return ret;
}



const ddrfiles_xml::emd_elementv context::get_subcontainer_list(const DIRELEMp de) const
{
    if(!de.isnull()) {
        
        const ddrfiles_xmlp ddrfilesxmlp(get_backup_ddrfiles_xmlp(de->get_location()));

        
        if(!ddrfilesxmlp.isnull()) {
            return ddrfilesxmlp->querySubEmds(de->get_location().get_gsanpath(), de->ignorecase());
        }
    }

    
    return ddrfiles_xml::emd_elementv();
}





bool context::set_location_info_from_upath(const upath& gsanpath, DIRELEM& de) const
{
    location loc(de.get_location());

    
    const ddrfiles_xmlp ddrfilesxmlp(get_backup_ddrfiles_xmlp(loc));
    
    if(ddrfilesxmlp.isnull()) {
        
        if(get_location_info_required() && !get_ddr_loc_info_ignored()) {
            Out->msg(WARN, "Unable to retrieve DDR info for '%s'", de.fullpath().image().tostr());
        }
        if(set_location_info_msg && !get_ddr_loc_info_ignored()) {
            DB->msg("context::set_location_info_from_upath failed to retrieve ddr_files.xml for %s", loc.image().tostr());
        }
        return false;
    }

    bool is_whole_container = true;
    loc.set_enclosing_container(ddrfilesxmlp->queryEmd(gsanpath, de.ignorecase(), is_whole_container));
    if (loc.get_enclosing_container() == NULL) {
        if(set_location_info_msg) DB->msg("context::set_location_info_from_upath unable to find emd for gsanpath:'%s' for de:'%s', loc:%s, ddrfilesxmlp->simage is:\n%s",
                                          *gsanpath.image(), *de.name(), *loc.image(), *ddrfilesxmlp->simage());
    }
    if(set_location_info_msg) DB->msg("context::set_location_info_from_upath gsanpath:'%s' (isroot:%d) de.fullpath:'%s' got emdp:'%s'",
                                      *gsanpath.image(), gsanpath.isroot(), *de.fullpath().image(),
                                      (loc.get_enclosing_container().isnull() ? "null" : *loc.get_enclosing_container()->image()));

    if (loc.get_enclosing_container().isnull()) {
        if(loc.get_format() == location::tformat::unknown || loc.get_format() == location::tformat::raw) {
            loc.set_emd_relative_path(gsanpath);
            de.set_location(loc);
        }
        return false;
    }
    const upath emdpath(loc.get_enclosing_container()->gsanFullPath);

    
    if (gsanpath == emdpath) {
        loc.set_emd_relative_path(upath(ustring()));
    } else {
        
        assert(de.ignorecase() || gsanpath.isDescendentOf(emdpath));
        upath lgsanpath(gsanpath.imagexml(), upath::kind_gsan);
        lgsanpath.set_begin_dirsep(false);
        loc.set_emd_relative_path(upath(lgsanpath.slice(emdpath.numelems(), lgsanpath.numelems()).imagexml()));
        if(set_location_info_msg) DB->msg("context::set_location_info_from_upath gsanpath:%s emdpath:%s slicing gsanpath.slice(emdpath.numelems():%d, gsanpath.numelems():%d) -> %s (%d) [%d]",
                                          *gsanpath.image(), *emdpath.image(), emdpath.numelems(), gsanpath.numelems(),
                                          *loc.get_emd_relative_path().image(), loc.get_emd_relative_path().has_begin_dirsep(), loc.get_emd_relative_path().numelems());
    }

    loc.set_containerid(loc.get_enclosing_container()->streamIndex);
    if(loc.get_format() == location::tformat::unknown)
        loc.set_format(loc.get_enclosing_container()->streamType);
    else if(loc.get_format() != loc.get_enclosing_container()->streamType)
        Out->msg(ERR, "Internal logic error: conflicting format information: %s != %s", location::tformat::image(loc.get_format()).tostr(), location::tformat::image(loc.get_enclosing_container()->streamType).tostr());
    de.set_location(loc);

    if(set_location_info_msg) DB->msg("context::set_location_info_from_upath ret gsanpath:'%s' emd.gsanFullPath:'%s' de.fullpath:'%s' emd_relpath:'%s' loc.containerid:'%d'",
                                      *gsanpath.image(), *emdpath.image(), *de.fullpath().image(), *loc.get_emd_relative_path().image(), loc.get_containerid());

    return true;
}

bool context::set_location_info(const ustring& called_from, const location& parentloc, DIRELEM& de) const {
    if (set_location_info_msg) DB->msg("context::set_location_info() called from %s, for de '%s' with parent loc:'%s'",
                                       *called_from, *de.fullpath().image(), *parentloc.image());

    
    bool ret(false);

    
    location loc(de.get_location());

    
    
    upath full_gsan_path;

    
    
    if(loc.getMedia() != location::media::ddr) {
        if(set_location_info_msg) DB->msg("context::set_location_info() called for DIRELEM that is not on DDR");
    }
    
    
    
    
    else if(loc.get_format() == location::tformat::raw && loc.get_containerid() > 0 && de.is_dirrec_present(KIND_deprecated_DDR_ALTDATA)) {
        
        
        if(set_location_info_msg) DB->msg("context::set_location_info() trusting container id of %d", loc.get_containerid());
        
        assert(!de.is_directory());
        ret = true;
    }
    else {
        
        full_gsan_path = parentloc.get_gsanpath();

        if(full_gsan_path.isempty()) {
            
            full_gsan_path = upath(de.name());
        }else if(!de.name().isempty() && de.name() != upath::root_element) {
            
            full_gsan_path = full_gsan_path / de.name();
        }

        
        if(loc.get_backupid() == 0) {
            
            loc.set_clientid(parentloc.get_clientid());
            loc.set_backupid(parentloc.get_backupid());
            de.set_location(loc);
        }

        ret = (!full_gsan_path.isempty() && set_location_info_from_upath(full_gsan_path, de));
    }

    if (set_location_info_msg) DB->msg("context::set_location_info() ret %d, full_gsan_path '%s', loc %s", ret, *full_gsan_path.image(), *de.loc_image());

    return ret;
}




const emd_elementp context::get_container_emd(const bool use_containerid_lookup, const DIRELEMp de) const
{
    emd_elementp ret;

    if(!de.isnull()) {
        
        const ddrfiles_xmlp ddrfilesxmlp(get_backup_ddrfiles_xmlp(de->get_location()));

        if(!ddrfilesxmlp.isnull()) {
            if(!use_containerid_lookup) {
                
                if(!ddrfilesxmlp.isnull()) {
                    bool is_whole_container(false); 
                    ret = ddrfilesxmlp->queryEmd(de->fullpath(), de->ignorecase(), is_whole_container);
                }
            } else {
                
                ret = ddrfilesxmlp->queryEmd(de->get_location().get_containerid());
            }
        }
    }

    return ret;
}

ustring context::determineClientID(const hfs_info_struct& hfs_info) {
    
    
    
    
    
    
    
    
    
    

    ustring retcid;

    if(hfs_info.clientidhash != hashcode::zero &&
       hfs_info.clientidhash != hashcode::empty &&
       !hfs_info.clientidhash.image().isempty())
        retcid = hfs_info.clientidhash.image();
    else if(hfs_info.main) {
        ADEMgrX* const adeMgr(hfs_info.main->getAdeMgr());
        if(adeMgr && adeMgr->isDDRenabled()) {
            DataDomainSysInfo ddrsysinfo;
            adeMgr->getSysInfo(ddrsysinfo);
            retcid = ddrsysinfo.clientID;
        }
    }

    if(!retcid.isempty())
        return retcid;

    
    
    if(hfs_info.clientid.image().bytelength() == (2*BYTES_IN_HASH) &&
       hfs_info.clientid.image().ishexstring() &&
       hfs_info.clientid != cidtype::none)
        retcid = hfs_info.clientid.image();
    else
        assert(!"Unable to determine client ID");

    return retcid;
}






void context::location_checker_summary()
{
    if (checkinfo != NULL) {
        DB->msg("context::location_checker_summary checkinfo:%p", checkinfo);
        Out->msg(INFO, "Validating location information");
        checkinfo->summary();
        delete checkinfo;
        checkinfo = NULL;
    }
}

bool context::validate_direlem(const DIRELEM& de) {
    
    if (checkinfo==NULL) checkinfo = new location_checker;
    return checkinfo->validate_entry(de);
}

void context::add_dstflags(utar_flags_info* dstflagsp) {
    DB->msg("Adding destination flags of %s", dstflagsp ? *dstflagsp->parsed_flags : "nul");
    dstflags = dstflagsp;
}












void context::check_for_raw_format(const location::tbackupid bid, const fileref& ddrfilesdata) {

    
    if(get_ddr_backup_has_unmapped_data(bid) >= 0)
        return; 

    ddrfiles_xml ddrfiles;
    if(ddrfilesdata.isnull() || ddrfilesdata.size() == 0 || !ddrfiles.loadXmlBackupFileList(ddrfilesdata)) {
        DB->msg("context::check_for_raw_format: failed to load ddr_files.xml for backup %s", tostr(+bid).tostr());
        return;
    }
    check_for_raw_format(bid, ddrfiles);
}

void context::check_for_raw_format(const location::tbackupid bid, ddrfiles_xml& ddrfiles) {
    
    if(get_ddr_backup_has_unmapped_data(bid) >= 0)
        return; 
    bool found_raw_files(false), found_cdsf_files(false);
    emd_elementp curelem;
    bool more_elems(ddrfiles.first_XmlEmd(curelem));
    while(more_elems && curelem.isdefined()) {
        if(curelem->streamType == location::tformat::raw)
            found_raw_files = true;
        else if(curelem->streamType == location::tformat::cdsf)
            found_cdsf_files = true;
        if(found_raw_files && found_cdsf_files) 
            break;
        more_elems = ddrfiles.next_XmlEmd(curelem);
    }
    if(found_raw_files && found_cdsf_files)
        Out->msg(WARN, "Backup has mix of raw and CDSF format files. This may affect calculation of container offsets.");

    if(dbgmsgs && found_raw_files)
        DB->msg("context::check_for_raw_format: found raw files, allowing lookups in ddr_files.xml to fail");

    
    set_ddr_backup_contains_unmapped_data(bid, found_raw_files);
}






















#define DisableRepair   ((xflag[31])&1048576)!=0

void context::setBackupAvtarVersion(const ustring& versionstr, int pidnum) {
    backupvers = tversion(versionstr);

    if (flags.extract && backupvers.getmajor() == 7 && backupvers.getminor() == 0 && pidtype(pidnum).kind() == pidtype::winclusterfs) {
        
        
        
        
        if (DisableRepair) {
            DB->msg("setBackupAvtarVersion location_info_repair code DISABLED");
        }
        else {
            DB->msg("setBackupAvtarVersion creating location_info_repair_sp");
            locRepair = location_info_repair_sp(new location_info_repair(this));
        }
    }
}




bool context::handleEsc24121LocAdjustment(const DIRELEM& parentde, const DIRELEM& de, const location& loc, int container_entry_idx, location& newloc) {

    newloc = loc;
    
    if (locRepair && loc.isFromDDR() && get_location_info_required()) {
        if (dbg_24121) DB->msg("handleEsc24121LocAdjustment checking to see if '%s' is either a unc_server or unc_share", *de.fullpath().image());
        if (de.is_unc_root()) {
            
            
            
            (void)locRepair->deriveUNCServerLocFromChildren(de, loc, container_entry_idx, newloc);
            return true;
        }
        else if (parentde.is_unc_root()) {
            
            
            (void)locRepair->deriveUNCShareLocFromChildren(de, loc, container_entry_idx, newloc);
            return true;
        }
    }

    return false;
}




bool context::handleEsc24121LocMissing(const DIRELEM& parentde, DIRELEM& de) {

    const bool parentDataOnDDR = parentde.get_location().isFromDDR();
    const bool missingLocationInfo = !de.is_dirrec_present(KIND_LOCATION_INFO);

    if (dbg_24121) DB->msg("handleEsc24121LocMissing called for %s, locrepair:%c, parentDataOnDDR:%c, missinglocation:%c", *de.fullpath().image(),
                locRepair ? 'T' : 'F', parentDataOnDDR ? 'T' : 'F', missingLocationInfo ? 'T' : 'F');

    
    
    
    if (locRepair && missingLocationInfo) {
        
        
        
        if (parentde.is_unc_root() && parentDataOnDDR) {
            location newloc(de.get_location());
            newloc.setMedia(location::media::ddr);
            newloc.set_format(location::tformat::cdsf);
            DB->msg("handleEsc24121LocMissing adding a LOCATION DIRREC to SHARE '%s' DIRELEM %s", *de.name(), *newloc.image(true));
            de.set_location(newloc);
            return true;
        }
    }

    return false;
}




#if !defined(BACKSTREAMDIR_H_INCLUDED)
#define BACKSTREAMDIR_H_INCLUDED












#include "fileref.h"
#include "scalar.h"
#include "cycle.h"
#include "direlem.h"
#include "fileoffset.h"
#include "dataextents.h"
#include "paxrec.h"
#include "ade_backup.h"
#include "statistic.h"
#include "backdataconsumer.h"

class cycle;
class workelem;             
class utar_flags_info;
class upath;
class filemem;
class parsestream_base;

class backstreamdir : public BackCycle,
                      nsAdeLib::ADEBackup,        
                      backdataconsumer::producer  
{

public:
  SAFEALLOC(backstreamdir);

  
  
  
  
  backstreamdir(BackCycle* parent_, context* main, workelem *info_,
                parsestream_base *parser, int traverse_depth,
                const bool use_container = false);         

  virtual ~backstreamdir();

  virtual void init();
  virtual void continueReading();           
  virtual void childdone(cycle *child);
  virtual void notifyparent();
  virtual void responseReceived(DataHasher* dataHasher) { childdone(dataHasher); }
  virtual void responseReceived(ChangeBlockHasher* changeBlockHasher) { childdone(changeBlockHasher); }

  
  virtual fileref nextdatablock(bool& suppress_requeue);

protected:
  
  parsestream_base *parser;

  
  int traverse_depth;

  
  bool reserved_hiddendir;

  int phase;                    
  bool forked_prev_restore;     

  name_to_direlemp_table curlist;  
  name_to_direlemp_table prevlist; 

  size_t curlistcount; 

  DIRELEMp save_obj_direlem;  
  fileref save_altdata, save_stubdata;

  DIRELEMp sysinfo;  

  void set_phase(int phasenum); 
  ustring phase_image(); 

  bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata);
  void process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata);
  void insert_self(DIRELEMp obj_direlem);

  
  
  
  void update_stats_counts(const DIRELEMp &de) const;

  fileref build_dirblock(name_to_direlemp_table& de_listing, fileoffset& totalsize,
                         bool flags_inode, bool sortrequired);

  
  
  
  void request_prevlist(ubigint64 parentinode = 0);

  
  
  
  bool ucontainer_addobj(const ubigint64 headflags, DIRELEMp& de, const ustring objname);


  
  
  

  
  
  
  
  
  
  
  
  
  
  const bool directories_after_files;   

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  const bool auto_close_directories;  


  
  
  

  
  bool merge_lists_avpax(const name_to_direlemp_table& prevlist,
                         name_to_direlemp_table& currlist);

  bool iterate_changeblocks(const bool initialzeme, const DIRELEMp& obj_direlem, const fileoffset::value_type last_off = 0, bool send_off = false);

  
  void backupextents(DIRELEMp de, const fileref extentsdata, const fileoffset& off_marker);
  
  bool restoredataextents(DIRELEMp prevde, DIRELEMp curde);
  bool restoring_extents;
  fileref prevextentsdata;  
  chunktype restoredtype;

  dataextents changes;       
  dataextents dataextents_from_pax_stream;  

  statistic extent_stats;
  int extent_index;
  int extent_interval;
  bool isonqueue;
  cycle *change_block_child; 
  cycle *data_hasher_child;  
  fileoffset change_filesize;
  fileoffset last_offset;    
  fileoffset increased_change_filesize; 
                                        
                                        
  
  ChangeBlockHasher changeBlockHasher;
  DataHasher dataHasher;

private:
  
  backstreamdir();

  
  void check_and_set_ddr_media(const ustring& calledfrom, const bool has_ddr_data, DIRELEMp direlemp) const;

  dataextents limit_extents_to_base_file(const dataextents& changes, fileoffset base_filesize) const;

  const bool use_container;
};

#endif
















#ifndef RESTDUMPSTREAM_H
#define RESTDUMPSTREAM_H

#include "cycle.h"
#include "dumpstreamutils.h"
#include "ucontainer_base.h"


struct restdumpstreamcontext
{
    restdumpstreamcontext() : mtime(0), flags(0), root_loc(), rootnode(0), acl_total(0), acl_block(0), acls_calculated_size(0) { }

    
    location                rootmetaloc;    
    upath                   subprefix;   
    undoo::vector<upath>    subtree;     
    epoch_t                 mtime;       
    const utar_flags_info  *flags;       

    location                root_loc;    

    
    name_to_direlemp_table  toplevel;    
    dumpstream::typemap     typemap;     
    dumpstream::dirmap      dirmap;      
    dumpstream::aclmap      aclmap;      
                                         
    int32_t                 rootnode;    

    
    dumpstream::inodemap    sendmap;     
    dumpstream::inodemap    timemap;     
    dumpstream::inodemap    aclsfound;     

    
    fileref                 inode3_hdr;  
    uint32_t                acl_total;   
    uint32_t                acl_block;   
    uint32_t                acls_calculated_size;   
    uint32_t                acl_count;   
    ucontainer::basep       ucontainerp; 
    bool                    xplatform;   
    ustring                 target;      
    ustring                 added_path;  

    
    typedef DEFINE_STL_MAP_TYPE(int32_t, DIRELEMp) direlem_cache;
    direlem_cache           rest_de_cache;  
};




class restdumpstream : public cycle
{
public:
    enum phase {
        phase_do_retrieve,
        phase_do_mark,
        phase_do_prune,
        phase_crossplatform,
        phase_findacls,
        phase_do_restore,
        phase_done
    };

    restdumpstream(context &main, const location& _rootmetaloc, const DIRELEM& de, upath subprefix,
                   const undoo::vector<upath> &subtree);
    
    restdumpstream(context &main, const location& _rootmetaloc, const DIRELEM& de, upath subprefix,
                   const undoo::vector<upath> &subtree, const ustring& target, const ustring &added_path);

    void init();
    void childdone(cycle *child);

private:
    restdumpstreamcontext m_ctx;     
    phase                 m_phase;
};





class restdumpstreamretrieve : public cycle
{
public:
    enum phase {
        phase_get_toplevel,
        phase_check_multivolume,
        phase_get_system_info,
        phase_get_dirmap,
        phase_get_aclmap,
        phase_get_typemap,
        phase_done
    };

    restdumpstreamretrieve(cycle *parent, restdumpstreamcontext &ctx);

    void init();
    void childdone(cycle *child);

private:
    restdumpstreamcontext &m_ctx;     
    name_to_direlemp_table m_listing; 
    fileref                m_buffer;  
    phase                  m_phase;
    bool                   retrieving_snapview_listing;
};




class restdumpstreammarkfiles : public cycle
{
public:
    restdumpstreammarkfiles(cycle *parent, DIRELEMp de, restdumpstreamcontext &ctx);

    void init();
    void childdone(cycle *child);

private:
    restdumpstreamcontext &m_ctx;     
    DIRELEMp              &m_de;      
    name_to_direlemp_table m_child;   
};



class restdumpcross_file : public cycle
{
public:
    enum phase {
        phase_get_header,
        phase_init_file,
        phase_get_next_action,
        phase_write_data,
        phase_get_tsaddr,
        phase_parse_tsaddr,
        phase_write_sparse,
        phase_finish_file,
        phase_done
    };

    restdumpcross_file(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx, ustring& filename);
    void init();
    void childdone(cycle *child);
    bool createfile();       

private:
    restdumpstreamcontext  &m_ctx;        
    int32_t                 m_inode;      
    upath                   m_path;       
    ustring                 m_track;      
    name_to_direlemp_table  m_listing;    
    DIRELEMp                m_de;         
    phase                   m_phase;
    ustring                 m_filename;   
    int64_t                 m_realsize;   
    upath                   m_fullpath;
    fileoffset::value_type  m_backup_size; 
    crossplatform_ctl       m_loc_counter; 
    fileoffset::value_type   m_backup_loc;   
    fileoffset::value_type   m_outfile_loc;  
    int                      m_bytes_to_process;
    fileref                  m_hdr_buf;
    fileref                  m_write_buf;
    fileref                  m_read_buf;
    cycle*                   m_hdr_cycle;
    crossplatform_ctl::XP_action    m_next_action;
};







class restdumpcross : public cycle
{
public:
    enum phase {
        phase_get_listing,
        phase_scan_children,
        phase_attributes,
        phase_done
    };

    restdumpcross(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx, ustring& filename, ustring target_dir);

    void init();
    void childdone(cycle *child);
    bool createdirectory();

private:
    restdumpstreamcontext  &m_ctx;         
    int32_t                 m_inode;       
    upath                   m_backup_path; 
    ustring                 m_track;       
    name_to_direlemp_table  m_listing;     
    DIRELEMp                m_de;          
    fileref                 m_buffer;      
    epoch_t                 m_mtime;       
    undoo::vector<intobj>   m_childinode;  
    undoo::vector<ustring>  m_childname;   
    phase                   m_phase;
    ustring                 m_filename;
    ustring                 m_target_dir;
    bool                    m_in_restorepath;
};







class restdumpstreamprune : public cycle
{
public:
    enum phase {
        phase_get_listing,
        phase_scan_children,
        phase_ntstreams,
        phase_done
    };

    restdumpstreamprune(cycle *parent, int32_t inode, upath path, ustring track, restdumpstreamcontext &ctx);

    void init();
    void childdone(cycle *child);

private:
    restdumpstreamcontext  &m_ctx;        
    int32_t                 m_inode;      
    int32_t                 m_acl_inode;  
    int32_t                 m_ntads;      
    upath                   m_path;       
    ustring                 m_track;      
    name_to_direlemp_table  m_listing;    
    DIRELEMp                m_de;         
    fileref                 m_buffer;     
    epoch_t                 m_mtime;      
    undoo::vector<intobj>   m_childinode; 
    undoo::vector<ustring>  m_childname;  
    phase                   m_phase;
};



class restdumpstream_markacls : public cycle
{
public:
    restdumpstream_markacls(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum = 0);

    void init();
    void childdone(cycle *child);

private:
    DIRELEMp               m_de;      
    restdumpstreamcontext &m_ctx;     
    fileref                m_listing;
};





class restdumpstreamoutput : public cycle
{
public:
    enum phase {
        phase_start,
        phase_clri,
        phase_bits,
        phase_root,
        phase_inode2,
        phase_dirs,
        phase_acl3, 
        phase_inode3,
        phase_inode3_acls_count,
        phase_inode3_acls_out,
        phase_files,
        phase_end1,
        phase_eom,
        phase_acls,
        phase_end2,
        phase_done
    };

    restdumpstreamoutput(cycle *parent, restdumpstreamcontext &ctx);

    void init();
    void childdone(cycle *child);
    int  count_acls_in_sendmap();

private:
    restdumpstreamcontext  &m_ctx;     
    name_to_direlemp_table  m_listing; 
    fileref                 m_buffer;  
    phase                   m_phase;
};




class restdumpstreamrange : public cycle
{
public:
    restdumpstreamrange(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum = 0);

    void init();
    void childdone(cycle *child);

private:
    DIRELEMp               m_de;      
    restdumpstreamcontext &m_ctx;     
    fileref                m_listing;
};





class restdumpstream_aclsize : public cycle
{
public:
    restdumpstream_aclsize (cycle *parent, DIRELEMp de, restdumpstreamcontext &ctx);
    void init();
    void childdone(cycle *child);

private:
    DIRELEMp              m_de;
    restdumpstreamcontext &m_ctx;
    name_to_direlemp_table m_child;             
};





class restdumpstreamacl : public cycle
{
public:
    restdumpstreamacl(cycle *parent, cycle *starter, DIRELEMp de, restdumpstreamcontext &ctx, int32_t inum);

    void init();
    void childdone(cycle *child);

private:
    DIRELEMp               m_de;             
    int32_t                m_inum;           
    fileref                m_slice;          
    fileref                m_buffer;         
    uint32_t               m_nextheaderoff;  
    uint32_t               m_lastblocksize;  
    restdumpstreamcontext &m_ctx;            
};


#endif



























































































#define BIGDIRGROUP   50000





#define SENDGROUP_RATIO 10





#define MAXSPAWN 250



#define MAXLISTINGBYTES (128*1024)

#include "common.h"
#include "debug.h"
#include "priqueue.h"
#include "sortdirwalk.h"
#include "fileref.h"
#include "filestream.h"
#include "backstate.h"
#include "backstats.h"
#include "filename_cache.h"
#include "workelem.h"
#include "output.h"
#include "file.h"
#include "cache.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "nbackdir.h"
#include "nbackfile.h"
#include "nbackdata.h"
#include "timer.h"
#include "mapiwalk.h"
#include "dirrec.h"
#include "ade_mgrx.h"
#include "reparse_points.h"

#include "filenames.h"  
#include "runstage.h"


#include "backhidden.h"
#include "win_os_version_info.h"

#include <algorithm> 

#define nbackdir_msg ((xflag[2]&8)!=0)
#define nbackdir_dironly_msg ((xflag[2]&16)!=0)
#define nbackdir_bigdir_msg ((xflag[2]&1048576)!=0)

#define dbg_reparse_points      (xflag[30]&8)

#define breadth_first ((xflag[10]&2048)!=0)
#define includetarget ((xflag[21]&2048)==0)
#define sis_feature_enabled ((xflag[22]&262144)==0)
#define check_pathlevel ((xflag[13]&2097152)==0)

#define partialdetails ((xflag[30]&2048)!=0)
#define ignore_zero_or_bad0_checksum_entries ((xflag[10]&33554432)!=0) 
















nbackdir::nbackdir(BackCycle *parent, workelem *info_, fileoffset offset_,
                   bool manual, bool reserve_hiddendir,
                   bool excluded_, bool top_level_,
                   int traverse_depth_, int callers_reparse_traverse_depth,
                   bool skip_contents_, cycle* starter, bool use_container_ ,
                   bool enqueue_on_thread_pool , inode_table *inode_tab_ ,
                   hardlink_path_table *hardlink_path_tab_ ,
                   bool write_ddrfiles_xml_ 
):
    BackCycle(parent, info_),
    dirgroup(NULL),
    elements(NULL),
    fillindex(0),
    sendindex(0),
    drainindex(0),
    more_dirgroups(false),
    flush_listing(false),
    maxgroupentries(BIGDIRGROUP),
    maxsendentries(BIGDIRGROUP/SENDGROUP_RATIO),
    group_count(0),
    entry_count(0),
    datachild(NULL),
    hiddendirp(NULL),
    altstrchild(NULL),
    securitychild(NULL),
    top_level(top_level_),
    skip_contents(skip_contents_),
    threadStarter(false),
    traverse_depth(traverse_depth_),
    reparse_traverse_depth(0),
    use_container(use_container_),
    skip_dir_container_entry(false),
    manual(manual),
    inode_tab(inode_tab_),
    hardlink_path_tab(hardlink_path_tab_),
    write_ddrfiles_xml(write_ddrfiles_xml_)
{
    assert(parent != NULL);
    elements = new direlemp_list_type(DEFAULTDIRSIZE); 
    cycle::offset = offset_;
    this->cyexcluded = excluded_;
    this->cyisdirectory = true; 

    
    

    if (!info) {        
        DB->bt_msg("nbackdir::nbackdir ---------------------> INFO is NULL <------------------------");
        Out->Abort("NULL workelem (info)");
        return;
    } else if(nbackdir_msg) {
        DB->msg("nbackdir::nbackdir (this:%p) (parent:%p %s) info->path='%s' de.path='%s' top-level=%d manual=%d track=%d use_container:%d starter:%p",
                this, parent, typeid(*parent).name(), *info->path.image(), *info->direlemp->fullpath().image(), top_level_, manual, getThreadNbr(), use_container, starter);
    }
    assert(this != starter);  

    
    if (info->direlemp->is_reparsePoint()) {
        
        
        if (traverse_depth == 1) {
            
            
            (void)HandleReparsePoint(info->direlemp, info->direlemp->fullpath(), true);
        }
        else if (traverse_depth > 1) {
            
            
            this->reparse_traverse_depth = ++callers_reparse_traverse_depth;
        }
    }
    else {
        this->reparse_traverse_depth = callers_reparse_traverse_depth;
    }

    if( reserve_hiddendir ) {
        const fileoffset hiddenoff = do_direlem( UNDOO_DIRECTORY_NAME, ATTR_DIRECTORY|ATTR_INTERNAL, KIND_UNIX, true, false, &hiddendirp );  
        assert(hiddenoff == 0);
        assert(nforked == 1);
        assert(hiddendirp != NULL);
        fillindex++;
    }

    assert(main);
    main->num_open_dirs++;

    
    
    
    
    
    
    skip_dir_container_entry = (!manual && top_level && !use_container);

    if( !manual ) {

        assert(info);
        ustring path = info->path.image();

        
        
        
        
        
        
        
        
        
        
        
        
        
        if ((flags.pluginid.kind() == pidtype::backupboost ? enqueue_on_thread_pool : true) && isNewStreamThreadOK(getThreadNbr(), info->path)) {
            
            
            
            DB->msg("nbackdir::nbackdir '%s' changing track (parent:%p) (this:%p)", *path, parent, this );
            todoEnqueue(TODO_RESPONSE, EMPTYCYCLE);    
            
            
            
            
            threadStarter = getrootinfo()->enqueueOnNewThreadRC(path, TODO_DIR, this, -traverse_depth, starter);

        } else if(starter) {
            starter->setnext(TODO_DIR, this, -traverse_depth);  

        } else {
            todoEnqueueInsert(TODO_DIR, this, -traverse_depth);
        }

        if (info->use_container) {
            assert(!info->container.isnull()); 
        }

    } else if (info->use_container) {
        
        
        assert(!info->container.isnull());
        container_begindir(info->direlemp, "constructor manual mode");
    }
}

void nbackdir::do_file_finish() {
    DB->msg("nbackdir::do_file_finish (this:%p)", this);
    childdone(NULL);  
}

bool nbackdir::initialize_dir() {
    scope s(nbackdirlock);

    if(nbackdir_msg || nbackdir_dironly_msg ) DB->msg("nbackdir::initialize_dir (this:%p) (parent:%p) fs path:'%s'", this, parent, *info->path.image());

    main->set_cur_filename(info->path, true);

    cyisdirectory = true;

    ELEMID elemid(info->path, info->direlemp->is_mapi() ? ELEMID::EKIND_MAPI :
                                                          ELEMID::EKIND_FILE);

    if (info->use_container) {
        assert(info->container.isdefined());
        
        container_begindir(info->direlemp, "nbackdir::initialize_dir");
    }

    
    maxgroupentries = flags.bigdirgroup>0?flags.bigdirgroup:BIGDIRGROUP;
    if (maxgroupentries < 100) maxgroupentries = 100;   

    maxsendentries = maxgroupentries/SENDGROUP_RATIO;
    if (maxsendentries < 50) maxsendentries = 50;       

    
    dirgroup = new dirwalkgroup(maxgroupentries, elemid, &main->state->fsinfo, true, main->state);

    const ustring direrr(dirgroup->geterror());
    
    if (!skip_contents && !direrr.isempty()) {
        
        if (info->direlemp->is_reparsePoint()) {
            
            
            Out->msg(ERR, "Unable to open target directory of reparse point '%s': link may be broken.", *info->path.image());
        }
        else {
            Out->msg(ERR, "<5244>Unable to open directory \"%s\" (%s).", *info->path.image(), *direrr);
        }

        
        if (info->use_container) {
            assert(info->container.isdefined());
            container_enddir(info->direlemp, "nbackdir::initialize_dir (dirwalk failed)");
        }
        hash = hashcode::empty;  
        set_error(true, "");  
        return false;
    }
    else
        Out->msg(VERBOSE, 4, "%s", *(info->path.image() / DIRSEPSTR));

    
    
    more_dirgroups = dirgroup->getnextgroup();
    group_count++;
    sendindex = maxsendentries;
    if (nbackdir_msg || nbackdir_bigdir_msg) DB->msg("nbackdir::initialize_dir (this:%p) dirgroup maxentries=%d, got dirgroup (%"Z"d elements), more=%d",
                                                     this, maxgroupentries, dirgroup->groupsize(), more_dirgroups);

    return true;
}

void nbackdir::init()
{
    if( nbackdir_msg ) DB->msg("nbackdir::init (this:%p) path='%s'", this, *info->path.image());

    cycle* prev_dircycle=NULL; 
                               
                               


    
    if (dirgroup == NULL && !initialize_dir()) {
        info->direlemp->set_file_size(sizeofchildren);  
        this->notifyparent();   
        return;
    }

    if(nbackdir_msg) {
        DB->msg("nbackdir::init: (this:%p), dirgroup (%s elements), maxentries=%d, more_dirgroups=%c, collect_done=%c, group_count=%d, flush_listing=%c",
	             this, *::tostr(dirgroup->groupsize()), maxgroupentries, (more_dirgroups?'T':'F'), (collectdone?'T':'F'), group_count, (flush_listing?'T':'F'));
    }

    scope s(nbackdirlock);

#if SYSTEM_WINDOWS
    if(!info->direlemp->is_encrypted()) {
        
        if(backupaltstream(info->direlemp))
            if(nbackdir_msg) DB->msg("nbackdir::init: alternative data stream of \"%s\" is backed up.", *info->path.image());
    }
#endif
    
    if(backupsecurity(info->direlemp))
        if(nbackdir_msg) DB->msg("nbackdir::init: security data of \"%s\" is backed up.", *info->path.image());

    
    
    
    
    if (collectdone) {
        assert(more_dirgroups);     
        elements->clear();          

        
        more_dirgroups = dirgroup->getnextgroup(); 
        group_count++;
        DB->msg("nbackdir::init: BIGDIR got next dirgroup (%"Z"d elements), maxentries=%d, more=%d",
                dirgroup->groupsize(), maxgroupentries, more_dirgroups);

        
        forksdone = false;
        collectdone = false;
        fillindex = 0;
        sendindex = maxsendentries;
        drainindex = 0;
    }

    
    
    if (fillindex == 0 && !flush_listing && more_dirgroups) {
        
        Out->msg(INFO, 3, "<12490>Processing large directory \"%s\" (group %d, %d >= %d entries)",
                 *info->path.image(), group_count, entry_count+(int)dirgroup->groupsize(), maxgroupentries);
    }

    flush_listing = false;

    assert(dirgroup != NULL);
    assert(elements != NULL);

    
    
    
    
    

    int cnt = 0;

    DIRELEMp dirp = NULL;
    
    for (; dirgroup->getnext(dirp); fillindex++) {
        if (!uapp::staging().canRun()) break;

        const upath fullpath(dirp->fullpath());

        
        
        assert(elements->size() == (size_t)fillindex);
        assert(elements->size() <= (size_t)maxgroupentries);  
                                                              
                                                              
        elements->push_back(dirp);

        if( nbackdir_msg ) {
            DB->msg("nbackdir::init (this:%p), curdir='%s'; evaluating path='%s' (isDir=%d) size=%s iswindrive=%d",
                    this, *(info->path.image()), *(fullpath.image()), dirp->is_directory(), *(dirp->file_size().image()), +dirp->is_drive() );
        }

        int deltlen = 0;
        
        
        bool matchesTargets = main->state->targets.match(fullpath, dirp->is_directory(), deltlen);

        if (nbackdir_msg) DB->msg("nbackdir::init (this:%p)'%s' %s match targets list, deltlen=%d", this, *fullpath.image(), matchesTargets ? "DOES" : "DOES NOT", deltlen);

        
        
        
        
        if(dirp->is_symlink() && (flags.dereference || !matchesTargets)) {
            DB->msg("nbackdir::init (this:%p) traversing symlink '%s'", this, *fullpath.image());
            
            
            dirp->initialize(fullpath, false, true); 
            matchesTargets = main->state->targets.match(fullpath, dirp->is_directory(), deltlen);
        }

        if( (flags.notemporary && dirp->is_markedtemporary()) ||
            (flags.nobackupsystem && dirp->is_system()) ||
            (flags.nobackuphidden && dirp->is_hidden())) {
            dirp->skip_this_file(true);
        }

        
        
        if( flags.skip_highlatency && dirp->is_highlatency()) {
            dirp->skip_this_file(true);
        }

        
        if(skip_contents) {
            DB->msg("nbackdir::init skipping directory contents, entry '%s'", *fullpath.image());
            (*elements)[fillindex] = NULL;
            continue;
        }

        if(dirp->is_directory()&&flags.no_recursion) {
            DB->msg("nbackdir::init skipping recursion into dir '%s'",*fullpath.image());
            (*elements)[fillindex] = NULL;
            continue;
        }

        
        if(dirp->should_skip_this_file()) { 
            if( nbackdir_msg ) DB->msg("nbackdir::init skipping file '%s'", *fullpath.image());
            (*elements)[fillindex] = NULL;
            continue;
        }
        

        if (!matchesTargets) {
            if( nbackdir_msg ) DB->msg("nbackdir::init skipping a non-included file (isdir=%d):%s", dirp->is_directory(), *fullpath.image());
            (*elements)[fillindex] = NULL;
            continue;
        }

        
        
        bool walkReparsePoint = true;
        if (dirp->is_reparsePoint()) {
            
            
            
            
            walkReparsePoint = HandleReparsePoint(dirp, fullpath, (matchesTargets && (deltlen != INVALID_LEVEL_MATCH && deltlen <= 0)));
        }

        
        
        

        bool exclude_dir = false;
        
        upath patpath(fullpath);
        if(dirp->is_directory()) {
            patpath.set_end_dirsep(true);
        }

        if( nbackdir_msg ) DB->msg("nbackdir::init (this:%p) - patpath.image = \"%s\" ", this, *patpath.image());
        if (cyexcluded || main->state->excludes.match(patpath)) {
            
            
            
            
            
            bool checkdepth = check_pathlevel;  
#if SYSTEM_WINDOWS
            checkdepth = flags.backupsystem || check_pathlevel;
#endif
            if(includetarget
               && ((!cyexcluded
                    && main->state->targets.exact(patpath, dirp->is_directory()))     
                   || ((deltlen != INVALID_LEVEL_MATCH) && (deltlen <= 0) && checkdepth))  
               
               
               
               
            ) {
                if(deltlen < 0) exclude_dir = true;
                Out->msg(INFO, "<8026>Backing up path \"%s\" even though it is excluded because it is in the targets list", *patpath.image());

            
            } else if ( main->state->includes.match(patpath) 
            ) {
                Out->msg(INFO, 3, "<5245>Including \"%s\" in backup.", *patpath.image());
                cyincluded++;  

            } else {
                
                if ((dirp->is_directory() && !main->state->includes.isempty())  
                    
                ) {
                    Out->msg(INFO, 3, "<5246>Traversing excluded directory \"%s\"", *patpath.image());
                    exclude_dir = true;

                } else {
                    Out->msg(INFO, 3, "<5247>Excluding \"%s\" from backup.", *patpath.image());
                    main->byteprogress(context::backupstats, stats::excluded, dirp->file_size().dvalue());
                    (*elements)[fillindex] = NULL;
                    continue;
                }
            }
        }
        else if (flags.exclude_cachefile && patpath.stripdir().contains("_cache") && main->state->cache_excludes.match(patpath)) {
            if( nbackdir_msg ) DB->msg("nbackdir::init - cache_excludes matches patpath.image = \"%s\" ", *patpath.image());
            
            if(cache::is_supported_cachefile(patpath.image(), NULL, NULL, NULL)){
                
                Out->msg (INFO, 3, "<7877>Excluding cachefile \"%s\" from backup.", *patpath.image());
                main->byteprogress(context::backupstats, stats::excluded, dirp->file_size().dvalue());
                (*elements)[fillindex] = NULL;
                continue;
            }
            else if (nbackdir_msg)
                DB->msg("nbackdir::init - does NOT excluding cachefile \"%s\" from backup.", *patpath.image());
        }
        if(!uapp::staging().canRun(RSTAGE_WRAPUP)) throw EXC_CANCEL;

        if( nbackdir_msg ) DB->msg("nbackdir::init (this:%p) filename = %s\n", this, *patpath.image());

        
        
        
        bool go = true;  
        
#if SYSTEM_UNIX
        ustring fstype, reason;
        
        
        
        
        
        
        
        
        
        
        if( !info->isapi && !dirp->is_device_file() && !dirp->same_device_as( *info->direlemp )) {
            go=main->state->fsinfo.do_mount_point(dirp->device_number(), fullpath, fstype, reason);
            DB->msg("nbackdir::init   >>>>>> AH HAH!!! go:%d", go);
            if (!go && fstype=="") {  
                Out->msg(WARN, "<5652>Not traversing into %s (%s) - %s (possible automount directory)",
                         *fullpath.image(), *fstype, *reason);
                DB->msg("nbackdir::init - Backup path %s has no fstype. Using --x15=131072 to continue traversing into the path",
                         *fullpath.image());
                (*elements)[fillindex] = NULL;
                continue; 
            }
        }

#endif
        
        if( nbackdir_msg ) DB->msg("nbackdir::init  maxfilesize=%.01f, direlem=%.01f",
                                   flags.maxfilesize, dirp->file_size().dvalue());
        if(!dirp->is_device_file() && go &&
           flags.maxfilesize != 0 && dirp->file_size().dvalue() > (flags.maxfilesize*1024*1024))  {
            DB->msg("nbackdir::init  file too large  (%s) (%.0f)", *fullpath.image(), +dirp->file_size().dvalue());
            Out->msg(WARN, "<5134>Excluding file \"%s\" (%.0f bytes) because it exceeds maximum file size of %.0f",
                     *fullpath.image(), dirp->file_size().dvalue(), flags.maxfilesize*1024*1024);
            main->byteprogress(context::backupstats, stats::excluded, dirp->file_size().dvalue());
            (*elements)[fillindex] = NULL;
            continue;
        }

        

        
        const fileoffset patchoffset(fillindex);   

        
        bool isa_directory = dirp->is_directory();







#if SYSTEM_UNIX
        if( ! go ) {
            

            DB->msg("nbackdir::init NOT DOING file system on %s, type=%s reason=%s\n", *fullpath.image(), *fstype, *reason);
            Out->msg(INFO, "<5135>Not traversing into %s (%s) - %s", *fullpath.image(), *fstype, *reason);

            
            
            if( ! isa_directory ) {
                Out->msg(WARN, "<5663>Found a file system mount point that is not a directory (%s)!", *fullpath.image());
                continue;
            } else {
                
                dirp->set_internal(true);
            }
        }
#endif

        if (info->direlemp->is_mapi())
            dirp->set_is_mapi();

        
        undoo::auto_ptr<workelem> w(new workelem(info, fullpath, dirp));
        if (w.get() == NULL) {
            set_error(true, "nbackdir::init Out of Memory");
            uapp::cancel(EXIT_MISC);
            return;
        }

        cycle *child;

        
        if( (dirp->is_device_file() || dirp->is_fifo()) && !main->state->targets.exact(fullpath, isa_directory) ) {
            dirp->set_hash(hashcode::zero);   
            main->getstatsobj(context::backupstats)->add_filecount(1);
            nbackfile::print_listing(main, w.get(), false, flags.showhash, hashcode::zero);
            continue;
        }

        if( isa_directory ) {
            

            
            if (!walkReparsePoint) {
                go = false;
            }
            
            nforked++;  

            
            
            
            child = create_nbackdir(this, 
                                    w.release(),              
                                    patchoffset,    
                                    false,          
                                    false,          
                                    exclude_dir,    
                                    false,          
                                    traverse_depth + 1,     
                                    reparse_traverse_depth, 
                                    !go,            
                                    prev_dircycle,  
                                    info->use_container,   
                                    threadStarter,
                                    inode_tab,
                                    hardlink_path_tab
                                    );
            if(info->use_container)prev_dircycle = child;  

        } else {
            bool createBackFile = true;
            if (!walkReparsePoint) {
                createBackFile = false;
            }
            if (createBackFile) {
                nforked++;  
                
                
                child = new nbackfile(this, w.release(), patchoffset);
            }
        }

        
        
        if(!info->use_container && (xflag[21]&2)==0 && ++cnt >= MAXSPAWN) {                     
            if( nbackdir_msg || nbackdir_dironly_msg ) DB->msg("nbackdir::init(%p): Requeueing self after %d elements", this, nforked);
            todoEnqueueInsert(TODO_DIR, this, -(traverse_depth+1));     
            fillindex++;                                                
            return;
        }

        
        if (fillindex >= sendindex) {
            if( nbackdir_msg || nbackdir_dironly_msg )
                DB->msg("nbackdir::init(%p): Flushing direlems at %d elements with nforked=%d ncollected=%d", this, fillindex, nforked, ncollected);
            flush_listing = true;                                       
            fillindex++;                                                
            sendindex = fillindex + maxsendentries;                     

           
           
           
           
           
           
           if (nforked == ncollected) {
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               childdone(NULL);
           }
           return;
        }

    } 

    childdone(NULL);  
}

void nbackdir::response(message& outargs ) {
    DB->msg( "nbackdir::response" );
    assert(false);
}

void nbackdir::childdone(cycle *child) {
    { scope s(nbackdirlock);    

    if( nbackdir_msg ) {
        
        DB->msg("nbackdir::childdone (this:%p) (child:%s at %p)", this, (child ? typeid(*child).name() : "forksdone"), child);
        DB->msg("nbackdir::childdone (this:%p) ncollected=%d nforked=%d collectdone=%s more_dirgroups=%s",
                this, ncollected, nforked, collectdone ? "true" : "false" , more_dirgroups ? "true" : "false");
        nbackfile * file = dynamic_cast<nbackfile *>(child);
        if (file) {
            DB->msg("nbackdir::childdone (this:%p) nbackfile done, filename='%s'", this, *file->getInfo()->direlemp->fullpath().image() );
        }
    }

    if(!collectdone) {
        if(child == NULL) {  
            
            
            
            
            
            
            if(!flush_listing)
                forksdone = true;
        } else {
            if((altstrchild != NULL) && (altstrchild == child)) {
                
                DIRELEMp de = info->direlemp;
                int dep_offset = de->adddephash(child->hash);
                dirrec_pack::dir_altstream altstr_pack(de.getimpl());
                altstr_pack.set(dep_offset, altstreamsize);
                if(nbackdir_msg)
                    DB->msg("nbackdir::childdone setting alternative data hash for folder: %s, hash %s, depoff:%d",
                             *de->name(), *child->hash.partialimage(), dep_offset);
            } else if((securitychild != NULL) && (securitychild == child)) {
                
                DIRELEMp de = info->direlemp;
                int dep_offset = de->adddephash(child->hash);
                dirrec_pack::large_security ls_pack(de.getimpl());
                ls_pack.set(dep_offset);
                if(nbackdir_msg)
                    DB->msg("nbackdir::childdone setting security for folder: \"%s\", hash %s, depoff:%d",
                             *de->name(), *child->hash.partialimage(), dep_offset);
            } else {
                assert(elements != NULL);
                assert(child->offset >= 0);
                assert(child->offset.value() < (bigint64)elements->size());

                const int child_index = (int)child->offset.ivalue();
                

                assert((*elements)[child_index] != NULL);         
                DIRELEM &child_de = *((*elements)[child_index]);  

                
                
                
                
                
                
                
                
                
                
                
                
                const bool togsan = (child_de.get_location().getMedia() == location::media::gsan || (child_de.get_location().getMedia() == location::media::unknown && !use_container));
                if ((child->hash == hashcode::zero && (togsan || child_de.is_directory() || child->has_error()))
                    || (child->cyexcluded && child->cyincluded==0) )
                {
                    
                    DB->msg("nbackdir::childdone setting '%s' to internal. hashcodezero:%c, togsan:%c, isdir:%c, has_error:%c",
                            *child_de.fullpath().image(), (child->hash == hashcode::zero)?'T':'F', togsan?'T':'F', child_de.is_directory()?'T':'F', child->has_error()?'T':'F');
                    child_de.set_internal(true);
                }

                if( main->isatombit() && child->cyisatomic )
                    child_de.set_is_atomic();

                if( nbackdir_msg ) {
                    ustring what(child_de.fullpath().image());
                    
                    if (what.isempty()) {
                        
                        BackCycle * bc = dynamic_cast<BackCycle *>(child);
                        if (bc != NULL && bc->getInfo()) {
                            what = bc->getInfo()->path.image();
                        }
                    }
                    DB->msg("nbackdir(%p)::childdone setslice '%s' hash:%s offset:%s size:%s", this, *what, *child->hash.partialimage(),
                        *child->offset.image(), *(child_de.file_size().image()));
                }

                if(nbackdir_msg)DB->msg("nbackdir::childdone setslice hash:%s offset:%s", *child->hash.partialimage(), *child->offset.image());
                child_de.set_hash(child->hash);

                child_de.set_computed_file_size(child_de.file_size());        

                if (child_de.computed_file_size() == 0) {                
                    child_de.set_computed_file_size(child->size);
                }

                if (flags.pluginid.kind() == pidtype::backupboost) {
                    bool is_hardlink = (!child_de.is_directory() && child_de.hard_links() > 1);
                    
                    
                    
                    if (child_de.is_directory() || is_hardlink) {
                        child_list.add_child(child_de.inode_number64());
                    }
                    const MetadataId metadataid(child_de.file_hash());
                    
                    
                    if (child_de.is_directory()) {
                        inode_tab->update_metadataid(child_de.inode_number64(), metadataid);
                    }
                    if (is_hardlink) {
                        
                        inode_tab->add_entry(child_de.inode_number64(), metadataid, child_de.file_size(), true, false,
                                             child_de.get_location().get_abs_offset_in_container().value());
                        
                        hardlink_path_tab->add_path_entry(child_de.inode_number64(), child_de.fullpath(),
                                                          bbevent::subtype_none, true ,
                                                          true );
                    }
                }

                
                BackCycle *tmp = dynamic_cast<BackCycle *>(child);
                
                if(tmp != NULL && ((tmp->getInfo() && tmp->getInfo()->direlemp->is_partial()) || (xflag[5]&32768)!=0) ) {
                    if( nbackdir_msg ) DB->msg("nbackdir::childdone patching %s to be internal, (this=%p)", *tmp->getInfo()->path.image(), this );
                    child_de.set_internal(true);
                }

                
                
                
                if (flags.from_stdin &&                                                 
                    flags.streamformat_in==utar_flags_enums::streamformat_none &&          
                    tmp->getInfo() && !tmp->getInfo()->direlemp->is_internal() )        
                {
                    child_de.set_file_size(child->size);                                     
                    if (!child->cyisdirectory)
                        main->addfilebytes(context::backupstats, child->size.dvalue()); 
                }

                const fileoffset changesize = child->size - child_de.file_size();
                if (!child->cyisdirectory && changesize > fileoffset(0)) { 
                    main->addfilebytes(context::backupstats, changesize.dvalue());
                }

                sizeofchildren += child->size;  
            }
            ncollected++;
        }

        
        if(forksdone && hiddendirp != NULL && !more_dirgroups && nforked-1 == ncollected ) {
            
            DB->servlog("LOGSTATS", main->getstatsobj(context::backupstats)->xml(main->getAdeMgr()), main->get_errorsummary_xml());  
            

            fileoffset   incdumpsize;
            if((flags.streamformat_in == utar_flags_enums::streamformat_dump) &&
               flags.incremental && child != NULL) 
                incdumpsize = child->size;

            bool backhidden_should_write_out_ddrfilesxml(false);
            
            if(nbackroot *nbr = dynamic_cast<nbackroot *>(parent)) {
                const workelem *parentinfo(nbr->getInfo());

                
                if(parentinfo && parentinfo->use_container && !parentinfo->container.isnull()) {
                    cycle::main->finalizeucontainer(parentinfo->container, false);

                    
                    nbr->set_ucontainer_finalized();

                    backhidden_should_write_out_ddrfilesxml = write_ddrfiles_xml;
                }
            }

            DB->msg("nbackdir::childdone calling backhidden nforked:%d ncollected:%d", nforked, ncollected);
            workelem *w = new workelem(info, hiddendirp->fullpath(), hiddendirp, filestatsref());
            w->use_container = false;
            
            backhidden *hidden = new backhidden(this, w, 0, incdumpsize, false, backhidden_should_write_out_ddrfilesxml); 
            hidden->noop();
        }

        
        
        
        
        if((forksdone || flush_listing) && nforked == ncollected) {
            if( nbackdir_msg ) DB->msg( "nbackdir::childdone done forking (nforked=%d, ncollected=%d): elements=%d", nforked, ncollected, (int)elements->size());
            assert(elements != NULL || !uapp::staging().canRun());

            
            
            
            if (info->use_container && forksdone && !more_dirgroups && uapp::staging().canRun()) {
                assert(info->container.isdefined());
                container_enddir(info->direlemp, "childdone");
            }

            if (info->use_container) {
                
                
                std::sort(elements->begin(), elements->end(), DIRELEM::direlemp_list_type_container_cmp);
            }

            
            drainindex = 0;
            if (forksdone) collectdone = true;

            if (flags.pluginid.kind() == pidtype::backupboost) {
                backhidden *backhidden_cycle = dynamic_cast<backhidden *>(parent);
                
                if (!backhidden_cycle) {
                    const MetadataId metadataid(hashcode::empty);
                    if (info->direlemp->is_directory()) {
                        ubigint64 inode = info->direlemp->inode_number64();
                        if (inode != 0)
                            
                            
                            inode_tab->add_entry(inode, metadataid, info->direlemp->file_size(), true, true,
                                                 (info->direlemp->get_location().get_abs_offset_in_container() +
                                                  info->direlemp->get_location().get_header_size()).value(),
                                                 &child_list);
                    } else {
                        
                        inode_tab->add_entry(info->direlemp->inode_number64(), metadataid, info->direlemp->file_size(), true, false,
                                             info->direlemp->get_location().get_abs_offset_in_container().value());
                    }
                }
            }

            if (datachild == NULL) {
                
                if (nbackdir_msg) DB->msg("nbackdir::childdone (this:%p) Spawning backdataconsumer", this);
                fileref x;
                workelem *w = new workelem(NULL, x);
                datachild   = new backdataconsumer(this, w, this, true  );  
            } else {
                
                todoEnqueue(TODO_CHUNK, datachild);
            }
        }
        return;
    } else {
        
        assert(datachild != NULL);
        assert(child == datachild);
        assert(!uapp::staging().canRun() || !more_dirgroups);

        
        
        
        if(threadStarter) {
            threadStarter = false;                  

            DB->msg("nbackdir::childdone() request stop thread:%d, new thread:%d for path '%s'",
                        getThreadNbr(), parent->getThreadNbr(), *info->path.image());

            todoEnqueue(TODO_DONE, NULL);           
            setThreadNbr(parent->getThreadNbr());   

            
            
            if (info->use_container && !info->container.isnull()) {
                
                main->finalizeucontainer(info->container);
            }
        }

        
        if (entry_count > maxgroupentries)
            Out->msg(WARN, "<5079>Large number of entries (%d > %d) in directory \"%s\" -- Listing not perfectly sorted.",
                     entry_count, maxgroupentries, *info->path.image());

        
        if( nbackdir_msg ) DB->msg("nbackdir::childdone (this:%p) - ALL DONE: size:%s sizeofchildren:%s de.name:'%s'", this, *size.image(), *sizeofchildren.image(), *info->direlemp->fullpath().image() );
        size = sizeofchildren;  
        info->direlemp->set_file_size(sizeofchildren);  
    }
    }   

    this->notifyparent();
}

void nbackdir::notifyparent() {
    if( nbackdir_msg ) DB->msg("nbackdir::notifyparent (this:%p) dir completed. path='%s' excluded:%d included:%d  (parent:%p)",
                                this, *info->path.image(), cyexcluded, cyincluded, parent);
    if (cyincluded > 0) parent->cyincluded++; 
    delete elements;
    elements = NULL;
    delete dirgroup;
    dirgroup = NULL;
    
    
    BackCycle::notifyparent();
    
}

nbackdir::~nbackdir() {
    

    ustring path = info->path.image();   

    main->num_open_dirs--;

    if(!manual && flags.report_targets_done)
        report_target_done(true, true);

    
    if(hash != hashcode::zero && !info->direlemp->is_internal() && !top_level) main->getstatsobj(context::backupstats)->add_dircount(1);
    if( nbackdir_msg || nbackdir_dironly_msg) DB->msg( "nbackdir::~nbackdir internal=%d, top_lev=%d (parent=%p) (this=%p) ""%s""", info->direlemp->is_internal(), top_level, parent, this, *path );
    if(! info->isapi) {
        if (nbackdir_msg) DB->msg("nbackdir::~nbackdir deleting info %p", info);
        delete info;
        info = NULL;
    } else {
        if (nbackdir_msg) DB->msg("nbackdir::~nbackdir NOT deleting info %p", info);
    }
    delete elements;
    elements = NULL;
    delete dirgroup;
    dirgroup = NULL;

    if(threadStarter) {  
        DB->msg("nbackdir::~nbackdir() stopping thread %d for path '%s'", getThreadNbr(), *path);
        todoEnqueue(TODO_DONE, NULL);   
    }
}










fileref nbackdir::nextdatablock(bool& suppress_requeue)
{
    assert(collectdone || flush_listing);

    fileref dirlisting;
    suppress_requeue = false;

    if (elements == NULL) return dirlisting;    

    if (nbackdir_bigdir_msg) DB->msg("nbackdir::nextdatablock(\"%s\"), elements=%d, group=%d, drainindex=%d, more_dirgroups=%d",
                                     *info->path.image(), (int)elements->size(), group_count, drainindex, more_dirgroups);

    assert(drainindex >= 0 && drainindex <= (int)elements->size());

    
    if (!partial_listing.isnull()) {        
        DB->msg("nbackdir::nextdatablock Appending \"%s\" to snapup", *info->path.image());
        dirlisting = partial_listing;       
        if (partialdetails) {
            DB->msg("nbackdir::nextdatablock: partial:");
            dirlisting.hexdump(true);
        }
        partial_listing = fileref();        
        return dirlisting;
    }

    
    if (drainindex >= (int)elements->size()) {
        if (flush_listing || more_dirgroups) {
            if (nbackdir_bigdir_msg) DB->msg("nbackdir::nextdatablock: Done with this group");

        
            elements->clear();                  
            fillindex=0;
            sendindex=maxsendentries;

            
            todoEnqueueInsert(TODO_DIR, this, -(traverse_depth+1));     

            suppress_requeue = true;            
            dirlisting.initlist(1);             
            return dirlisting;
        }

        if (nbackdir_bigdir_msg) DB->msg("nbackdir::nextdatablock: All done!");
        return dirlisting;                      
    }

    
    
    
    
    dirlisting.initlist(DEFAULTDIRSIZE * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    
    for (int tmpindex=drainindex; tmpindex < (int)elements->size(); tmpindex++) {
        if ((*elements)[tmpindex] != NULL) {
            DIRELEM &dir = *((*elements)[tmpindex]);
            if(!dir.is_directory()) {
                
                
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[tmpindex] = NULL;     
                entry_count++;
                
            }

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (nbackdir_bigdir_msg) DB->msg("nbackdir::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            tmpindex++;               
            break;
        }
    }

    for (; drainindex < (int)elements->size(); drainindex++) {
        if ((*elements)[drainindex] != NULL) {
            DIRELEM &dir = *((*elements)[drainindex]);
            if(dir.is_directory()) {
                
                
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[drainindex] = NULL;     
                entry_count++;
                
            }

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (nbackdir_bigdir_msg) DB->msg("nbackdir::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            drainindex++;               
            break;
        }
    }

    if (nbackdir_bigdir_msg || nbackdir_dironly_msg) DB->msg("nbackdir::nextdatablock returning %s (drainindex=%d)", *dirlisting.desc(), drainindex);

    return dirlisting;
}


void nbackdir::cancelled() {
}






BackCycle *create_nbackdir(
                       BackCycle *parent,
                       workelem *info,
                       fileoffset offset,
                       bool manual ,
                       bool reserve_hiddendir_ ,
                       bool excluded_ ,
                       bool top_level_ ,
                       int traverse_depth_ ,
                       int reparse_traverse_depth_ ,
                       bool skip_contents_ ,
                       cycle* starter ,
                       const bool use_container ,
                       bool enqueue_on_thread_pool ,
                       inode_table *inode_tab_ ,
                       hardlink_path_table *hardlink_path_tab_ 
)
{
    traverse_depth_++;          
    if (nbackdir_dironly_msg) DB->msg("create_nbackdir(\"%s\"): Creating dir with traverse_depth=%d", *info->path.image(), traverse_depth_);
    return new nbackdir(parent, info, offset,
                        manual, reserve_hiddendir_, excluded_, top_level_,
                        (int)traverse_depth_, reparse_traverse_depth_,
                        skip_contents_, starter, use_container,
                        enqueue_on_thread_pool, inode_tab_, hardlink_path_tab_
                        );
}





fileoffset nbackdir::add_element(DIRELEMp de)
{
     scope s(elements_mut);
     const fileoffset index = elements->size();
     elements->push_back(de);
     return index;
}



fileoffset nbackdir::add_direlem(DIRELEMp de, bool haschild)
{
    const fileoffset patchoffset = add_element(de);
    if(haschild)
        nforked++;
    else {
        sizeofchildren += de->file_size();
        main->byteprogress(context::backupstats, stats::ispresent, de->file_size().dvalue());
    }
    return patchoffset;
}

void nbackdir::do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also )
{
    DB->msg("nbackdir::do_file(%s), attr=%d, datasize=%s", *name, attributes, *data.size64().image());
    DIRELEMp direlem = new DIRELEM;
    if( attributes & ATTR_INTERNAL )
    {
        Out->msg(INFO, 3, "<5084>Sending %s to server (%s bytes)", *name, *data.size64().image());
        direlem->zero();

        if (info->direlemp->is_mapi())
             direlem->set_is_mapi();
        epoch_t now((epoch_t)timer::now());
        direlem->initialize( hashcode::zero, now, now, now, data.size64(), attributes, name);


        if (use_container_also) {
            assert(!info->container.isnull());

            
            
            
            
            
            if(nbackdir_msg)DB->msg("nbackdir::do_file DDR: before beginfile (offset: %s, dir %s)", *info->container->get_curroffset().image(),
                    *direlem->fullpath().image());

            ucontainer::errortype errcode;
            if ((errcode = info->container->beginfile(direlem.getimpl(),data.size64())) != ucontainer::pce__success) {
                Out->Abort("nbackdir::do_file: Problem calling beginfile for %s (%s)",
                         *direlem->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            } else {
                if (nbackdir_msg) DB->msg("nbackdir::do_file DDR: beginfile (abs_offset_in_container: %"LL"d, dir %s)",
                                          direlem->get_location().get_abs_offset_in_container().value(),
                                          *direlem->fullpath().image());
            }

            if ((errcode = info->container->appenddata(data)) != ucontainer::pce__success) {
                Out->Abort("nbackdir::do_file: Problem calling appenddata for %s (%s)",
                         *direlem->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }
            
            
            
            
            
            if (nbackdir_msg) DB->msg("nbackdir::do_file DDR: after appenddata (offset: %s, dir %s)",
                   *info->container->get_curroffset().image(), *info->direlemp->fullpath().image());

            if ((errcode = info->container->endfile(direlem.getimpl(),0)) != ucontainer::pce__success) {
                Out->Abort("nbackdir::do_file: Problem calling endfile for %s (%s)",
                        *direlem->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }
            
            
            
            
            
            if (nbackdir_msg) DB->msg("nbackdir::do_file DDR: after endfile (offset: %s, dir %s)",
                   *info->container->get_curroffset().image(), *direlem->fullpath().image());
        }

    } else {
        if (info->direlemp->is_mapi())
            direlem->set_is_mapi();
    }

    const fileoffset patchoffset = add_element(direlem);

    cycle *child;
    if( !data.isnull() ) {
        workelem *w = new workelem( info, (upath)name, direlem, info->fstats, data);
        w->use_container = use_container_also;
        child = new nbackdata(this, w, patchoffset, false , 0, use_container_also );
        sizeofchildren += data.size64(); 
    } else {
        workelem *w = new workelem( info, direlem->fullpath(), direlem, info->fstats);
        w->use_container = use_container_also;
        child = new nbackfile(this, w, patchoffset);
    }
    nforked++;
}










fileoffset nbackdir::do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink, DIRELEMp *direlemp ) 
{
    if( nbackdir_msg || nbackdir_dironly_msg)
        DB->msg("nbackdir::do_direlem (this:%p) creating and adding DIRELEM with de.fullpath='%s', attributes=%d, kind=%d, dont_stat=%d, follow=%d, direlemp=%p)",
                this, *name, attributes, kind, dont_stat_file, follow_symlink, direlemp);

    DIRELEMp de;
    

    
    
    
    
    
    
    if( dont_stat_file ) {
        de = new DIRELEM;
        de->zero();
        epoch_t now((epoch_t)timer::now());
        de->initialize( hashcode::zero, now, now, now, fileoffset(0), attributes, name);
        de->set_fullpath(upath(name));
        if(kind == KIND_UNIX)
            de->set_unix_attributes(0666, 0, 0);
        else if(kind == KIND_UNIX_SP)
            de->set_unix_special(0, 0, 0, 1);
    } else {
        
        de = new DIRELEM( (upath)name, false, follow_symlink );
    }
    

    if( flags.mapi )
        de->set_is_mapi();

    if( flags.from_stdin ) {
        de->set_stdin();
        if (flags.streamformat_in==utar_flags_enums::streamformat_none) de->set_file_size(0);       
    }

    const fileoffset patchoffset = add_element(de);
    if (nbackdir_msg) DB->msg("nbackdir::do_direlem (this:%p) added direlem with gsan path='%s' to elements at offset %.0f", this, *de->fullpath().image(), patchoffset.dvalue());

    
    if(flags.xmlunentitifydpnpaths) {
        
        const ustring name(de->name());
        const ustring unentitified_name(xml_message::convert_xmlstring(name));
        if(name != unentitified_name) {
            DB->msg("nbackdir::do_direlem unentitified name '%s' to '%s'", *name, *unentitified_name);
        }
        de->set_name(unentitified_name);
    }

    if (direlemp != NULL) *direlemp = de;       

    nforked++;
    return patchoffset;
}






bool nbackdir::backupaltstream(DIRELEMp de) {
#if !SYSTEM_WINDOWS
    DB->msg("nbackdir::backupaltstream - This function only supports for Windows OS.");
    return false;
#else
    if(!de->supportsADS() || de->is_encrypted() || (xflag[5]&262144)) {
        return false;  
    }

    if(altstrchild != NULL)
        return false;  

    DWORD winrwmode = GENERIC_READ;
    DWORD sharemode = FILE_SHARE_READ;
    bool  isNTorlater = win_os_version_info::is_windows_NT_or_newer();
    if( isNTorlater ) {
        winrwmode |= READ_CONTROL;
        sharemode |= FILE_SHARE_DELETE;
    }

    
    
    
    
    
    const upath path = info->path;
    const HANDLE altfh = CreateFile(*path.patht("CreateFile"),
                       winrwmode,
                       sharemode,
                       NULL,
                       OPEN_EXISTING,
                       FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_POSIX_SEMANTICS,
                       NULL );
    BOOL success = (altfh != INVALID_HANDLE_VALUE && altfh != NULL);

    if(!success) {
        int err_code = (int)GetLastError();
        DB->msg("nbackdir::backupaltstream - Failed open \"%s\", error = %d", *path.image(), err_code);
        return false;
    }

    DWORD alt_data_read = 0;
    DWORD alt_data_read_block = flags.blocksize;
    fileref altdata;  
    fileref alt_data; 
    void *ctx = NULL;
    if(nbackdir_msg) DB->msg("nbackdir::backupaltstream - Successfully opened \"%s\"", *path.image());
    altdata.initlist(alt_data_read_block);
    alt_data.initmem(alt_data_read_block);
    altstreamsize = 0;
    while(success) {
        success = BackupRead(altfh, (BYTE*)alt_data.start(), alt_data_read_block, &alt_data_read, false, false, &ctx );
        if(nbackdir_dironly_msg)
            DB->msg("nbackdir::backupaltstream - calling BackupRead() at \"%s\", data read = %d", *path.image(), alt_data_read);
        if(alt_data_read == 0)  
            break;

        if(success) {
            altdata.append(alt_data);
            altstreamsize += alt_data_read;
        }
        else {
            int err_code = (int)GetLastError();
            DB->warn("nbackdir::backupaltstream - BackupRead for alternative data stream at \"%s\" failed, error %d, read %d bytes.",
                      *path.image(), err_code, alt_data_read);
        }
    }
    success = BackupRead(altfh, (BYTE*)alt_data.start(), alt_data_read_block, &alt_data_read, true, false, &ctx ) && success;
    CloseHandle(altfh);

    alt_data.initmem((size_t)altstreamsize.value());
    alt_data.setslice(0, altstreamsize.ivalue(), altdata.start());
    if(!success) {
        DB->msg("nbackdir::backupaltstream - BackupRead failed at \"%s\".", *path.image());
        altstreamsize = 0;
        return false;
    }
    if(alt_data.isnull() || alt_data.size() == 0) {    
        if(nbackdir_dironly_msg)
            DB->msg("nbackdir::backupaltstream - no aliternative data stream at \"%s\".", *path.image());
        altstreamsize = 0;
        return false;
    }

    
    workelem *w = new workelem(NULL, alt_data);
    w->ignoreStats = true;
    altstrchild = new nbackdata( this, w, do_not_set_hash, NULL);  
    altstrchild->noop();
    DB->msg("nbackdir::backupaltstream - alternative data size %d, child cycle offset %d", altstreamsize, offset.ivalue());

    nforked++;
    return true;
#endif
}








bool nbackdir::backupsecurity(DIRELEMp de) {
    fileref securitydata;
    de->get_security(securitydata);

    
    if(nbackdir_msg)
        DB->msg("nbackdir::backupsecurity - path: \"%s\", data size = %d, acl_datathreshold=%d", *de->fullpath().image(), securitydata.size(), flags.acl_datathreshold);
    if((securitydata.size() < flags.acl_datathreshold) && (xflag[5]&131072)==0)  
        return false;        

    if(securitychild != NULL)
        return false;  

    workelem *w = new workelem(NULL, securitydata);
    w->ignoreStats = true;
    
    
    
    securitychild = new nbackdata( this, w, do_not_set_hash, NULL, false);
    securitychild->noop();
    if(nbackdir_msg) DB->msg("nbackdir::backupsecurity security child offset %d", offset.ivalue());

    fileref empty;
    de->set_security(empty);  

    nforked++;

    return true;
}


bool nbackdir::HandleReparsePoint(DIRELEMp dirp, const upath& fullpath, bool walkOverride ) {
    bool walkReparsePoint = true;

    if (nbackdir_msg || dbg_reparse_points) DB->msg("nbackdir::HandleReparsePoint (this:%p) '%s', type=%s", this, *dirp->fullpath().image(), ReparsePoints::CStringForType(dirp->get_reparseType()));

    if (dirp->is_reparsePoint()) {
        upath target;
        Reparse_Type rType = dirp->get_reparseType();        
        unsigned int targAttrs = 0x00;
        
        
        
        if (rType == REPARSE_UNKNOWN || ReparsePoints::IsReparsePointTargetType(rType)) {
            
            rType = ReparsePoints::GetReparsePointInfo(fullpath, target, &targAttrs);

            
            dirp->set_reparseType(rType);
        }

        if (ReparsePoints::IsReparsePointTargetType(rType)) {
            
            ReparsePoints::SaveReparsePointDataToDirelem(*dirp, target, rType, targAttrs);
            if (!walkOverride && !ReparsePoints::ShouldTraverseReparsePoint(fullpath, rType, target, this->reparse_traverse_depth)) {
                walkReparsePoint = false;    
            }
        }
        else if (rType == REPARSE_CLUSTERSHAREDVOL) {
            
            
            walkReparsePoint = true;
        }
        else if (rType == REPARSE_DFS) {
            
            
            walkReparsePoint = false;
        }
        else if (rType == REPARSE_DEDUP) {
            
            
            ReparsePoints::SaveReparsePointDataToDirelem(*dirp, fullpath, rType, 0x00);
            walkReparsePoint = true;
        }
        else if (rType == REPARSE_SIS) {
            if (sis_feature_enabled) {
                
                if (!ReparsePoints::backup_sislink(*dirp)) {
                    
                    Out->msg(ERR, "Error occurred during initialization of SIS link \"%s\"!", *fullpath.image());
                    dirp->skip_this_file(true);
                }
            }
            else {
                Out->msg(INFO, "<9946>Avamar's Single Instance Storage backup feature is disabled, SIS link \"%s\" will be saved as a regular file and not a SIS link.", *dirp->fullpath().image());
            }
            walkReparsePoint = true;
        }
        else if (rType == REPARSE_NON_MSFT) {
            
            
            
            walkReparsePoint = true;
        }
        else {
            
            
            
            ReparsePoints::SaveReparsePointDataToDirelem(*dirp, target, rType, targAttrs);
            walkReparsePoint = true;
        }
    }
    return walkReparsePoint;
}



bool nbackdir::check_cache(const bool begindir, const DIRELEMp de, const ustring& path)
{
    
    
    
    
    if(!(flags.usearchiveattr && de->is_archived()) && main->state->fcache) {

        if(nbackdir_msg)DB->msg("nbackdir::check_cache(begindir=%d) calling fcache lookup(\"%s\", mtime=%d, detect_acl_changes=%d",
                                begindir, *path, de->mtime(), flags.detect_acl_changes);

        
        int          tagword(0);
        bool         cacheisatomic(false);
        unsigned int cache_atime(0);
        location     loc;

        
        if(!main->state->fcache->get_file_info(de->fullpath(), de->mtime(),
                                               0,  
                                               de->attr(), de->get_kind(),
                                               de->filecache_extflags() | (begindir ? DIRELEM::extflag_begindir : DIRELEM::extflag_enddir),
                                               getThreadNbr(),
                                                hash, tagword, cacheisatomic, cache_atime, loc,
                                               false)
        ) {
            if(nbackdir_msg) DB->msg("nbackdir::check_cache(begindir=%d) filename_cache miss %s", begindir, *path);
        } else {
            
            
            if(loc.isFromDDR()) {
                const tchecksum checksum(loc.get_checksum());

                if(!checksum.isempty()) {
                    if(checksum.value == 0 || checksum.value == tchecksum::DDRMGR_BADCHECKSUM) {
                        
                        DB->msg("nbackdir::check_cache(begindir=%d): Checksum for %s has a %#x value", begindir, *de->fullpath().image(), checksum.value);

                        if(ignore_zero_or_bad0_checksum_entries) {
                            Out->msg(WARN, "Ignoring filename cache entry use for '%s' (begindir:%d) because of checksum value %#x", *de->fullpath().image(), begindir, checksum.value);
                            return false;
                        }
                    }

                    
                    loc.set_checksum_type(1);
                } else {
                    
                    Out->msg(WARN, "Cache hit for %s has no checksum", *de->fullpath().image());
                    return false;
                }
            }

            const ucontainer::errortype errcode1(begindir ?
                                                 info->container->synthbegindir(loc, de.getimpl()) :
                                                 info->container->synthenddir(loc, de.getimpl())
                                                 );
            if(nbackdir_msg) DB->msg("nbackdir::check_cache(begindir=%d): ucontainer synthdir_%s %s ret:%d loc: %s", begindir, begindir?"begin":"end", *path, errcode1, *de->get_location().image());

            if(errcode1 == ucontainer::pce__success) {
                return true;
            }
        }
    }

    return false;
}



void nbackdir::container_begindir(const DIRELEMp de, const ustring& desc) {

    if (skip_dir_container_entry) {
        DB->msg("nbackdir::container_begindir  No header added to container for '%s'", *de->fullpath().image());
        return;
    }

    const ustring path(de->fullpath().image());

    ucontainer::errortype errcode(ucontainer::pce__success);
    if(!check_cache(true, de, path)) {
        
        errcode = begin_dir(info->container, de, desc);
    }

    
    
    
    
    
    if(errcode == ucontainer::pce__success && main->state->fcache && de->has_accurate_metadata() && uapp::staging().canRun()) {

        
        main->state->fcache->put_file_info( upath(path),
                                            0,
                                            de,
                                            true,
                                            0,
                                            DIRELEM::extflag_begindir,
                                            getThreadNbr());
    }
}



void nbackdir::container_enddir(const DIRELEMp de, const ustring& desc) {

    if (skip_dir_container_entry) {
        DB->msg("nbackdir::container_enddir  No footer added to container for '%s'", *de->fullpath().image());
        return;
    }

    const ustring path(de->fullpath().image());

    ucontainer::errortype errcode(ucontainer::pce__success);
    if(!check_cache(false, de, path)) {
        
        errcode = end_dir(info->container, de, desc, path);
    }

    
    
    
    if(errcode == ucontainer::pce__success && main->state->fcache && de->has_accurate_metadata() && uapp::staging().canRun()) {

        
        main->state->fcache->put_file_info( upath(path),
                                            0,
                                            de,
                                            true,
                                            0,
                                            DIRELEM::extflag_enddir,
                                            getThreadNbr());
    }
}

#if !defined(CYCLE_H_INCLUDED)
#define CYCLE_H_INCLUDED












#include "message.h"
#include "context.h"
#include "hashcode.h"
#include "hexhash.h"
#include "sendcallbase.h"
#include "ustring.h"
#include "fileoffset.h"
#include "exportstream_xml.h"

class multivolumeroot;
class utar_flags_info;
class async_callback;
class workelem;
class BackCycle;
class ADEMgrX;
class replcycle;
class safebool;
class pidtype;


class cycle {
public:
    cycle(cycle *parent, context *main = NULL);
    virtual void init();

    
    virtual void response(message& outargs);

    
    virtual void notifyparent();

    
    virtual void childdone(cycle *child);

    
    virtual void noop();

    
    
    virtual void setnext(todo_kind kind, cycle *next, const bigint64 priority);

    virtual ustring image() const;

    
    
    
    
    
    
    void bt_msg(const ustring &msg) const;

    
    virtual void setautodelete(bool b);

    
    virtual void deleteself();

    SAFEDEF();
    virtual ~cycle();

    bool has_error() { return error; }
    void set_error(bool error_, ustring msg);

    cycle *get_next_cycle() { return next_cycle; }

    inline int getDepth() const { return(depth); }

    int id();  

    
    void setasroot(multivolumeroot* ri) { rootinfo = ri; }  
    void setparentandroot(cycle *parent_);
    multivolumeroot* getrootinfo() { return(rootinfo); }
    int getThreadNbr() const { return(threadloopnum); }
    void setThreadNbr(int num) { threadloopnum = num; }

    
    ADEMgrX* getAdeMgr();
    void sendRemoteCall(cycle *cy, message& inargs);
    void enqueueResponse(cycle *cy, message& outargs, bool error);
    void todoEnqueue(todo_kind kind, cycle *cy = NULL);
    void todoEnqueueInsert( todo_kind kind, cycle *cy, bigint64 next_priority);

    virtual cycle *restore_range(const hashcode &h, const fileoffset &startbyte, const fileoffset &endbyte,
                                 const bool expectatomic, fileref &outslice, ustring &errmsg, DIRELEM &direlem,
                                 ucontainer::basep &rest_container, bool use_container = false);
    

    
    
    bool isNewStreamThreadOK(int currentThread, const upath& fulldirpath) const;
    

    cycle *    parent;
    context *  main;    

    hashcode   hash;    
    fileoffset offset;  
    fileoffset size;    

    utar_flags_info& flags;  
    async_callback *cb; 

    int nforked;       
    int ncollected;    
    int cyincluded;    
    bool cyisatomic;   

  
    bool forksdone    :1;
    bool collectdone  :1;
    bool cydeleted    :1;
    bool cyisdirectory:1;  
    bool cyexcluded   :1;  
protected:
    bool autodelete   :1;

    cycle *   next_cycle;    
    bigint64  next_priority; 
    todo_kind next_kind;     

    bool      error;

private:
    int       ident;
    int       depth;          

    multivolumeroot* rootinfo;
    int       threadloopnum;  

    NOCOPY(cycle);
}; 



#define bicycle cycle


extern cycle *EMPTYCYCLE;






class BackCycle : public cycle
{
protected:
    workelem*  info;
    void report_target_done(bool isdir, bool success) const;
public:
    
    
    BackCycle(BackCycle *parent_, context *main_, workelem *info_ = NULL) : cycle(parent_, main_), info(info_) {}

    
    BackCycle(BackCycle *parent_, workelem *info_ = NULL) : cycle(parent_), info(info_) {}
    BackCycle(cycle *parent_, workelem *info_ = NULL) : cycle(parent_), info(info_) {}

    
    inline workelem* getInfo() const { return(info); }
    virtual void notifyparent();

    
    virtual ucontainer::errortype begin_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc);
    ucontainer::errortype end_dir(ucontainer::basep container, const DIRELEMp direlemp, const ustring desc, const ustring path);

    
    
    
    
    static fileref build_diratomic(direlemp_list_type& de_listing, fileoffset& totalsize,
                                   bool flags_inode, int max_compchunk_size);

    virtual ustring image() const;
};  





class replcycle : public BackCycle
{
public:
    replcycle(replcycle *parent, context *main = NULL, workelem* info = NULL);

    inline int getAtomicDepth() {return(atomic_depth);}
    inline void setAtomicDepth(int adepth) {atomic_depth = adepth; }

    virtual void update_stats(context::statstype st, stats::reason why, chunktype ctype, double sz);
    bool   count_atomic_depth;  
    int    ddrindexfrombackup;  
    exportstream_xmlp backupinfop; 
    
    
    
    
    
    
    
    
    
    
    safebool* migration_sysinfo_write;

    
    
    
    static bool should_use_raw_containers(const tversion& avtar_version_that_created_backup, const pidtype& pid);

private:
    int    atomic_depth;   
};





class startupddr_exception {
public:
    SAFEPOOLALLOC(startupddr_exception);
    startupddr_exception(const int ddrindex_): ddrindex(ddrindex_) { }
    int get_ddrindex() const { return ddrindex; }
private:
    startupddr_exception();
    const int ddrindex;
};

#endif
















#include "common.h"
#include "debug.h"
#include "output.h"
#include "upath.h"
#include "replfile.h"
#include "restdata.h"
#include "backstate.h"
#include "workelem.h"
#include "nbackdata.h"
#include "filename_cache.h"
#include "filerefx.h"
#include "workelem.h"

#define debug_msgs ((xflag[11]&2097152)!=0)


#define SRC_DPN dpn0
#define DST_DPN dpn1





replfile::replfile(replcycle *parent, const hashcode& hash_, const int sliceoff_,
                   const ustring& name_,
                   chunktype ctype_, const int traverse_depth_, workelem* info, cycle *starter)
  : replcycle(parent, NULL, info),
    rhash(hash_),
    name(name_),
    ctype(ctype_),   
    traverse_depth(traverse_depth_),
    phase(0)
{
    
    

    
    
    
    this->offset = fileoffset(sliceoff_);

    this->hash = hashcode::empty;               

    this->use_raw_container = (!backupinfop.isnull() && replcycle::should_use_raw_containers(main->get_avtar_version_that_created_backup(), backupinfop->get_pid()));
    
    if(starter)
        starter->setnext(TODO_FILE, this,  -traverse_depth);
    else
        main->add_insert(TODO_FILE, this, -traverse_depth);         
}





replfile::repldumper::repldumper(replfile* repl_, workelem* info_) : repl(repl_), info(info_) {
    if(debug_msgs) DB->msg("replfile::repldump::repldumper()  file: %s, this(%p), info(%p), prefetchqueue(%p)", *info->direlemp->name(), this, info, info->prefetchqueue);
}


replfile::repldumper::~repldumper() {
    if(debug_msgs) DB->msg("replfile::repldump::~repldumper()");
}


int replfile::repldumper::dump(const fileref& data) {
    assert(info != NULL);
    if(debug_msgs) DB->msg("replfile::repldumper::dump file: %s, data size=%d bytes info:%p", *info->direlemp->name(), data.size(), info);
    
    if(info->use_container) {    
        assert(info->container != NULL);
        ucontainer::errortype errty = info->container->appenddata(data);
        if(errty != ucontainer::pce__success)
            Out->msg(ERR, "Replicating file %s to DDR has problem with error: %s.", *(info->direlemp->name()), *ucontainer::error_description(errty));
    } else {    
        prefetchbuf *dataread = new prefetchbuf;
        dataread->buf = data;
        if(debug_msgs) DB->msg("repldumper::dump() info(%p), prefetchqueue(%p)", info, info->prefetchqueue);
        info->prefetchqueue->enqueue(dataread);
    }

    if(debug_msgs) DB->msg("replfile::repldumper::dump() - data progression size %d", data.size());
    
    repl->update_progress(data.size());
    if(debug_msgs) DB->msg("replfile::repldumper::dump done.");
    return data.size();
}



void replfile::init() {
    
    filename_cache *fcache = main->state->fcache;

    hashcode dsthash;
    int tagword=0;
    bool isatom=false;
    unsigned int atime=0;
    location loc;
    double rsize = info->direlemp->file_size().dvalue();

    
    
    
    
    const epoch_t de_mtime(info->direlemp->mtime());
    if(de_mtime != 0) {
        const bool getfileinfo = (fcache != NULL) && !use_raw_container && fcache->get_file_info(upath(name),
                                                                                                 de_mtime,
                                                                                                 (int)info->direlemp->file_size().value(),
                                                                                                 info->direlemp->attr(),
                                                                                                 info->direlemp->get_kind(),
                                                                                                 info->direlemp->filecache_extflags(),
                                                                                                 parent->getThreadNbr(),
                                                                                                 dsthash,    
                                                                                                 tagword,
                                                                                                 isatom,
                                                                                                 atime,
                                                                                                 loc,
                                                                                                 false);    
        if(getfileinfo && tagword != 0) {
            if(loc.getMedia() == location::media::ddr && !loc.get_checksum().isempty() ) {
                loc.set_checksum_type(1);
            }

            if(loc.getMedia() != location::media::gsan) {
                if(container_cachehit(info->direlemp, loc)) {
                    update_stats(context::restorestats, stats::filecache, chunktype(0), rsize);
                    if(debug_msgs) DB->msg("replfile fcache->get_file_info cache hit %s: %s --> %s", *name, *rhash.partialimage(), *dsthash.partialimage());
                    hash = hashcode::zero;
                    main->addfilecount(context::restorestats, 1);
                    info->direlemp->set_hash(hashcode::zero);
                    notifyparent();
                    return;
                }
            }
        }
    }

    if(!uapp::staging().canRun()) {
        
        notifyparent();
        return;
    }

    if(info->use_container) assert(!info->container.isnull());

    
    if(flags.destination_data == client_config_flags::gsan_to_ddr) {
        if(info->use_container || use_raw_container) {
	  if(use_raw_container) {
              location::tcontainerid raw_containerid(1);
              info->container = main->open_raw_container_for_write(upath(name), raw_containerid);
              if(info->container.isnull()) {
                  DB->msg("replfile::init() - Failed to open raw container for gsan to ddr replication! (path %s)", *name);
                  Out->Abort("Problem on open container for '%s'", *info->path.image());
              } else
                  info->use_container = true;
            }
            ucontainer::errortype errcode = info->container->beginfile(info->direlemp.getimpl(), info->direlemp->file_size().value(), true);
            if(errcode != ucontainer::pce__success)
                Out->Abort("Problem calling beginfile for '%s' (%s)", *info->direlemp->name(), *ucontainer::error_description(errcode));
            else if(debug_msgs)
                DB->msg("replfile::init() - ucontainer->beginfile succeed");
        } else {
            DB->msg("replfile::init() - Container is empty in gsan to ddr replication! (path %s)", *name);
            Out->Abort("Container is empty for GSAN to DDR replication. (%s)", *name);
        }
    } else if(info->container.isnull()) {    
        info->container = main->open_container_for_read(info->direlemp->get_location());
    }

    dir = *info->direlemp;
    restinfo.direlem = dir;
    restinfo.path = upath(name);

    if(debug_msgs) DB->msg("replfile::init() size=%.0f rsize=%.0f", size.dvalue(), rsize);

    if(flags.destination_data == client_config_flags::ddr_to_gsan) {  
        
        
        
        info->prefetchqueue = new waitqueue(1, 5);
    }

    
    
    

    if(flags.destination_data == client_config_flags::gsan_to_ddr) {
        filerefx::initpipedump(restinfo.data, new repldumper(this, info), false, false);
        cycle*child = new restdata(this, rhash, &ctype, dir.is_atomic(), restinfo);
        child->noop();
        if(debug_msgs) DB->msg("replfile::init - child(restdata)=%p, restinfo data pointer = %p", child, restinfo.data.base());
        
        restinfo.data.free();
    } else if(flags.destination_data == client_config_flags::ddr_to_gsan) {
        info->dpninx = DST_DPN;
        info->data.initcat();
        restinfo.container = info->container;    
        replfetcher* t = new replfetcher(this, restinfo, info, flags.validate, flags.media_in_size);  
        cycle* child = new backappend(this, main, info, info->data, false);    
        child->noop();
        if(debug_msgs) DB->msg("replfile::init - child(backappend)=%p", child);
        t->start();    
    } else {
        assert(!"Invalid replication data destination.");
        notifyparent();
        return;
    }
    nforked++;
    if(debug_msgs) DB->msg("replfile::init() nforked=%d", nforked);
    childdone(NULL);
}

void replfile::response(message& outargs) {
    assert(false);
}

void replfile::childdone(cycle *child) {
    
    if(has_error()) {
        DB->msg("replfile::childdone (this:%p child:%p) has_error setting hash to empty", this, child);
        hash = hashcode::empty;
        
        notifyparent();
        return;
    }
    if(debug_msgs) DB->msg("replfile::childdone (this:%p child:%p) fcache:%p", this, child, main->state->fcache);

    if(child != NULL)
        ncollected++;
    else
        forksdone = true;

    if(forksdone && ncollected == nforked) {
        if(debug_msgs) DB->msg("replfile::childdone: collect done child %p, rhash %s, NEW file hash %s, name = %s",
                                child, *rhash.partialimage(), *hash.partialimage(), *name);
        collectdone = true;
        main->addfilecount(context::backupstats, 1);

        if(info && !info->container.isnull() && (flags.destination_data == client_config_flags::gsan_to_ddr)) {
            ucontainer::errortype errcode = info->container->endfile(info->direlemp.getimpl(), info->direlemp->file_size().value());
            if(errcode != ucontainer::pce__success)
                Out->Abort("replfile::childdone Problem calling endfile for '%s' (%s)",
                            *info->direlemp->name(), *ucontainer::error_description(errcode));
            else
                if(debug_msgs) DB->msg("replfile::childdone() - ucontainer->endfile succeed");

            if(use_raw_container) {
                if(!main->close_raw_container_for_write(info->container)) {
                    DB->msg("replfile::childdone() - Failed to close raw container for file '%s'", *name);
                    Out->Abort("Unable to close container for raw format write of '%s'", *info->path.image());
                } else
                    DB->msg("replfile::childdone() - raw container close succeed");
                info->container = NULL;
                info->use_container = false;
            }
            info->direlemp->set_hash(hashcode::zero);
        }
        else if (flags.destination_data == client_config_flags::ddr_to_gsan) {
            DB->msg("replfile::childdone: NEW file hash %s, info size = %s, info direlem file_size = %s, info direlem computed file_size = %s, name = %s",
                     *hash.partialimage(), *info->size.image(), *info->direlemp->file_size().image(), *info->direlemp->computed_file_size().image(), *name);
            
            if(info->direlemp->computed_file_size() != info->direlemp->file_size())
                info->direlemp->set_computed_file_size(info->direlemp->file_size());
            info->direlemp->set_hash(hash);
            info->direlemp->clear_location();
        }

        
        
        const epoch_t de_mtime(info->direlemp->mtime());

        if(debug_msgs) DB->msg("replfile::childdone: rhash %s, NEW file hash %s, name = %s, mtime = %s", *rhash.partialimage(), *hash.partialimage(), *name, *tostr(de_mtime));

        if( main->state->fcache && de_mtime != 0 && (hash != hashcode::zero) && (hash != hashcode::empty) ) {
            main->state->fcache->put_file_info( upath(name),
                                                (int)info->direlemp->file_size().value(),
                                                info->direlemp,
                                                cyisatomic,
                                                0,
                                                info->direlemp->filecache_extflags(),
                                                parent->getThreadNbr() );

            if(debug_msgs) DB->msg( "replfile::childdone fcache->put_file_info( %s, ...)", *name);
        }

        notifyparent();
        return;
    }
}



bool replfile::container_cachehit(DIRELEMp direlem, location loc) {
    if (debug_msgs) DB->msg("replfile::container_cachehit loc:%s", *loc.image());
    hash = hashcode::zero; 

    if (loc.get_backupid() == 0) {
        Out->msg(WARN, "Unable to use filename cache for file '%s', previous data not found in container.  Backing up data.", *direlem->name());
        return false;
    }

    ucontainer::errortype errcode;
    DB->msg("replfile::container_cachehit calling synthobj loc:%s", *loc.image());
    direlem->set_location(loc);
    if ((errcode = info->container->synthobj(direlem.getimpl())) != ucontainer::pce__success) {
        Out->msg(WARN, "replfile::container_cachehit: Problem calling synthobj for %s (%s)",
                 *direlem->fullpath().image(), *ucontainer::error_description(errcode));
        
        return false;
    }

    
    
    main->state->fcache->put_file_info( upath(name),
                                        (int)direlem->file_size().value(),
                                        direlem,
                                        cyisatomic,
                                        0,
                                        DIRELEM::extflag_nul,
                                        parent->getThreadNbr());

    if (debug_msgs) {
        location newloc(direlem->get_location());
        DB->msg("replfile::container_cachehit path=%s synthed from\n    loc:%s to\n    loc:%s",
                *name, *loc.image(), *newloc.image());
    }

    return true;
}

replfile::~replfile() {
    if(info) {
        delete info;
        info = NULL;
    }
}


replfile::replfetcher::replfetcher(replfile *repl_, restelem & restinfo_, workelem* info_, bool validate_, int media_in_size_ ) :
                                   repl(repl_), restinfo(restinfo_), info(info_), validate(validate_), media_in_size(media_in_size_)
{
    static int pfthreadcnt = 0;
    setdesc(ustring::sprintf("pf%d", ++pfthreadcnt));
}

void replfile::replfetcher::body() {
    detach();           

    if(debug_msgs)DB->msg(("replfetcher::body(): %s (%.0f bytes)"), *restinfo.path.image(), restinfo.direlem.file_size().dvalue());
    
    filerefx::initpipedump(restinfo.data, new replfile::repldumper(repl, info), false, false);
    assert(repl != NULL);
    ucontainer::errortype result = restdata::read_data_from_ucontainer(repl->main, restinfo, validate, media_in_size);
    if(result != ucontainer::pce__success) {
        DB->msg("replfile::replfetcher::body bad result from read_data_from_ucontainer");
        ustring errstr = ustring::sprintf(LOCTXT("Unable to replicate data for file '%s' (code:%s)."),
                                  *restinfo.direlem.fullpath().image(), *ucontainer::error_description(result));
        Out->msg(ERR, "%s", *errstr);
    } else if(debug_msgs) {
        DB->msg("replfetcher::body() read_data_from_ucontainer file '%s'",
            *restinfo.direlem.fullpath().image());
    }

    if(restinfo.data.getrefcount() > 0)
        restinfo.data.free();

    
    if((info->prefetchqueue != NULL) && (!info->prefetchqueue->is_terminated())) {
        info->prefetchqueue->terminate();  
    }

    if (debug_msgs) DB->msg(("replfetcher exit body()."));
}







void replfile::update_progress(double sz) {
    main->addfilebytes(context::restorestats, sz);  
    main->addfilebytes(context::backupstats, sz);
    if ((sz > 0.0) && (flags.destination_data == client_config_flags::gsan_to_ddr)){
        
        main->addprogbytes(context::restorestats, sz);  
        main->addprogbytes(context::backupstats, sz);
    }
}
#ifndef BACKEMCTARINODE2HASH_H
#define BACKEMCTARINODE2HASH_H

#include "cycle.h"
#include "dumpstreamutils.h"
#include "roothashlistrec.h"
#include "restdirlistproducer.h"
#include "hardlink_path_table.h"
#include "infofile_info.h"





































class backemctar_i2h_hashes : public BackCycle, restdirlistproducer::consumer
{
public:
    backemctar_i2h_hashes(BackCycle* parent_, workelem* we, hashcode i2h_hash, fileoffset i2h_tablesize);
    backemctar_i2h_hashes(BackCycle* parent_, workelem* we, inode_table* inodetab);
    ~backemctar_i2h_hashes();

    void init();
    void childdone(cycle *child);

    
    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer);

    SAFEPOOLALLOC(backemctar_i2h_hashes);

private:
    enum phase { phase_h_startvolume = 0,
                 phase_h_sysinfo,
                 phase_h_volume,
                 phase_h_volumedone };

    phase                    m_phase;
    hashcode                 m_i2h_hash;           
    fileoffset               m_tablesize;          
    inode_table*             m_inodetab;
    fileref                  m_newhiddendir;       
    direlemp_list_type       m_sysinfo_contents;
    direlemp_list_type       m_volume_contents;    
};




class backemctar_i2h_volume : public BackCycle, restdirlistproducer::consumer
{
    typedef backupboost::hardlink_path_table hardlink_path_tab;
public:
    backemctar_i2h_volume(BackCycle* parent_, workelem* info_, const bool useddr_, const bool is_zfs_backup_=false);
    backemctar_i2h_volume(BackCycle* parent_, workelem* info_, inode_table* inodetab_, hardlink_path_tab* hl2pathtab_, const bool useddr_, const bool is_zfs_backup_=false);
    ~backemctar_i2h_volume();

    void init();
    void childdone(cycle *child);

    
    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer);

    
    
    fileoffset emctar_file_hash_size(const DIRELEM &de);

    void get_end_offsets(DIRELEMp& de, ubigint64 &hdroffset, ubigint64 &dataoffset, ubigint64 &padoffset, ubigint64 &extattroffset);

    SAFEPOOLALLOC(backemctar_i2h_volume);

private:


    enum phase { phase_vol_init  = 0,
                 phase_vol_read,          
                 phase_vol_write_i2h,     
                 phase_vol_backupboost,
                 phase_vol_writehashes,   
                 phase_vol_done };

    phase           m_phase;
    inode_table*    m_inodetab;
    fileoffset      m_tablesize;          
    DIRELEMp        m_vol_sysinfo;

    hardlink_path_tab* m_hl2pathtab;

    inode_table::child_dir_list childlist;  
                                            
    const bool      useddr;

    const bool      is_zfs;

    const bool target_top_dir;
};





class backemctarinode2hash : public BackCycle, restdirlistproducer::consumer
{
public:
    backemctarinode2hash(BackCycle* parent_, workelem *info_, location::tbackupid prev_backupid_, const bool useddr_, const bool destroy_workelem_=false, ubigint64 backupboost_session_id_=0, const bool is_zfs_backup_=false);
    void init();
    void childdone(cycle *child);

    
    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer);
    virtual ~backemctarinode2hash();

    SAFEPOOLALLOC(backemctarinode2hash);

private:
    enum phase { phase_top_startvolumes = 0,
                 phase_top_ddrfiles,
                 phase_backupboost_convert,
                 phase_work_results,
                 phase_top_sysinfo,
                 phase_archive_info,
                 phase_top_write_sysinfo,
                 phase_top_write,
                 phase_top_alldone};

    phase                    m_phase;
    ustring                  m_ddrfiles_name;    
    hashcode                 m_ddrfiles_hash;    
    hashcode                 m_work_results_hash;
    fileoffset               m_ddrfiles_size;    
    fileoffset               m_work_results_size;
    DIRELEMp                 m_snapview_sysinfo;
    fileref                  m_newhiddendir;     
    direlemp_list_type       m_sysinfo_contents; 
    direlemp_list_type       m_top_contents;     
    location::tbackupid      prev_backupid;      
    const bool               useddr;
    const bool               destroy_workelem;
    const bool               is_zfs;
    ubigint64                backupboost_session_id;
    ubigint64                backupboost_backup_time; 
    infofile_info            infofile;
    DIRELEMp                 infofile_de;
    DIRELEMp                 infofile_xml_de;
    fileoffset               infofile_size;
    fileoffset               infofile_xml_size;
};


#endif 
#include "common.h"
#include "debug.h"

#include "client.h"
#include "synccall.h"
#include "utar_commands.h"  
#include "acntmngr.h"
#include "clientpersistent.h"
#include "backstate.h"
#include "utar_flags_info.h"
#include "dpnsession.h"
#include "ade_mgrx.h"

dpnsession::dpnsession(utar_flags_info *flags_, hfs_info_struct& hfs_info_, context::statstype st) 
    : mydb(NULL), mymemman(NULL), myout(NULL), flags(flags_), 
      main(NULL), sync(NULL), state(NULL), ps(NULL), hfs(NULL), acnt(NULL), info(NULL),
      blktype(0), mainstats(NULL), utarcommands(NULL), loginsucceeded(false)
{
    if(DB == NULL) {
        DB = new debug("dpnsession", false, false, false);
        DB->messages_on = false;
        mydb = DB;
        mymemman = new memman;
        mymemman->initialize(0, "dpnsession");
    }
    if(Out == NULL) {
        Out = new output("dpnsession", 0, 0, 0, 0, 0, 0, 0);
        myout = Out;
    }

    if(!flags->quiet)
        Out->setVerbosity(STD);   

    DB->msg ("dpnsession::dpnsession flags are now:\n\n%s\n\n", *flags->parsed_flags);

    main = hfs_info_.main;

    state = new backstate(flags->args, false, flags->parallel_type);
    if(!state->is_valid()) {
        DB->msg("dpnsession: No valid targets exist, exiting");
        return;
    }
    
    sync = new synccall(*main);

    cidtype clientid = cidtype(flags->clientid);

    info            = new hfs_info_struct;
    info->main      = main;
    info->sync      = sync;
    info->clientid  = clientid;
    info->auth      = hfs_info_.auth;
    info->blk       = hfs_info_.blk;
    info->blktype   = hfs_info_.blktype;
    info->clientidhash  = hfs_info_.clientidhash;
    blktype         = info->blktype;
    location        = info->clientidhash;

    utar_flags_info dstflags;   
    utarcommands = new utar_commands(*flags, *info, dstflags);

    if (flags->clientid.isempty()) {
        clientid = cidtype(info->blk.path.hash().image());
    }

    loginsucceeded = true;
    mainstats = new backstats(); 
    DB->msg ("dpnsession::dpnsession new acntmngr(sync)");
    acnt = new acntmngr(sync);
}

dpnsession::~dpnsession() {
    DB->msg("dpnsession::~dpnsession");

    DB->msg("dpnsession::~dpnsession about to delete mainstats");
    delete mainstats;
    DB->msg("dpnsession::~dpnsession about to delete info");
    delete info;
    DB->msg("dpnsession::~dpnsession about to delete acnt");
    delete acnt;
    DB->msg("dpnsession::~dpnsession about to delete sync");
    delete sync;
    DB->msg("dpnsession::~dpnsession about to delete state");
    delete state;
    DB->msg("dpnsession::~dpnsession about to delete myout");
    delete myout;
    DB->msg("dpnsession::~dpnsession about to delete mymemman");
    delete mymemman;  
    DB->msg("dpnsession::~dpnsession about to delete utarcommands");
    delete utarcommands;

    DB->msg("dpnsession::~dpnsession about to call userid::static_cleanup");
    userid::static_cleanup();
    DB->msg("dpnsession::~dpnsession about to call groupid::static_cleanup");
    groupid::static_cleanup();
}
















#include "common.h"
#include "debug.h"
#include "restsslicefile.h"
#include "restdata.h"
#include "context.h"
#include "utar_flags_info.h"
#include "output.h"
#include "pipe_control.h"
#include "emctarpipe.h"
#include "platerror.h"
#include "utar_flags_enums.h"
#include "uwrapper.h"
#include "dirrec_pack.h"
#include "filerefx.h"
#include "backstate.h"
#include "paxndmp.h"

#ifdef USEADE  
#include "msgpack_c.h"
#include "ade_mgrx.h"
#endif

#include "data_regions.h"
#include "ndmp_volume_entification.h"
#include "emctarstream.h"

#define sslice_msg    ((xflag[2]&4)!=0)
#define cmr10_msgs    ((xflag[19]&524288) != 0)

#define dowfs    ((xflag[15]&2)==0)


#define disablenewcelerrahardlinkrest ((xflag[20]&32768)!=0)
#define disabletruncationhardlinkrealderead ((xflag[20]&131072)!=0)


#define disablefilepipethrottling ((xflag[15] & 16777216) != 0)

enum phases { phase_init,                          
              phase_read_real_header,              
              phase_read_ufs64data,                
              phase_sslice_header,                 
              phase_forksdone                      
            };

restsslicefile::restsslicefile(bicycle *parent, const hashcode& hash,
                               DIRELEM& direlem, cycle *starter, ucontainer::basep rest_container)
  : bicycle(parent),
    ADERestore(parent->main),
    decrementfilecount(false), phase(phase_init),
    ppipe_control(NULL),
    tmpde(),
    islnk(false), isfirst(false), realde(), realh(), realsize(0), dir_offset(0), have_full_header(false), use_container(false), is_real_file(false), setactivelimit(false),
    catalog_enabled(main ? ((main->getAdeMgr()->getHfsInfo(dpn0)).metaStore != NULL) : false)
{
    ppipe_control = (main ? dynamic_cast<emctarpipe*>(main->getpipe_control(&info)) : NULL);

    
    
    dataProvider.setup(this, this);

    assert( !direlem.is_directory() );
    assert( restelem::is_celerra_streamslice_restore(direlem, main->state->pid_of_backup, flags.pluginid) );
    assert(ppipe_control && ppipe_control->is_emctar());
    assert(flags.streamformat_out == utar_flags_enums::streamformat_emctar);

    nforked = ncollected = 0;

    info.direlem = direlem;
    info.path = direlem.fullpath();

    dirrec_pack::regions drr(&info.direlem);
    if (!drr.get(eoff)) {
        Out->msg(ERR, "During restore of '%s', unable to find REGIONS dirrec", *info.direlem.fullpath().image());
        phase = phase_forksdone;
        todoEnqueue(TODO_DONE, this);
        return;
    }

    location loc(info.direlem.get_location());
    use_container = (loc.getMedia() > location::media::gsan);
    if (use_container) {
        if (rest_container.isdefined()) {
            
            info.container = rest_container;
        } else {
            
            if (sslice_msg) DB->msg("restsslicefile::restsslicefile opening container (ID:%d)", loc.get_containerid());
            info.container = main->open_container_for_read(loc);
        }
    }

    
    
    
    realhdrsize = 16384;

    todoEnqueue(TODO_FILE, this);
}

void restsslicefile::init() {
    
    

    
    
    
    islnk = main->check_emctar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset, true);

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    
    
    
    
    
    
    
    
    
    if (!disablefilepipethrottling) {
        
        
        
        bigint64 maxfilepipedepth = (bigint64)flags.filecyclethrottlethresh * (1024 * 1024);
        
        
        
        bigint64 maxpipequeuedepth = (bigint64)flags.maxpipemb * (1024 * 1024);
        
        fileoffset reservedbytespending = ppipe_control->reserved_bytes_pending();
        
        
        fileoffset filesize = islnk ? realsize : eoff.back().second;
        
        
        
        if ( (reservedbytespending > 0) && ((reservedbytespending + filesize) > maxfilepipedepth) ) {
            
            todoEnqueueInsert(TODO_FILE, this, 1);
            return;
        }
        
        
        
        setactivelimit = ((reservedbytespending + filesize) > maxpipequeuedepth);
        if (setactivelimit)
            
            
            main->safesetactivelimit(TODO_FILE_CACHE, "wait for large file cycle to complete", true);
    }

    if (islnk) {
        
        
        if (sslice_msg) DB->msg("restsslicefile::init %s inode %s, context says we're a hardlink: isfirst:%d realde:%s realh:%s realsize:%s",
                                *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()), isfirst,
                                (realde.isnull()?"(nullde)":*realde->fullpath().image()),
                                *real_metadataid.partialimage(), *realsize.image());

        
        
        is_real_file = (realh == info.direlem.file_hash());

        if (realsize < realhdrsize) {
            realhdrsize = realsize;
        }

        if (!is_real_file) {
            
            
            
            ustring errmsg;

            
            
            
            
            cycle *child = restore_range(realh, 0, realhdrsize, true, tmprealbuf, errmsg, info.direlem, info.container, use_container);
            if (!child) {
                ustring errdesc = LOCTXT(errmsg);
                Out->msg(ERR, "Unable to spawn restore of hardlink original data for %s: %s",
                         *info.direlem.fullpath().image(), *errdesc);
            }

            phase = phase_read_real_header;

        } else if (use_container && ((ubigint64)info.direlem.get_location().get_abs_offset_in_container().value() != dir_offset)) {
            
            
            
            
            
            
            
            
            

            
            
            
            
            
            
            if (isfirst) {
                
                
                
                if (sslice_msg) DB->msg("restsslicefile::init ucontainer defined, and offsets don't match. Create \"fake\" realde");
                assert (realde.isnull());

                
                
                realde = new DIRELEM;

                
                location loc(info.direlem.get_location());
                real_loc = realde->get_location();

                
                
                
                real_loc.setMedia(loc.getMedia());
                real_loc.set_format(loc.get_format());
                real_loc.set_backupid(loc.get_backupid());
                real_loc.set_containerid(loc.get_containerid());

                
                if (sslice_msg) DB->msg("restsslicefile::init Updating abs_offset_in_container to %"LL"d", dir_offset);
                real_loc.set_abs_offset_in_container(dir_offset);

                
                
                
                real_loc.set_coverage_size(realsize);

                
                realde->set_location(real_loc);
            }

            
            
            assert (!realde.isnull());
            ustring errmsg;

            if (sslice_msg) DB->msg("restsslicefile::init Spawning restore_range() for realde with inode:%s at container offset:%"LL"d",
                                    *tostr(info.direlem.emctar_inode_number64()), dir_offset);

            
            
            
            
            cycle *child = restore_range(realh, 0, realhdrsize, true, tmprealbuf, errmsg, *realde, info.container, true);
            if (!child) {
                ustring errdesc = LOCTXT(errmsg);
                Out->msg(ERR, "Unable to spawn restore of hardlink original data for %s: %s",
                         *realde->fullpath().image(), *errdesc);
            }

            phase = phase_read_real_header;

        } else {
            
            
            
            
            if (sslice_msg) DB->msg("restsslicefile::init %s is hardlink, first, and context says our hash is the 'real' one, so continue as normal.",
                                    *info.direlem.fullpath().image());
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    fileoffset a, b;
    if (!data_regions::findrange(eoff, data_regions::header, true, a, b)) {
        Out->msg(ERR, "During restore of %s, endoffset '%s' does not contain a header section; ACLs will not be restored for this object",
                 *info.direlem.fullpath().image(), *data_regions::image_endoffsets(eoff));
    }
    ustring errmsg;
    cycle *child = restore_range(info.direlem.file_hash(), 0, b, true, tmpbuf, errmsg, info.direlem, info.container, use_container);
    if (!child) {
        ustring errdesc = LOCTXT(errmsg);
        Out->msg(ERR, "Unable to spawn restore of header section for %s %s %s",
                 *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(), *errdesc);
    }

    
    
    
    
    if (phase == phase_init)
        phase = phase_sslice_header;

    
    
    
    main->set_cur_filename(info.direlem.fullpath());

    if (sslice_msg) DB->msg("restsslicefile::init '%s' spawned %p to restore [0, %s] from %s (streamslice)",
                            *info.direlem.fullpath().image(), child, *b.image(), *info.direlem.file_hash().partialimage());

    
    if (nforked == 0) {
        
        notifyparent();
        return;
    }

    
}


void restsslicefile::handleData(fileoffset foOffset, fileref& restoreData)
{
    Out->msg(ERR, "restsslicefile class does not implement nsAdeLib::ADERestore interface");
    assert(false);
}


bool restsslicefile::process_header_buffer(const fileref &buf, DIRELEMp &de,
                                           const MetadataId &metadataid, const fileoffset &sz,
                                           bool erronads, bool erronpad)
{
    emctarstream::parser p("", utar_flags_enums::streamformat_emctar, 512, 30, 0, "");
    p.save_security = true;
    p.set_source_data(buf);
    fileref altref, stubref;
    if (!p.getentry(de, altref, stubref)) {
        return false;
    }

    p.recordmarks(de);
    dirrec_pack::regions drr(de.getimpl());
    data_regions::endoffsets_t tmpeoff;
    if (!drr.get(tmpeoff)) {
        Out->Abort("Invalid header format found for '%s'", *de->fullpath().image());
        return false;
    }

    if (sslice_msg) DB->msg("restsslicefile::process_header_buffer parser found de for '%s', endoffsets %s, altref.size:%s stubref.size:%s",
                            *de->fullpath().image(), *data_regions::image_endoffsets(tmpeoff), *altref.size64().image(), *stubref.size64().image());
    if (!altref.isnull())
        altref.hexdump(false);

    baselocation_sp blp(de->get_metadataLocation());
    de->set_hash(metadataid.tohashcode(), blp );

    bool already_reported_error = false;
    if (erronads && p.cur_has_ads()) {
        
        Out->msg(ERR, "Unable to properly handle (CIFS) alternate data streams on (NFS) hardlinks: %s",
                 *info.direlem.fullpath().image());
        already_reported_error = true;
    }
    fileoffset cur_endoff(tmpeoff.rbegin()->second);
    int pad(p.cur_padding());
    if (!already_reported_error && erronpad && (cur_endoff + de->file_size() + pad) != sz) {
        Out->msg(ERR, "During restore of '%s', unable to determine the primary data and padding "
                 "sections for hardlink realde.  Expected (cur_endoff:%s + de->file_size():%s + pad:%d == sz:%s)",
                 *info.direlem.fullpath().image(), *cur_endoff.image(), *de->file_size().image(), pad, *sz.image());
    }
    tmpeoff.push_back(std::make_pair(data_regions::primarydata, cur_endoff+de->file_size()));
    cur_endoff += de->file_size();
    tmpeoff.push_back(std::make_pair(data_regions::padding, cur_endoff+pad));

    if (sslice_msg) DB->msg("restsslicefile::process_header_buffer resetting eoffs to %s", *data_regions::image_endoffsets(tmpeoff));
    drr.set(tmpeoff);

    return true;
}

void restsslicefile::write_zeros_to_slice(fileref &sliceref)
{
    fileref zeros;
    zeros.initnull(sliceref.size());
    sliceref.setslice64(0, zeros.makeslice(0, sliceref.size()));
}


bool restsslicefile::process_ufs64data_phase() {
    if (ncollected < nforked) {
        if (sslice_msg) {
            DB->msg("Returning because not all forked children have been collected. ");
        }
        return true;
    }
    if (!tmprealbuf.isnull()) {
        
        
        realbuf.append(tmprealbuf);
    }
    phase = phase_sslice_header;
    
    fileref ufs64lendata = realbuf.copyslice(m_ufs64_data_start.ivalue() - UFS64DATA_SIZE_OF_LENGTH_SECTION, UFS64DATA_SIZE_OF_LENGTH_SECTION);
    ubigint64 ufs64len(parsestream_base::extractubigint64(ufs64lendata, 0, UFS64DATA_SIZE_OF_LENGTH_SECTION, 8));
    fileoffset hdrsizetoread = m_ufs64_data_start + ufs64len;
    if (hdrsizetoread > realhdrsize) {
        have_full_header = false;
        
        restore_realh_data(realhdrsize, hdrsizetoread);
        return true;
    }
    else {
        
        
        have_full_header = true;
    }
    return false;
}

void restsslicefile::restore_realh_data(fileoffset offset, fileoffset hdrsizetoread) {
    ustring errmsg;
    tmprealbuf.initmem((size_t)(hdrsizetoread - offset).value());
    cycle* child = restore_range(realh, offset, hdrsizetoread, true, tmprealbuf, errmsg,
                       (is_real_file ? *realde : info.direlem),
                       info.container, is_real_file);
    if (!child) {
        ustring errdesc = LOCTXT(errmsg);
        Out->msg(ERR, "Unable to spawn restore of hardlink original header data for %s: %s",
                    *realde->fullpath().image(), *errdesc);
    }
}

void restsslicefile::childdone(cycle *child) {
    if(sslice_msg)
        DB->msg("restsslicefile::childdone 1 child:%p nforked:%d ncollected:%d phase:%d",
                child, nforked, ncollected, phase);

    if (child) {         
        ncollected++;
    }

    
    
    if (phase == phase_forksdone) {
        if (ncollected < nforked) return; 

        if (sslice_msg || info.data.getrefcount() != 1)
            DB->msg( "restsslicefile::childdone %s, info.data.getrefcount = %d", *info.direlem.fullpath().image(), info.data.getrefcount() );
        info.data.free();   

        
        
        if (setactivelimit)
            main->safesetactivelimit(TODO_MAX, "large file cycle complete", true);

        if (sslice_msg) DB->msg( "restsslicefile::childdone %s num_open_files=%d", *info.direlem.fullpath().image(), +main->num_open_files );
        if(decrementfilecount) main->num_open_files--;
        decrementfilecount=false;
        notifyparent();
        return;
    }

    
    
    
    
    
    if (phase == phase_read_real_header) {
        if (ncollected < nforked) return; 
        emctarstream::header hdr;
        hdr.initialize(tmprealbuf);
        bool is_ufs64 = (hdr.version == BALDEAGLE_DIALECT_VERSION || 
                     hdr.version == BALDEAGLE_DIALECT_VERSION_EA || 
                     hdr.version == BALDEAGLE_E_VERSION || 
                     hdr.version == BALDEAGLE_E_VERSION_EA);
        if (!hdr.isgood())
            Out->msg(ERR, "Bad header data for real file found when restoring emctar header data for %s: %s",
                     *info.direlem.fullpath().image(), *hdr.errormsg());
        fileoffset hdrsizetoread = hdr.namesize + hdr.extsize + 512;
        if (is_ufs64) {
            hdrsizetoread += UFS64DATA_SIZE_OF_LENGTH_SECTION;
            m_ufs64_data_start = hdrsizetoread;
            
            
            phase = phase_read_ufs64data;
        }
        else {
            phase = phase_sslice_header;
        }
        realbuf = tmprealbuf.copyslice(0, tmprealbuf.size());
        
        tmprealbuf.initmem((size_t)0);
        
        
        if (hdrsizetoread > realhdrsize) {
            have_full_header = false;
            
            restore_realh_data(realhdrsize, hdrsizetoread);
            realhdrsize = hdrsizetoread;
            return;
        }
        else if (phase == phase_sslice_header) {
            
            have_full_header = true;
        }
    }
    
    if (phase == phase_read_ufs64data) {
        if (process_ufs64data_phase()) {
            return;
        }
    }
    if (phase == phase_sslice_header) {
        if (ncollected < nforked) {
            if (sslice_msg) DB->msg("returning because we have not collected all forked children");
            return;
        } else {
            if (sslice_msg) DB->msg("continuing with phase_sslice_header: nforked %d ncollected %d", nforked, ncollected);
        }

        if (!realbuf.isnull()) {
            if (sslice_msg) DB->msg("realbuf:%s for '%s' %s", *realbuf.size64().image(), *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()));

            
            
            
            
            
            
            if (use_container && !realde.isnull()) {
                real_loc = realde->get_location();
            }

            
            if (!have_full_header) {
                
                
                realbuf.append(tmprealbuf);
                have_full_header = true;
            }

            if (!process_header_buffer(realbuf, realde, real_metadataid, realsize, true, true)) {
                Out->msg(ERR, "Restore of %s from inode_table for '%s' inode:%s resulted in non streamslice data",
                         *real_metadataid.partialimage(), *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()));
            } else {
                realde->set_inode_number64(info.direlem.emctar_inode_number64());

                
                
                if (use_container && !realde.isnull()) {
                    realde->set_location(real_loc);
                }
            }
        }

        fileref secref;

        if (!tmpbuf.isnull()) {
            if (sslice_msg) DB->msg("tmpbuf:%s for '%s' %s", *tmpbuf.size64().image(), *info.direlem.fullpath().image(), *tostr(info.direlem.emctar_inode_number64()));
            MetadataId de_metadataid(info.direlem.file_hash());
            if (!process_header_buffer(tmpbuf, tmpde, de_metadataid, eoff.rbegin()->second, false, false)) {
                Out->msg(WARN, "Restore of %s had an invalid header",*info.direlem.fullpath().image());
            } else {
                tmpde->set_inode_number64(info.direlem.emctar_inode_number64());
            }
            
            
            
            
            if (!flags.ignoreacls && tmpde->get_security(secref)) {
                if (sslice_msg) DB->msg("copysecurity setting %s bytes of data on %s direlem", *secref.size64().image(), *info.direlem.fullpath().image());
                info.direlem.set_security(secref);
            }

            if (tmpde->get_ufs64data().size() > 0) {
                    info.direlem.set_ufs64data(tmpde->get_ufs64data());
            }
        }

        
        
        
        
        if (!realde.isnull()) {
            if (!secref.isnull()) realde->set_security(secref);
            if (sslice_msg) DB->msg("restsslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde:'%s' %s eattr:%d",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *tmpde->fullpath().image(), *tmpde->file_hash().partialimage(), tmpde->get_security_size(),
                                    *realde->fullpath().image(), *realde->file_hash().partialimage(), realde->get_security_size());
        } else {
            if (sslice_msg) DB->msg("restsslicefile::childdone islnk:%d ncol:%d '%s' %s, tmde:'%s' %s eattr:%d,  realde: (null)",
                                    islnk, ncollected, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                                    *tmpde->fullpath().image(), *tmpde->file_hash().partialimage(), tmpde->get_security_size());
        }

    }

    islnk = main->check_emctar_hardlinked_file(info.direlem, isfirst, realde, real_metadataid, realsize, dir_offset, true);
    
    
    

    
    
    
    if (!catalog_enabled) {
        realh = real_metadataid.tohashcode();
    }

    if (islnk) {
        if (!isfirst) {
            if (sslice_msg) DB->msg("restsslicefile::childdone %s is hardlink, but not first, %s was that.  Add entry.",
                                    *info.direlem.fullpath().image(), *realde->fullpath().image());
            ustring realfullpath(ppipe_control->convert_path_to_hardlink_path(realde->fullpath().image()));
            process_emctar_reg_to_lnk(realfullpath);

            
            
            if (setactivelimit)
                main->safesetactivelimit(TODO_MAX, "large file cycle complete", true);

            
            main->record_one_hardlink_restore(info.direlem);

            notifyparent();
            return;
        } else {
            if (realde.isnull()) {
                
                
            } else {
                
                
                
                
                realde->set_fullpath(info.direlem.fullpath());

                if (!catalog_enabled) {
                    
                    realde->set_hash(realh);
                }

                info.direlem = *realde;
                tmpbuf = realbuf; 
                                  
                dirrec_pack::regions rr(&info.direlem);
                if (rr.get(eoff)) {
                    if (sslice_msg) DB->msg("restsslicefile::childdone childdone for phase_hardlink_header, after resetting info.direlem '%s' we have eoff %s",
                                            *info.direlem.fullpath().image(), *data_regions::image_endoffsets(eoff));
                }
            }
        }
    }

    
    
    
    
    
    fileref adsslice, stubslice, extentsdummy;
    ppipe_control->addfile(info.direlem, info.path.image(),
                           info.data, adsslice, stubslice, extentsdummy,
                           pipe_control::REGTYPE);

    if (islnk && isfirst) {
        main->record_hardlinked_file(info.direlem);
    }

    main->print_path(info.direlem);
    
    
    
    
    
    main->addfilebytes(context::restorestats,
                       data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());

    
    
    
    
    
    
    
    
    

    if (!extentsdummy.isnull()) {
        Out->msg(ERR, "Celerra/VNX restore doesn't know about changeblock extents, while processing %s pipe_control::addfile returned extents fileref requiring %s bytes",
                 *info.direlem.fullpath().image(), *extentsdummy.size64().image());
        write_zeros_to_slice(extentsdummy);
    }

    if (!stubslice.isnull()) {
        
        
        
        if (sslice_msg) DB->msg("stubslice from tmpbuf");
        stubslice.setslice64(0, tmpbuf.makeslice(0, stubslice.size()));
    }
    ustring errmsg;
    if (!adsslice.isnull()) {
        cycle *child = restore_section(data_regions::ads, true, adsslice, errmsg);
        if (!child) {
            ustring errdesc = LOCTXT(errmsg);
            Out->msg(ERR, "Unable to restore alternate data streams for '%s': %s",
                     *info.direlem.fullpath().image(), *errdesc);
            write_zeros_to_slice(adsslice);
        }
    }
    if (!info.data.isnull()) {
        
        cycle *child = restore_section(data_regions::primarydata, true, info.data, errmsg);
        if (!child) {
            ustring errdesc = LOCTXT(errmsg);
            Out->msg(ERR, "Unable to restore data for '%s': %s",
                     *info.direlem.fullpath().image(), *errdesc);
            write_zeros_to_slice(info.data);
        }
    } else {
        if (info.direlem.file_size() > 0) {
            Out->msg(ERR, "While restoring '%s' pipe_control reserved 0 bytes in the output stream for file data, but our recorded file size is %s",
                     *info.direlem.fullpath().image(), *info.direlem.file_size().image());
        }
    }

    phase = phase_forksdone;
    childdone(NULL);
}

restsslicefile::~restsslicefile() {
    if(decrementfilecount) main->num_open_files--;
}

cycle *
restsslicefile::restore_section(data_regions::section_t sectiontype, bool fromend, fileref &outslice, ustring &errmsg)
{
    errmsg = "";

    fileoffset startbyte, endbyte;
    if (!data_regions::findrange(eoff, sectiontype, fromend, startbyte, endbyte)) {
        errmsg = ustring::sprintf("could not find range for section type:%d in '%s' direlem with filehash %s, endoffsets %s",
                                  sectiontype, *info.direlem.fullpath().image(),
                                  *info.direlem.file_hash().partialimage(),
                                  *data_regions::image_endoffsets(eoff));
        return NULL;
    }
    if (startbyte == endbyte) {
        errmsg = ustring::sprintf("empty section type:%d found", sectiontype);
        return NULL;
    }

    cycle *c = restore_range(info.direlem.file_hash(), startbyte, endbyte, true, 
                             outslice, errmsg, info.direlem, info.container, use_container);
    if (sslice_msg) DB->msg("restsslicefile::restore_section child:%p %s using file_hash():%s [%s %s]",
                            c, *info.direlem.fullpath().image(), *info.direlem.file_hash().partialimage(),
                            *startbyte.image(), *endbyte.image());

    return c;
}




void restsslicefile::process_emctar_reg_to_lnk(const ustring &realfullpath)
{
    info.direlem.set_tar_hardlink(true);
    info.direlem.clrdephashes();
    info.direlem.del_dirrec(KIND_EMCTAR_STUBDATA); 
    info.direlem.del_dirrec(KIND_EMCTAR_DEDUP);    
    info.direlem.del_dirrec(KIND_REGIONS);

    fileref dataslice, altslice, stubslice, extentsslice;
    ppipe_control->addfile(info.direlem, *info.direlem.fullpath().image(),
                           dataslice, altslice, stubslice, extentsslice, pipe_control::LNKTYPE, realfullpath);

    main->print_path(info.direlem);
    main->addfilebytes(context::restorestats,
                       data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue()); 
    main->byteprogress(context::restorestats, stats::hardlink,
                       data_regions::rangesize(eoff, data_regions::primarydata, true).dvalue());   

    
    
    if (!dataslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of file data, but no data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *dataslice.size64().image());
        write_zeros_to_slice(dataslice);
    }
    if (!altslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of alt data, but no alt data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *altslice.size64().image());
        write_zeros_to_slice(altslice);
    }
    if (!stubslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of stub data, but no stub data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *stubslice.size64().image());
        write_zeros_to_slice(stubslice);
    }
    if (!extentsslice.isnull()) {
        Out->msg(ERR, "While re-writing regular file '%s' as hardlink to '%s' pipe_control indicates that we should restore %s bytes of extents data, but no extents data is associated with a LNK record",
                 *info.direlem.fullpath().image(), *realfullpath, *extentsslice.size64().image());
        write_zeros_to_slice(extentsslice);
    }
}

#if !defined(EXPORT_NETAPPVOL_H_INCLUDED)
#define EXPORT_NETAPPVOL_H_INCLUDED












#include "cycle.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "dumpcontext.h"
#include "ustring.h"
#include "ade_restore.h"


class export_netappvol : public bicycle, nsAdeLib::ADERestore {
public:
    typedef enum {
        phase_construct,
        phase_init,
        phase_gather,
        phase_dirs_and_files,
    } phases;

    export_netappvol(bicycle            *parent,
                     const location&     _theloc,
                     const restelem&     restinfo,
                     cycle              *starter,
                     dumpcontext::dirlistelem *dumpparent,
                     bool                excluded_,
                     int                 traverse_depth_ = 0,
                     bool                waspreexisting=true,
                     bool                directory_dir_=false);

    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~export_netappvol();

    SAFEPOOLALLOC(export_netappvol);
private:
    NOCOPY(export_netappvol);

    
    
    typedef DEFINE_STL_MAP_TYPE(location::tcontainerid, fileoffset) toffsetmap;

    
    void calculate_abs_offset(toffsetmap& offmap, DIRELEMp dep) const;

    
    const bool process_listing(name_to_direlemp_table& detable) const;

    
    
    
    const bool process_listing(undoo::vector<DIRELEMp>& delist) const;

    
    const undoo::vector<DIRELEMp> detable2delist(name_to_direlemp_table& detable);

    
    const unsigned enqueue_cycles(const undoo::vector<DIRELEMp> delist);

    const location theloc;

    
    const bool directory_dir;

    
    phases phase;

    
    const int traverse_depth;

    
    restelem info;

    
    dumpcontext::dirlistelem *dumpparent;

    name_to_direlemp_table dir_contents; 
};

#endif


#if !defined(HASHSERVER_H_INCLUDED)
#define HASHSERVER_H_INCLUDED




















#include "threadbase.h"
#include "vector.h"
#include "msgqueue.h"

class message;
class context;

class hashserver {
public:
    
    
    
    hashserver(int nthreads, context *main);

    
    
    
    void send(message& m);

    
    int num_inprocess() { return +inprocess; }

    
    ~hashserver();

    SAFEPOOLALLOC(hashserver);

private:
    class hashthread : public threadbase {
    public:
        hashthread(msgqueue& hashqueue, safeint &inprocess, context *main, int index);
        void terminate();
        SAFEPOOLALLOC(hashthread);
    private:
        msgqueue& hashqueue;
        context *main;
        int index;
        double bytecount;
        safeint &inprocess;

        void body();
    };

    msgqueue hashqueue;
    undoo::vector<scalar<hashthread *> >threads;
    safeint inprocess;
};

#endif















#include "common.h"
#include "debug.h"
#include "direlem.h"
#include "axionfsdirelem.h"
#include "context.h"
#include "dpnobject.h"

#define USE_FULLPATH 0   

#define debug_axionfs      ((xflag[2]&(1<<22))!=0)
#define disable_backup_calls      ((xflag[13]&1024)!=0)


axionfsDIRELEM::axionfsDIRELEM(context *main_)
    : subnodes(), main(main_), hasmetadata(false)
{
    
    
    contents.initlist(1024);
    metadata.initlist(1024);
}

axionfsDIRELEM::axionfsDIRELEM(const DIRELEM& direlem)
    : DIRELEM(direlem),
      subnodes(), main(NULL), hasmetadata(false)
{
    
    
    contents.initlist(1024);
    metadata.initlist(1024);
}

axionfsDIRELEM::~axionfsDIRELEM() {
    

    
    
    DEFINE_STL_MAP_TYPE(ustring, axionfsDIRELEM *)::iterator i = subnodes.begin();
    while (i != subnodes.end()) {
        delete i->second;
        i++;
    }
}


axionfsDIRELEM *axionfsDIRELEM::enter(const ustring &name, bool is_dir, mode_t mode) {
    
    assert(is_directory());

    
    
    axionfsDIRELEM *ne = new axionfsDIRELEM(main);
    ne->set_name(name);

    
    
    ne->statbuf.st_dev     = 0;
    ne->statbuf.st_ino     = 0; 
    ne->statbuf.st_mode    = mode;
    ne->statbuf.st_nlink   = 0;
    ne->statbuf.st_uid     = 1000; 
    ne->statbuf.st_gid     = 1000; 
    ne->statbuf.st_rdev    = 0;
    ne->statbuf.st_size    = 0; 
    ne->statbuf.st_atime   = ne->statbuf.st_mtime = ne->statbuf.st_ctime = ::time(NULL);
#if SYSTEM_UNIX
    ne->statbuf.st_blksize = 4096;
    ne->statbuf.st_blocks  = 0;
#endif

    if (is_dir) {
        ne->set_is_directory();
        ne->statbuf.st_mode |= S_IFDIR; 
    } else {
        ne->set_is_atomic();
        ne->statbuf.st_mode |= S_IFREG; 
    }
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::enter set mode to %x for direlem %p", (int)ne->statbuf.st_mode, ne);
        
    subnodes[name] = ne;
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::enter entered ne %p as %s in directory %s",
                                ne, *ne->name(), *fullpath());
    return ne;
}




int axionfsDIRELEM::symlink(const ustring &name, const ustring &linkto) 
{
    if (!is_directory())
        return -ENOENT;

    
    
    axionfsDIRELEM *ne = new axionfsDIRELEM(main);
    ne->set_name(name);

    
    
    ne->statbuf.st_dev     = 0;
    ne->statbuf.st_ino     = 0; 
    ne->statbuf.st_mode    = 0;
    ne->statbuf.st_nlink   = 0;
    ne->statbuf.st_uid     = 1000; 
    ne->statbuf.st_gid     = 1000; 
    ne->statbuf.st_rdev    = 0;
    ne->statbuf.st_size    = 0; 
    ne->statbuf.st_atime   = ne->statbuf.st_mtime = ne->statbuf.st_ctime = ::time(NULL);
#if SYSTEM_UNIX
    ne->statbuf.st_blksize = 4096;
    ne->statbuf.st_blocks  = 0;
#endif

    ne->set_is_symlink();
#if SYSTEM_UNIX
    ne->statbuf.st_mode |= S_IFLNK;
#endif
        
    ne->contents.append(linkto);
    ne->close();

    subnodes[name] = ne;
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::symlink entered ne %p as %s in directory %s",
                                ne, *ne->name(), *fullpath());

    return 0;
}


void axionfsDIRELEM::write(const fileref &data, bool ismetadata) {
    assert(!is_directory());
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::write writing %d bytes to %s (metadata %d)",
                                data.size(), *fullpath(), ismetadata);

    if (disable_backup_calls)
        return;

    if (ismetadata) {
        metadata.append(data);
        hasmetadata = true;
    } else {
        contents.append(data);
    }
}



bool axionfsDIRELEM::initfrommetadata()
{
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfrommetadata++"); 
    int off = 0;
    bool goodinit = populate(metadata, off);
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfrommetadata got %d as the size of the data written from metadata fileref, which has size %d",
                                off, metadata.size());

    if (!goodinit) {
        DB->error("axionfsDIRELEM::initfrommetadata '%s' failed to initialize from metadata", *fullpath());
        return false;
    }

    if (off < metadata.size()) {
        
        dpnobj_types::metadatahdr hdr;
        metadata.getslice(off, sizeof(struct dpnobj_types::metadatahdr), (void*)(&hdr));
        DB->msg ("axionfsDIRELEM::initfrommetadata found additional section, length %d, kind %d",
                 +hdr.length, +hdr.kind);
        if (hdr.kind != dpnobj_types::ntfs_presection) {
            DB->msg ("... no ntfs_presection");
            return false;
        }
        off += sizeof(struct dpnobj_types::metadatahdr);
        fileref newcontents;
        newcontents.initcat();
        newcontents.append(metadata.copyslice(off, +hdr.length));
        off += +hdr.length;

        newcontents.append(contents);

        metadata.getslice(off, sizeof(struct dpnobj_types::metadatahdr), (void *)(&hdr));
        if (hdr.kind != dpnobj_types::ntfs_postsection) {
            DB->msg ("... no ntfs_postsection");
            return false;
        }
        off += sizeof(struct dpnobj_types::metadatahdr);
        newcontents.append(metadata.copyslice(off, +hdr.length));

        contents = newcontents;
        contents.makecontiguous();
    }
    

    return true;
}

bool axionfsDIRELEM::initfromdefaults()
{
    bigint64 fsize = contents.size64().value();
    
    
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfromdefaults about to fill statbuf");
    statbuf.st_dev     = 0;
    statbuf.st_ino     = 0; 
    
    statbuf.st_nlink   = 1;
    statbuf.st_uid     = 1000; 
    statbuf.st_gid     = 1000; 
    statbuf.st_rdev    = 0;            if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfromdefaults about to set size"); 
    statbuf.st_size    = (off_t)fsize; if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfromdefaults about to get time_t"); 
    time_t now = ::time(NULL);         if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfromdefaults got time_t"); 
    statbuf.st_atime   = now;
    statbuf.st_mtime   = now;
    statbuf.st_ctime   = now;
#if SYSTEM_UNIX
    statbuf.st_blksize = 4096;
    statbuf.st_blocks  = 1;
#endif
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::initfromdefaults about to initialize from statbuf"); 
    initialize(statbuf, true);

    return true;
}


int axionfsDIRELEM::close(bool ismeta) {
    
    if (debug_axionfs) DB->msg ("axionfsDIRELEM::close closing '%s' (meta %d) which is %d bytes long.",
                                *fullpath(), ismeta, contents.size());
    if (ismeta)
        return 0;
    assert(main != NULL);
    hashcode h;
    fileoffset worksize;

    bool goodinit = true;
    if (hasmetadata) 
        goodinit = initfrommetadata();    
    if (!goodinit || !hasmetadata)
        goodinit = initfromdefaults();

    if (!goodinit) {
        DB->error ("axionfsDIRELEM::close error initializing our direlem fields");
        return -EIO;
    }

    if (!is_directory() && !disable_backup_calls) {
        if (main->backup_orphaned_file(contents, h, false, worksize)) {
            DB->msg ("axionfsDIRELEM::close ERROR for '%s', unable to backup %d bytes of content (ismeta %d)!", 
                     *fullpath(), contents.size(), ismeta);
            return -EIO;
        }
        if (debug_axionfs) 
            DB->msg ("axionfsDIRELEM::close, successfully backed up our contents, got file hash '%s'", *h.partialimage());
    }
    
    set_hash(h);
    
    
    
    contents.initlist(1024);
    metadata.initlist(1024);

    return 0;
}


void axionfsDIRELEM::keys(undoo::vector<ustring>& res) const {
    if(subnodes.size() == 0)
        res.clear();
    else {
        DEFINE_STL_MAP_TYPE(ustring, axionfsDIRELEM *)::const_iterator i = subnodes.begin();
        while (i != subnodes.end()) {
            res.push_back(i->first);
            i++;
        }
    }
}


axionfsDIRELEM *axionfsDIRELEM::lookup(const ustring& name) {
    if(subnodes.size() == 0)
        return 0;
    else {
        DEFINE_STL_MAP_TYPE(ustring, axionfsDIRELEM *)::const_iterator i = subnodes.find(name);
        if (i == subnodes.end())
            return NULL;
        return i->second;
    }
}


void axionfsDIRELEM::set_fullpath(const ustring& path) {
#if USE_FULLPATH
    DIRELEM::set_fullpath(path);
#endif
}

const ustring axionfsDIRELEM::fullpath() const {
#if USE_FULLPATH
    return DIRELEM::fullpath();
#else
    return DIRELEM::name();
#endif
}



void axionfsDIRELEM::dump_image(int depth) const {
    ustring tabs;
    for (int i=0; i<depth; i++) 
        tabs += ustring("  ");
    if (!is_directory()) {
        DB->msg ("%s%s %s", *tabs, *file_hash().partialimage(), *name());
    } else {
        DB->msg ("%s%s", *tabs, *name());
        DEFINE_STL_MAP_TYPE(ustring, axionfsDIRELEM *)::const_iterator i = subnodes.begin();
        while (i != subnodes.end()) {
            i->second->dump_image(depth+1);
            i++;
        }
    }
}

#if !defined(NBACKDIR_MANUAL_H_INCLUDED)
#define NBACKDIR_MANUAL_H_INCLUDED


























#include "hashcode.h"
#include "cycle.h"
#include "nbackroot.h"
#include "backhidden.h"
#include "backdataconsumer.h"

class priqueue;
class connection;
class backstats;
class profile;
class fileref;
class backstate;
class DIRELEM;
class workelem;
class context;

#include "sortdirwalk.h"


class nbackdir_manual : public BackCycle, public hiddendirfuncs, backdataconsumer::producer {
public:
    nbackdir_manual(BackCycle *parent, workelem *info_, fileoffset offset,
                    int& _nsynth_done,
                    
                    bool reserve_hiddendir=false,
                    
                    bool top_level_=false,
                    const bool usecontainer=false
                   );
    virtual ~nbackdir_manual();

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();

    
    virtual void do_file_finish();  
    virtual void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false);

    fileoffset do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink=false, DIRELEMp *direlemp=NULL );

    void do_stuff();

    
    
    
    fileoffset add_direlem(DIRELEMp de, bool haschild=false); 
    void add_subcycle(nbackdir_manual* subcycle);

    SAFEPOOLALLOC(nbackdir_manual);

private:

  
  
    class onechild {
    public:
        onechild(DIRELEMp de, nbackdir_manual* subcycle)
         : de(de),subcycle(subcycle){}
        SAFEPOOLALLOC(onechild);
        DIRELEMp de;
        nbackdir_manual* subcycle;
    };
    typedef undoo::vector<onechild> elem_vector;

    void do_stuff_ucontainer_pre();
    void do_stuff_ucontainer_post();

    elem_vector  *elements;             

    int          fillindex;             
    int          sendindex;             
    int          drainindex;            

    bool         more_dirgroups;        
    bool         flush_listing;         
    int          maxgroupentries;       
    int          maxsendentries;        
    int          group_count;           
    int          entry_count;           

    bicycle *    datachild;             
    DIRELEMp     hiddendirp;            

    const bool   top_level;             
    const bool   raw_format_makeview;   

    int          traverse_depth;        
    fileoffset   sizeofchildren;        
    mtex         elements_mut;          

    bool   use_container;         

    
    fileoffset add_element(DIRELEMp de, nbackdir_manual* childcycle);

    const bool reserve_hiddendir;
    fileoffset hiddenoff;   

  
    bool modify_child_de(const cycle* child); 
    bool spawn_hiddendir(const cycle *child); 
    bool do_flush_listing();                  

    
    virtual fileref nextdatablock(bool& suppress_requeue);
    bool synth_direlem(DIRELEMp de);
    virtual void cancelled();
    virtual ustring image() const { return "nbackdir_manual"; }

    int& nsynth_done;       

    
    
    
    
    static bool timeoffcmp(const onechild& lh, const onechild& rh);

    bool source_object_is_entire_container(const DIRELEMp& de) const;

}; 


#endif
















#include "common.h"
#include "debug.h"
#include "backemctarinode2hash.h"
#include "replroot.h"
#include "repldata.h"
#include "todoelem.h"
#include "roothashlist.h"
#include "msgpack_c.h"
#include "workelem.h"

replroot::replroot(hashcode& tophash_, context& main, const ustring& sessname, const int ddrIndexFromBackup, workelem *info, const exportstream_xmlp backupinfop_, bool search_sysinfo_)
  : replcycle(NULL, &main, info),
    tophash(tophash_),
    name(sessname),
    replicateDDR(NULL),
    startedTableGen(false),
    search_sysinfo(search_sysinfo_),
    comp_root_hash(true)
{
    ddrindexfrombackup = ddrIndexFromBackup;
    backupinfop = backupinfop_;
    ADEMgrX* adeMgr = cycle::main->getAdeMgr();
    if( (ddrIndexFromBackup > 0) && adeMgr->isDDRenabled() && !info->rechunk) {
        replicateDDR = new CopyDDRFile(cycle::main, this);
        replicateDDR->replicate();      
        cycle::nforked += 1;
    }
    
    cycle *child;
    chunktype rtype = chunktype::atomicdir;

    if(flags.pluginid.kind() == pidtype::migrate) {
        child = new repldata(this, tophash, 0, true, 0, sessname, rtype, TIME32(NULL), 0, info, NULL, false, search_sysinfo, this); 
    } else {
        child = new repldata(this, tophash, 0, true, 0, sessname, rtype, TIME32(NULL), 0, info, NULL); 
    }
    child->noop();
    cycle::nforked += 1;
    forksdone = true;
}




replroot::~replroot()
{
    if(replicateDDR != NULL) {
        delete replicateDDR;
        replicateDDR = NULL;
    }
}




void replroot::childdone(cycle *child)
{
    
    if(search_sysinfo && comp_root_hash && (flags.pluginid.kind() == pidtype::migrate)) {
        if(child != NULL) {
            cycle::ncollected += 1;
        }

        DB->msg("replroot::childdone search childdone, forksdone=%d, cycle::nforked=%d, cycle::ncollected=%d", forksdone, cycle::nforked, cycle::ncollected);
        if( forksdone && (cycle::nforked == cycle::ncollected) ) {
            chunktype rtype = chunktype::atomicdir;
            
            
            forksdone = false;
            search_sysinfo = false;
            child = new repldata(this, tophash, 0, true, 0, name, rtype, TIME32(NULL), 0, info, NULL); 
            child->noop();
            cycle::nforked += 1;
            forksdone = true;
            return;
        }

        return;
    }

    
    
    
    
    
    if(child != NULL) {          
        cycle::ncollected += 1;
        tophash = child->hash;   
        DB->msg("replroot::childdone(GSAN), ncollected=%d, error=%d", ncollected, has_error());
        
        
        
        
        DB->msg("replroot::childdone() replhash %s, direlem location: %s, resulthash: %s, destination: %d",
                *tophash.partialimage(), *info->direlemp->loc_image(), *info->resulthash.partialimage(), (int)flags.destination_data);

        if(!backupinfop.isnull())
            DB->msg("replroot::childdone() startedTableGen = %d, pid_os: %d, backup pid: %s.", startedTableGen, backupinfop->get_pid().os(), *backupinfop->get_pid().imagex());

        
        if (!startedTableGen && (flags.destination_data != client_config_flags::same_destination) && !backupinfop.isnull() &&
            ((backupinfop->get_pid().os() == pidtype::os_celerra) ||
             (backupinfop->get_pid().os() == pidtype::os_isilon)  ||
             (backupinfop->get_pid().os() == pidtype::os_zfs))) {
            DB->msg("replroot::childdone() different destination media, regenerate inode2hash table");
            
            
            
            workelem* replElem = new workelem(NULL, info->direlemp);
            replElem->direlemp->set_hash(tophash);
            replElem->path = upath("");
            replElem->dpninx = dpn1;
            
            
            
            bool use_ddr = main->get_dstflags()->ddrenabled && (flags.destination_data != client_config_flags::ddr_to_gsan);
            const bool is_zfs_backup(backupinfop->get_pid().os() == pidtype::os_zfs);
            backemctarinode2hash *i2hTable = new backemctarinode2hash(this, replElem, location::tbackupid(), use_ddr, true , 0 , is_zfs_backup);
            i2hTable->noop();
            cycle::nforked++;
            startedTableGen = true;
            DB->msg("replroot::childdone() started inode2hash generation");
        }
    }
    if( forksdone && (cycle::nforked == cycle::ncollected) ) {
        
        
        
        DB->msg("replroot::childdone() replroot finishing now");
        if (flags.destination_data == client_config_flags::ddr_to_gsan) {
            info->direlemp->clear_location();
        }
        main->add(TODO_DONE, NULL, has_error());
        notifyparent();
    }
}




void replroot::set_comp_root_hash(bool comp_hash)
{
    comp_root_hash = comp_hash;
}



void replroot::responseReceived(CopyDDRFile* copyDDRFile)
{
    cycle::ncollected += 1;
    DB->msg("replroot::responseReceived(DDR), ncollected=%d, error=%d", ncollected, has_error());
    childdone(NULL);
}






void replroot::CopyDDRFile::replicate()
{
    fname = "full_ddr_list";
    DB->msg("replroot::CopyDDRFile::replicate() DDR replication start.");
    adeMgr->getCopyResultAsync(fname, 0, this);
}






void replroot::CopyDDRFile::response(message& outargs)
{
    
    
    
    msgerrors result = outargs.responsecode();
    if(result == MSG_ERR_CORRUPT_DATA) {
        Out->msg(ERR, "<10521>Corrupted DDR copy, name=%s", *fname);
        return;
    }
    
    
    
    
    assert(! outargs.isnull());
    msgpack_c::ade_computehash ch(outargs);
    chunktype kind;
    fileref structData;
    ch.res(UNPACK, hash, kind, structData);
    
    if(kind != chunktype::rwheader) { 
        Out->msg(ERR, "<10522>Corrupted DDR copy -- response is wrong, name=%s", *fname);
        return;
    }
    
    
    
    ResultHashReturnStruct returnStruct;
    if(structData.size() >= (int)sizeof(returnStruct))
        memcpy(&returnStruct, structData.start(), sizeof(returnStruct));
    else {
        Out->msg(ERR, "Corrupted DDR copy -- returned data size too small, name=%s", *fname);
        return;
    }
    
    
    
    ddrValue.index = returnStruct.ddrFileIndex;
    ddrValue.offset = returnStruct.ddrFileOffset;
    ddrValue.size = returnStruct.finalSize;
    ddrValue.ddrResult = true;
    
    cyisatomic = true;  
    hash = hash.zero;   
    DB->msg("CopyDDRFile::response() isatomic=%d name=%s, DDRindex=%u, DDRoffset=%s",
             cyisatomic, *fname, ddrValue.index, *ddrValue.offset.image());
    ((replroot*)parent)->responseReceived( this );
}

#if !defined(DUMPCONTEXT_H_INCLUDED)
#define DUMPCONTEXT_H_INCLUDED












#include "fileref.h"
#include "fileoffset.h"
#include "tassoc.h"
#include "dumpinodemap.h"
#include "dumpdirtable.h"
#include "direlem.h"
#include "direlem_netapp.h"

class context;
class direlem;
class boolvect;
class ndmpcontrol;


class dumpcontext {
public:
    
    dumpcontext(context *main, const fileref& stream, bool little_endian, const ustring& frompath);

    
    ~dumpcontext();

   
   
   
   
    class dirlistelem {
    public:
        DIRELEM_netapp direlem;     
        fileref data;        
        dirlistelem *parent; 
        dirlistelem *link;   

        
        
        dumpdirtable fakeinodes;

        
        dirlistelem(const DIRELEM& direlem_, const fileref& data_, dirlistelem *parent_)
          : direlem(direlem_),  
            data(data_),
            parent(parent_),
            link(NULL),
            fakeinodes(data.size() / 100 + 1)  
        {}

        SAFEPOOLALLOC(dirlistelem);
    }; 

    
    
    
    dirlistelem *add_directory(DIRELEM& direlem, fileref& data, dirlistelem *parent);

    
    void insert_target(const ustring& target);

    
    void do_bitmaps();

    
    void do_directories();

    
    void do_files();

    
    void do_netapp_inode3_acls();

    
    void do_netapp_acls();

    
    static fileref zeros(int n);

    fileoffset get_streamoffset() const { return streamoffset; }

    SAFEPOOLALLOC(dumpcontext);

    ndmpcontrol *control;

    friend class restdumpdir;
    friend class restdumpfile;
    friend class dumppipe;

protected:
    
    fileoffset streamoffset;      

private:
    
    context *main;

    
    bool dumpnetapp;

    
    bool ontap73acls;

    
    fileref stream;

    
    dumpinodemap inodes;

    
    dumpinodemap aclinodes;

    
    tassoc<intobj, fileref> savedacls;

    
    dirlistelem *head;
    dirlistelem **tailp;

    
    upath frompath;

    
    int totaldirsize;

    
    bool missing;

    
    int nextfake;

    
    epoch_t dumptime;

    
    int rootinode;

    
    int nextseq;

    
    
    
    tassoc<intobj, bool> linkseen;

    
    tassoc<intobj, int> seqtab;

    
    fileref zeroblock;

    int skipcount;

    
    class dumpheader;

    
    void gen_inodes();

    void newseq(int inode);

    
    void gen_seq();

    
    int get_fake();

    
    int get_inode(const DIRELEM& direlem, dirlistelem *parent) const;

    
    int get_seq(const DIRELEM& direlem, dirlistelem *parent) const;

    
    void appendstream(const fileref &data);

    
    
    void do_header(dumpheader& dh, bool addtostream=true, int spare_26=0, bool inode3acl = false);

    
    void do_end();

    
    void setattrs(dumpheader& dh, const DIRELEM_netapp& de);

    
    void check_netapp_acl(const DIRELEM_netapp& de, fileref *ref = 0);

  
  
    bool do_file_header(fileref& header, fileoffset& size_needed,
                        const DIRELEM& de, const fileoffset startoff);

    void do_zero_length_file(const DIRELEM& de, fileref& header);

    class dirheadlist;
    class direntry_list;

    friend class direntry_list;

    
    intassoc name_to_inode;
    typedef tassoc<intobj, int> inttobool;
    inttobool is_attr_file;

};

#endif
















#include "common.h"
#include "debug.h"

#include <algorithm>

#include "backdumpstream.h"
#include "runstage.h"
#include "restdirlist.h"
#include "restdata.h"
#include "backhidden.h"
#include "nbackdata.h"
#include "timer.h"
#include "filenames.h"
#include "ndmp_volume_entification.h"
#include "context.h"
#include "tchecksum.h"

#include "utar_ctl_sup.h"
#include "ucontainer_base.h"

#define msg1 ((xflag[2]&2048)!=0)   
#define msg2 ((xflag[2]&4096)!=0)   
#define umsg ((xflag[2]&134217728)!=0)   

#define do_dir_map     ((xflag[22] & 128) == 0)     
#define do_acl_ref_map ((xflag[22] & 2048)!= 0)     
#define go_slower      ((xflag[22] & 4096)!= 0)     

#define inject_ddr_checksum_error ((xflag[26]&4)!=0) 
#define ddr_checksums_enabled ((xflag[29]&16384)==0) 

#define use_sizemin_hint  ((xflag[29] & 134217728) != 0) 
#define enable_netapp_dirmap_update ((xflag[22] & 2147483648) != 0)








static bool compare_strings(const ustring &lhs, const ustring &rhs)
{
    return lhs.lessthan(rhs);
}


#define TOPLEVELIST_SIZE  10
static const char* toplevel_list[TOPLEVELIST_SIZE] = {
    "start",
    "inode.use.map",
    "inode.stream.map",
    "directory",
    "acl3",
    "file",
    "end.1",
    "inode.acl.map",
    "acl",
    "end.2"
};


backdumpstream::backdumpstream(BackCycle *parent, workelem *info)
    : BackCycle(parent, info)
    , m_phase(!flags.incremental      ? phase_process_dir : phase_restore_prev_dir)
    , m_subdir(flags.ndmp_prefix)
    , m_info(info)
    , m_stream(new dumpstream::parser(flags))
    , m_current_dir_item(0)  
    , m_saved_top(NULL)
    , m_begindir_sent(false)
    , m_parent(parent)
    , metadatastorep(NULL)
{
    if(msg1) DB->msg("backdumpstream::backdumpstream constructor parent:%p, this:%p, parser:%p",
                     parent, this, m_stream.getimpl());
    assert(parent != NULL);
    if (flags.incremental) {
        BackupRootInfo prevbackup;
        main->find_prev_backup(prevbackup);
        assert(prevbackup.isFromGsan());    
        m_prevhash = prevbackup.getRootLocation().getHash();
    }
    m_info->direlemp->set_is_root_directory();
    m_info->direlemp->set_name(flags.ndmp_prefix);  

    const hfs_info_struct& hfsInfo(main->getAdeMgr()->getHfsInfo(dpn0));
    catalog_enabled = (hfsInfo.metaStore != NULL);
    if (catalog_enabled) {
        metadatastorep = hfsInfo.metaStore;
        
        
        
        if (!open_backup_metastore()) {
            Out->Abort("Problem opening backup Metadata store instance for '%s'",
                       *info->direlemp->fullpath().image());
            return;
        }
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'",
                       *info->direlemp->fullpath().image());
            return;
        }
    }

    if (!go_slower && info->use_container) { 
        
        
        Out->msg(INFO, "CDSF backup does not use asynchronous reading of NetApp stream. Disabling that feature.");
    }
    todoEnqueueInsert(TODO_DIR, this, -getDepth());
}


backdumpstream::backdumpstream(BackCycle *parent, hashcode prevhash, workelem *info, dumpstream::parserp stream, MetadataIntf_sp parent_metadataIntfp_)
    : BackCycle(parent, info)
    , m_phase(prevhash != hashcode::ones && flags.incremental ? phase_restore_prev_dir : phase_process_dir)
    , m_prevhash(prevhash)
    , m_info(info)
    , m_stream(stream)
    , m_current_dir_item(0)  
    , m_saved_top(NULL)
    , m_begindir_sent(false)
    , m_parent(parent)
    , metadatastorep(NULL)
{
    if(msg1) DB->msg("backdumpstream::backdumpstream constructor parent:%p this:%p parser:%p, first phase=%s dir=%s",
                     parent, this, m_stream.getimpl(), *phasetext(), *m_info->direlemp->fullpath().image());
    if (msg1) DB->msg("    prevhash is ones: %d, prevhash is zeros: %d  incremental=%d", (prevhash != hashcode::ones),
                      (prevhash != hashcode::ones), flags.incremental);

    const hfs_info_struct& hfsInfo(main->getAdeMgr()->getHfsInfo(dpn0));
    catalog_enabled = (hfsInfo.metaStore != NULL);
    if (catalog_enabled) {
        metadatastorep = hfsInfo.metaStore;
        parent_metadataIntfp = parent_metadataIntfp_;
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'",
                       *info->direlemp->fullpath().image());
            return;
        }
    }

    assert(parent != NULL);
    todoEnqueueInsert(TODO_DIR, this, -getDepth());
}



backdumpstream::~backdumpstream()
{
    if(msg1) DB->msg("backdumpstream::~backdumpstream parent:%p this:%p path:%s",
                     parent, this, *m_info->direlemp->fullpath().image());
    delete m_info;
    m_items_in_dir.clear();
}



void backdumpstream::init()
{
    if(msg1) DB->msg("backdumpstream::init parent:%p this:%p path:%s",
                     parent, this, *m_info->direlemp->fullpath().image());

    m_diroffset = m_info->direlemp->get_location().get_abs_offset_in_container() + m_info->direlemp->get_location().get_header_size();
    if (m_info->direlemp->fullpath().image() == "") m_diroffset = 0;  
    if (umsg) DB->msg(" INIT LOCATION for %s = %s (%s + %s)", *m_info->direlemp->fullpath().image(), *m_diroffset.image(),
            *m_info->direlemp->get_location().get_abs_offset_in_container().image(), *m_info->direlemp->get_location().get_header_size().image());

    




    m_current_dir_item = 0;  
    childdone(0);
}





class dir_size_accumulator : public name_to_direlemp_table::iterator {
public:
    dir_size_accumulator(const bool &isrootdirectory_, fileoffset *accum_size_) : isrootdirectory(isrootdirectory_ )
    {
        size = accum_size_;
    }
    virtual ~dir_size_accumulator() {}
    virtual void callback(const ustring& name, const DIRELEMp& de) {
        
        if (!isrootdirectory || name == TS_FILE_FILENAME) *size += de->file_size();
    }
protected:
    bool isrootdirectory;
    fileoffset *size;
};
































void backdumpstream::childdone(cycle *child)
{
    const bool isrootdirectory = m_info->direlemp->fullpath() == upath("");
    const bool isdirdirectory  = m_info->direlemp->fullpath() == upath(TS_DIR_FILENAME);
    const bool isacl3directory = m_info->direlemp->fullpath() == upath(TS_ACL3_FILENAME);

    if (msg1) DB->msg("------TOP OF CHILDDONE, %s  phase=%d %s root=%d dirdir=%d acl3dir=%d", *m_info->direlemp->fullpath().image(),
           m_phase, *phasetext(), isrootdirectory, isdirdirectory, isacl3directory);

    
    if ((child != NULL) && (m_phase==phase_process_dir) && (info->use_container)) {
         endFileInContainer (child);
    }


next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_notify_parent) {
        case phase_restore_prev_dir:
    {
            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s retrieving previous backup contents",
                             parent, this, *m_info->direlemp->fullpath().image());
            
            if (msg2) DB->msg("backdumpstream::cilddone: calling restdirlist for dir %s,  offset=%s ", *m_info->direlemp->fullpath().image(), *m_diroffset.image());
            

            
            location prev_loc(m_info->direlemp->get_location().make_template(true , m_diroffset));

            
            
            
            
            
            
            
            if (isrootdirectory) {
                prev_loc.set_containerid(0);
                prev_loc.set_enclosing_container(NULL);  
            }
            const location prevloc(location::media::gsan, m_prevhash);
            child = new restdirlist(this, prevloc, upath(m_subdir), prev_loc, m_children);
            child->noop();
            m_phase = isrootdirectory                                  ? phase_retrieve_system_info :
                      m_info->direlemp->name() == UNDOO_DIRECTORY_NAME ? phase_retrieve_dir_map
                                                                       : phase_calc_initial_size;
    }
            break;

        case phase_retrieve_system_info: {
            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s retrieving %s",
                             parent, this, *m_info->direlemp->fullpath().image(), UNDOO_DIRECTORY_NAME);

            m_children.remove(UNDOO_DIRECTORY_NAME, m_sysinfo);
            if (m_sysinfo.isnull()) {
                Out->msg(FATAL, "<8452>Incremental backup unable to retrieve previous backup .system_info");
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "can't retrieve previous backup's .system_info");
                goto next_phase;
            }
            workelem *w = new workelem(info, m_sysinfo);
            child = new backdumpstream(this, m_sysinfo->file_hash(), w, m_stream, cur_metadataIntfp);
            child->noop();
            
            m_phase = phase_update_dirmap;
            break;
        }
        case phase_update_dirmap: {
            
            
            
            
            
            
            
            
            
            
            
            m_phase = phase_calc_initial_size;
            
            bool old_dirmap_found = do_dir_map && m_stream->get_dir_map().version() < 2;
            if (old_dirmap_found) {
                if (!enable_netapp_dirmap_update) {
                    Out->msg(WARN, "Old NetApp dirmap version is found. Use x22=2147483648 for an incremental to "\
                             "update dirmap to the most current version. This may result in an incremental backup "\
                             "that takes a long time, but is performed only once. This new dirmap is then used to "\
                             "significantly improve NetApp restore performance. Performing an L0 backup will also "\
                             "generate the new dirmap version.");
                    goto next_phase;
                }
            } else {
                goto next_phase;
            }
            DIRELEMp de = m_children.lookup(TS_DIR_FILENAME);
            if (de.isnull()) Out->msg(ERR, "Could not retrieve 'directory' streamslice from previous backup");
            
            m_stream->get_dir_map().setversion();
            
            location prev_loc(de->get_location());
            
            
            
            hfs_info_struct& hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);
            prev_loc.set_clientid(hfsinfo.clientid.image());
            
            BackupRootInfo prevBackup;
            main->find_prev_backup(prevBackup);
            const location baseloc(prevBackup.getMedialoc(), de->file_hash());
            
            flags.extract = true;
            
            ucontainer::basep container = main->open_container_for_read(prev_loc);
            Out->msg(INFO, "Old version of dirmap found, updating to most current version 2.");
            child = new dirmapupdatecycle(this, baseloc, prev_loc, container, m_stream);
            child->noop();
            break;
        }
        case phase_retrieve_dir_map: {
            m_sysinfo = m_info->direlemp;
            
            
            m_phase = phase_retrieve_acl_map;
            if (!do_dir_map) {
                
                Out->msg(WARN, "<11045>Directory map disabled for this backup.  Restores may be slower.");
                goto next_phase;
            }
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s retrieving dir map",
                             parent, this, *m_info->direlemp->fullpath().image());
            DIRELEMp de = m_children.lookup(TS_DIRMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(WARN, "<11046>Unable to retrieve directory map from previous backup.  Restores may be slower.");
                xflag[22] |= 128; 
                goto next_phase;
            }
            Out->msg(INFO, "<8453>Reading %s from previous backup", TS_DIRMAP_FILENAME);
            m_buffer.initlist(0);
            child = new restdata(this, de->file_hash(), 0, false, restelem(m_buffer));
            child->noop();
            break;
        }
        case phase_retrieve_acl_map: {
            if (do_dir_map) {
                
                m_stream->get_dir_map().init(m_buffer);
            }

            
            
            m_phase = phase_retrieve_type_map;
            if (!do_acl_ref_map) {
                
                goto next_phase;
            }
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s retrieving acl map",
                             parent, this, *m_info->direlemp->fullpath().image());
            DIRELEMp de = m_children.lookup(TS_ACLMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(WARN, "<11047>Unable to retrieve ACL references from previous backup.  Continuing.");
                xflag[22] &= ~2048; 
                goto next_phase;
            }
            Out->msg(INFO, "<8453>Reading %s from previous backup", TS_ACLMAP_FILENAME);
            m_buffer.initlist(0);
            child = new restdata(this, de->file_hash(), 0, false, restelem(m_buffer));
            child->noop();
            break;
        }
        case phase_retrieve_type_map: {
            if (do_acl_ref_map) {
                
                m_stream->get_acl_ref_map().init(m_buffer);
            }

            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s retrieving type map",
                             parent, this, *m_info->direlemp->fullpath().image());
            DIRELEMp de = m_children.lookup(TS_TYPEMAP_FILENAME);
            if (de.isnull()) {
                Out->msg(FATAL, "<11048>Unable to retrieve inode type index from previous backup.");
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "can't retrieve inode type from previous backup");
                goto next_phase;
            }
            Out->msg(INFO, "<8453>Reading %s from previous backup", TS_TYPEMAP_FILENAME);
            fileref typemap = m_stream->get_type_map();
            child = new restdata(this, de->file_hash(), 0, false, restelem(typemap));
            child->noop();
            
            m_phase = phase_notify_parent;
            break;
        }
        case phase_calc_initial_size: {
            
            
            
            
            
            

            
            
            
            
            
            
            
            fileoffset* accum_size(&m_size);
            dir_size_accumulator iter(isrootdirectory, accum_size);
            m_children.iterate(&iter);

            if (msg2) DB->msg("backdumpstream::childdone previous backup path=%s size=%g",
                              *m_info->direlemp->fullpath().image(), m_size.dvalue());
            m_phase = phase_read_stream;
            goto next_phase;
        }
        case phase_read_stream:
        {
            
            
            
            undoo::vector<ustring> tmp_list;
            if (!isrootdirectory) {
                m_children.keys(tmp_list);  
                for (unsigned int ii=0; ii < tmp_list.size(); ii++) {
                    m_items_in_dir.push_back(tmp_list[ii]);
                }
                
                
                
                
                if (isdirdirectory || isacl3directory) {
                    sortSpecialDirectories (isdirdirectory);
                }
                else {
                    std::sort(m_items_in_dir.begin(), m_items_in_dir.end(), compare_strings);
                }
            }
            else {  
                    
                DIRELEMp de = m_children.lookup(TS_ACL3_FILENAME);  
                bool acl3_used = (!de.isnull());
                de = m_children.lookup(TS_FILE_FILENAME);  
                bool file_used = (!de.isnull());
                de = m_children.lookup(TS_ACL_FILENAME);   
                bool oldacl_used = (!de.isnull());

                for (unsigned int ii=0; ii < TOPLEVELIST_SIZE; ii++) {
                    if ((strcmp(toplevel_list[ii], TS_ACL3_FILENAME) == 0) && !acl3_used)   continue;
                    if ((strcmp(toplevel_list[ii], TS_FILE_FILENAME) == 0) && !file_used)   continue;
                    if ((strcmp(toplevel_list[ii], TS_ACL_FILENAME)  == 0) && !oldacl_used) continue;
                    m_items_in_dir.push_back(toplevel_list[ii]);
                }
            }
            if (umsg) printdirlist("END OF READ_STREAM PHASE --------------------------- ");
            m_current_dir_item = 0;
            m_phase = phase_process_dir;
        }
        

    case phase_process_dir: {
            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s reading stream",
                             parent, this, *m_info->direlemp->fullpath().image());

            
            
            
            
            
            
            const bool gofaster = !flags.incremental && !go_slower && !isrootdirectory && !info->use_container && !catalog_enabled;

            if(gofaster && child!=NULL && nforked > 0) {
                ++ncollected;
                
                if(!forksdone || ncollected<nforked) break;
            } else { 
                ustring name;
                dumpstream::parser::path_action next;
                next = m_stream->next_modified_path(m_info->direlemp->fullpath(), name);
                if (msg2) DB->msg("backdumpstream::childdone: next_modified_path for dir %s returned name %s and action %d", *m_info->direlemp->fullpath().image(), *name, next);

                
                
                
                maintainDirOrder(next, name, isrootdirectory);  

                
                if (next == dumpstream::parser::delete_item) {
                    
                    
                    DIRELEMp de;
                    m_children.remove(name, de);
                    if (!de.isnull()) {
                        if (!isrootdirectory || name == TS_FILE_FILENAME) m_size -= de->file_size();
                    }
                    
                    m_current_dir_item--; 
                    m_items_in_dir.erase(m_items_in_dir.begin()+m_current_dir_item);
                    if (msg2) DB->msg("REMOVED ITEM %s from dir %s, m_current_dir_item is now %d", *name, *m_info->direlemp->fullpath().image(), m_current_dir_item);

                    if (umsg) printdirlist ("AFTER DELETE -----------------------------------------");
                    goto next_phase;
                } 

                
                
                
                if (isrootdirectory) {
                    if (next != dumpstream::parser::no_more_items)
                        main->handling_system_info(name != TS_FILE_FILENAME);
                    else
                        main->handling_system_info(false);
                }

                if (next == dumpstream::parser::subdir_item) {
                    handleSubdirectory(name, isrootdirectory, child);
                    m_phase = phase_process_dir; 
                    if(!gofaster) break;
                    ++nforked;
                } 

                if (next == dumpstream::parser::save_item) {
                    
                    
                    saveItemFromStream(name, isrootdirectory, child);
                    m_phase = phase_process_dir; 
                    if(!gofaster) {
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        if (catalog_enabled)
                            m_phase = phase_add_item_to_metastore;
                        break;
                    }
                    ++nforked;
                }  

                if(gofaster) {
                    if(next == dumpstream::parser::no_more_items) forksdone=true;

                    
                    if(next != dumpstream::parser::no_more_items) {
                        if(msg1) DB->msg("backdumpstream this:%p enqueing nforked:%d ncollected:%d", this, nforked, ncollected);
                        todoEnqueueInsert(TODO_DIR, this, -getDepth());
                    }

                    
                    if(ncollected < nforked) {
                        break;
                    }
                }
                assert(next == dumpstream::parser::no_more_items);
            }  

            
            m_phase = isrootdirectory ? phase_make_system_info : phase_write_directory;
	    
	    
            
            if (isrootdirectory)
            {
                
                if (main->tomato)
                {
                    ctl_messagep max_changed_date_msg(new ctl_message(ctl_message::type::send_max_changed_date));
                    max_changed_date_msg->set_max_changed_date(m_stream->get_max_changed_date(flags.incremental));
                    main->tomato->post_to_parent(max_changed_date_msg, NULL);
                }
            }
            
            
            if (info->use_container) {
                endDirInContainer();
                if (isrootdirectory) {
                    main->finalizeucontainer(info->container, false);
                }
            }
            if (catalog_enabled) {
                if (!isrootdirectory) {
                    
                    if (!add_directory_to_metastore(info->direlemp)) {
                        Out->Abort("Problem adding directory '%s' in Metadata store.",
                                   *info->direlemp->fullpath().image());
                        return;
                    }
                }
            }
            goto next_phase;
        }
        case phase_add_item_to_metastore: {
            
            
            if (info->use_container) {
                endFileInContainer(child);
            }
            
            if (!add_item_to_metastore(m_child_de)) {
                Out->Abort("Problem adding item '%s' to '%s' in Metadata store.",
                           *m_child_de->fullpath().image(), *info->direlemp->fullpath().image());
                return;
            }
            m_phase = phase_process_dir;
            goto next_phase;
        }
        case phase_make_system_info: {
            
            m_stream->validatebitmaps(flags.incremental);
            
            main->getstatsobj(context::backupstats)->add_filecount((double)m_stream->get_file_count());

            
            DIRELEMp de = new DIRELEM;
            de->initialize(0, 0, 0, 0, ATTR_DIRECTORY|ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);
            m_children.enter(UNDOO_DIRECTORY_NAME, de); 
            m_items_in_dir.push_back(UNDOO_DIRECTORY_NAME);  

            Out->msg(INFO, "<8454>Preparing tables for backup");
            if (do_dir_map) {
                DB->msg("backdumpstream::childdone: Generating dir_map (Memory usage: %dMB)", axion_procinfo().vmsize_mb);
                main->sysinfo_files_and_data.enter(ustring(TS_DIRMAP_FILENAME), m_stream->get_dir_map().flatten());
            }
            if (do_acl_ref_map) {
                DB->msg("backdumpstream::childdone: Generating acl_ref_map (Memory usage: %dMB)", axion_procinfo().vmsize_mb);
                main->sysinfo_files_and_data.enter(ustring(TS_ACLMAP_FILENAME), m_stream->get_acl_ref_map().flatten());
            }
            DB->msg("backdumpstream::childdone: Generating type_map (Memory usage: %dMB)", axion_procinfo().vmsize_mb);
            main->sysinfo_files_and_data.enter(ustring(TS_TYPEMAP_FILENAME), m_stream->get_type_map());
            workelem *w = new workelem(info, de);
            w->use_container = false;
            backhidden *bh = new backhidden(this, w, 0, 0, false, true);

            if (flags.incremental)
            {
                assert(m_sysinfo != 0);
                bh->save_last_sysinfo(m_sysinfo);
            }

            bh->noop();
            m_phase = phase_write_directory;
            break;
        }
        case phase_write_directory: {
            

            
            if (isrootdirectory || m_info->direlemp->fullpath().get(0) == TS_FILE_FILENAME) {
                
                
                if (msg2) DB->msg("backdumpstream::childdone adding unmodified bytes path=%s size=%g",
                                  *m_info->direlemp->fullpath().image(), m_size.dvalue());
                main->byteprogress(context::backupstats, stats::ispresent, m_size.dvalue());

                
                
                
                
                
                
                
                main->addfilebytes(context::backupstats, m_size.dvalue());
            }

            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s saving directory contents",
                             parent, this, *m_info->direlemp->fullpath().image());
            direlemp_list_type childlist;
            ustring name;
            DIRELEMp de;
            epoch_t ctime = INT_MAX;
            epoch_t mtime = 0;
            fileoffset fsize;

            
            if (m_children.size() != m_items_in_dir.size()) {
               DB->msg("backdumpstream::childdone: write_dir: sizes DIFFER m_children=%d m_items_in_dir=%d", m_children.size(), (int)m_items_in_dir.size());
               printdirlist ("backdumpstream::childdone: write dir sizes differ");

               undoo::vector<ustring> tmp_list2;
               m_children.keys(tmp_list2);  
               DB->msg("backdumpstream::childdone: write_dir: sizes DIFFER, number of keys = %d", (int) tmp_list2.size());
               for (unsigned int ii=0; ii < tmp_list2.size(); ii++) {
                   DB->msg("    key %d = %s", ii, *tmp_list2[ii]);
               }
            }

            if (isdirdirectory || isacl3directory) {
                sortSpecialDirectories (isdirdirectory);
            }
            for (unsigned int ii = 0; ii < m_items_in_dir.size(); ii++) {
                de = m_children.lookup(m_items_in_dir[ii]);
                if (de == NULL) {    
                    Out->msg(ERR, "Mismatch in directory list checking for '%s' in directory '%s'. This item will not be backed up.",
                             *m_items_in_dir[ii], *m_info->direlemp->fullpath().image());
                    continue;
                }

                
                
                if (de->file_hash() == hashcode::ones) {
                    if (msg2) DB->msg("backdumpstream::childdone: write_dir: hash is ones for %s. It is being deleted.", *de->fullpath().image());
                    continue;
                }
                childlist.push_back(de);
                epoch_t atm, ctm;
                unsigned int tf;
                de->get_ext_times(ctm, atm, tf);
                ctime = std::min(ctime, ctm);
                mtime = std::max(mtime, de->mtime());
                
                
                if (isrootdirectory && name == TS_FILE_FILENAME) fsize = de->file_size();
            }

            if (childlist.size() == 0) {
                
                
                
                
                if (msg2) DB->msg("backdumpstream::childdone: write_dir: childlist empty ");

                
                if (!info->use_container || !m_begindir_sent) {
                    m_phase = phase_notify_parent;
                    goto next_phase;
                }
            }
            

           if (msg2) for (unsigned int jj = 0; jj < childlist.size(); jj++) {
               DB->msg("backdumpstream::childdone: write_dir: after sort, childlist[%d] = %s", jj, *childlist[jj]->name());
            }

            
            m_info->direlemp->set_mtime(mtime);
            if (ctime != INT_MAX) m_info->direlemp->set_ext_times(ctime, 0);

            

            
            m_size = 0;
            m_info->data = build_diratomic(childlist, m_size, flags.inode, main->getmaxdirelemsize(dpn0));
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s directory size is %s",
                             parent, this, *m_info->direlemp->fullpath().image(), *size.image());
            if (fsize != 0) m_size = fsize; 
            m_info->direlemp->set_file_size(m_size); 

            
            workelem *w = new workelem(m_info, m_info->path, m_info->direlemp, m_info->fstats, m_info->data);
            w->use_container = false; 
            
            
            
            
            
            w->ignoreStats = true;
            child = new nbackdata(this, w, fileoffset(0), true);
            child->noop();

            m_phase = isrootdirectory && flags.ndmp_prefix != "" ? phase_create_volume_dir : phase_notify_parent;
            break;
        }
        case phase_create_volume_dir: {
            
            if (flags.ndmp_prefix.isempty()) {
                Out->msg(FATAL, "<11050>Volume name is empty.  Check --ndmp-prefix flag.");
                uapp::staging().startTermination(EXIT_DUMPSTREAM, "volume name is empty");
                goto next_phase;
            }
            if (catalog_enabled) {
                
                if (!add_directory_to_metastore(m_info->direlemp)) {
                    Out->Abort("Problem adding directory '%s' in Metadata store.",
                               *info->direlemp->fullpath().image());
                    return;
                }
            }
            m_items_in_dir.clear();  
            const epoch_t now = (epoch_t)timer::now();
            m_info->direlemp->set_file_size(m_size); 
            m_size = 0; 
            m_info->direlemp->set_name(flags.ndmp_prefix);
            if (m_info->direlemp->file_hash() == hashcode::ones) {
                m_info->direlemp->set_hash(m_prevhash);
                
            }
            dirrec_pack::ndmp_volume vol(m_info->direlemp.getimpl());
            vol.set(ndmp_unentify_volume(flags.ndmp_prefix));
            m_children.enter(flags.ndmp_prefix, m_info->direlemp);
            m_items_in_dir.push_back(flags.ndmp_prefix);  

            flags.ndmp_prefix = ""; 
            m_saved_top = m_info->direlemp;
            m_info->direlemp = new DIRELEM;
            m_info->direlemp->initialize(hashcode::ones, now, now, now, 0, ATTR_DIRECTORY, "");
            m_phase = phase_write_directory;
            goto next_phase;
        }
        case phase_notify_parent:
            
            if (nforked > 0) {
                
                if (child != NULL) {
                    ++ncollected;
                    forksdone = true; 
                }
                if (!forksdone || ncollected < nforked) {
                    if (!uapp::staging().canRun()) {
                        Out->msg(INFO, "<11051>Backup cycle terminated for directory '%s'.  Waiting for children to finish.",
                                 *m_info->direlemp->fullpath().image());
                    } else if (msg1) {
                        DB->msg("backdumpstream::childdone parent:%p this:%p path:%s size:%s waiting for children",
                                parent, this, *m_info->direlemp->fullpath().image(), *m_info->direlemp->file_size().image());
                    }
                    break;
                }
            }

            
            if(msg1) DB->msg("backdumpstream::childdone parent:%p this:%p path:%s size:%s notifying parent",
                             parent, this, *m_info->direlemp->fullpath().image(), *m_info->direlemp->file_size().image());
            if (m_info->direlemp->is_directory()) {
                
                
                m_info->direlemp->set_file_size(m_size);
            }

            notifyparent();
            break;

        default:
            
            Out->msg(ERR, "<8455>Unexpected phase number %d (path = %s)", m_phase, *m_info->direlemp->fullpath().image());
            break;
    }
    
}





void backdumpstream::addItemToContainer(ustring& name, bool isrootdirectory) {

    if (umsg) DB->msg("DDR backdumpstream::addItemToContainer called with name=%s isroot=%d", *name, isrootdirectory);
    if (!info->use_container) {
        if (umsg) DB->msg("ERROR!!!!!! CALLING SYNTHOBJ WHEN BACKUP IS NOT TO A CONTAINER!!!!!!");
    }
    else {
        if (!m_begindir_sent) startDirInContainer();  

        fileref dummy;
        DIRELEMp de = m_children.lookup(name);
        if (!de.isnull()) {
            if (!isrootdirectory) {
                m_size -= de->file_size();

                
                
                
                main->byteprogress(context::backupstats, stats::ispresent, de->file_size().dvalue());

                
                
                
                
                
                main->addfilebytes(context::backupstats, de->file_size().dvalue());
            }
            ucontainer::errortype errcode;
            fileoffset offset;
            if (umsg) DB->msg("LOCATION: backdumpstream::addItemToContainer: %s stored in ucontainer; calling synthobj()", *de->name());
            if (umsg) DB->msg("       LOCATION fullpath = %s ", *de->fullpath().image());
            if (umsg) DB->msg("       LOCATION info= %s", *de->get_location().image());

            location pre_loc(de->get_location());
            
            if (inject_ddr_checksum_error) {
                pre_loc.set_checksum(+pre_loc.get_abs_offset_in_container().value() & 0xFFFFFFFF);
                DB->msg("backdumpstream::addItemToContainer: synth obj: %s, location: %s, injected bad checksum: %d",
                         *de->fullpath().image(), *pre_loc.image(), pre_loc.get_checksum().value);
            }
            
            pre_loc.set_checksum_type(ddr_checksums_enabled? 1 : 0);
            de->set_location(pre_loc);

            if ((errcode = info->container->synthobj(de.getimpl())) != ucontainer::pce__success) {
                ustring errdesc = LOCTXT(*ucontainer::error_description(errcode));
                Out->Abort("Error synthesizing object '%s' to container. (%s)", *de->fullpath().image(), *errdesc);
                return;
            }
            if (umsg) DB->msg("LOCATION backdumpstream::addItemToContainer: after synth, dir is %s ",
                *de->fullpath().image());
            if (umsg) DB->msg("         LOCATION offset returned is %s", *offset.image());
        }
        else { 
            if (umsg) DB->msg("DDR backdumpstream::addItemToContainer: Got a null direlem when extracting %s from parent directory", *name);
        }
    }
}

const char* phasenames[] = {
    "RESTORE_PREV_DIR",
    "RETRIEVE_SYSTEM_INFO",
    "RETRIEVE_DIR_MAP",
    "RETRIEVE_ACL_MAP",
    "RETRIEVE_TYPE_MAP",
    "CALC_INITIAL_SIZE",
    "READ_STREAM",
    "PROCESS_DIR",
    "MAKE_SYSTEM_INFO",
    "WRITE_DIRECTORY",
    "CREATE_VOLUME_DIR",
    "NOTIFY_PARENT"
};

ustring backdumpstream::phasetext() {

    if (((int) m_phase > 11) || ((int)m_phase < 0)) {
        return "UNKNOWN";
    }
    return phasenames[m_phase];
}


void backdumpstream::printdirlist (const char* mytext) {
    DB->msg("PRINTDIRLIST: %s", mytext);
    DB->msg("        m_current_dir_item = %d", m_current_dir_item);

    for (unsigned int i=0; i <m_items_in_dir.size(); i++) {
         DB->msg("        m_items_in_dir[%d] = %s", i, *m_items_in_dir[i]);
    }
}




void backdumpstream::handleSubdirectory(const ustring& name, bool isrootdirectory, cycle* child) {

    
    const epoch_t now((epoch_t)timer::now());
    hashcode prevhash = hashcode::ones;    
    DIRELEMp de = m_children.lookup(name);
    location loc;
    if (de.isnull() && name == TS_ACL3_FILENAME) {
        
        de = m_children.lookup(TS_ACL_FILENAME);
        if (!de.isnull()) Out->msg(INFO, "<11049>Upgrading ACL layout to OnTap 7.3 format.");
    }
    if (!de.isnull()) {
        prevhash = de->file_hash();
        loc = de->get_location();
        if (!isrootdirectory || name == TS_FILE_FILENAME) m_size -= de->file_size();
    }

    de = new DIRELEM;
    de->initialize(hashcode::ones, now, now, now, 0, ATTR_DIRECTORY, name);
    de->set_fullpath(m_info->direlemp->fullpath() / upath(name));
    de->set_location(loc);
    de->set_unix_special(0, 0, 0, 0);
    m_children.enter(name, de); 

    workelem *w = new workelem(info, de);
    child = new backdumpstream(this, prevhash, w, m_stream, cur_metadataIntfp);
    child->noop();
}




void backdumpstream::saveItemFromStream(const ustring& name, bool isrootdirectory, cycle* child) {

    fileref dummy;
    m_child_de = m_children.lookup(name);
    if (!m_child_de.isnull() && !isrootdirectory) m_size -= m_child_de->file_size();   
    m_stream->getentry(m_child_de, dummy, dummy);
    m_children.enter(name, m_child_de); 

    
    if (info->use_container && !m_child_de->is_directory()) {
        if (!m_begindir_sent) startDirInContainer();  
        beginFileInContainer (m_child_de);
    }

    workelem *w = new workelem(info, m_child_de);
    
    
    child = new nbackdata(this, w, 0, false, m_stream.getimpl(), info->use_container);
    child->noop();
}




void backdumpstream::beginFileInContainer (DIRELEMp& de) {

    if (!m_begindir_sent) startDirInContainer(); 

#if (POINTER64)  
    if (umsg) DB->msg("backdumpstream::beginFileInContainer: --- before beginfile (LOCATION offset: %s, file=%s  mysize=%ld)",
        *info->container->get_curroffset().image(),
             *de->fullpath().image(), de->file_size().value());
#endif
    if (umsg) DB->msg("        LOCATION: %s",  *de->get_location().image());

    ucontainer::errortype errcode;

    
    fileoffset myoffset((de->inode_number() == 3)     ? TP_BSIZE :
                         use_sizemin_hint             ? TP_BSIZE :
                         (de->file_size() < TP_BSIZE) ? TP_BSIZE :
                         (de->file_size() > m_stream->get_object_size()) ?
                          m_stream->get_object_size() : de->file_size());
    if (umsg && de->is_netapp_sparse_file()) DB->msg("backdumpstream::beginFileInContainer: using myoffset = %ld for sparse file.", myoffset.value());
    if (umsg && use_sizemin_hint)  DB->msg("backdumpstream::beginFileInContainer: xflag set, so that offset is always minimal (%ld)", myoffset.value());

    if ((errcode = info->container->beginfile(de.getimpl(), myoffset, 1 )) != ucontainer::pce__success)
    {

        ustring errdesc = ucontainer::error_description(errcode);
#if (POINTER64)  
        Out->Abort("Problem creating beginfile in container for file '%s' (%s) offset=%ld",
            *de->fullpath().image(), *errdesc, myoffset.value());
        return;
#endif
    } else {
#if (POINTER64)  
        if (umsg) DB->msg("backdumpstream::beginFileInContainer: --- after beginfile (LOCATION abs_offset_in_container: %"LL"d, file=%s filesize=%ld offset=%ld)",
                          de->get_location().get_abs_offset_in_container().value(),
                          *de->fullpath().image(), de->file_size().value(), myoffset.value());
#endif
        if (umsg) DB->msg("        LOCATION: %s",  *de->get_location().image());
    }
}




void backdumpstream:: endFileInContainer (cycle* child) {

    BackCycle *bc = dynamic_cast<BackCycle *>(child);

    if ((bc != NULL) && (bc->getInfo() != NULL) && (!bc->getInfo()->direlemp.isnull())) {
        DIRELEMp tmpde(bc->getInfo()->direlemp);
        if (!tmpde->is_directory()) {
            if (umsg) DB->msg("backdumpstream::endFileInContainer: --- before endfile (offset: %s, file=%s)",
                *info->container->get_curroffset().image(),
                *tmpde->fullpath().image());
            ucontainer::errortype errcode;
            fileoffset myoffset = 0;
            if ((errcode = info->container->endfile(tmpde.getimpl(), myoffset)) != ucontainer::pce__success)
            {
                ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
#if (POINTER64)  
                Out->Abort("Problem creating container endfile for file '%s' (%s) offset=%ld",
                    *tmpde->fullpath().image(), *errdesc, myoffset.value());
                return;
#endif
            } else {
                if (umsg) DB->msg("backdumpstream::endFileInContainer: --- after endfile LOCATION (returned offset: %s, file=%s)",
                    *info->container->get_curroffset().image(),
                    *tmpde->fullpath().image());
                if (umsg) DB->msg("        de LOCATION: %s)", *tmpde->get_location().image());
            }
        }  
    }
    else {
        if (umsg) DB->msg("backdumpstream::endFileInContainer: Problem setting up BackCycle to do endfile");
    }
}






void backdumpstream::startDirInContainer() {

    if (umsg) DB->msg("backdumpstream::startDirInContainer TOP, called for dir %s", *m_info->direlemp->fullpath().image());
    if (m_begindir_sent) return;  

    
    if (m_info->direlemp->fullpath() != upath(""))  {  
        backdumpstream *myparent = dynamic_cast<backdumpstream *>(m_parent);
        myparent->startDirInContainer();
    }

    if (umsg) DB->msg("backdumpstream::startDirInContainer: before begindir (offset: %s, dir=%s)",
        *info->container->get_curroffset().image(), *m_info->direlemp->fullpath().image());

    ucontainer::errortype errcode;
    if ((errcode = info->container->begindir(m_info->direlemp.getimpl())) != ucontainer::pce__success)
    {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem creating container begindir for directory '%s' (%s)",
            *m_info->direlemp->fullpath().image(), *errdesc);
        return;
    } else {
        if ((errcode = info->container->begindircontent(m_info->direlemp.getimpl())) != ucontainer::pce__success) {
            ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
            Out->Abort("Problem starting container begindircontent for directory '%s' (%s)",
                *m_info->direlemp->fullpath().image(), *errdesc);
            return;
        }

        if (umsg) DB->msg("backdumpstream::startDirInContainer: after begindircontent dir=%s, de LOCATION %s",
            *m_info->direlemp->fullpath().image(), *m_info->direlemp->get_location().image());
    }
    m_begindir_sent = true;
}




void backdumpstream::endDirInContainer() {

    if (umsg) DB->msg("backdumpstream::endDirInContainer: before enddir (offset: %s, dir=%s)",
        *info->container->get_curroffset().image(),
        *m_info->direlemp->fullpath().image());

    if (!m_begindir_sent) {
        DB->msg("backdumpstream::endDirInContainer: Problem - no begindir has been sent for this directory.");
        return;   
    }

    ucontainer::errortype errcode;
    if ((errcode = info->container->enddir(m_info->direlemp.getimpl())) != ucontainer::pce__success)
    {
        ustring errdesc = LOCTXT(ucontainer::error_description(errcode));
        Out->Abort("Problem creating container enddir for directory '%s' (%s)",
            *m_info->direlemp->fullpath().image(), *errdesc);
        return;
    }

    if (umsg) DB->msg("backdumpstream::endDirInContainer: after enddir (offset: %s, dir=%s)",
        *info->container->get_curroffset().image(), *m_info->direlemp->fullpath().image());
}



void backdumpstream::maintainDirOrder( const dumpstream::parser::path_action action, const ustring& name, const bool isrootdirectory) {

    if (umsg) printdirlist ("backdumpstream::maintainDirOrder: At the top ----------------------");

    
    if (action == dumpstream::parser::no_more_items) {
        while (m_current_dir_item < m_items_in_dir.size()) {
            if (info->use_container) addItemToContainer(m_items_in_dir[m_current_dir_item], isrootdirectory);
            m_current_dir_item++;
        }
        if (umsg) printdirlist ("backdumpstream::maintainDirOrder: after calling loop to finish out directory ----------------------");
        return;
    }

    
    
    
    unsigned int list_loc = 0;
    bool found = false;
    for (unsigned int i = 0; i < m_items_in_dir.size(); i++) {
        if (name == m_items_in_dir[i]) {
            found = TRUE;
            list_loc = i;
            break;
        }
    }

    
    if (umsg) DB->msg("backdumpstream::maintainDirOrder: NAME %s was %s found in dir %s. index %d, current=%d.",
                *name, (found ? "" : "**NOT**"), *m_info->direlemp->fullpath().image(), list_loc, m_current_dir_item);

    
    if (m_items_in_dir.size() != 0) {    
        
        while ((m_current_dir_item < m_items_in_dir.size()) &&
                (found ? (name != m_items_in_dir[m_current_dir_item]) : (m_items_in_dir[m_current_dir_item] < name)) ) {
            if (info->use_container) addItemToContainer(m_items_in_dir[m_current_dir_item], isrootdirectory);
            m_current_dir_item++;
        }
    }

    if (!found) {  
        if (umsg) DB->msg("backdumpstream::maintainDirOrder: inserting new item %s at location %d", *name, m_current_dir_item);
        m_items_in_dir.insert(m_items_in_dir.begin() + m_current_dir_item, name);
    }
    m_current_dir_item++;  
    if (umsg) printdirlist ("backdumpstream::maintainDirOrder: after updating list ----------------------");
}






void backdumpstream::sortSpecialDirectories (bool isdirdir) {

    ustring special (isdirdir ? "2" : "3");  
    int myloc = 0;
    if (m_items_in_dir[0] != special) {   
        for (unsigned int i = 0; i < m_items_in_dir.size(); i++) {
            if (m_items_in_dir[i] == special) {
                myloc = i;
                break;
            }
        }
        if (myloc != 0) {  
            ustring tmp = m_items_in_dir[0];
            m_items_in_dir[0] = m_items_in_dir[myloc];
            m_items_in_dir[myloc] = tmp;
        }
    }
    
    std::sort(m_items_in_dir.begin()+1, m_items_in_dir.end(), compare_strings);
}

bool backdumpstream::open_backup_metastore()
{
    assert(metadatastorep != NULL);
    
    SavesetIntf_sp saveset_interfacep;
    storeResultCodes store_errcode(storeSuccess);
    if ((store_errcode = metadatastorep->getOpenBackup(saveset_interfacep, parent_metadataIntfp)) != storeSuccess) {
        Out->msg(ERR, "Problem calling catalog getOpenBackup() for %s (result code=%d)",
                 *info->direlemp->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backdumpstream::backdumpstream: getOpenBackup() successful for %s (parent_metadataIntfp.count=%ld)",
                          *info->direlemp->fullpath().image(), parent_metadataIntfp.use_count());
    }
    return true;
}




bool backdumpstream::open_metastore_directory_entry()
{
    assert(metadatastorep != NULL);
    
    storeResultCodes store_errcode(storeSuccess);
    if (!parent_metadataIntfp || (store_errcode = parent_metadataIntfp->openDir(*info->direlemp, cur_metadataIntfp)) != storeSuccess) {
        Out->msg(ERR, "Problem calling catalog openDir() for %s (result code=%d)",
                 *info->direlemp->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backdumpstream::open_metastore_directory_entry: openDir() successful for dir %s",
                          *info->direlemp->fullpath().image());
    }
    return true;
}



bool backdumpstream::add_directory_to_metastore(DIRELEMp obj_direlem)
{
    if (!obj_direlem.isdefined()) {
        Out->msg(ERR, "Attempted to add non-existent directory to metadata store.");
        return false;
    }
    assert(metadatastorep != NULL);
    
    storeResultCodes store_errcode(storeSuccess);
    if (!cur_metadataIntfp || (store_errcode = cur_metadataIntfp->closeDir(*obj_direlem)) != storeSuccess) {
        Out->msg(ERR, "Problem calling catalog closeDir() for %s (result code=%d)",
                 *obj_direlem->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backdumpstream::add_directory_to_metastore: closeDir() successful for dir %s",
                          *obj_direlem->fullpath().image());
    }
    return true;
}






bool backdumpstream::add_item_to_metastore(DIRELEMp obj_direlem)
{
    if (!obj_direlem.isdefined()) {
        Out->msg(ERR, "Attempted to add non-existent object to metadata store.");
        return false;
    }
    assert(metadatastorep != NULL);
    storeResultCodes store_errcode(storeSuccess);
    if (!cur_metadataIntfp || (store_errcode = cur_metadataIntfp->add(*obj_direlem)) != storeSuccess) {
        Out->msg(ERR, "Problem calling catalog add() for %s (result code=%d)",
                 *obj_direlem->fullpath().image(), store_errcode);
        return false;
    } else {
        if (msg2) DB->msg("backdumpstream::add_item_to_metastore: add() successful for %s",
                          *obj_direlem->fullpath().image());
    }
    return true;
}





dirmapupdatecycle::dirmapupdatecycle(cycle *parent, const location &baseloc, const location &loc,
                                     ucontainer::basep container, dumpstream::parserp stream)
    : cycle(parent, 0)
    , m_phase(phase_get_child_direlems)
    , m_baseloc(baseloc)
    , m_loc(loc)
    , m_stream(stream)
    , m_container(container)
    , m_dirlistidx(0)
    , m_keylistidx(0)
    , m_dircount(0)
    , m_processed(0)
{
    todoEnqueueInsert(TODO_DIR, this, -getDepth());
}

void dirmapupdatecycle::init()
{
    
    
    undoo::vector<intobj> v = m_stream->get_dir_map().keys();
    
    
    
    
    
    
    sort(v.begin(), v.end(), std::less<int>());
    for (size_t i = 0; i < v.size(); i++) {
        int inode = int(v[i]);
        
        if (inode > 2) {
            
            upath inodestr = m_stream->get_type_map().format(inode);
            
            inodestr.pop_back();
            
            inodestr.pop_front();
            
            m_dirlist.push_back(inodestr.image());
        }
    }
    
    m_dirlist.erase(std::unique(m_dirlist.begin(), m_dirlist.end()), m_dirlist.end());
    
    m_dircount = m_stream->get_dir_map().size() - 2;
    childdone(0);
}

void dirmapupdatecycle::displayprogress()
{
    
    int displayrange = m_dircount / 10;
    if ((displayrange > 0 && m_processed % displayrange == 0) || m_processed == m_dircount)
        Out->msg(INFO, "Updated %d out of %d dirmap entries...", m_processed, m_dircount);
}

void dirmapupdatecycle::childdone(cycle *child)
{
next_phase:
    switch (uapp::staging().canRun() ? m_phase : phase_done) {
        case phase_get_child_direlems: {
            
            if (m_dirlistidx < (int)m_dirlist.size()) {
                upath path(m_dirlist[m_dirlistidx++]);
                
                child = new restdirlist(this, m_baseloc, path, m_loc, m_listing);
                child->noop();
            } else {
                m_phase = phase_done;
                goto next_phase;
            }
            m_phase = phase_get_child_names;
            break;
        }
        case phase_get_child_names: {
            
            
            m_listing.keys(m_keylist);
            m_keylistidx = 0;
            m_phase = phase_get_child_streamslice;
            goto next_phase;
        }
        case phase_get_child_streamslice: {
            
            if (m_keylistidx < (int)m_keylist.size()) {
                ustring key(m_keylist[m_keylistidx++]);
                filestatsref fstats;
                
                if (m_listing.lookup(key, m_de)) {
                    int dirslicesize = (int)m_de->file_size().ivalue();
                    m_buffer.initlist(dirslicesize);
                    restelem re(m_de->fullpath(), *m_de, fstats, m_buffer, m_container);
                    
                    child = new restdata(this, m_de->file_hash(), 0, true, re, m_container.isdefined());
                    child->noop();
                } else {
                    Out->msg(WARN, "Could not find direlem for %s during dirmap update", *key);
                    goto next_phase;
                }
            } else {
                m_keylist.clear();
                m_phase = phase_get_child_direlems;
                goto next_phase;
            }
            m_phase = phase_update_dirmap_entry;
            break;
        }
        case phase_update_dirmap_entry: {
            int mtime, nt_ads, acl_inode;
            undoo::vector<intobj> childinode;
            undoo::vector<ustring> childname;
            
            dumpstream::parsedumpdir(m_buffer, mtime, nt_ads, childinode, childname, acl_inode);
            
            m_stream->get_dir_map().add(m_buffer);
            m_processed++;
            displayprogress();
            m_phase = phase_get_child_streamslice;
            goto next_phase;
        }
        case phase_done:
            notifyparent();
            break;
        default:
            Out->msg(ERR, "Invalid phase number %d", m_phase);
            break;
    }
}


































































































#define BIGDIRGROUP   50000





#define SENDGROUP_RATIO 10




#define MAXSPAWN 250



#define MAXLISTINGBYTES (128*1024)

#include "common.h"
#include "debug.h"
#include "priqueue.h"
#include "sortdirwalk.h"
#include "fileref.h"
#include "filestream.h"
#include "backstate.h"
#include "backstats.h"
#include "workelem.h"
#include "output.h"
#include "file.h"
#include "cache.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "nbackdir_manual_unc.h"
#include "nbackfile.h"
#include "nbackdir.h"
#include "nbackdata.h"
#include "timer.h"
#include "dirrec.h"
#include "ade_mgrx.h"

#include "filenames.h"  
#include "runstage.h"

#include "MetadataStore.h"
#include "hfs_info_struct.h"

#include "backhidden.h"

#include <algorithm> 


#define msg1 ((xflag[2]&8)!=0)
#define msg2 ((xflag[2]&16)!=0)
#define msg3 ((xflag[2]&1048576)!=0)



nbackdir_manual_unc::nbackdir_manual_unc(BackCycle *parent, workelem *info_, fileoffset offset,
                                 bool reserve_hiddendir_, bool top_level_,
                                 const bool use_container_ 
):
    BackCycle( parent, info_),
    elements(NULL),
    fillindex(0),
    sendindex(0),
    drainindex(0),
    more_dirgroups(false),
    flush_listing(false),
    maxgroupentries(BIGDIRGROUP),
    maxsendentries(BIGDIRGROUP/SENDGROUP_RATIO),
    group_count(0),
    entry_count(0),
    datachild(NULL),
    hiddendirp(NULL),
    top_level(top_level_),
    traverse_depth(0),
    use_container(use_container_),
    reserve_hiddendir(reserve_hiddendir_),
    manual_index(0),
    nbackdir_index(0),
    nbackfile_index(0),
    backstream_index(0),
    doneAddingSubcycles(false),
    ddrDirClosed(false)
{
    if (msg1) DB->msg("nbackdir_manual_unc::nbackdir_manual_unc (parent:%p) (this:%p) fs path='%s' de.path='%s' top-level=%d track=%d use_container:%d",
        parent, this, *info->path.image(), *info->direlemp->fullpath().image(), top_level_, getThreadNbr(), use_container);

    
    
    
    if(use_container && info->use_container) {
        assert(!info->container.isnull());
    }

    elements  = new direlemp_list_type(DEFAULTDIRSIZE); 

    if(!info) DB->bt_error(("nbackdir_manual_unc::nbackdir_manual_unc ---------------------> INFO is NULL <------------------------"));
    else {
        if (info->direlemp->get_location().getMedia() > location::media::gsan) {
            if ((!use_container) || (!info->use_container)) {
                Out->msg(INFO, "nbackdir_manual_unc::nbackdir_manual_unc constructor has use_container:%d info->use_container:%d, but direlem points at ddr",
                         use_container, info->use_container);
                assert(!info->container.isnull());
                use_container = true;
                info->use_container = true;
                
                
            }
        }
    }

    cycle::offset = offset;
    this->cyexcluded = false;
    this->cyisdirectory = true; 

    
}

void nbackdir_manual_unc::do_file_finish() {
    if (msg1) {
        DB->msg("nbackdir_manual_unc::do_file_finish(this: %p) done adding subcycles to '%s' nforked=%d, forksdone=%d, ncollected=%d nbackmans:%d/%d, nbackdirs:%d/%d, nbackfiles:%d/%d",
            this, *info->direlemp->fullpath().image(), nforked, forksdone, ncollected, manual_index, (int)nbackdir_manual_unc_subcycles.size(), nbackdir_index, (int)nbackdir_subcycles.size(),
            nbackfile_index, (int)nbackfile_subcycles.size());
    }

    
    
    assert(collectdone == false);
    doneAddingSubcycles = true;
}


void nbackdir_manual_unc::init()
{
    if (msg1) DB->msg("nbackdir_manual_unc::init");
    assert(false);
}

void nbackdir_manual_unc::response(message& outargs ) {
    if (msg1) DB->msg("nbackdir_manual_unc::response");
    assert(false);
}

void nbackdir_manual_unc::childdone(cycle *child) {

    if( msg1 ) {
        DB->msg( "nbackdir_manual_unc::childdone (this:%p de.path:%s info.path:%s) (child:%s at %p)", this, *info->direlemp->fullpath().image(), *info->path.image(), child ? typeid(*child).name() : "SELF", child);
        DB->msg( "nbackdir_manual_unc::childdone forksdone:%d ncollected=%d nforked=%d collectdone=%d more_dirgroups=%d", forksdone, ncollected, nforked, collectdone, more_dirgroups );
    }

    if(!collectdone) {
        scope s(countersMutex);
        if(child == NULL) {  
            assert(doneAddingSubcycles);
            forksdone = true;

        } else {  
            if (msg1) DB->msg("nbackdir_manual_unc::childdone size of child=%s", *child->size.image());

            
            
            if (flags.pluginid.kind() != pidtype::backupboost || uapp::staging().canRun()) {
                modify_child_de(child);
            }
            sizeofchildren += child->size;  
            ncollected++;

            
            
            
            
            
            
            if (doneAddingSubcycles) {
                forksdone = !processSubcycles();
            }
        }

        
        if(forksdone && reserve_hiddendir && !more_dirgroups && nforked == ncollected ) {
            if( msg1 )DB->msg("nbackdir_manual_unc::childdone preparing to spawn .system_info directory for %s", *info->direlemp->fullpath().image());
            hiddenoff = do_direlem( UNDOO_DIRECTORY_NAME, ATTR_DIRECTORY|ATTR_INTERNAL, KIND_UNIX, true, false, &hiddendirp );
            spawn_hiddendir(child);     
            reserve_hiddendir = false;  
        }

        
        
        
        
        if((forksdone || flush_listing) && nforked == ncollected) {
            if( msg1 ) DB->msg( "nbackdir_manual_unc::childdone: done forking (doneAddingSubcycles=%c nforked=%d, ncollected=%d): elements=%d", doneAddingSubcycles ? 'T' : 'F', nforked, ncollected, (int)elements->size());
            assert(elements != NULL || !uapp::staging().canRun());

            if (forksdone) {
                assert(doneAddingSubcycles);
                
                if( msg1 ) DB->msg( "nbackdir_manual_unc::childdone all children collected this=%p size:%s sizeofchildren:%s name:'%s'", this, *size.image(), *sizeofchildren.image(), *info->direlemp->fullpath().image() );
                collectdone = true;

                size = sizeofchildren;  
                info->direlemp->set_file_size(sizeofchildren);  

                if (info->use_container) {
                    
                    
                    std::sort(elements->begin(), elements->end(), DIRELEM::direlemp_list_type_container_cmp);
                }
            }

            if( msg1 ) DB->msg( "nbackdir_manual_unc::childdone - FLUSHING 'listing' for '%s'; forksdone=%d, flush_listing=%d: num_elements=%d", *info->path.image(), forksdone, flush_listing, (int)elements->size());
            do_flush_listing();
            drainindex = 0;
        }

        if (ShouldDoUcontainerPost(child)) {
            const bool include_self_in_ucontainer = (!info->direlemp->is_root() && info->direlemp->name()!="");

            if (include_self_in_ucontainer) do_stuff_ucontainer_post();
        }

    } else if (child == datachild) { 
        assert(!uapp::staging().canRun() || !more_dirgroups);

        
        if (msg1) DB->msg( "nbackdir_manual_unc::childdone - FLUSHING 'complete' for '%s'; forksdone=%d, flush_listing=%d: num_elements=%d", *info->path.image(), forksdone, flush_listing, (int)elements->size());
        if (entry_count > maxgroupentries)
            Out->msg(WARN, "<5079>Large number of entries (%d > %d) in directory \"%s\" -- Listing not perfectly sorted.",
                     entry_count, maxgroupentries, *info->path.image());

        this->notifyparent();
    }
    else {
        
        
        
        if (child != NULL) {
            DB->msg("nbackdir_manual_unc::childdone '%s' got UNEXPECTED childdone() call from %s", *BackCycle::image(), *child->image());
            assert(false);
        }

    }
}

void nbackdir_manual_unc::notifyparent() {
    if( msg1 ) DB->msg( ("nbackdir_manual_unc::notifyparent (this:%p) %s excluded:%d included:%d  (parent:%p)"),
                                this, *info->path.image(), cyexcluded, cyincluded, parent);
    if (cyincluded > 0) parent->cyincluded++; 

    
    
    BackCycle::notifyparent();
    
}

nbackdir_manual_unc::~nbackdir_manual_unc() {
    

    ustring path = info->path.image();   

    main->num_open_dirs--;

    
    if(hash != hashcode::zero && !info->direlemp->is_internal() && !top_level) main->getstatsobj(context::backupstats)->add_dircount(1);
    if( msg1 || msg2) DB->msg( "nbackdir_manual_unc::~nbackdir_manual_unc internal=%d, top_lev=%d (parent=%p) (this=%p) ""%s""", info->direlemp->is_internal(), top_level, parent, this, *path );
    if(! info->isapi) {
        if (msg1) DB->msg("nbackdir_manual_unc::~nbackdir_manual_unc deleting info %p", info);
        delete info;
    } else {
        if (msg1) DB->msg("nbackdir_manual_unc::~nbackdir_manual_unc NOT deleting info %p", info);
    }

    delete elements;
    elements = NULL;

}


bool nbackdir_manual_unc::modify_child_de(const cycle* child)
{
    assert(elements != NULL);
    assert(child != NULL);
    assert(child->offset >= 0);
    assert(child->offset.value() < (bigint64)elements->size());

    const int child_index = (int)child->offset.ivalue();
    

    assert((*elements)[child_index] != NULL);         
    DIRELEM &child_de = *((*elements)[child_index]);  
    if (msg1) DB->msg("nbackdir_manual_unc::modify_child_de info.name %s offset:%d child_de.path:%s", *info->path.image(), child_index, *child_de.fullpath().image());


    
    
    
    
    if( (child->hash == hashcode::zero && (child_de.is_directory()?true:child_de.get_location().getMedia() == location::media::gsan))
        || (child->cyexcluded && child->cyincluded==0) )
    {
        assert(false);
        child_de.set_internal(true);
    }

    if( main->isatombit() && child->cyisatomic )
        child_de.set_is_atomic();

    if(msg1)DB->msg( ("nbackdir_manual_unc::modify_child_de setslice hash:%s offset:%s"), *child->hash.partialimage(), *child->offset.image());
    child_de.set_hash(child->hash);
    child_de.set_file_size(child->size);
    child_de.set_computed_file_size(child_de.file_size());        






















    const fileoffset changesize = child->size - child_de.file_size();
    if (!child->cyisdirectory && changesize > fileoffset(0)) { 
        main->addfilebytes(context::backupstats, changesize.dvalue());
    }
    return true;
}


void nbackdir_manual_unc::do_stuff_ucontainer_pre() {
    assert(!info->container.isnull());

    if (msg1) DB->msg("nbackdir_manual_unc::do_stuff_ucontainer_pre <dirop> begindir '%s'", *info->direlemp->fullpath().image());

    
    if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d before begindir  '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());
    ucontainer::errortype errcode1(info->container->begindir(info->direlemp.getimpl()));
    if (errcode1 != ucontainer::pce__success) {
        Out->Abort("nbackdir::nbackdir Problem calling begindir for %s (%s)",
                 *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode1));
        return;
    } else {
        if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d after  begindir  '%s' loc:%s",
                         info->container->containerid, *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());
    }

    
    if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d before begindirc '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    ucontainer::errortype errcode2(info->container->begindircontent(info->direlemp.getimpl()));
    if (errcode2 != ucontainer::pce__success) {
        Out->Abort("nbackdir::nbackdir Problem calling begindircontent for %s (%s)",
                   *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode2));
        return;
    } else {
        if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d after  begindirc '%s' loc:%s",
                          info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    }
}



bool nbackdir_manual_unc::ShouldDoUcontainerPost(const cycle * child) const {

    bool usingCatalog(false);

    hfs_info_struct& hfsInfo = cycle::main->getAdeMgr()->getHfsInfo(dpn0);
    if (hfsInfo.metaStore != NULL) {
        usingCatalog = true;
    }

    if ((!info->use_container && !usingCatalog) || ddrDirClosed) {
        return false;
    }

    
    if (nbackdir_manual_unc_subcycles.size() > 0 && collectdone) {
        return true;
    }

    
    

    
    if (nbackdir_manual_unc_subcycles.size() == 0 && (nbackdir_subcycles.size() > 0 || nbackfile_subcycles.size() > 0 || backstream_subcycles.size() > 0) && collectdone) {
        return true;
    }

    
    
    if (child == NULL && nbackdir_manual_unc_subcycles.size() == 0 && nbackdir_subcycles.size() == 0 && nbackfile_subcycles.size() == 0 && backstream_subcycles.size() == 0) {
        return true;
    }

    return false;
}


void nbackdir_manual_unc::do_stuff_ucontainer_post() {
    assert(!info->container.isnull());
    assert(!ddrDirClosed);

    if (msg1) DB->msg("nbackdir_manual_unc::do_stuff_ucontainer_post <dirop> enddir '%s'", *info->direlemp->fullpath().image());

    
    if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d before enddir    '%s' loc:%s",
                      info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    ucontainer::errortype errcode(info->container->enddir(info->direlemp.getimpl()));
    if (errcode != ucontainer::pce__success) {
        Out->Abort("nbackdir_manual_unc::~nbackdir_manual_unc Problem calling enddir for %s (%s)",
                 *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
        return;
    } else {
        if (msg2) DB->msg("nbackdir_manual_unc ucontainer %d after  enddir    '%s' loc:%s",
                          info->container->containerid, *info->direlemp->fullpath().image(),*info->direlemp->get_location().image());
    }
    ddrDirClosed = true;
}


bool nbackdir_manual_unc::do_stuff() {

    if (msg1) {
        DB->msg("nbackdir_manual_unc::do_stuff() (this:%p) use_container:%d info->use_container:%d de.name:'%s' numelems=%d",
            this, use_container, info->use_container, *info->direlemp->name(), (int)elements->size());
        DB->msg("nbackdir_manual_unc::do_stuff() num_nbackmans:%d, num_nbackdirs:%d, num_nbackfiles:%d, num_backstream:%d",
            (int)nbackdir_manual_unc_subcycles.size(), (int)nbackdir_subcycles.size(), (int)nbackfile_subcycles.size(), (int)backstream_subcycles.size());
    }

    
    
    
    
    
    assert(doneAddingSubcycles || flags.parallel);

    if (info->use_container) assert(!info->container.isnull());

    if (info->use_container && info->container.isnull()) {
        
        
        
        
        
        Out->msg(FATAL, "During snapview where no ucontainer output is being created, attempt to process '%s' in ucontainer mode",
                 *info->direlemp->fullpath().image());
        childdone(NULL);
        return false;
    }

    
    const bool include_self_in_ucontainer = (!info->direlemp->is_root() && info->direlemp->name()!="");

    if (info->use_container && include_self_in_ucontainer) do_stuff_ucontainer_pre();

    bool somethingStarted = processSubcycles();

    
    
    
    if (!somethingStarted && doneAddingSubcycles) {
        
        childdone(NULL);
        
        if (nforked != ncollected) {
            somethingStarted = true;
        }
    }

    if (info->use_container && flags.parallel && include_self_in_ucontainer && !ddrDirClosed) {
        do_stuff_ucontainer_post();
    }

    if (msg1) DB->msg("nbackdir_manual_unc::do_stuff() DONE  info->use_container:%d '%s', somethingStarted:%d", info->use_container, *info->direlemp->fullpath().image(), somethingStarted);

    return somethingStarted;
}







inline bool nbackdir_manual_unc::exitProcessSubcycles(bool somethingOutstanding) {
    if (info->use_container && !flags.parallel && somethingOutstanding) {
        return true;
    }
    return false;

}













bool nbackdir_manual_unc::processSubcycles() {
    bool somethingStarted = false;

    if (msg1) {
        DB->msg("nbackdir_manual_unc::processSubcycles (this: %p) ENTER doneAddingSubcycles=%d, forksdone=%d, nforked=%d, ncollected=%d",
            this, doneAddingSubcycles, forksdone, nforked, ncollected);
        DB->msg("nbackdir_manual_unc::processSubcycles nbackmans:%d/%d, nbackdirs:%d/%d, nbackfiles:%d/%d",
            manual_index, static_cast<int>(nbackdir_manual_unc_subcycles.size()), nbackdir_index, static_cast<int>(nbackdir_subcycles.size()),
            nbackfile_index, static_cast<int>(nbackfile_subcycles.size()));
    }

    scope s(countersMutex);
    while ((manual_index < (int)nbackdir_manual_unc_subcycles.size()) && !exitProcessSubcycles(somethingStarted)) {
        nbackdir_manual_unc * nbm = *nbackdir_manual_unc_subcycles[manual_index].getptr();
        if (nbm != NULL) {
            if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Calling (%s %p)->do_stuff()", this, *nbm->getInfo()->direlemp->fullpath().image(), nbm);
            
            nforked++;
            if (!nbm->do_stuff()) {
                
                if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Call to (%s)->do_stuff() was completed without spawning children", this, *nbm->getInfo()->direlemp->fullpath().image());
            }
            else {
                if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Call to (%s)->do_stuff() required spawning children", this, *nbm->getInfo()->direlemp->fullpath().image());
                somethingStarted = true;
            }
        }
        manual_index++;
    }

    
    while ((nbackdir_index < (int)nbackdir_subcycles.size()) && !exitProcessSubcycles(somethingStarted)) {
        nbackdir * nb =*nbackdir_subcycles[nbackdir_index].getptr();
        if (nb != NULL) {
            
            if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Enqueing nbackdir('%s')", this, *nb->getInfo()->direlemp->fullpath().image());
            todoEnqueueInsert(TODO_DIR, nb, traverse_depth+1);
            nforked++;
            somethingStarted = true;
        }

        nbackdir_index++;
    }

    
    while ((nbackfile_index < (int)nbackfile_subcycles.size()) && !exitProcessSubcycles(somethingStarted)) {
        nbackfile * nbf = *nbackfile_subcycles[nbackfile_index].getptr();
        if (nbf != NULL) {
            
            if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Enqueing nbackfile('%s')", this, *nbf->getInfo()->direlemp->fullpath().image());
            todoEnqueueInsert(TODO_FILE_CACHE, nbf, traverse_depth+1);
            nforked++;
            somethingStarted = true;
        }

        nbackfile_index++;
    }

    
    while ((backstream_index < (int)backstream_subcycles.size()) && !exitProcessSubcycles(somethingStarted)) {
        backstream * bsc = *backstream_subcycles[backstream_index].getptr();
        if (bsc != NULL) {
            
            if (msg1) DB->msg("nbackdir_manual_unc::processSubcycles() (this: %p) Enqueuing backstream('%s')", this, *bsc->getInfo()->direlemp->fullpath().image());
            todoEnqueueInsert(TODO_DIR, bsc, traverse_depth+1);
            nforked++;
            somethingStarted = true;
        }

        backstream_index++;
    }

    return somethingStarted;
}

bool nbackdir_manual_unc::spawn_hiddendir(const cycle *child)
{
    
    DB->servlog("LOGSTATS", main->getstatsobj(context::backupstats)->xml(main->getAdeMgr()), main->get_errorsummary_xml());  
    

    fileoffset   incdumpsize;
    if((flags.streamformat_in == utar_flags_enums::streamformat_dump) &&
       flags.incremental && child != NULL) 
        incdumpsize = child->size;

    
    bool needToWriteDdrFiles = false;
    nbackroot * const nbr = dynamic_cast<nbackroot *>(parent);
    if(nbr != NULL) {
        const workelem *parentinfo(nbr->getInfo());

        
        if(parentinfo && parentinfo->use_container && !parentinfo->container.isnull()) {
            cycle::main->finalizeucontainer(parentinfo->container, false);
            nbr->set_ucontainer_finalized();

            needToWriteDdrFiles = true;

        }
    }
    else {
        
        assert(false);
    }

    if (msg1) DB->msg("nbackdir_manual_unc::childdone calling backhidden nforked:%d ncollected:%d", nforked, ncollected);
    workelem *w = new workelem(info, hiddendirp->fullpath(), hiddendirp, filestatsref());
    w->use_container = false;
    backhidden *hidden = new backhidden(this, w, hiddenoff, incdumpsize, false, needToWriteDdrFiles);
    hidden->noop();
    nforked++;
    return true;
}

bool nbackdir_manual_unc::do_flush_listing()
{
    








    
    if (datachild == NULL) {
        fileref x;
        workelem *w = new workelem(NULL, x);
        datachild   = new backdataconsumer(this, w, this, true  );  
        nforked++;  
    } else {
        
        todoEnqueue(TODO_CHUNK, datachild);
    }
    return true;
}











fileref nbackdir_manual_unc::nextdatablock(bool& suppress_requeue)
{
    assert(collectdone || flush_listing);

    fileref dirlisting;
    suppress_requeue = false;

    if (elements == NULL) return dirlisting;    

    if (msg3) DB->msg(("nbackdir_manual_unc::nextdatablock(\"%s\"), elements=%d, group=%d, drainindex=%d, more_dirgroups=%d"),
                       *info->path.image(), (int)elements->size(), group_count, drainindex, more_dirgroups);

    assert(drainindex >= 0 && drainindex <= (int)elements->size());

    if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock %s: nextdatablock: drainindex=%d, elements=%d", *info->path.image(), drainindex, (int)elements->size());
    
    if (drainindex >= (int)elements->size()) {
        if (flush_listing || more_dirgroups) {
            if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock: Done with this group");

        
            elements->clear();                  
            fillindex=0;
            sendindex=maxsendentries;

            
            todoEnqueueInsert(TODO_DIR, this, -(traverse_depth+1));     

            suppress_requeue = true;            
            dirlisting.initlist(1);             
            return dirlisting;
        }

        if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock: All done!");
        return dirlisting;                      
    }

    
    
    
    
    dirlisting.initlist(DEFAULTDIRSIZE * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    
    for (int tmpindex=drainindex; tmpindex < (int)elements->size(); tmpindex++) {
        if ((*elements)[tmpindex] != NULL) {
            DIRELEM &dir = *((*elements)[tmpindex]);

            
            
            
                
                
                if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock laying out tmp element %d '%s'", tmpindex, *dir.name());
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[tmpindex] = NULL;     
                entry_count++;
                
            

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            tmpindex++;               
            break;
        }
    }

    for (; drainindex < (int)elements->size(); drainindex++) {
        if ((*elements)[drainindex] != NULL) {
            DIRELEM &dir = *((*elements)[drainindex]);

            
            DB->msg("nbackdir_manual_unc::nextdatablock: ELEMENT %d '%s' WAS NOT EMPTY!!!", drainindex, *dir.name());

            if(dir.is_directory()) {
                
                
                DB->msg("nbackdir_manual_unc::nextdatablock laying out drain element %d '%s'", drainindex, *dir.name());
                main->layout_direlem(dir, dirlisting, true, main->isnewdir(), flags.inode);
                (*elements)[drainindex] = NULL;     
                entry_count++;
                
            }

        }

        
        if (dirlisting.size() > MAXLISTINGBYTES) {
            if (msg3) DB->msg("nbackdir_manual_unc::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            drainindex++;               
            break;
        }
    }

    if (msg3 || msg2) DB->msg("nbackdir_manual_unc::nextdatablock returning %s (drainindex=%d)", *dirlisting.desc(), drainindex);

    return dirlisting;
}


void nbackdir_manual_unc::cancelled() {
}









fileoffset nbackdir_manual_unc::add_element(DIRELEMp de)
{
     scope s(elements_mut);
     const fileoffset index = elements->size();
     elements->push_back(de);
     return index;
}



fileoffset nbackdir_manual_unc::add_direlem(DIRELEMp de, bool haschild)
{
    if (msg1) DB->msg("nbackdir_manual_unc::add_direlem '%s' to '%s' use_container:%d haschild:%d loc:%s ", *de->name(), *info->direlemp->name(), use_container, haschild, *de->get_location().image());

    const fileoffset patchoffset = add_element(de);
    if(de->get_location().get_format() >= location::tformat::cdsf) 
        use_container=true;
    if(haschild) {
        
    }
    else {
        sizeofchildren += de->file_size();
        main->byteprogress(context::backupstats, stats::ispresent, de->file_size().dvalue());
    }
    return patchoffset;
}


void nbackdir_manual_unc::setnext(todo_kind kind, cycle *next, const bigint64 priority) {
    
    
}






void nbackdir_manual_unc::add_subcycle(BackCycle* subcycle, bool alreadyEnqueued) {
    if(subcycle == NULL) return;

    if (msg1) DB->msg("nbackdir_manual_unc(%p, %s)::add_subcycle() '%s' for '%s', alreadyEnqueued=%d", this, *getInfo()->direlemp->fullpath().image(),
            typeid(*subcycle).name(), *subcycle->getInfo()->direlemp->fullpath().image(), alreadyEnqueued);

    if (!alreadyEnqueued) {
        if (typeid(*subcycle) == typeid(nbackdir)) {
            nbackdir_subcycles.push_back(dynamic_cast<nbackdir *>(subcycle));
            
        }
        else if (typeid(*subcycle) == typeid(nbackdir_manual_unc)) {
            nbackdir_manual_unc_subcycles.push_back(dynamic_cast<nbackdir_manual_unc *>(subcycle));
            
        }
        else if (typeid(*subcycle) == typeid(nbackfile)) {
            nbackfile_subcycles.push_back(dynamic_cast<nbackfile *>(subcycle));
            
        }
        else if (typeid(*subcycle) == typeid(backstream)) {
            backstream_subcycles.push_back(dynamic_cast<backstream *>(subcycle));
            
        }
        else {
            assert(false);
        }
    }
    else {
        
        nforked++;
    }
}

void nbackdir_manual_unc::do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also )
{
  assert(false);
}








fileoffset nbackdir_manual_unc::do_direlem( const ustring& name, unsigned char attributes, unsigned char kind, bool dont_stat_file, bool follow_symlink, DIRELEMp *direlemp ) 
{
    if( msg1 || msg2) DB->msg("nbackdir_manual_unc::do_direlem(\"%s\", attributes=%d, kind=%d, dont_stat=%d, follow=%d, direlemp=%p)", *name, attributes, kind, dont_stat_file, follow_symlink, direlemp);

    DIRELEMp de;
    

    if( dont_stat_file ) {
        de = new DIRELEM;
        de->zero();
        epoch_t now((epoch_t)timer::now());
        de->initialize( hashcode::zero, now, now, now, fileoffset(0), attributes, name);
        de->set_fullpath(upath(name));
        if(kind == KIND_UNIX)
            de->set_unix_attributes(0666, 0, 0);
        else if(kind == KIND_UNIX_SP)
            de->set_unix_special(0, 0, 0, 1);
    } else {
        
        de = new DIRELEM( (upath)name, false, follow_symlink );
    }

    if( flags.mapi )
        de->set_is_mapi();

    if( flags.from_stdin ) {
        de->set_stdin();
        if (flags.streamformat_in==utar_flags_enums::streamformat_none) de->set_file_size(0);       
    }

    const fileoffset patchoffset = add_element(de);

    
    if(flags.xmlunentitifydpnpaths) {
        
        const ustring name(de->name());
        const ustring unentitified_name(xml_message::convert_xmlstring(name));
        if(name != unentitified_name) {
            DB->msg(("unentitified name '%s' to '%s'"), *name, *unentitified_name);
        }
        de->set_name(unentitified_name);
    }

    if (direlemp != NULL) *direlemp = de;       

    return patchoffset;
}


















#include "common.h"
#include "debug.h"
#include "utar_commands.h"
#include "filenames.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "datetime.h"
#include "acntmngr.h"
#include "output.h"
#include "univ.h"
#include "timer.h"
#include "msgpack_c.h"
#include "compelem.h"
#include "fileoffset.h"
#include "userid.h"
#include "xml_message.h"
#include "build.h"
#include "ade_mgrx.h"
#include "sessionprofile.h"
#include "runstage.h"
#include "filename_cache.h"
#include "hash_cache.h"
#include "replicate.h"
#include "filerefx.h"
#include "ddr_interface.h"
#include "mctypes.h"
#include "arglist.h"
#include "avspawn.h"
#include "browse_filesystem.h"
#include "list_archive.h"
#include "dumpstreamutils.h"
#include "restroot.h"
#include "ndmp_volume_entification.h" 
#include "cdsf_container.h"
#include "restmain.h"
#include "BackupRootInfo.h"
#include "macosx_utils.h"
using namespace backupboost;

#include "MetadataStore.h"
#include "filemap.h"

#if SYSTEM_UNIX_LINUX
    #include "xmldoc.h"
#endif
#if SYSTEM_WINDOWS
    #include "mapix.h"
    #include "mapiwalk.h"
    #include "mapistream.h"
    #include "mapibase.h"
    #include "winpriv.h"
    #include "volumeinfo.h"
#endif
#include "file_system_info.h"
#include "platerror.h"
#include "backstate.h"

#include <strstream>
#if SYSTEM_WINDOWS
   #include "ntsecurity.h"
   #include "ntrestore_at_reboot.h"
   #include "windedup.h"
#endif

#include "exclude.h"
#include "restdirpart.h"        

#include <ctype.h>
#include "dpnobject.h"
#include "netsys.h"
#include "uwrapper.h"
#include "ui18n.h"
#include "ndmp_volume_entification.h"
#include "direlem_iter.h"
#include <algorithm>
#include <stdexcept>

#if !SYSTEM_WINDOWS
#include "processlock.h"
#endif

#include "backupboost_interface.h"
using namespace backupboost;

#define restmsg             ((xflag[2]&32)!=0)
#define backstreamdir_msg1  ((xflag[2]&2048)!=0)
#define backstreamdir_msg2  ((xflag[2]&4096)!=0)
#define cdsf_msg            ((xflag[2]&1)!=0) 

#define trynewparsing       ((xflag[22]&256)==0)


#define restmultistream     ((xflag[30]&1024)!=0)

using briutils::get_toplevel_de;
typedef context::prep_for_sysinfo prep_for_sysinfo;
path2direlemp_table utar_commands::netapp_direlemp_cache;
bool utar_commands::netapp_browse;

mtex utar_commands::sysinfo_file_mutex;

fileref utar_commands::migrateinfo_fr;
fileref utar_commands::workresults_fr;

int utar_commands::sysinfo_off;
double utar_commands::sysinfo_chunksize;

utar_commands::utar_commands(utar_flags_info& flags_, hfs_info_struct& hfs_info_,
                             utar_flags_info& dstflags_)
  : flags(flags_), hfs_info(hfs_info_), dstflags(dstflags_), outputxml(false), dirRestRoot(NULL)
{
    uids = userid::instance();
    gids = groupid::instance();
    curentries = 0;
    m_adeMgr = NULL;
}

utar_commands::utar_commands(utar_flags_info& flags_, hfs_info_struct& hfs_info_,
                             utar_flags_info& dstflags_,
                             ctl_messagep requestp_, ctl_queuep responseq_)
  : flags(flags_), hfs_info(hfs_info_), dstflags(dstflags_),
    requestp(requestp_), responseq(responseq_),
    outputxml(false), dirRestRoot(NULL)
{
    uids = userid::instance();
    gids = groupid::instance();
    curentries = 0;
    m_adeMgr = NULL;
}



bool utar_commands::gethashdata(fileref& data, const hashcode& hash_,
                                chunktype& kind, const hfs_info_struct &hfs_info, ustring& errdesc
) {
    hashcode hash(hash_);

    message m;
    msgpack_c::gethashdata ghd(m);

    
    
    bool fromcache = hfs_info.main->restorecache_lookup(hash, m) && m.requestcode()==GET_HASH_DATA;
    if(!fromcache) {
        
        int userid = 0;  
        time_t prefetchtime = 0;  
        ghd.arg(PACK, hash, userid, prefetchtime);

        m = hfs_info.sync->call(m, 0);

        if(!m.isgoodresponse()) {
            DB->msg("utar_commands::gethashdata bad response %s",  *m.found_image());
            errdesc = m.found_image();
            return false;
        }
    }

    int cachelevel;  
    ghd.res(UNPACK, kind, data, cachelevel);

    if(!fromcache) hfs_info.main->restorecache_enter(hash, m);

    return true;
}


bool utar_commands::list_hash_entries(const location& fromLoc, std::vector<ustring> &entries,
                                      ustring& errdesc) const
{
    try {
        direlem_iter entryiter(fromLoc, &hfs_info);
        
        
        if (entryiter == direlem_iter()) {
            errdesc = ustring::sprintf("No entries found for location %s", *fromLoc.image());
            return false;
        }
        
        
        while (entryiter != direlem_iter()) {
            entries.push_back(entryiter->name());
            ++entryiter;
        }
        return true;
    } catch (const std::runtime_error& e) {
        errdesc = ustring::sprintf("Exception looking up entries for location %s : %s", *fromLoc.image(), e.what());
    }
    return false;
}

namespace {
    upath get_corrected_path(const upath& searchpath, bool add_rootdirelem_if_necessary) {

        
        
        upath correctedpath(searchpath);

        
        
        
        
        
        if(searchpath.numelems() == 1 && !searchpath.has_begin_dirsep() && !searchpath.has_end_dirsep())
        {
            const ustring xpath(searchpath.image());
            if(xpath.first() == '@' && xpath.last() == '@') {
                const ustring ypath(xml_message::fromathexat(xpath));
                if(!ypath.equal(xpath)) {
                    correctedpath = upath(ypath, searchpath.kind());
                    DB->msg("get_corrected_path: path converted to '%s'", *correctedpath.image());
                }
            }
        }

        
        
        
        if(add_rootdirelem_if_necessary && searchpath.has_begin_dirsep())
            correctedpath = upath(searchpath.image(), searchpath.kind(), true);

        return correctedpath;
    }

    
    struct de_name_compare {
        de_name_compare(const ustring& lookfor, bool ignorecase=false) : lookfor(lookfor), ignorecase(ignorecase) {}
        bool operator()(const DIRELEM& de) const {
            return (ignorecase || de.ignorecase()) ? de.name() == lookfor : de.name().equal(lookfor);
        }
    private:
        ustring lookfor;
        bool ignorecase;
    };
}




bool utar_commands::get_direlem(const location& search_start_loc, const upath& lookfor, DIRELEM& searchresult, ustring& errdesc,
                                 const upath& assign_fullpath, const bool ignorecase,
                                 const bool force_gsan_metaloc) const
{
    
    
    return get_direlem(hfs_info, flags, search_start_loc, lookfor, searchresult, errdesc, assign_fullpath, ignorecase, force_gsan_metaloc);

}






















bool utar_commands::get_direlem(const hfs_info_struct& hfs_info, const utar_flags_info& flags,
                                 const location& search_start_loc, const upath& lookfor, DIRELEM& searchresult, ustring& errdesc,
                                 const upath& assign_fullpath, const bool ignorecase,
                                 const bool force_gsan_metaloc)
{
    
    

    if(lookfor.isempty()) {
        errdesc = "Empty search path";
        return false;
    }

    if(search_start_loc.isFromGsan() && (xflag[10]&65536))
        return lookup_gsan_path(search_start_loc.getHash(), lookfor, searchresult, errdesc, assign_fullpath, hfs_info);

    
    

    
    
    
    
    
    
    
    
    
    baselocation metaloc(search_start_loc);
    if (force_gsan_metaloc) {
        metaloc.setMedia(baselocation::media::gsan);
    }
    searchresult.set_metadataLocation(metaloc);

    searchresult.set_is_directory();
    if(search_start_loc.isFromGsan()) {
        const hashcode search_start_hash(search_start_loc.getHash()),
                       dehash(searchresult.file_hash());
        if(search_start_hash == hashcode::empty ||
           (search_start_hash == hashcode::zero && (dehash == hashcode::zero || dehash == hashcode::empty)))
        { 
            errdesc = ustring::sprintf("Invalid or empty directory hash: %s", search_start_hash.partialimage().tostr());
            return false;
        }
        if(dehash != hashcode::zero &&
           search_start_hash != hashcode::zero &&
           dehash != search_start_hash) 
            DB->msg("utar_commands::get_direlem mismatching metadata hashes: metaloc=%s, de.file_hash=%s",
                    search_start_hash.partialimage().tostr(), dehash.partialimage().tostr());
    }

    upath found_fullpath;

    try {
        
        
        
        
        
        const bool skip_set_location(force_gsan_metaloc && is_netapp_browse());
        const DIRELEM::iterator found(get_direlem(DIRELEM::iterator(searchresult, &hfs_info, skip_set_location),
                                                  lookfor, found_fullpath, errdesc, flags, ignorecase));
        if(found == DIRELEM::iterator()) 
            return false;
        searchresult = *found;
    }catch(const std::runtime_error& e) {
        errdesc = ustring::sprintf("Exception looking up '%s': %s", lookfor.image().tostr(), e.what());
        return false;
    }

    if(!assign_fullpath.isempty())
        searchresult.set_fullpath(searchresult.calculate_file_path(assign_fullpath, false));
    else if((xflag[10]&1048576) == 0)
        searchresult.set_fullpath(found_fullpath);

    return true;
}

DIRELEM::iterator utar_commands::get_direlem(DIRELEM::iterator iter, const upath& lookfor, upath& found_fullpath,
                                              ustring& errdesc, bool ignorecase) const
{
    return get_direlem(iter, lookfor, found_fullpath, errdesc, flags, ignorecase);
}










DIRELEM::iterator utar_commands::get_direlem(DIRELEM::iterator searchiter, const upath& lookfor, upath& found_fullpath,
                                              ustring& errdesc, const utar_flags_info& flags, const bool ignorecase, const DIRELEM& parentDE)

{

    
    
    

    const DIRELEM::iterator end;
    const bool ignore_case(!flags.case_sensitive || ignorecase);

    if (restmsg) DB->msg("parentde (%s) Loc: %s", *parentDE.fullpath().image(), *parentDE.get_location().image(true));

    
    
    upath correctedpath(get_corrected_path(lookfor, false));

    
    found_fullpath = upath();

    DIRELEM::iterator founditer;
    if (correctedpath.has_begin_dirsep()) {
        found_fullpath.set_begin_dirsep();

        founditer = std::find_if(searchiter, end, de_name_compare(DIRELEM_ROOT, ignore_case));
        if(founditer == end) {
            return end;
        }

        
        searchiter = DIRELEM::iterator(*founditer, founditer);

        
        
        correctedpath = correctedpath.to_relative();
        correctedpath.set_begin_dirsep(false);
    }

    const int last_index(correctedpath.numelems()-1);
    for(int i(0); i<=last_index; ++i) {

        ustring pathpiece(correctedpath.get(i));
        assert(!pathpiece.isempty());
        if(pathpiece.isempty()) {
            errdesc = ustring::sprintf("Internal error: unable to parse search path '%s'", lookfor.image().tostr());
            return end;
        }

        
        if(flags.xmlunentitifydpnpaths) {
            
            const ustring unentitified_name(xml_message::convert_xmlstring(pathpiece));
            if(pathpiece != unentitified_name) {
                DB->msg("utar_commands::get_direlem unentitified name '%s' to '%s'", *pathpiece, *unentitified_name);
                pathpiece = unentitified_name;
            }
        }

        const bool ignore_case(!flags.case_sensitive || ignorecase);
        founditer = std::find_if(searchiter, end, de_name_compare(pathpiece, ignore_case));
        if(founditer == end) {
            if(i == 0) {
                
                
                
                
                
                
                
                
                for(int j=1; j<=std::min(2, last_index); ++j) {
                    ustring newpathpiece(correctedpath.get(0));
                    for(int k=1; k<=j; ++k)
                        newpathpiece = newpathpiece / correctedpath.get(k);
                    founditer = std::find_if(searchiter, end, de_name_compare(newpathpiece, ignore_case));
                    if(founditer != end) {
                        pathpiece = newpathpiece;
                        i += j; 
                        goto foundpiece;
                    }
                }
            }
            if(errdesc.isempty())
                errdesc = ustring::sprintf("Element '%s' at position %d in search path '%s' not found", *pathpiece, i, lookfor.image().tostr());
            return end;
        }

        if (restmsg) DB->msg("founditer (%s), loc:%s", *founditer->fullpath().image(), *founditer->get_location().image());
        {
            upath::elemcat pathpiece_type(upath::elem_entry);

            
            if(founditer->is_unc_root())
                pathpiece_type = upath::elem_unc_server;
            else if(found_fullpath.numelems() == 1 && found_fullpath.get_start(upath::elem_unc_server) == 0)
                pathpiece_type = upath::elem_unc_share;
            
            
            else if(founditer->is_guid_volume()) {
                pathpiece_type = upath::elem_volume;
#if SYSTEM_WINDOWS
                if(found_fullpath.isempty())
                    found_fullpath = upath(WINPATH_PREFIX);
#endif
            
            
            }else if(founditer->is_globalroot_volume()) {
                pathpiece_type = upath::elem_globalroot_part;
#if SYSTEM_WINDOWS
                if(found_fullpath.isempty())
                    found_fullpath = upath(WINPATH_PREFIX);
#endif
            }

            found_fullpath.push_back(pathpiece, pathpiece_type);
        }
foundpiece:

        if(i == last_index) 
            break;

        
        
        if((i == last_index - 1) && last_index == 3 && is_netapp_browse()) {
            const upath dir_path(correctedpath.slice(0, 2));
            DIRELEMp dir_dep = new DIRELEM(*founditer);

            DB->msg("utar_commands::get_direlem-iter: Adding cache entry for path:'%s'", *dir_path.image());
            netapp_direlemp_cache.add_table_entry(dir_path, dir_dep);
        }

        if(!founditer->is_directory()) {
            errdesc = ustring::sprintf("Element '%s' at position %d in search path '%s' is not a directory", pathpiece.tostr(), i, lookfor.image().tostr());
            return end;
        }

        
        
        searchiter = DIRELEM::iterator(*founditer, founditer);
        if (restmsg) DB->msg("searchiter(%s) Loc: %s", *searchiter->fullpath().image(), *searchiter->get_location().image(true));
    }

    return founditer;
}

bool utar_commands::lookup_gsan_path(hashcode search_start_hash, const upath& lookfor, DIRELEM& searchresult,
                                     ustring& errdesc, const upath& assign_fullpath, const hfs_info_struct& hfs_info)
{
    
    
    assert(hfs_info.main->handling_system_info() || !hfs_info.main->get_location_info_required());

    const upath correctedpath(get_corrected_path(lookfor, true));

    
    
    message m( LOOKUP_PATH );
    msgpack_c::lookup_path lp(m);
    ustring filename(correctedpath.image());
    lp.arg(PACK, filename, search_start_hash);

    
    m = hfs_info.sync->call(m, 0);
    if(m.responsecode() != MSG_ERR_NONE || m.data().isnull()) {
        DB->msg("utar_commands::lookup_gsan_path error on LOOKUP_PATH (%s)", *m.found_image());
        errdesc = m.found_image();
        return false;
    }
    fileref data;
    lp.res(UNPACK, data);

    int off=0;
    if(!searchresult.populate(data, off, assign_fullpath)) {
        
        errdesc = "DIRELEM::populate failed";
        return false;
    }
    return true;
}





bool utar_commands::get_file(const BackupRootInfo& backupInfo, fileref& data, const upath& path) const
{
    DB->msg("utar_commands::get_file: %s %s", *backupInfo.image(), *path.image());
    DIRELEM de(get_toplevel_de(backupInfo, hfs_info));
    ustring errdesc;
    if (!get_direlem(backupInfo.getRootLocation(), path, de, errdesc)) {
        DB->msg("utar_commands::get_file failed to get '%s': %s", path.image().tostr(), errdesc.tostr());
        return false;
    }
    const bool resultOK = restore_file(data, &de);

    return( resultOK && !data.isnull() ); 
}


bool utar_commands::get_sysinfo_file(const BackupRootInfo& backupInfo, fileref& data, const upath& path) const
{
    scope s(sysinfo_file_mutex);
    DB->msg("utar_commands::get_sysinfo_file: %s %s", *backupInfo.image(), *path.image());
    DIRELEM de(get_toplevel_de(backupInfo, hfs_info));
    ustring errdesc;
    if (!get_direlem(backupInfo.getRootLocation(), path, de, errdesc)) {
        DB->msg("utar_commands::get_file failed to get '%s': %s", path.image().tostr(), errdesc.tostr());
        return false;
    }
    chunktype ctype;
    const bool resultOK = hfs_info.main->restore_gsanonly_file(data, de.file_hash(), &ctype);
    return( resultOK && !data.isnull() );
}



bool utar_commands::get_hbeprofilepath(const BackupRootInfo& backupInfo, ustring& profile_path) const
{
    bool res = false;

    
    const ustring hbeprofilepath = ustring(UNDOO_DIRECTORY_NAME) + ustring("/") + ustring(HBE_PROFILE_PATH_FILENAME);

    fileref data;
    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    res = get_file(backupInfo, data, upath(hbeprofilepath));

    data.getdata(profile_path);
    return res;
}




bool utar_commands::get_view_override(client_config_flags::view_type vt, const BackupRootInfo& backupInfo, fileref& data) const
{
    bool res(false), view_specified(true);
    ustring base_filename;
    switch(vt) {
    case client_config_flags::view_plugin:   base_filename = VIEW_PLUGIN_FILENAME; break;
    case client_config_flags::view_redirect: base_filename = VIEW_REDIRECT_FILENAME; break;
    case client_config_flags::view_filelist: base_filename = VIEW_DTO_FILELIST_FILENAME; break;
    case client_config_flags::view_raw: return false; 
    default: view_specified = false; break;
    }

    const ustring udir(UNDOO_DIRECTORY_NAME);
    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    if(view_specified) {
        res = get_file(backupInfo, data, upath(udir/base_filename));
    }else if(flags.pluginnum != 0) { 
        res = get_file(backupInfo, data, upath(udir/VIEW_PLUGIN_FILENAME));
    }
    
    if(!res)
        res = get_file(backupInfo, data, upath(udir/BROWSE_OVERRIDE_FILENAME));
    return res;
}







bool utar_commands::get_infofile(const BackupRootInfo& backupInfo)
{
    static bool reported_already = false;

    infofile.reset();
    const ustring info = get_sysinfo_path("utar_commands::get_infofile", backupInfo, true) / ARCHIVE_INFO_FILENAME;

   if (!flags.hfsaddr.isempty() || !flags.catalog_address.isempty()) {
        fileref data;
        const prep_for_sysinfo context_is_prepped(*hfs_info.main);
        bool res = get_file(backupInfo, data, upath(info));
        if(!res) return false;

        infofile.parsefileref(data);
    }
    else {
        return false;
    }


    bool celerrai18n = infofile.celerrai18n;

    if (flags.isexplicit("celerrai18n"))
    {
        if (!reported_already)
        {
            Out->msg(INFO,"Using explicitly set value from flag --celerrai18n = %s",(flags.celerrai18n) ? "true" : "false");
            Out->msg(INFO,"--celerrai18n value stored in %s is %s",*info, (celerrai18n) ? "true" : "false");
            reported_already = true;
        }
    }
    else
    {
        flags.celerrai18n = celerrai18n;
    }

    return true;
}

bool utar_commands::get_infofile_obj(const DIRELEM& de, infofile_info& infofile) const
{
    fileref data;
    const bool result = restore_file(data, &de);
    if (result && !data.isnull()) {
        infofile.parsefileref(data);
        return true;
    }
    return false;
}

bool utar_commands::get_work_results(const BackupRootInfo& backupInfo, target_work_results& work_results)
{
    fileref work_results_fref;
    const ustring work_results_path = get_sysinfo_path("utar_commands::get_work_results", backupInfo, false) / WORKRESULTS_FILENAME;
    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    bool res = get_sysinfo_file(backupInfo, work_results_fref, upath(work_results_path));
    if (!res) return false;
    ustring work_results_data;
    work_results_fref.getdata(work_results_data);
    work_results.parse(work_results_data);
    return true;
}

const fileref utar_commands::get_encodingsfile(const BackupRootInfo& backupInfo) const
{
    
    const ustring info = ustring(UNDOO_DIRECTORY_NAME) + ustring("/") + ustring(ENCODINGS_FILENAME);

    fileref data;
    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    (void)get_file(backupInfo, data, upath(info));

    return data;
}

const bool utar_commands::get_ddrfiles_xml(const BackupRootInfo& backupInfo, const ustring& filename, fileref& data) const
{
    const ustring info = get_sysinfo_path("utar_commands::get_ddrfiles_xml", backupInfo, false) / filename;

    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    const bool resultOK = get_file(backupInfo, data, upath(info));
    return resultOK;
}

const ustring utar_commands::get_backuptag(const BackupRootInfo& backupInfo) const {
    
    
    
    if ((xflag[21]&4096)==0 && backupInfo.get_taghash() == 0) return "";

    
    
    
    
    fileref fdata;
    const upath tagpath(UNDOO_DIRECTORY_NAME "/" BACKUPTAG_FILENAME);
    DIRELEM de(get_toplevel_de(backupInfo, hfs_info));
    ustring errdesc;
    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    bool res = get_direlem(backupInfo.getRootLocation(), tagpath, de, errdesc);
    if (res) {
        ustring tag;
        res = de.get_backuptag(tag);
        DB->msg("--------------------found res:%d tag:%s", res, *tag);
        if(res) return tag;

    } else {
        DB->msg("utar_commands::get_backuptag have to get file %s", *tagpath.image());
        res = get_file(backupInfo, fdata, tagpath);
    }

    if(!res) return "";
    return ustring(fdata);
}

bool utar_commands::read_id_list(const ustring& filename, associd *list, const BackupRootInfo& backupInfo) const {
    fileref fdata;
    list->clear();                      

    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    bool res = get_file(backupInfo, fdata, upath(filename));

    if(!res) return false;

    return list->from_file(fdata);      
}

bool utar_commands::get_inode_table(const BackupRootInfo& backupInfo)
{
    fileref fdata;
    const ustring filename = get_sysinfo_path("utar_commands::get_inode_table", backupInfo, true) / ustring(INODE2HASH_TABLE_FILENAME);
    ustring inode_save_filename = ustring::sprintf("getinode2hashtable_%d_", getpid()) + flags.ndmp_prefix;
#ifdef NAME_MAX
    if (inode_save_filename.bytelength() > NAME_MAX)
        inode_save_filename = inode_save_filename.substr(0, NAME_MAX);
#endif
    const ustring inode_save_path = flags.vardir / inode_save_filename;
    fdata.initdisk(inode_save_path, 0, filemap::write, false, true, true);
    
    
    
    
    
    
    
    if ((flags.streamformat_out == utar_flags_enums::streamformat_cdsf) ||
        (flags.streamformat_in == utar_flags_enums::streamformat_cdsf)  ||
        (flags.pluginid.kind() == pidtype::backupboost)                 ||
        (flags.ddrenabled)) {
        DB->msg("utar_commands::get_inode_table Setting inodetab.use_inode_tree = true");
        hfs_info.main->inodetab.use_inode_tree = true;
    } else {
        DB->msg("utar_commands::get_inode_table Setting inodetab.use_inode_tree = false");
        hfs_info.main->inodetab.use_inode_tree = false;
    }

    hfs_info.main->inodetab.is_zfs_backup = (flags.streamformat_out == utar_flags_enums::streamformat_zfs);

    
    
    if (flags.ddrenabled) {
        
        
        

        DIRELEM de(get_toplevel_de(backupInfo, hfs_info));
        ustring errdesc;
        upath vol_path = upath(flags.ndmp_prefix);
        DB->msg("utar_commands::get_inode_table looking up volume:%s", *flags.ndmp_prefix);
        if (!get_direlem(backupInfo.getRootLocation(), vol_path, de, errdesc)) {
            
            DB->msg("utar_commands::get_inode_table Failed to find volume %s in previos (base) backup", *flags.ndmp_prefix);
            assert (false);
        } else {
            hfs_info.main->inodetab.volume_offset = (ubigint64)de.get_location().get_abs_offset_in_container().value();
            DB->msg("utar_commands::get_inode_table Saved offset (%"LL"d) for volume:%s",
                    hfs_info.main->inodetab.volume_offset, *flags.ndmp_prefix);
        }
    }

    DB->msg("utar_commands::get_inode_table using %s", *filename);

    const prep_for_sysinfo context_is_prepped(*hfs_info.main);
    bool res = get_file(backupInfo, fdata, upath(filename));

    if (!res) {
        DB->msg("utar_commands::get_inode_table could not get file '%s', returning false", *filename);
        return false;
    }

    res = hfs_info.main->inodetab.parse(fdata);
    if (!res)
    {
        DB->msg("utar_commands::get_inode_table got %d bytes of data, but could not parse", fdata.size());
    }
    else
    {
        DB->msg("utar_commands::get_inode_table parsed table successfully");
        if (backstreamdir_msg2)
        {
            hfs_info.main->inodetab.debug_dump();
        }
    }

    return res;
}

bool utar_commands::backuptag_match(const ustring& backuptag, const char taghash, const BackupRootInfo &backupInfo) const {


    
    
    
    if ((xflag[21]&4096)==0 && taghash != backupInfo.get_taghash()) return false;

    const ustring snapup_backuptag = get_backuptag(backupInfo);
    DB->msg("backuptag_match comparing, '%s' with '%s'", *backuptag, *snapup_backuptag);

    
    return backuptag.equal(snapup_backuptag);
}

bool utar_commands::get_ids(const BackupRootInfo& backupInfo) const {

    const ustring dir(UNDOO_DIRECTORY_NAME);
    
    const ustring uids_name = dir + ustring("/") + ustring(USERS_ID_FILENAME);
    const ustring gids_name = dir + ustring("/") + ustring(GROUP_ID_FILENAME);

    return read_id_list(uids_name, uids, backupInfo) &&
           read_id_list(gids_name, gids, backupInfo);
}

     






bool utar_commands::get_backuplist(BackupRootInfoList &lst, bool include_partials, const int flags_count, const bool metadata_only) const
{
    DB->msg("utar_commands::get_backuplist");

    ustring select_info;
    prectime after_time = 0;
    datetime aftertime;

    if ((!flags.restore_after.isnull()) || (0 !=flags.restore_within_days)) {
        if(!flags.restore_after.isnull()){
            if (!aftertime.utarformat(*flags.restore_after)) {
                
                Out->msg(ERR, "<7699>Invalid date/time: --after=\"%s\"", *flags.restore_after);
                return false;
            }
        }
        if(0 !=flags.restore_within_days){
            if(flags.restore_within_days < 0){
                Out->msg(ERR, "Days cannot be negative: --within=%d", flags.restore_within_days);
                return false;
            }
            const datetime currenttime; 
            datetime aftertimetmp;
            const avduration withintime(HR_PER_DAY*flags.restore_within_days,0,0); 
            if(currenttime.tobtime() < withintime.toticks()){
                Out->msg(ERR, "Days is too big: --within=%d", flags.restore_within_days);
                return false;              
            }
            aftertimetmp = currenttime - withintime;
            if(aftertimetmp < aftertime) 
                aftertime = aftertimetmp;
        }
        select_info += ustring::sprintf("after \"%s\"", *aftertime.imageTZ());
        after_time = aftertime.tobtime();
    } 

    prectime before_time = 0;
    datetime beforetime;
    if (!flags.restore_before.isnull()) {
        if (!beforetime.utarformat(*flags.restore_before)) {
            
            Out->msg(ERR, "<7700>Invalid date/time: --before=\"%s\"", *flags.restore_before);
            return false;
        }
        if (!select_info.isempty()) select_info += DBTXT(" and ");
        select_info += ustring::sprintf("before \"%s\"", *beforetime.imageTZ());
        before_time = beforetime.tobtime();
    } 

    
    if (flags.snapuptime) {
        DB->msg("Selecting backup based on --snapuptime=%"LL"d", flags.snapuptime);
        after_time = flags.snapuptime;
        before_time = flags.snapuptime;
    }

    
    pluginidlist rpluginidlist;
    if (!flags.parse_pluginid_flags(rpluginidlist))
        return false;

    ustring count_info;
    if (flags_count > 0) count_info = ustring::sprintf("%d ", flags_count);

    if(!count_info.isempty() || !select_info.isempty()) {
        
        if (after_time != 0 && before_time != 0)
            Out->msg(INFO, "<7701>Selecting %sbackups after \"%"AVDATE"s %s\" before \"%"AVDATE"s %s\"", *count_info,
                *aftertime.image(), *datetime::TzDst.av_tzname, *beforetime.image(), *datetime::TzDst.av_tzname);
        else if (after_time != 0)
            Out->msg(INFO, "Selecting %sbackups after \"%"AVDATE"s %s\"", *count_info,
                *aftertime.image(), *datetime::TzDst.av_tzname);
        else if (before_time != 0)
            Out->msg(INFO, "Selecting %sbackups before \"%"AVDATE"s %s\"", *count_info,
                *beforetime.image(), *datetime::TzDst.av_tzname);
        else
            Out->msg(INFO, "Selecting %sbackups", *count_info);
    }
    
    
    DB->msg("utar_commands::get_backuplist: count=%d after=%s before=%s", flags_count, *after_time.hexstr(), *before_time.hexstr());
    acntmngr acnt(hfs_info.sync);

    
    
    
    
    
    tretentiontype rtype(flags.retentiontype);
    if (!flags.isexplicit("retention-type"))
        rtype.setretention(tretentiontype::all);
    if (!(rtype.get_errors().isempty())) Out->msg(ERR, "%s", *rtype.get_errors());

    tbackuptype btype(flags.backuptype);
    if (!(btype.get_errors().isempty())) Out->msg(ERR, "%s", *btype.get_errors());

    msgerrors rslt = MSG_ERR_NONE;
    if (hfs_info.metaStore != NULL) {
        rslt = hfs_info.metaStore->getBackups(lst, hfs_info.blk, hfs_info.auth, flags.count, +after_time, +before_time, include_partials, false, true, rtype.tochar(), btype.rawvalue(), flags.replicate || flags.account_metadata, rpluginidlist.is_empty()?NULL:&rpluginidlist);
    }
    else {
        acntmngr acnt(hfs_info.sync);
        roothashlist rhl;

        if (metadata_only) {
            rslt = acnt.getBackups(rhl, hfs_info.blk, hfs_info.auth, 1, +after_time, +before_time, include_partials, false, true, rtype.tochar(),
                                   tbackuptype::metadata.rawvalue(), true , rpluginidlist.is_empty()?NULL:&rpluginidlist);
            if(rslt==MSG_ERR_NONE) {
                lst = BackupRootInfoList(location::media::gsan, rhl);
                DB->msg("utar_commands::get_backuplist metadata only lst count=%s", *::tostr(lst.size()));
            }
            return (rslt==MSG_ERR_NONE);
        }

        rslt = acnt.getBackups(rhl, hfs_info.blk, hfs_info.auth, flags_count, +after_time, +before_time, include_partials, false, true, rtype.tochar(), btype.rawvalue(), flags.replicate || flags.account_metadata, rpluginidlist.is_empty()?NULL:&rpluginidlist);
        if(rslt==MSG_ERR_NONE){
            lst = BackupRootInfoList(location::media::gsan, rhl);
	    }
    }

    if(rslt!=MSG_ERR_NONE) {
        
        Out->msg(ERR, "<5180>Failed to retrieve backup list from account '%s' (error code %d %s).", *hfs_info.blk.path.image() ,rslt, *message::err_image(rslt));
        Out->msg(ERR, "<5181>Did you specify the account (--acnt) correctly?");
    }
    return (rslt==MSG_ERR_NONE);
}


bool utar_commands::filter_backuplist(const BackupRootInfoList& inlist, BackupRootInfoList& outlist) const {

    return filter_backuplist(inlist, flags.label, flags.backuptag, flags.labelnum, SavesetId(flags.savesetId), outlist);
}






bool utar_commands::filter_backuplist(const BackupRootInfoList& inlist, const ustring& label, const ustring& backuptag, const int labelnum, const SavesetId& savesetId, BackupRootInfoList& outlist) const
{
    DB->msg("utar_commands::filter_backuplist");

    if (inlist.empty()) return false;
    
    if (label.isempty() && backuptag.isempty() && labelnum == 0 && savesetId.isNull()) {
        DB->msg("utar_commands::filter_backuplist no label specified");
        outlist = inlist;
        return true;
    }

    BackupRootInfoList newlist;
    BackupRootInfo one_backup;

    if (labelnum > 0 || !savesetId.isNull()) {  
        DB->msg("utar_commands::filter_backuplist looking for labelnum:%d, savesetId:%s", labelnum, *savesetId.image());
        for (size_t i = 0; i < inlist.size(); i++) {
            inlist.get(one_backup, i);
            if (one_backup.isUsed()){
                const SavesetId backupId = one_backup.getSavesetId();
                
                
                if ((labelnum !=0 && backupId == labelnum) ||
                    ( backupId == savesetId)) {
                    if (!newlist.add(one_backup))
                        Out->msg(ERR, "<5182>Unable to add matching backup to list.");
                    break;  
                }
            }
        }

    } else {  
        DB->msg("utar_commands::filter_backuplist looking for label:%s", *label);

        
        const rhlLabel lab(*label, *backuptag, 0, 0);
        DB->msg("utar_commands::filter_backuplist, label='%s', backuptag='%s', taghash=%d\n", *label, *backuptag, lab.get_taghash());

        for (size_t i = 0; i < inlist.size(); i++) {
            inlist.get(one_backup, i);
            if (one_backup.isUsed()) {
                const bool labelmatch = (!label.isempty() && one_backup.getLabelName() == label);
                const bool tagmatch   = (!backuptag.isempty() && backuptag_match(backuptag, lab.get_taghash(), one_backup));
                if ((labelmatch == !label.isempty()) && (tagmatch == !backuptag.isempty())) {
                    if (!newlist.add(one_backup))
                        Out->msg(ERR, "<5182>Unable to add matching backup to list.");
                }
            }
        }
    }
    outlist = newlist;

    DB->msg("utar_commands::filter_backuplist new list.size() = %s", *::tostr(newlist.size()));

    if (newlist.empty()) {  
        Out->msg(ERR, "<5183>No backups with a label matching '%s' or backuptag '%s' or labelnum %d were found.", *label, *backuptag, labelnum);
        return false;
    }

    return true;
}












bool utar_commands::pick_backup(BackupRootInfo& chosenBackup, bool get_oldest, BackupRootInfoList* listp) const
{
    BackupRootInfoList list;
    

    if (listp == NULL) {        
        listp = &list;
    }

    
    if (listp->empty()) {
        if (!get_backuplist(*listp, flags.incpartials, flags.count))
            return false;
        if (listp != &list && !get_oldest)      
            listp->sort(BackupRootInfoList::SortNewToOld); 
            
            
    }

    
    
    if (!filter_backuplist(*listp, list))
        return false;  

    if (get_oldest || listp == &list)   
        list.sort(get_oldest ? BackupRootInfoList::SortOldToNew : BackupRootInfoList::SortNewToOld);

    (void) list.get(chosenBackup, 0);

    
    
    if (flags.replicate && !flags.account_metadata && list.size() >= 2) {
        if (chosenBackup.getBackupType() == tbackuptype::metadata)
           (void)list.get(chosenBackup, 1);
    }

    if (!flags.hfsaddr.isempty() && chosenBackup.isFromGsan()) {
        message m(INITUSERINFO);
        m.body().hash = chosenBackup.getrootrec().getRoot();      

        
        m = hfs_info.sync->call(m, 0);
    }

    return true;
}


        



xml_messagep utar_commands::backuprootinfo_to_xml(const BackupRootInfo& backupInfo, const bool for_exportstream )
{
    if( flags.archives )
       get_infofile(backupInfo);
    return backupInfo.toXml(get_backuptag(backupInfo), for_exportstream, infofile.appversion);
}




bool utar_commands::display_list(BackupRootInfoList& list)
{
    bool ret = true;
    bool do_xml = (outputxml == true) || (flags.format == "xml");
    xml_messagep mess;

    if (do_xml) {
        mess = new xml_message("list_backups");
    }

    if ( list.empty() ) {
        if(flags.web_format) {
            Out->msg(STD, "0");
        }
        Out->msg(ERR, "<5184>No matching backups found.");
        ret = false;

    } else {
        const ustring dir(UNDOO_DIRECTORY_NAME);
        const ustring info   (dir / ARCHIVE_INFO_FILENAME);
        const ustring mount  (dir / ARCHIVE_MOUNT_FILENAME);
        const ustring comment(dir / COMMENT_FILENAME);
        DB->msg("utar_commands::display_list: path:%s, mount:%s comment:%s", *info, *mount, *comment);

        BackupRootInfo one_backup;
        list.sort(BackupRootInfoList::SortNewToOld);

        if (!flags.web_format && !flags.short_output && !do_xml)
            Out->msgnn(STD, "%s", *infofile.header());

        for (size_t i = 0; i < list.size(); i++) {
            list.get(one_backup, i);
            if (one_backup.isUsed()) { 
                datetime dt(one_backup.getBackupTime());

                
                if(!flags.inctiered && one_backup.isTiered()) {
                    DB->msg("utar_commands::display_list: Skipping tiered backup (Label:'%s')", *one_backup.getLabelName());
                    continue;
                }

                if(!flags.incpartials && one_backup.isPartial())
                    continue;

                if (flags.web_format) {
                    Out->msg(STD, "\nrecord:\ndate:%"AVDATE"s\nlabel:%s\nlabelnum:%s",
                            *dt.image(), *one_backup.getLabelName(), *one_backup.getSavesetId().image());
                    if (one_backup.isPartial()) Out->msg(STD, LOCTXT("partial:"));
                } else if (do_xml) {
                    mess->children.push_back(backuprootinfo_to_xml(one_backup));
                } else {
                    if (one_backup.isFromCatalog()) {
                        Out->msg(STD, "%s", *one_backup.getSavesetId().image());
                    }
                    if (one_backup.isPartial())
                        Out->msgnn(STD, "*");
                    else
                        Out->msgnn(STD, " ");
                    Out->msgnn(STD, "%"AVDATE"s %5s %-16s", *dt.image(), *one_backup.getSavesetId().image(), *one_backup.getLabelName());
                }

                
                
                
                
                if (flags.short_output) {
                    Out->msg(STD, "%s", "");
                }
                else if (do_xml) {
                    
                } else {
                    
                    if (get_infofile(one_backup)) {
                        Out->msgnn(STD, "%s", *infofile.info(flags.verbose, flags.web_format));
                    } else {
                        Out->msg(STD, LOCTXT("     --- No information available ---"));
                    }
                }

                const prep_for_sysinfo context_is_prepped(*hfs_info.main);

                
                fileref cdata;
                if(flags.verbose > 1 &&
                   get_file(one_backup, cdata, upath(comment))
                ) {
                     Out->msg(VERBOSE, LOCTXT("-- comment --"));
                     cdata.print(stdout);
                     
                }

                
                fileref data;
                if(flags.verbose > 2&&
                   get_file(one_backup, data, upath(mount))
                ) {
                     data.print(stdout);
                     uwrapper::uprintf("\n");
                }
            }
        }
    }

    if (do_xml) {
        
        
        if(!requestp.isnull() && !responseq.isnull()) {
            
            requestp->set_res_list_snapups(mess->children);

            const ctl_queue::rettype success(responseq->enqueue(requestp));

            if (success != ctl_queue::enqueued_ret) {
                DB->msg("utar_commands::display list() unable to queue list %s",
                        *ctl_queue::rettype_image(success));
            }
        } else {
            Out->msg(STD, "%s", mess->simage().tostr());
        }
    }

    return ret;
}



bool utar_commands::preload_ddrfiles_from_gsan(const BackupRootInfo& backupInfo)
{
    DB->msg("utar_commands::preload_ddrfiles_from_gsan for: %s", *backupInfo.image());
    if (backupInfo.getDDRIndex() <= 0) {
        return true; 
    }

    bool ret(false);

    
    fileref data;
    if (get_ddrfiles_xml(backupInfo, ustring(DATADOMAINFILES_FILENAME), data)) {
        if (!data.isnull() && data.size64() > 0) {
            
            ddrfiles_xmlp xmlp(new ddrfiles_xml());
            if(!xmlp.isnull() && xmlp->loadXmlBackupFileList(data)) {
                
                const hfs_info_struct& hfs_info(getHfsInfoStruct());
                ddr_interface::set_ddr_files(hfs_info.clientidhash.image(), +backupInfo.getBackupTime(), xmlp);

                ret = true;
            }
        }
    }

    
    if(!ret) {
        Out->msg(INFO, "<17872>Failed to pre-load ddr_files.xml from gsan system_info directory");
        DB->msg("Failed to pre-load ddr_files.xml from gsan system_info directory for roothashlistrec: %s", *backupInfo.image());
    }

    return ret;
}

bool utar_commands::display_history(BackupRootInfoList& list)
{

    DB->msg("utar_commands::display_history: list.size=%s", *::tostr(list.size()));
    if (list.empty() ) {
        if(flags.web_format)  Out->msg(STD, "0");
        Out->msg(ERR, "<5184>No matching backups found.");
        return false;
    }
    list.sort(BackupRootInfoList::SortNewToOld);

    xml_messagep xmlp;
    if(flags.format == "xml")
        xmlp = new xml_message("history");

    hashcode prevhash = hashcode::ones;         
    epoch_t prevmtime = 0;                      
    int count = 0;

    for (size_t i = 0; i < list.size(); i++)
    {
        BackupRootInfo one_backup;
        list.get(one_backup, i);

        
        
        ustring argument_copy = flags.arg;

        
        const pidtype backup_pid = one_backup.getPluginType();
        if (backup_pid.os() == pidtype::os_windows) { 
            
            
            
            DB->msg("utar_commands::display_history(): Fetching history of a windows backup");
            argument_copy = argument_copy.strip(ustring::STRIP_LEADING, '\\').stdseparators();
        }
        else {
            DB->msg("utar_commands::display_history(): Fetching history of a non-windows backup");
        }

        
        
        
        upath path(argument_copy,(backup_pid.os() == pidtype::os_windows ? upath::kind_win : upath::kind_unix));

        
        
        
        
        
        
        
        if (one_backup.isFromCatalog() &&
            one_backup.getPluginType().kind() == pidtype::ndmp &&
            !set_ndmp_prefix_for_catalog_backup("utar_commands::display_history", one_backup)) {
            
            
            
            Out->msg(INFO, "Unable to retrieve top-level (volume) name of NDMP Catalog backup (Label:'%s') while traversing list of previous backups.",
                    *one_backup.getLabelName());
            continue;
        }

        
        if(!flags.inctiered && one_backup.isTiered()) {
            DB->msg("utar_commands::display_history(): Skipping tiered backup (Label:'%s')", *one_backup.getLabelName());
            continue;
        }

        (void)preload_ddrfiles_from_gsan(one_backup);

        if (one_backup.isUsed()) 
        {
            const pidtype curpid = one_backup.getPluginType();

            ustring errdesc;
            DIRELEM de(get_toplevel_de(one_backup, hfs_info));

            
            
            bool foundItInBrowseOverride = false;
            if (((xflag[29]&16) == 0) && (one_backup.getPluginType().kind() != pidtype::ndmp)) {
                ustring listing;
                list_archive la(*this);

                
                
                foundItInBrowseOverride = la.checkBrowseOverrideForPath(one_backup, path, listing);
                if (foundItInBrowseOverride) {
                    
                    
                    
                    
                    
                    if (!get_direlem(one_backup.getRootLocation(), path, de, errdesc)) {
                        
                        
                        try {
                            direlem_iter myiter(one_backup, &hfs_info);
                            if (myiter == direlem_iter()) {
                                
                                DB->msg("utar_commands::display_history() - empty backup??");
                                foundItInBrowseOverride = false;
                            }
                            else {
                                while (myiter != direlem_iter() && (myiter->is_internal() || myiter->is_hidden())) {
                                    
                                    ++myiter;
                                }
                                if (myiter != direlem_iter()) {
                                    de = *myiter;
                                    
                                }
                                else {
                                    DB->msg("utar_commands::display_history() - no non .system_info entries");
                                    foundItInBrowseOverride = false;
                                }
                            }
                        }
                        catch (const std::exception& e) {
                            Out->msg(ERR, "exception thrown trying to iterate backup - %s", e.what());
                            foundItInBrowseOverride = false;
                        }
                    }
                }
            }

            if (!foundItInBrowseOverride &&
                !get_direlem(one_backup.getRootLocation(), path, de, errdesc, upath(""), curpid.os()==pidtype::os_novell)) {
                
                

                upath substpath;
                
                
                
                if ( curpid.os() == pidtype::os_celerra ||
                     curpid.os() == pidtype::os_netapp  ||
                     curpid.os() == pidtype::os_isilon  ||
                     curpid.os() == pidtype::os_zfs) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    std::vector<ustring> entry;
                    if (!list_hash_entries(one_backup.getRootLocation(), entry, errdesc))
                        continue;
                    for (size_t e = 0; e < entry.size(); e++) {
                        upath epath(ndmp_unentify_volume(entry[e]), upath::kind_unix, true);
                        if (epath.numelems() < 2) continue; 
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        upath potential_volume_path = path.slice(0, epath.numelems()-2);
                        if (backstreamdir_msg2) DB->msg("utar_commands::display_history: Entified path comparison: '%s' vs '%s'",
                                                        *epath.image(), *potential_volume_path.image());
                        if (epath.compare(potential_volume_path, upath::compare_case_sensitive)) {
                            
                            
                            substpath = upath(entry[e]) / path.slice(epath.numelems()-1, path.numelems()).to_relative();
                            break;
                        }
                    }
                }
                if (substpath.isempty()) continue;
                if (backstreamdir_msg1) DB->msg("utar_commands::display_history: Substitute path found: '%s'",
                                                *substpath.image());
                if (!get_direlem(one_backup.getRootLocation(), substpath, de, errdesc,
                                 upath(""), curpid.os()==pidtype::os_novell))
                    continue;
            }
            const hashcode filehash = de.file_hash();
            const epoch_t mtime     = de.mtime();
            if(filehash == prevhash && mtime == prevmtime && ! flags.allsnapups)
                continue;
            count++;
            prevhash = filehash;
            prevmtime = mtime;
            const fileoffset fsize = de.file_size();
            const int plugin = one_backup.getPluginType().number();
            const unsigned long createtime = one_backup.getBackupTime().toUnixTime();

            if (!xmlp.isnull())
            {
                xml_messagep elem = new xml_message("elem");
                if (one_backup.isFromCatalog()){
                        elem->enter("savesetid",        one_backup.getSavesetId().image());
                }
                else {
                        elem->enter("labelnum",         one_backup.getSavesetId().image());
                }
                elem->enter("label",            one_backup.getLabelName());
                elem->enter("mtime",            mtime);
                elem->enter("size",             one_backup.getTotalBytes());  
                elem->enter("plugin",           plugin);
                elem->enter("createtime",       createtime);
                elem->enter("created_prectime", one_backup.getBackupTime().hexstr());
                elem->enter("expires",          one_backup.getExpires().toUnixTime());
                elem->enter("retentiontype",    one_backup.getRetentionType().image());
                elem->enter("backuptype",       one_backup.getBackupType().enduserimage()); 
                elem->enter("ddrindex",         one_backup.getDDRIndex());  

		        
                get_infofile( one_backup );
                if( ! infofile.appversion.isempty() )
                    elem->enter("appversion", infofile.appversion);
                else
                    elem->enter("appversion", "unavailable");

                const ustring tag = get_backuptag(one_backup);
                if(!tag.isempty()) elem->enter("backuptag", tag);

                
                xmlp->children.push_back(elem);

                continue;
            }

            if(count == 1 && !(flags.web_format || (flags.format == "xml"))) {
                Out->msg(STD, LOCTXT("  Seq       Label          Date      Time     Size   Plugin  Create  "));
                Out->msg(STD, " ----- ---------------- ---------- -------- -------- ------ ---------");
            }

            datetime ft(mtime);
            if (flags.verbose >=2) {
                Out->msg(STD, "%5s %s: %s", *one_backup.getSavesetId().image(), *one_backup.getBackupTime().dtstr(), *de.print(path, flags.verbose != 0, uids, gids, flags.web_format, false ));
            } else
            if (flags.web_format )
                Out->msg(STD, LOCTXT("\nrecord:\nlabelnum:%s\nlabel:%s\ndate:%s\nsize:%s\nplugin:%d\ncreatetime:%lu"),
                         *one_backup.getSavesetId().image(), *one_backup.getLabelName(), *ft.image(), *fsize.image(), plugin, createtime);
            else
                Out->msg(STD, " %5s %-16s %s %8s %6d %9lu", *one_backup.getSavesetId().image(), *one_backup.getLabelName(), *ft.image(), *fsize.image(), plugin, createtime);
        }
    }

    if(count == 0)
    {
        if(flags.web_format)  Out->msg(STD, "0");
        Out->msg(ERR, "<5920>File %s not found.", *flags.arg);
        return false;
    }

    if(!xmlp.isnull())
    {
        Out->msg(STD, "%s", xmlp->simage().tostr());
    }

    return true;
}

        


        














bool utar_commands::find_entified_name (const hashcode& roothash, const ustring& orig_path, ustring& ent_path,
     bool return_top  ) {

    upath path(orig_path);
    upath substpath;
    ustring errdesc;

    if ( (currpid.os() != pidtype::os_celerra) &&  
         (currpid.os() != pidtype::os_netapp) &&
         (currpid.os() != pidtype::os_isilon) &&
         (currpid.os() != pidtype::os_zfs) )  {
        DB->msg("utar_commands::find_entified_name: trying to find entified name in a non-NDMP backup.");
        return false;
    }

    DB->msg("utar_commands::find_entified_name: NDMP backup. Trying entified version of path \"%s\".", *orig_path);
    std::vector<ustring> entry;
    const location rootloc(location::media::gsan, roothash);
    if (!list_hash_entries(rootloc, entry, errdesc)) {
        Out->msg(ERR, "<12481>Unable to retrieve top level listing of hash: %s", *errdesc);
        return false;
    }

    for (size_t e = 0; e < entry.size(); e++) {
        upath epath(ndmp_unentify_volume(entry[e]), upath::kind_unix, true);
        if (epath.numelems() < 2) continue;  
        DB->msg("utar_commands::find_entified_name: Entified path comparison: '%s' vs '%s'",
                                        *epath.image(), *path.slice(0, epath.numelems()-2).image());
        if (epath.compare(path.slice(0, epath.numelems()-2), upath::compare_case_sensitive)) {
            if (!return_top)
                substpath = upath(entry[e]) / path.slice(epath.numelems()-1, path.numelems()).to_relative();
            else
                substpath = upath(entry[e]);  
            break;
        }
        else DB->msg("utar_commands::find_entified_name: comparison fails: '%s' vs. '%s'",
                     *epath.image(), *path.slice(0, epath.numelems()-2).image());
    }
    if (substpath.isempty()) {
        DB->msg("utar_commands::find_entified_name: path \"%s\" not found errcode %s", *orig_path, *errdesc);
        return false;
    }
    ent_path  = substpath.image();
    DB->msg("utar_commands::find_entified_name: volume for path \"%s\" was found in backup", *ent_path);
    return true;
}





bool utar_commands::restore_file(fileref& res, const DIRELEM* direlem, const fileoffset startoff, const fileoffset endoff,
    ucontainer::basep containerp) const
{
    
    
    
    
    
    if(res.isnull()) {  
        const fileoffset maxSize(4*1024*1024);
        if( direlem->file_size() < fileoffset(4*1024*1024) ) {
            res.initlist(direlem->file_size().ivalue());
        }
        else {
            res.initlist(maxSize.ivalue());
        }
    }
    hfs_info.main->addfilecount(context::restorestats, 1);
    assert(!hfs_info.main->is_in_async_mode());
    restroot *rst = new restroot(hfs_info.main, res, direlem, startoff, endoff, containerp);
    assert(rst != NULL);
    const bool ok = !hfs_info.main->loop();    
    return ok;
}




bool utar_commands::get_frompath(ustring& frompath) {
    upath infrompath(frompath);

    
    

    
    infrompath.set_end_dirsep(false);














      frompath = infrompath.image();



    DB->msg("utar_commands::get_frompath frompath = \"%s\"", *frompath);

    return true;
}

        




restroot* utar_commands::get_dirRestRoot(context* main)
{
    if ((main != NULL) && (dirRestRoot == NULL))
        dirRestRoot = new restroot(main);
    return dirRestRoot;
}

        

void utar_commands::display_snapup_info(const BackupRootInfo& backupInfo,
                                        const infofile_info& infofile,
                                        pidtype& pid_of_backup)
{
    const pidtype pid = backupInfo.getPluginType();

    
    
    pid_of_backup = this->currpid = pid;

    Out->msg(INFO, "<8745>Backup from %s host \"%s\" (%s) with plugin %d - %s %s",
             *infofile.osversion, *hfs_info.blk.path.image(),
             *infofile.hostname,
             pid.number(), *pidtype::image(pid.os()), *pidtype::image(pid.kind())
    );

    DB->msg("utar_commands::display_snapup_info setting currpid to %s", *pid.imagex());

    datetime dt(backupInfo.getBackupTime());
    ustring lab;
    if (!backupInfo.getLabelName().isempty())
        lab = ustring::sprintf(" label \"%s\"", *backupInfo.getLabelName());

    Out->msg(INFO, "<5538>Backup #%s%s timestamp %"AVDATE"s %s, %s files, %s",
        *backupInfo.getSavesetId().image(), *lab, *dt.image(), *datetime::TzDst.av_tzname,
        *commas(infofile.nfiles), *byteunits(infofile.dsize));
}

void utar_commands::display_snapup_info(const BackupRootInfo& backupInfo, bool check_info) {
    if(check_info) {
        if (!get_infofile(backupInfo)) {
            Out->msg(ERR, "<5896>No backup information found."); return;
        }
        pidtype dummy;
        display_snapup_info(backupInfo, infofile, dummy);
    } else {
        datetime dt(backupInfo.getBackupTime());
        ustring lab;
        if (!backupInfo.getLabelName().isempty())
            lab = ustring::sprintf(" label \"%s\"", *backupInfo.getLabelName());
        Out->msg(INFO, "<6780>Backup #%s%s timestamp %"AVDATE"s %s",
                 *backupInfo.getSavesetId().image(), *lab, *dt.image(), *datetime::TzDst.av_tzname);
    }
    hfs_info.main->sessinfo[dpn0].addlabel(backupInfo);
}




void utar_commands::display_snapup_version_info(const BackupRootInfo& backupInfo) const
{
    const ustring pluginstr(ustring::sprintf("plugin %s", *backupInfo.getPluginType().imagex()));
    const ustring savesetid(backupInfo.getSavesetId().image());

    
    if( ! infofile.appversion.isempty() ) {
        Out->msg(INFO, "Backup #%s had been created by avtar version %s as %s", *savesetid, *infofile.appversion, *pluginstr);
        hfs_info.main->setBackupAvtarVersion(infofile.appversion, infofile.pidnum);
    }
    else	
        Out->msg(INFO, "Avtar version unavailable for backup set #%s as %s", *savesetid, *pluginstr);
}

ustring utar_commands::readlink(const dpnobj& obj, ubigint64 size) {
    char target[256];
    obj.read(0, target, (int)size);
    target[size] = '\0';
    return target;
}







bool utar_commands::safemkdir(const upath& path, const bool inherit_permissions) {
    if(DIRELEM::querydirectoryexists(path)) {
        DB->msg("* Safemkdir(\"%s\") - Already exists", *path.image());
        return true;  
    }
    DB->msg("* Safemkdir(\"%s\") - %s inherited ACLs", *path.image(), inherit_permissions?"With":"Without");

#if SYSTEM_WINDOWS
    
    const int numelems(path.numelems());
    if(numelems == 1 || numelems == 2) {
        ustring elem_name;
        upath::elemcat elem_cat;
        
        if(path.get(numelems - 1, elem_name, elem_cat)) {
            if((numelems == 1) ?
               
               ((elem_cat == upath::elem_drive ||
                 elem_cat == upath::elem_unc_server)) :
               
               (elem_cat == upath::elem_unc_share)) {
                return true;
            }
        }
    }
#endif

    
    const int mval = uwrapper::umkdir(*path.image(), 0777);

    
    
    if ( mval != 0 && errno != EEXIST && errno != ENOSYS ) {
        platerror pe(platerror::use_clib);
        Out->msg(WARN, "<5191>Could not create directory \"%s\" (%s).", *path.image(), *pe.description());
     
     
     
     
     
     
     
    }

#if !SYSTEM_WINDOWS  
    
    
    if (inherit_permissions) {
        DIRELEM de;
        de.initialize(path.parentdir());        
        de.set_fullpath(path);                  
        de.set_file_attributes(true);           
    }
#endif

    return true;
}





bool utar_commands::mkdir_full(const utar_flags_info& flags, ustring path) {
    path = path.fix_dirseps(true);
    if (path.isempty()) return true;
    stringlist dirs(path.split(DIRSEP, true));   
    int numdirs = dirs.size();

    if (numdirs > 0) {
        ustring mkdirpath;
        if (path.byteindex(0) == DIRSEP) mkdirpath = DIRSEPSTR;

        for(int i=0; i<numdirs; i++) {
            mkdirpath = mkdirpath/dirs[i];
#if SYSTEM_WINDOWS
            if(i == 0) {
                upath dirpath(path);
                ustring elem_name;
                upath::elemcat elem_cat;
                if(dirpath.get(0, elem_name, elem_cat) && elem_cat == upath::elem_wack_wack_prefix && elem_name == "?")
                    mkdirpath = ustring(WINPATH_PREFIX);
            }
            if (flags.mapi) {
                ELEMID elemid((upath)mkdirpath, ELEMID::EKIND_MAPI);
                mapiwalk mwalk(elemid, true);
                if (!mwalk.mkfldr())
                    return false;
            } else if (upath(mkdirpath).isCreatableForRestore()) {
                if (!safemkdir((upath)mkdirpath, true ))
                    return false;
            }
            else {
                
            }
#else
            if (!safemkdir((upath)mkdirpath, flags.permissions)) return false;
#endif
        }
    }
    return true;
}

int utar_commands::check_write(const ustring& path) {
#if SYSTEM_WINDOWS
    return 0;  
#elif SYSTEM_UNIX
    return access(*path, W_OK);
#endif
}




bool utar_commands::mkdirpath_checkwrite(const utar_flags_info& flags, ustring& path) const
{
    if (!path.isempty()) {
        path = path.fix_dirseps(true);
        if (!mkdir_full(flags, path)) {
            platerror pe;
            Out->msg(ERR, "<6782>Could not create directory \"%s\" for restore (%s).  Possibly bad path or insufficient write privileges.", *path, *pe.description());
            return false;
        } else if (flags.mapi == false && check_write(path) != 0) {  
            platerror pe;
            Out->msg(ERR, "<8752>Do not have write permission for \"%s\" (%s)", *path, *pe.description());
            return false;
        }
    }
    return true;
}

bool utar_commands::finishRestore(const bool priorSuccess, dirlist* topdirs, const ustring& frompath) const
{
    bool success = priorSuccess;
    context* main = hfs_info.main;
    
    
    
    while(topdirs) {
        
        
        if(topdirs->preexisting && !flags.existingdiraclrestore ) {      
            DB->msg("* Leaving perms of existing directory intact (\"%s\")", *topdirs->de.fullpath().image());
            break;
        }
#if SYSTEM_WINDOWS
        if( topdirs->de.is_drive() ) { 
            break; 
        }
#endif
        
        if(!(flags.online_system_state && !flags.existingdiraclrestore))
        {
          DB->msg("* Setting final perms (\"%s\")", *topdirs->de.fullpath().image());
          topdirs->de.set_file_attributes(flags.permissions);
        }
        dirlistp next = topdirs->link;
        
        topdirs = next;
    }


    int warnings, errors, fatals;
    Out->get_total_counts(warnings, errors, fatals);

    success &= (fatals == 0);

    ustring cmd = flags.validate?DBTXT("Validate"):DBTXT("Restore");
    if(!uapp::staging().canRun()) {
       Out->msg(WARN, "<7702>%s interrupted.", *cmd); 
       success = false;
    } else if(! success) {
        if (frompath.isempty())
            Out->msg(ERR, "<5261>%s failed", *cmd);
        else
            Out->msg(ERR, "<5263>%s of \"%s\" failed", *cmd, *frompath);
    } else {
        size_t  iDirACLLostCount = main->getdirACLstrippedcount();
        size_t  iFileACLLostCount = main->getfileACLstrippedcount();

        if( iDirACLLostCount && iFileACLLostCount ) {
            Out->msg(INFO, "<5542>Restore was not able to reapply security on %d directories and %d files due to lack of support in target file system",
                            (int)iDirACLLostCount, (int)iFileACLLostCount);
        } else if( iDirACLLostCount ) {
            Out->msg(INFO, "<5543>Restore was not able to reapply security on %d directories due to lack of support in target file system",
                            (int)iDirACLLostCount);
        } else if( iFileACLLostCount ) {
            Out->msg(INFO, "<5544>Restore was not able to reapply security on %d files due to lack of support in target file system",
                            (int)iFileACLLostCount);
        }
        ustring errmsg = "";
        if (errors > 0) errmsg = ustring::sprintf(" with %d error%s", errors, (errors==1)?"":"s");
        if (frompath.isempty())
            Out->msg(INFO, "<5262>%s completed%s", *cmd, *errmsg);
        else
            Out->msg(INFO, "<5267>%s of \"%s\" completed%s", *cmd, *frompath, *errmsg);
    }
    return success;
}


class massocid : public associd {
private:
    virtual ustring extern_lookup(int id) { return ustring(); }
};

#if 0   
bool utar_commands::get_snapview_user_group_maps(const hashcode &hash,
                                                 tassoc<ustring, associd *> &uids_map,
                                                 tassoc<ustring, associd *> &gids_map)
{
    DB->msg("utar_commands::get_snapview_user_group_maps++");
    std::vector<ustring> topleveldirs;
    ustring errdesc;
    if (!list_hash_entries(hash, topleveldirs, errdesc, 0)) {
        DB->error ("utar_commands::get_snapview_user_group_maps failed to get topleveldirs for %s",
                   *hash.partialimage());
        return false;
    }

    for (std::vector<ustring>::const_iterator i = topleveldirs.begin();
         i != topleveldirs.end();
         i++)
    {
        DB->msg("utar_commands::get_snapview_user_group_maps dir working on %s", *(*i));
        ustring uidpath(*i / UNDOO_DIRECTORY_NAME / USERS_ID_FILENAME);
        ustring gidpath(*i / UNDOO_DIRECTORY_NAME / GROUP_ID_FILENAME);
        fileref data;
        if (get_file(hash, data, uidpath)) {
            DB->msg("utar_commands::get_snapview_user_group_maps found uids for %s", *uidpath);
            associd *ids = new massocid();
            ids->from_file(data);
            uids_map.enter(*i, ids);
        }
        if (get_file(hash, data, gidpath)) {
            DB->msg("utar_commands::get_snapview_user_group_maps found gids for %s", *gidpath);
            associd *ids = new massocid();
            ids->from_file(data);
            gids_map.enter(*i, ids);
        }
    }
    return true;
}
#endif




exitcodes_t utar_commands::do_restore() {

    if (restmsg) DB->msg("utar_commands::do_restore()");
    bool do_progress = true;

    if( xflag[3]&512 ) {
        
        
        
        Out->msg( INFO, "<7703>Not sending SESSION INFO & PROGRESS messages to restore DPN");
        do_progress = false;
    }
    
    stringlist emptylist;
    backstate state(emptylist, false, flags.parallel_type);

    
    
    
    if((flags.args.size() == 0) && (!flags.arg.isempty()))
        flags.args.push_back(flags.arg);

    if (restmsg) DB->msg("utar_commands::do_restore: args '%s'", *flags.args.image());

    

    
    
    
    
    bool args_set(false);       
    if (flags.parallel && (flags.maxstreams > 1)) {   
        if (restmultistream) DB->msg("utar_commands::do_restore: potentially parallel restore - checking...");
        stringlist destargs;    
        const bigint64 fasize(flags.args.size());       
        if (flags.srcdstlist.size() > 0) {      
            if (restmultistream) DB->msg("utar_commands::do_restore: checking non-empty srcdstlist...");
            for (bigint64 i = 0; i < fasize; i++) {
                const ustring thisarg(flags.args[static_cast<size_t> (i)]);
                const ustring dest(flags.srcdstlist.lookup(thisarg));
                if (dest.isempty())     
                    destargs.push_back(thisarg);
                else
                    destargs.push_back(dest);
            }
        }
        else if (fasize > 1) {  
            if (flags.redirrestore) {  
                
                
                if (restmultistream) DB->msg("utar_commands::do_restore: parsing test-redirect arguments...");
                for (bigint64 i = 0; i < fasize; i++) {
                    const ustring thisarg(flags.args[static_cast<size_t> (i)]);
                    const bigint64 equalsign = thisarg.find(0, '=');
                    if (equalsign >= 0) {   
                        if (equalsign == 0)     
                            DB->msg("utar_commands::do_restore: arg %s '%s' starts with '=' - error?", *tostr(i), *thisarg);
                        destargs.push_back(thisarg.substr(static_cast<size_t> (equalsign + 1)));
                    } else {        
                        destargs.push_back(thisarg);
                    }
                }
            }
            else if (!flags.target.isempty()) {     
                if (restmultistream) DB->msg("utar_commands::do_restore: parsing target and arguments...");
                
                
                
                
                
                
                const ustring prefix(flags.target);
                for (bigint64 i = 0; i < fasize; i++) {
                    ustring dest(flags.args[static_cast<size_t> (i)]);
                    if (flags.preservepaths)        
                        dest = prefix / dest;
                    else {
                        const upath dest_path(dest);
                        dest = prefix / dest_path.stripdir();
                    }
                    destargs.push_back(dest);
                }
            }
        }
        
        if (destargs.size() > 0) {      
            assert(destargs.size() == fasize);
            if (restmultistream) {
                DB->msg("utar_commands::do_restore: args -> destinations:");
                for (bigint64 i = 0; i < destargs.size(); i++) {
                    DB->msg("\t [%s] '%s' -> '%s'", *tostr(i), *flags.args[static_cast<size_t> (i)], *destargs[static_cast<size_t> (i)]);
                }
            }
            state.targets.init(destargs, false, NULL, false, false);
            args_set = true;
        }
    }

    if (!args_set) {    
        if (restmultistream) DB->msg("utar_commands::do_restore: no parallel targets found - using args.");
        state.targets.init(flags.args, false, NULL, false, false);
    }

    state.enter_exclude_include_lists(flags, true, false);

    if (restmsg) DB->msg("utar_commands::do_restore: incs '%s'", *state.targets.includelist().image());
    if (hfs_info.main) {
        hfs_info.main->set_dpn_statstype(dpn0, context::restorestats);
        if (!hfs_info.main->state) {
            hfs_info.main->state = &state;
            if (restmsg) DB->msg("utar_commands::do_restore new backstate");
        }
        if (restmsg) DB->msg("utar_commands::do_restore has state :)");
    } else {
        DB->msg("utar_commands::do_restore no main!???? ");
    }

    

    buildinfo build("avtar", buildinfo::client_version); 

    
    if (flags.to_stdout && !flags.showlog &&
        (flags.streamformat_out == utar_flags_enums::streamformat_none) &&
        (flags.args.size() == 0 || flags.arg.isempty())) {
        Out->msg(ERR, "<5354>You must specify a file to restore when using --to-stdout");
        return EXIT_BAD_FLAGS;
    }

    hostinfo host;
    datetime start;
    ustring currhostname(netsys::getcurrhostname());
    ustring cpus;
    if (host.numprocessors()==1)
        cpus = LOCTXT("CPU");
    else
        cpus = LOCTXT("CPUs");
    ustring flags_str;
    if (flags.replicate)
        flags_str = LOCTXT("replicate");
    else
        if (flags.validate)
            flags_str = LOCTXT("validate");
        else
            flags_str = LOCTXT("restore");

    Out->msg(INFO, "<5295>Starting %"AVARG"s at %"AVDATE"s %s as \"%s\" on \"%s\" (%d %"AVARG"s) [%s]\n",
             *flags_str, *start.image(), *datetime::TzDst.av_tzname, *host.osuser(), *currhostname, host.numprocessors(), *cpus, *build.version());

#if SYSTEM_WINDOWS
    winpriv wp(winpriv::EPrivTypeRestore);
    winpriv wp2(winpriv::EPrivTypeSecurity);
    winpriv wp3(winpriv::EPrivTypeBackup); 
    if( !wp.is_enabled() ) {
        Out->msg(WARN, "<6027>Current user (%s) could not enable SE_RESTORE_NAME privilege.  Some files may fail to restore properly.", *host.osuser());
    }
    if( !wp2.is_enabled() ) {
        Out->msg(WARN, "<6976>Current user (%s) could not enable SE_SECURITY_NAME privilege.  ACLs cannot be restored ", *host.osuser());
    } else {
        
        if(!flags.isexplicit("permissions")) flags.permissions = true;
    }
    if( !wp3.is_enabled() ) {
        Out->msg(WARN, "<7704>Current user (%s) could not enable SE_BACKUP_NAME privilege.  Some files may fail to restore properly.", *host.osuser());
    }

    
    
    if (win_os_version_info::is_server_2012_or_newer() && flags.windowsRestoreHydrated) {
        if (!WinDedup::Initialize(this, flags.windowsRehydrateLimit)) {
            Out->msg(WARN, "Unable to initialize Avtar's 'Windows Deduplication' module - Avtar will be unable to de-optimize Windows Deduplicated files");
        }
    }

    
    
    if (restmsg) DB->msg("utar_commands::do_restore Building mount points list for all volumes on the system" );
    VolumeInfo::build_win_mount_points_maps();

    if (!flags.restoreshortnames) {
        Out->msg(INFO, "--restoreshortnames flag not specified; 8.3 names (if available in the backup) will not be restored with files/dirs. If the target OS supports 8.3 names, then the OS will create 8.3 names automatically.");
    }

#endif
    
    
    if(!flags.permissions && !flags.dtoexportstream) {
        flags.ignoreacls = true;
    }

    file_system_info::unlimit_filesize();

    DIRELEM::ignoreacls       = flags.ignoreacls;
    DIRELEM::ignorerwxmapping = flags.ignorerwxmapping;

    if (restmsg) DB->msg("utar_commands::do_restore permissions=%d, ignoreacls=%d, ignorerwxmapping=%d", flags.permissions, DIRELEM::ignoreacls, DIRELEM::ignorerwxmapping);

    exitcodes_t exitCode = do_restore_work(do_progress, state);
#if SYSTEM_WINDOWS
    if (win_os_version_info::is_server_2012_or_newer() && flags.windowsRestoreHydrated) {
        WinDedup::RehydrateFiles();
        WinDedup::Terminate();
    }
#endif
    return (exitCode);
}


exitcodes_t utar_commands::do_restore_work(const bool do_progress, backstate& state)
{
    BackupRootInfo one_backup;
    location::tbackupid backupid;
    bool have_sysinfo(false);
    tddrindex ddrIndexFromBackup = 0;
    DataDomainSysInfo ddrSysInfo; 
    ddrfiles_xmlp ddrfiles = NULL;

    if (!pick_backup(one_backup, !(flags.restore_after.isempty()&&(0==flags.restore_within_days)))) {
        if(flags.reportonly)
            Out->msg(INFO, "<5200>No matching backups found.");
        else
            Out->msg(ERR, "<5184>No matching backups found.");
        return EXIT_NO_ARCHIVES;
    }

    if(!(flags.replicate && flags.allsnapups)) {
        
        if(!flags.replicate && one_backup.isFromGsan()) {
            const roothashlistrec rec = one_backup.getrootrec();
            const bool override_direct_restore_allowed(((xflag[31]&4096)!=0));
            if (!rec.isDirectRestoreAllowed()) {
                if (override_direct_restore_allowed)
                    Out->msg(WARN, "Attempting a restore of a backup marked 'not directly restorable'.");
                else {
                    Out->msg(ERR, "This backup may only be restored by replicating the data back to an Avamar only server first.");
                    return EXIT_RESTORE_FAIL;
                }
            }
        }

        backupid = location::tbackupid(one_backup.getBackupTime());  
        if(!flags.replicate || (flags.destination_data == client_config_flags::ddr_to_gsan)) {  
            ddrIndexFromBackup = one_backup.getDDRIndex();
        }

        
        hfs_info.main->prev_backup = one_backup;

        
        
        
        
        
        const bool login_ok(login_to_ddr(one_backup, ddrIndexFromBackup, backupid));

        
        
        
        
        if(!login_ok && (flags.dtoexportstream && flags.extract)) {
            Out->msg(FATAL, "Cannot login to DDR server to perform export");
            return EXIT_CONNECT;
        }

        
        have_sysinfo = get_infofile(one_backup);

        display_snapup_version_info(one_backup);
    }

    
    
    
    
    if(ddrIndexFromBackup > 0 && flags.streamformat_out == utar_flags_enums::streamformat_dump) {
        
        
        
        DB->msg("utar_commands::do_restore_work is *not* calling context::initializeavtarwork, instead we rely on context::restore_dumppipe to open the container and assign it to context::ucontainer so that netapp restores can use that");
    }

#if SYSTEM_WINDOWS
    if (win_os_version_info::is_server_2012_or_newer() && flags.windowsRestoreHydrated) {
        assert(one_backup.isFromGsan());    
        WinDedup::SetRestoreInfo(one_backup, upath(flags.vardir));
    }

    
    if (flags.hberestoresystem == "prepare" || flags.hberestoresystem == "finalize") {
        
        flags.hbesystemprofilepath = "";
        
        ustring profile_path;
        BackupRootInfo the_backup;
        (void)pick_backup(the_backup, !(flags.restore_after.isempty()&&(0==flags.restore_within_days)));
        assert(the_backup.isFromGsan());
        if (!get_hbeprofilepath(the_backup, profile_path)) {
            
            flags.hberestoresystem = "disable";
            Out->msg(ERR, "<8754>Could not retrive the HBE profile path. Disabling HBE functionality.");
            
            return EXIT_RESTORE_FAIL;
        } else {
            
            flags.hbesystemprofilepath = profile_path;

            
            if (flags.hberestoresystem == "prepare") {
                
                if (!flags.target.isempty()) {
                    flags.target = "";
                    Out->msg(INFO, "<8755>Restoring to a non default location during the HBE prepare phase is not supported. Specified target restore location will be ignored.");
                }
                
                if (!flags.args.isempty()) {
                    
                    
                    Out->msg(INFO, "<8756>Restoring during the HBE prepare phase is not supported. Specified targets for restore will be ignored.");
                    flags.args.clear();
                }
                
                flags.args.push_back(profile_path);
            }
        }
    }
#endif

    
    if (flags.streamformat_out == utar_flags_enums::streamformat_emctar ||
        flags.streamformat_out == utar_flags_enums::streamformat_isilon ||
        flags.streamformat_out == utar_flags_enums::streamformat_zfs)
        if (!get_inode_table(one_backup))
            Out->msg(WARN, "<7414>Unable to load inode table from %s in the %s directory in the backup, hardlink restores may fail",
                     INODE2HASH_TABLE_FILENAME, UNDOO_DIRECTORY_NAME);

    if (flags.validate || flags.replicate || (flags.streamformat_out == utar_flags_enums::streamformat_dump)) {
        flags.target = "";                                      
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                
                                                                

    } else if ((flags.streamformat_out == utar_flags_enums::streamformat_tar) ||
               (flags.streamformat_out == utar_flags_enums::streamformat_pax) ||
               (flags.streamformat_out == utar_flags_enums::streamformat_isilon) ||
               (flags.streamformat_out == utar_flags_enums::streamformat_zfs) ||
               (flags.streamformat_out == utar_flags_enums::streamformat_avpax) ||
               (flags.streamformat_out == utar_flags_enums::streamformat_cdsf)) {
        get_ids(one_backup);                                          

    } else if (!(flags.to_stdout || flags.showlog) &&
               have_sysinfo &&                                  
               infofile.pidnum != 0 &&                          
               infofile.pidnum != flags.pluginid.number() &&    
               !restoremain::check_xrest_option(flags.restoreoption, flags.target, flags.srcdstlist))
    {
        Out->msg(ERR, "<5347>A target or save-as directory must be specified for cross-target restores");
        return EXIT_BAD_FLAGS;
    }


    
    const fileref snapup_encodings(get_encodingsfile(one_backup));

    hfs_info.main->character_encodings.restore_encodings(flags.encodings,
                                                         infofile.osversion,
                                                         snapup_encodings);

#if SYSTEM_WINDOWS
    
    ustring encoding_description;
    if(hfs_info.main->character_encodings.description(encoding_description)) {
        Out->msg(INFO, "<5949>Backup file system character encoding is %s.", *encoding_description);
    } else {
        encodings fs_encoding(encodings::filesystem);

        Out->msg(WARN, "<5987>File system character encoding %d not supported on this client.", fs_encoding.value());
    }
#else
    Out->msg(INFO, "<5949>Backup file system character encoding is %s.", *encodings(encodings::filesystem).value());
#endif

    if (!flags.replicate) {
        display_snapup_info(one_backup, infofile, state.pid_of_backup);
        hfs_info.main->sessinfo[dpn0].addlabel(one_backup);
    } else {
        
        hfs_info.main->sessinfo[dpn0].adddsthost(dstflags.hfsaddr);
    }

   
    if (!flags.directory.isempty()) {
        DB->msg("utar_commands::do_restore_work changing directory to %s", *flags.directory);
        Out->msg(INFO, "<5145>Changing to directory \"%s\".", *flags.directory);
        if (uwrapper::uchdir(flags.directory) != 0) {
            Out->msg(FATAL, "<5215>Unable to change to directory \"%s\".", *flags.directory);
            return EXIT_BAD_FLAGS;
        }
    }

#if SYSTEM_WINDOWS
    
    if (flags.restoreatreboot) { 
        
        
        ntrestore_at_reboot::set_restore_time_stamp();
    }
#endif

    ustring target(flags.target);   
    hfs_info.main->target_path = target;

    
    ustring desc;
    if(flags.replicate) {
        if(flags.reportonly && dstflags.degenerate)  
            desc = "caprep";
        else
            desc = "replsrc";
    } else if(flags.validate)
        desc = "validate";
    else
        desc = "avtarrestore";

    if( do_progress ) {
        
        
        
        if(flags.replicate && hfs_info.main->getdpnmaxmessage(dpn0) < STRIPECONVERSION) flags.workorderid = widtype::nah.image();

        hfs_info.main->startsession(hfs_info.main->sessinfo[dpn0], dpn0, AVTAR_EXENAME, target, flags, cidtype(flags.clientid), widtype(flags.workorderid), NULL, false, desc, one_backup.getLabelName());
    }

    
    

    
    
    
    if (((currpid.os() == pidtype::os_celerra) || (currpid.os() == pidtype::os_netapp)) &&
            ((flags.args.size() == 0) && (!MULTIPATH_RESTORE || (xflag[22]&16))) && !flags.dtoexportstream) {
        std::vector<ustring> volumes_in_backup;
        ustring errdesc;
        if (list_hash_entries(one_backup.getRootLocation(), volumes_in_backup, errdesc) ) {
            for (unsigned int ii = 0; ii < volumes_in_backup.size(); ii++) {
                if (volumes_in_backup[ii] != UNDOO_DIRECTORY_NAME) {
                    ustring unentified_volume = ndmp_unentify_volume(volumes_in_backup[ii]);
                    flags.args.push_back(unentified_volume);
                    DB->msg("utar_commands::do_restore_work: Adding [%s] to args volume list", *unentified_volume);
                }
            }
        }
        else  {
            
            
            Out->msg(WARN, "Problem getting volume list from root hash of Celerra backup: %s", *errdesc);
        }
    }

    
    
    
    if (macosx_utils::is_system_integrity_protection_enabled()) {
        Out->msg(WARN, "System Integrity Protection is enabled! Avtar will be unable to restore files located in system directories or for certain system applications.");
    }

    bool success = true;
    bool haswork = true;
    if (flags.replicate) {
        if (!flags.internal) {                          
            DB->msg("utar_commands::do_restore_work: Forcing --internal to TRUE for replicate");
            dstflags.internal = true;
            flags.internal = true;
        }
        if(!(flags.reportonly && dstflags.degenerate))    
            flags.capacity_match_bits = 0;  
        dstflags.pluginid = flags.pluginid; 

        BackupRootInfoList list;
        if (flags.allsnapups) {
             
             
             
             
             int fcount(flags.count);
             if (!flags.account_metadata && flags.count > 0) fcount++;

             DB->msg("utar_commands::do_restore_work: Getting complete list of backups");
             bool include_partial = flags.incpartials && (flags.ddrenabled || dstflags.ddrenabled) &&
                                    (dstflags.ddrindex > 0) && (flags.destination_data == client_config_flags::same_destination);
             (void) get_backuplist(list, include_partial, fcount);  

             
             if (!flags.account_metadata && fcount > 0 && list.size() > 0)
                 verify_metadata_backups(list);

         } else {
             list.add(one_backup);           
             BackupRootInfo metadata_rec;    
             if (get_metadata_backup(metadata_rec)) {
                 success = list.add(metadata_rec);
                 if (success) Out->msg(INFO, "Adding Metadata Backup #%s to list of backups to replicate.", *metadata_rec.getSavesetId().image());
             }
         }
         if (success && haswork) {
             replicate repl(hfs_info.main, flags, dstflags);
             success = repl.run(list, this);
         }
    }
    
    
    
    else if (hfs_info.main->state->pid_of_backup == pidtype(pidtype::os_linux, pidtype::backupboost)) {
        
        target_work_results work_results;
        
        if (!get_work_results(one_backup, work_results)) {
            Out->msg(ERR, "Failed to determine backup list to perform restore.");
            success = false;
            return EXIT_RESTORE_FAIL;
        }
        stringlist backup_list;
        work_results.list_backups(backup_list);
        if (backup_list.isempty()) {
            Out->msg(ERR, "Backup list is empty, could not find backup to restore.");
            success = false;
            return EXIT_RESTORE_FAIL;
        }
        if (flags.parallel && (flags.maxstreams > 1)) {
            
            
            
            
            if (!target.isempty()) {
                
                
                
                
                
                
                
                stringlist dest_arg_list;
                dest_arg_list.push_back(target);
                state.targets.init(dest_arg_list, false, NULL, false, false);
            } else {
                
                
                
                
                
                state.targets.init(backup_list, false, NULL, false, false);
            }
        }
        
        
        
        if (flags.args.isempty()) {
            
            
            flags.args += backup_list;
            for (int backup_index = 0; backup_index < backup_list.size(); backup_index++) {
                ustring backup_name(backup_list[backup_index]);
                ustring entified_backup_name(ndmp_entify_volume(backup_name));
                if (restmsg) DB->msg("utar_commands::do_restore_work: calling singlepath_restore for '%s'", *entified_backup_name);
                
                
                ustring restore_target(target.isempty() ? backup_name: target);
                singlepath_restore sp_rest(this, hfs_info, one_backup, flags, entified_backup_name, restore_target);
                
                success = sp_rest.run(false);
            }
        } else {
            
            
            for (int target_index = 0; target_index < flags.args.size(); target_index++) {
                upath target_path(flags.args[target_index]);
                target_path.set_end_dirsep(false);
                bool found_backup(false);
                
                for (int backup_index = 0; backup_index < backup_list.size(); backup_index++) {
                    upath backup_path(backup_list[backup_index]);
                    
                    
                    
                    
                    
                    if (target_path.isDescendentOf(backup_path) || target_path.compare(backup_path)) {
                        int target_numelems = target_path.numelems();
                        int backup_numelems = backup_path.numelems();
                        upath elem(target_path.slice(backup_numelems, target_numelems));
                        elem.set_begin_dirsep(false);
                        upath entified_backup_path(ndmp_entify_volume(backup_list[backup_index]));
                        upath backup_target_path(entified_backup_path / elem);
                        upath restore_target_path(target);
                        bool include_last(target.isempty());
                        if (target.isempty()) {
                            
                            
                            
                            
                            
                            
                            restore_target_path = target_path.parentdir();
                            if (target_path.compare(backup_path)) {
                                
                                
                                
                                
                                
                                restore_target_path = backup_path;
                                include_last = false;
                            }
                        }
                        if (restmsg) DB->msg("utar_commands::do_restore_work: calling singlepath_restore for '%s'", *backup_target_path.image());
                        singlepath_restore sp_rest(this, hfs_info, one_backup, flags, backup_target_path.image(), restore_target_path.image());
                        success = sp_rest.run(include_last);
                        found_backup = true;
                        break;
                    }
                }
                if (!found_backup) {
                    Out->msg(WARN, "Could not find backup for '%s' to be restored", *target_path.image());
                    success = false;
                }
            }
        }
    } else if((flags.args.size() == 0) && (!MULTIPATH_RESTORE || (xflag[22]&16))) { 
        
        
        if (restmsg) DB->msg("utar_commands::do_restore_work: calling singlepath_restore for '%s'", *flags.arg);
        singlepath_restore sp_rest( this, hfs_info, one_backup, flags, flags.arg, target );
        success = sp_rest.run(false);
    } else if(MULTIPATH_RESTORE && (xflag[22]&16)==0 &&     
              (flags.streamformat_out != utar_flags_enums::streamformat_dump ||
               (one_backup.isFromGsan() && is_inode_dumpformat(one_backup.getRootLocation().getHash(), currpid)))) {

        
        if (restmsg) DB->msg("utar_commands::do_restore_work: calling multipath_restore for '%s'", *flags.args.image());
        multipath_restore mp_rest(this, hfs_info, one_backup, flags, flags.args, target);
        mp_rest.run(true);
    } else if ((flags.streamformat_out == utar_flags_enums::streamformat_dump) && flags.args.size() > 1) {
        Out->msg(FATAL, "<7706>Restriction: Cannot restore more than one directory or file to 'dump' format");
    } else {    
        
        
        for (int i=0; i<flags.args.size(); i++) {
            if (i > 0 && flags.to_stdout && (flags.streamformat_out == utar_flags_enums::streamformat_none) && (xflag[10]&128)==0) {
                
                
                Out->msg(INFO, "<6430>Only one file restored to Standard Output");
                break;
            }
            
            

            
            if ((currpid.os() != pidtype::os_celerra) && (currpid.os() != pidtype::os_isilon) && (currpid.os() != pidtype::os_zfs) &&
                    ((currpid.os() != pidtype::os_netapp) || (flags.showlog) )) {
                if (restmsg) DB->msg("utar_commands::do_restore_work: calling singlepath_restore for '%s'", *flags.args[i]);
                singlepath_restore sp_rest( this, hfs_info, one_backup, flags, flags.args[i], target );
                success = sp_rest.run(flags.args.size()>1);
            }
            else {  
                    
                    
                BackupRootInfo myBackup;
                (void)pick_backup(myBackup, !(flags.restore_after.isempty()&&(0==flags.restore_within_days)));

                bool isa_volume = false;
                ustring my_frompath (flags.args[i]);;
                ustring unentified_from = ndmp_unentify_volume(my_frompath);
                upath ufrom_path(unentified_from);
                std::vector<ustring> volumes_in_backup;
                ustring errdesc;

                
                if (list_hash_entries(one_backup.getRootLocation(), volumes_in_backup, errdesc) ) {
                    for (unsigned int ii = 0; ii < volumes_in_backup.size() && !isa_volume; ii++) {
                        upath epath(ndmp_unentify_volume(volumes_in_backup[ii]), upath::kind_unix, true);
                        if (epath.compare(ufrom_path, upath::compare_case_sensitive)) {
                            isa_volume = true;
                        }
                    }
                }

                ustring my_target (target);
                if (isa_volume && (currpid.os() != pidtype::os_netapp)) {
                    my_target = (target / unentified_from);
                }
                if (restmsg) DB->msg("utar_commands::do_restore_work: calling singlepath_restore for '%s'", *my_frompath);
                singlepath_restore sp_rest( this, hfs_info, myBackup, flags, my_frompath, my_target );
                if (isa_volume || (currpid.os() == pidtype::os_netapp))
                    success = sp_rest.run(false); 
                else
                    success = sp_rest.run(true);
            }  
        }
    }
    
    if(dirRestRoot != NULL) {
        
        
        
        hfs_info.main->add(TODO_DIR, dirRestRoot, false);
        hfs_info.main->loop();  
        
        
        
        
        ubigint64 restoreSize = dirRestRoot->getListSize();
        for(ubigint64 i = 0; i < restoreSize; i++) {
            
            dirlist* topdirs = NULL;
            ustring fromPath, toPath;
            success = dirRestRoot->getCloseParameters(i, (void**)&topdirs, fromPath, toPath);
            success = finishRestore(success, topdirs, fromPath);
        }
        
        delete dirRestRoot;
        dirRestRoot = NULL;
    }

    
    
    if(!success)
        uapp::staging().startTermination(EXIT_MISC, "failed to restore");



        
        
        
        ADEMgrX* adeMgr = hfs_info.main->getAdeMgr();	
        if (adeMgr != NULL) {  
            SessionProfile* sessionProfile = adeMgr->getSessionProfile();
            if(sessionProfile != NULL) {
            	
            	sessionProfile->finishSession(uapp::staging().getExitCode(), 0, hfs_info.main->sessinfo, 0);
            }
        }
        

        const ustring dircnt = hfs_info.main->getstatsobj(context::restorestats)->get_dircount()==0 ? "" : ustring::sprintf(", %s %s", *commas(hfs_info.main->getstatsobj(context::restorestats)->get_dircount()), DIRECTORY_NOUN);

        if (!haswork) {
             
        } else if(flags.validate) {
            double elapsed_secs(timer::elapsed()+0.001); 
            Out->msg(INFO, "<7924>Examined selection(s) with %s (%s files%s) in %3.2f minutes: %s/hour",
                     *byteunits(hfs_info.main->getstatsobj(context::restorestats)->get_filebytes_prog()),   
                     *commas(hfs_info.main->getstatsobj(context::restorestats)->get_filecount()),
                     *dircnt,
                     elapsed_secs/60,
                     *byteunits((hfs_info.main->getstatsobj(context::restorestats)->get_filebytes_prog()/elapsed_secs)*3600)   
                    );
        } else {
            double restored = hfs_info.main->getstatsobj(context::restorestats)->get_filebytes_sent() +
                              hfs_info.main->getstatsobj(context::restorestats)->get_filebytes(stats::reduced);
            if (hfs_info.main->getstatsobj(context::restorestats)->get_filebytes(stats::skipped) > 0)
                Out->msg(INFO, "<7925>Restored %s from selection(s) with %s in %s files%s (%s in %s files skipped)",
                         *byteunits(restored),
                         *byteunits(hfs_info.main->getstatsobj(context::restorestats)->get_filebytes_prog()),   
                         *commas(hfs_info.main->getstatsobj(context::restorestats)->get_filecount()),
                         *dircnt,
                                          *byteunits(hfs_info.main->getstatsobj(context::restorestats)->get_filebytes(stats::skipped)),
                                          *commas(hfs_info.main->getstatsobj(context::restorestats)->get_filecnt(stats::skipped)));
            else
                Out->msg(INFO, "<7925>Restored %s from selection(s) with %s in %s files%s",
                     *byteunits(restored),
                     *byteunits(hfs_info.main->getstatsobj(context::restorestats)->get_filebytes_prog()),   
                     *commas(hfs_info.main->getstatsobj(context::restorestats)->get_filecount()),
                         *dircnt);

            if(restored > 0) {          
                double elapsed_secs(timer::elapsed()+0.001); 
                Out->msg(INFO, "<6090>Restored %s in %3.2f minutes: %s/hour (%s files/hour)",
                         *byteunits(restored),
                         elapsed_secs/60,
                         *byteunits((restored/elapsed_secs)*3600),
                         *commas((hfs_info.main->getstatsobj(context::restorestats)->get_filecount()/elapsed_secs)*3600));
            }
        }




    datetime finish;
    Out->msg(INFO, "<7883>Finished at %"AVDATE"s %s, Elapsed time: %s",
                   *finish.image(), *datetime::TzDst.av_tzname, *timer::elapsedstring(timer::elapsed()));

    if (!uapp::staging().canRun()) {
        return uapp::staging().getExitCode();
    }

    if (!success) return EXIT_RESTORE_FAIL;

#if SYSTEM_WINDOWS
    
    if (flags.restoreatreboot) { 
        
        stringlist temp_restore_dirs_list = ntrestore_at_reboot::get_temp_restore_dir_list();

        if( temp_restore_dirs_list.size() > 0) {
            
            
            
            Out->msg(INFO, "Starting to process restore files in the temp location");
            if (ntrestore_at_reboot::process_temp_restore_files(flags.vardir)) {
                Out->msg(INFO, "Completed processing restore files in the temp location");
                Out->msg(WARN, "Reboot is required to complete restore, please reboot the system");
            } else {
                Out->msg(WARN, "Could not process all or some files in the temp restore location");
            }
        }
    }
#endif

    return EXIT_OK;
}


exitcodes_t utar_commands::do_archives(const bool query_only , bool output_list )
{
    BackupRootInfoList list;
    exitcodes_t ret = EXIT_OK;

    if ( !get_backuplist(list, flags.incpartials, flags.count) )  
        ret = EXIT_NO_ARCHIVES;

    if (ret != EXIT_OK) return EXIT_MISC;

    if(!query_only) {
        datetime dt;
        Out->msg(INFO, "<7377>Backups for %s as of %"AVDATE"s %s", (flags.catalog_path.isempty() ? (*hfs_info.blk.path.image()) : flags.catalog_path.tostr()), *dt.image(), *datetime::TzDst.av_tzname);
    }

    if (list.empty()) {         
        if(!query_only) {
            if (flags.label.isempty() && flags.labelnum==0)     
                Out->msg(INFO, "<5200>No matching backups found.");
            else
                Out->msg(ERR, "<5184>No matching backups found.");
        }
        ret = EXIT_NO_ARCHIVES;
    }

    
    if (!filter_backuplist(list, list))
        return EXIT_NO_ARCHIVES;

    if (output_list && !display_list(list)) return EXIT_MISC;

    return EXIT_OK;
}






exitcodes_t utar_commands::do_delete()
{
    BackupRootInfoList list;
    exitcodes_t ret = EXIT_OK;

    if ( !get_backuplist(list, flags.incpartials, flags.count) )  
        ret = EXIT_NO_ARCHIVES;

    if (ret != EXIT_OK) return EXIT_MISC;

    datetime dt;
    Out->msg(INFO, "<7377>Backups for %s as of %"AVDATE"s %s", *hfs_info.blk.path.image(), *dt.imageTZ(), *datetime::TzDst.av_tzname);

    if (list.empty()) {         
        if (flags.label.isempty() && flags.labelnum==0)     
            Out->msg(INFO, "<5200>No matching backups found.");
        else
            Out->msg(ERR, "<5184>No matching backups found.");
        ret = EXIT_NO_ARCHIVES;
    }

    DB->msg("utar_commands::do_delete found %s records", *::tostr(list.size()));

    
    if (!filter_backuplist(list, list))
        return EXIT_NO_ARCHIVES;

    
    list.sort((flags.restore_after.isnull()&&(0==flags.restore_within_days)) ? BackupRootInfoList::SortNewToOld : BackupRootInfoList::SortOldToNew);

    acntmngr acnt(hfs_info.sync);
    const blktraj block(hfs_info.blk);
    const authid  auth(hfs_info.auth);
    BackupRootInfo one_backup;
    if (list.get(one_backup, 0)) {
        const prectime snapuptime(one_backup.getBackupTime());
        const datetime date(snapuptime);
        if(flags.force_nfs) {
            msgerrors rslt = acnt.delBackup(block, auth, snapuptime, false, false);
            if(rslt != MSG_ERR_NONE) {
                Out->msg(WARN, "<8031>Deletion of backup %s in \"%s\" failed during move", *snapuptime.image(), *one_backup.image());
            } else {
                Out->msg(INFO, "<7380>Deleted backup #%s timestamp %"AVDATE"s %s label \"%s\"", *one_backup.getSavesetId().image(), *date.image(), *datetime::TzDst.av_tzname, *one_backup.getLabelName());
            }
        } else {
            Out->msg(ERR, "<5538>Backup #%s timestamp %"AVDATE"s %s label \"%s\" not deleted; --force option must be used to delete",
                     *one_backup.getSavesetId().image(), *date.image(), *datetime::TzDst.av_tzname, *one_backup.getLabelName());
        }
    } else {
      Out->msg(ERR, "<5184>No matching backups found.");
      return EXIT_NO_ARCHIVES;
    }

    
    

























    return EXIT_OK;
}



exitcodes_t utar_commands::do_history() {
    if(flags.arg == "") {
        Out->msg(ERR, "<5921>You must specify a file for --history");
        return EXIT_BAD_FLAGS;
    }
    BackupRootInfoList list;

    if ( !get_backuplist(list, flags.incpartials, flags.count) )      
        return EXIT_NO_ARCHIVES;

    datetime dt;
    Out->msg(INFO, "<5922>History of %s for %s as of %"AVDATE"s %s", *flags.arg, *hfs_info.blk.path.image(), *dt.image(), *datetime::TzDst.av_tzname);

    if (list.empty()) {           
      if (flags.label.isempty() && flags.labelnum==0)    
        Out->msg(INFO, "<5200>No matching backups found.");
      else
        Out->msg(ERR, "<5184>No matching backups found.");
      return EXIT_NO_ARCHIVES;
    }

    
    if (!filter_backuplist(list, list))
        return EXIT_NO_ARCHIVES;

    if (!display_history(list)) return EXIT_NO_ARCHIVES;

    return EXIT_OK;
}







exitcodes_t utar_commands::do_browse(utar_flags_info& flags) {

    ctl_messagep answer;
    ctl_messagep requestp = new ctl_message(ctl_message::type::browse_contents);

    requestp->set_arg_browse_contents(flags.pluginid, *flags.arg);
    browse_filesystem browseit(flags.vardir, flags.bindir, flags.sysdir,
                               flags.force_nfs, flags.fs_force, flags.fs_ignore, requestp->getpid());

    if(browseit.doit(requestp, answer, "", flags.browse_timeout, flags.browse_csv_only, flags.browse_smb_shares_list)) {
        
        if(((xflag[19]&256)==0) && !answer.isnull() && (answer->gettype() == ctl_message::type::browse_contents)) {
            Out->msg(INFO, LOCTXT("%s"), *answer->simage());
        }
    }
    return EXIT_OK;
}






exitcodes_t utar_commands::do_backupboost_browse(utar_flags_info& flags) {

    ctl_messagep answer;
    ctl_messagep requestp = new ctl_message(ctl_message::type::browse_contents);

    
    
    

    if (!flags.backupboostconfig.isempty()) {
        flags.arg = flags.backupboostconfig.image(',');
        requestp->set_arg_browse_type("configure");

    } else if (!flags.backupboostunconfig.isempty()) {
        flags.arg = flags.backupboostunconfig.image(',');
        requestp->set_arg_browse_type("unconfigure");

    } else if (flags.backupboostlist) {
        
    }

    requestp->set_arg_browse_contents(flags.pluginid, *flags.arg);

    browse_filesystem browseit(flags.vardir, flags.bindir, flags.sysdir,
                               flags.force_nfs, flags.fs_force, flags.fs_ignore, requestp->getpid());

    browseit.doit(requestp, answer, "", flags.browse_timeout, flags.browse_csv_only, flags.browse_smb_shares_list);

    
    if(((xflag[19]&256)==0) && !answer.isnull() && (answer->gettype() == ctl_message::type::browse_contents)) {
        Out->msg(INFO, LOCTXT("%s"), *answer->simage());
    }

    return EXIT_OK;
}








exitcodes_t utar_commands::do_backupboost_journal_cleanup(utar_flags_info& flags, context* main)
{
    backupboost::backupboost_interface bb_int;
    if (!bb_int.initialize()) {
        Out->msg(ERR, "Failed to load BackupBoost shared library during journal maintenance.");
        return EXIT_ABORT;
    }

    bool get_mount_list(true);
    stringlist target_mount_list;
    
    if (!flags.bbjournalmaintlist.isempty()) {
        target_mount_list = flags.bbjournalmaintlist.image().split(' ');
        get_mount_list = false;
    }
    
    
    
    if (get_mount_list) {
        backupboost_interface::lfs_handle lfs_handle;
        int lfs_error(bb_int.init_library(bb_int.lib_version(), lfs_handle));
        if (lfs_error != LFS_SUCCESS) {
            Out->msg(ERR, "Initialize BackupBoost library for list mounts failed with %s (return code: %d).",
                    *bb_int.err_code_to_desc(lfs_error), lfs_error);
            return EXIT_TARGETLIST;
        }

        unsigned int mount_count(0);
        const unsigned int max_mount_count(backupboost::maximumMountCount);
        lfs_error = LFS_MORE_MOUNT_POINT;

        while ((lfs_error == LFS_MORE_MOUNT_POINT) && (++mount_count <= max_mount_count)) {
            ustring mount_point;
            int mount_point_is_configured(0);
            int mount_point_is_supported(0);

            lfs_error = bb_int.list_mounts(lfs_handle, mount_point, mount_point_is_configured, mount_point_is_supported);
            if (lfs_error == LFS_MORE_MOUNT_POINT) {
                if (mount_point_is_supported) {
                    if (mount_point_is_configured) {
                        Out->msg(INFO, "Adding %s for BackupBoost journal maintenance.", *mount_point);
                        target_mount_list.push_back(mount_point);
                    }
                } else {
                    Out->msg(INFO, "Path %s is not a supported BackupBoost mount, skipping from journal maintenance.", *mount_point);
                }
            } else if (lfs_error != LFS_NO_MORE_MOUNT_POINT) {
                Out->msg(ERR, "BackupBoost list mount points failed with %s.",
                              *bb_int.err_code_to_desc(lfs_error));
                return EXIT_TARGETLIST;
            }
        }

        if (mount_count > max_mount_count)
            Out->msg(WARN, "BackupBoost number of mount points of %d reached maximum allowed count of %d",
                     mount_count, max_mount_count);
    }

    if (!bb_int.shutdown()) {
        Out->msg(ERR, "BackupBoost shutdown failed.");
        return EXIT_ABORT;
    }

    if (target_mount_list.isempty()) {
        Out->msg(INFO, "No BackupBoost configured mounts are found, not performing journal maintenance.");
        return EXIT_OK;
    }

    const ustring session_id_time_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILENAME);

#if !SYSTEM_WINDOWS
    
    
    
    const ustring lock_file(flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILELOCK);
    processlock lock_obj(lock_file);

    const int max_tries(60);
    int tries(0);
    while (!lock_obj.checkandobtainlock()) {
        if (++tries > max_tries) {
            Out->msg(ERR, "Failed to get access to file '%s' for BackupBoost journal log maintenance", *session_id_time_file);
            return EXIT_ABORT;
        }
        Out->msg(INFO, "File '%s' for BackupBoost journal log maintenance is locked, waiting for release with '%d' tries remaining.", *session_id_time_file, max_tries - tries);
        uapp::sleep(1000);
    }
#endif

    
    
    if (!main->session_id_time_table.parse(session_id_time_file)) {
        Out->msg(ERR, "Failed to parse file '%s' for BackupBoost journal log maintenance", *session_id_time_file);
        return EXIT_ABORT;
    }

    
    datetime before_time;
    if (!before_time.utarformat(*flags.bbjournalmaintdate)) {
        Out->msg(ERR, "Invalid date/time: --bbjournalmaintdate=\"%s\" is specified for BackupBoost journal maintenance.", *flags.bbjournalmaintdate);
        return EXIT_ABORT;
    }
    ubigint64 search_time(prectime(before_time.tobtime()).toUnixTime64());

    
    
    
    for (int i = 0; i < target_mount_list.size(); i++) {
        const upath mount_path(target_mount_list[i]);
        ubigint64 session_id(0);
        if (main->session_id_time_table.get_session_entry(mount_path, search_time, session_id)) {
            
            if (session_id != 0) {
                session_id--;
            }
            Out->msg(INFO, "Removing journal logs for mount '%s' and session id '%s' for search time '%s'.", *mount_path.image(), *tostr(session_id), *tostr(search_time));
            
            int ret(bb_int.delete_logs(mount_path.image(), session_id));
            if (ret != LFS_SUCCESS) {
                Out->msg(WARN, "Failed to delete BackupBoost journal logs for mount %s and session id %s: %s.",
                    *mount_path.image(), *tostr(session_id), *bb_int.err_code_to_desc(ret));
                continue;
            }
            main->session_id_time_table.remove_session_entries(mount_path, search_time);
            if (!main->session_id_time_table.image(session_id_time_file))
                Out->msg(ERR, "Failed to write file '%s' for journal log maintenance.", *session_id_time_file);
        } else {
            Out->msg(INFO, "No session id data found, not performing journal log maintenance for mount '%s' at session time of '%s'.", *mount_path.image(), *tostr(search_time));
        }
    }

    return EXIT_OK;
}

        






exitcodes_t utar_commands::do_command()
{
    if (flags.catalog_address.isempty()) {
        DB->dosyslog(flags.commandline());
    }

    exitcodes_t retval = EXIT_OK;

    if (flags.labelnum < 0) {
        Out->msg(ERR, "<5687>Illegal sequencenumber %d, must be positive.", flags.labelnum);
        return EXIT_BAD_FLAGS;
    }

    
    if(!requestp.isnull()) {
        
        const ctl_message::type ty(requestp->gettype());
        if(ty.value() == ctl_message::type::list_snapup_contents) {
            
            list_archive la(*this);
            retval = la.do_list_archive();
        } else if(ty.value() == ctl_message::type::list_snapups) {
            outputxml = true;
            retval = do_archives();
        } else {
            Out->msg(ERR, "<6784>Illegal request message to tar_commands '%s'.", *ty.image());
            retval = EXIT_BAD_FLAGS;
        }
    } else {
        
        if(flags.extract)       retval = do_restore();   

        else if(flags.archives) retval = do_archives();  

        else if(flags.history)  retval = do_history();   

        else if(flags.list)
        {
            list_archive la(*this);
            retval = la.do_list_archive();
        }

        else if(flags.delbackup) retval = do_delete();
    }

    return retval;
}








bool utar_commands::is_inode_dumpformat(const hashcode& roothash, const pidtype& pid) {
    DB->msg("utar_commands::is_inode_dumpformat pid=%s", *pid.imagex());
    if(!trynewparsing) return false;

    if(!(pid==pidtype::none)
       && pid.os()!=pidtype::os_netapp
       && pid.kind()!=pidtype::ndmp
    ) return false;
    upath testpath = dumpstream::typemap::format(2, dumpstream::typemap::dir);
    if (flags.ndmp_prefix.bytelength() > 0)
        testpath = upath(flags.ndmp_prefix) / testpath;

    DIRELEM de;
    ustring errdesc;
    const location rootloc(location::media::gsan, roothash);
    DB->msg("utar_commands::is_inode_dumpformat looking up %s", *testpath.image());
    bool ret= get_direlem(rootloc, testpath, de, errdesc);
    DB->msg("utar_commands::is_inode_dumpformat pid=%s ret:%d", *pid.imagex(), ret);
    return ret;
}

ddrfiles_xmlp utar_commands::load_ddr_files(fileref ddrfilesxml)
{
    ddrfiles_xmlp ddrfiles = new ddrfiles_xml();

    if (ddrfiles == NULL) {
        Out->msg(FATAL, "Restoring a backup from DDR, but failed to load '.system_info/ddr_files.xml' file found inside backup");
        return NULL;
    }

    
    if (! ddrfiles->loadXmlBackupFileList(ddrfilesxml)) {
        Out->msg(FATAL, "Restoring a backup from DDR, but failed to parse '.system_info/ddr_files.xml' file found inside backup");
        return NULL;
    }

    return ddrfiles;
}

exitcodes_t utar_commands::init_ddr()
{
    if (m_adeMgr != NULL) return EXIT_OK;

    
    BackupRootInfo one_backup;
    (void)pick_backup(one_backup, !(flags.restore_after.isempty()&&(0==flags.restore_within_days)));
    assert(one_backup.isFromGsan());

    tddrindex ddrIndexFromBackup = 0;
    DataDomainSysInfo ddrSysInfo; 
    const hashcode roothash = one_backup.getrootrec().getRoot();
    const prectime snapuptime = one_backup.getBackupTime();  
    if (roothash == hashcode::zero) {
        Out->msg(ERR, "<5184>No matching backups found.");
        return EXIT_NO_ARCHIVES;
    }
    ddrIndexFromBackup = one_backup.getDDRIndex();

    
    hfs_info.main->prev_backup = one_backup;

    if (ddrIndexFromBackup > 0) {

        
        ddrSysInfo.labelnum = flags.labelnum;
        ddrSysInfo.fileName = DATADOMAINFILES_FILENAME;
        ddrSysInfo.hexBackupTime = +snapuptime;

        
        flags.ddrenabled = true; 

        
        const fileref snapup_encodings(get_encodingsfile(one_backup));

        hfs_info.main->character_encodings.restore_encodings(flags.encodings,
                                                             infofile.osversion,
                                                             snapup_encodings);

        if ((m_adeMgr = hfs_info.main->getAdeMgr()) != NULL) {        
            
            
            
            
            exitcodes_t result = m_adeMgr->loginDDRWithIndex(flags.path, ddrIndexFromBackup, flags.extract, flags.replicate);
            if(result != EXIT_OK) {
                DB->msg("utar_commands::do_restore_work unable to log into ddr");
                return(result);
            }

            
            
            
            if(m_adeMgr->isDDRenabled()) { 
                hfs_info_struct&   hfs_info = m_adeMgr->getHfsInfo(dpn0);
                ddrSysInfo.clientID = hfs_info.clientidhash.image();

                m_adeMgr->setSysInfo(ddrSysInfo);

                
                
                
            }
        }
    }

    return EXIT_OK;
}


bool utar_commands::login_to_ddr(const BackupRootInfo& backupInfo, const tddrindex ddrIndexFromBackup, const location::tbackupid backupid) {
    if (ddrIndexFromBackup <= 0) return true;
    DB->msg("utar_commands::login_to_ddr ddrindex:%d streamformat-in:%d", +ddrIndexFromBackup, flags.streamformat_in);

    DB->msg("utar_commands::login_to_ddr found non-zero ddrindex %d in backup, logging into the ddr", ddrIndexFromBackup);

    flags.ddrenabled = true; 










    if ((flags.pluginid.kind() == pidtype::vcbimage)  
        || (flags.pluginid.kind() == pidtype::ostackimage)
        || (flags.streamformat_in == utar_flags_enums::streamformat_raw))
    {
        flags.streamformat_in = utar_flags_enums::streamformat_raw;
        Out->msg(INFO, "<9936>Relogging into Server to support DDR restore");
        
        if (!hfs_info.main->enableADEChunker(hfs_info)) {   
            Out->msg(ERR, "<9937>Could not restart ADE for DDR restore");
            return false;
        }
        assert(hfs_info.main->ADEChunkerEnabled());
    }



    ADEMgrX* adeMgr = hfs_info.main->getAdeMgr();

    if(adeMgr == NULL) {    
        DB->msg("utar_commands:: ademg==NULL");
        return false;
    }

    
    
    
    exitcodes_t result = adeMgr->loginDDRWithIndex(flags.path, ddrIndexFromBackup, flags.extract, flags.replicate);
    if(result != EXIT_OK) {
        DB->msg("utar_commands:: unable to log into ddr");
        return false;
    }

    
    
    
    if(!adeMgr->isDDRenabled()) {
        DB->msg("utar_commands:: ddr is not enabled");
        return false;
    }

    DataDomainSysInfo ddrSysInfo; 
    ddrSysInfo.labelnum = flags.labelnum;
    ddrSysInfo.fileName = DATADOMAINFILES_FILENAME; 
    ddrSysInfo.hexBackupTime = +backupid;

    hfs_info_struct& hfs_info(adeMgr->getHfsInfo(dpn0));
    ddrSysInfo.clientID = hfs_info.clientidhash.image();
    flags.clientid = hfs_info.clientidhash.image();
    DB->msg("utar_commands::login_to_ddr flags.clientid:%s", *flags.clientid);

    
    const bool filePresent = get_ddrfiles_xml(backupInfo, ddrSysInfo.fileName, ddrSysInfo.ddrfilesData);

    
    if(!filePresent) {
        int ddrHandle = 0;
        adeMgr->get_ddrhandle(ddrHandle);
        const ddrfiles_xmlp ddrfiles(ddr_interface::get_ddr_files(ddrHandle, hfs_info.clientidhash.image(), backupid));

        if(!ddrfiles.isnull()) {
            DB->msg("utar_commands::login_to_ddr read ddr_files.xml from ddr\n%s\n", *ddrfiles->simage());
            
            ddrSysInfo.ddrfilesData.initmem(ddrfiles->simage());
        } else {
            DB->msg("utar_commands::login_to_ddr unable to load ddr_files.xml from %s ", *backupInfo.image());
            Out->msg(FATAL, "Can't continue");
        }
    } else DB->msg("utar_commands::login_to_ddr found ddr_files.xml in MetadataStore's .system_info");

    

    
    adeMgr->setSysInfo(ddrSysInfo);
    adeMgr->setDDRSysInfo(ddrSysInfo);

    hfs_info.main->check_for_raw_format(backupid, ddrSysInfo.ddrfilesData); 

    
    if(!flags.makeview && !flags.parallel && !flags.replicate) {
        
        
        hfs_info.main->initializeContainerCache();
    }

    return true;
}





const ustring utar_commands::get_sysinfo_path(const ustring& called_from, const BackupRootInfo& backupInfo, const bool volume_specific_sysinfo , ustring prefix ) const
{
    
    ustring sysinfo_path(UNDOO_DIRECTORY_NAME);

    
    
    if (prefix.isempty()) {
        prefix = flags.ndmp_prefix;
    }

    if (((backupInfo.getPluginType().kind() == pidtype::ndmp) || (backupInfo.getPluginType().kind() == pidtype::backupboost)) &&
        (volume_specific_sysinfo || backupInfo.isFromCatalog())) {
        

        if (prefix.isempty() && !set_ndmp_prefix_for_catalog_backup("utar_commands::get_sysinfo_path", backupInfo)) {
            
            
            DB->msg("utar_commands::get_sysinfo_path: Expected to pre-pend ndmp_prefix flag value to '.system_info', but flag is empty.");
        }

        
        if (!prefix.isempty()) {
            sysinfo_path = prefix / sysinfo_path;
        }
    }

    DB->msg("utar_commands::get_sysinfo_path: Called from '%s'.  Returning '%s'", *called_from, *sysinfo_path);
    return sysinfo_path;
}






const bool utar_commands::set_ndmp_prefix_for_catalog_backup(const ustring& called_from, const BackupRootInfo& backupInfo) const
{
    bool ret_val(false);
    if (backupInfo.isFromCatalog() && (backupInfo.getPluginType().kind() == pidtype::ndmp)) {
        
        
        
        
        
        const context::prep_for_no_ddr_container ddr_loc_ignored(*hfs_info.main);

        
        
        
        
        const prep_for_sysinfo context_is_prepped(*hfs_info.main);

        
        
        try {
            const direlem_iter top_level_iter(backupInfo, &hfs_info);
            if (top_level_iter == direlem_iter()) {
                
                DB->msg("utar_commands::get_ndmp_prefix_for_catalog_backup() - empty backup??");
            } else {
                assert(top_level_iter->is_directory());
                flags.ndmp_prefix = top_level_iter->name();  
                ret_val = true;
            }
        }
        catch (const std::exception& e) {
            Out->msg(ERR, "exception thrown trying to iterate backup - %s", e.what());
        }
    }
    DB->msg("utar_commands::get_ndmp_prefix_for_catalog_backup: Called from '%s'.  Returning '%s'",
            *called_from, ret_val ? "TRUE" : "FALSE");
    return ret_val;
}



bool utar_commands::get_metadata_backup(BackupRootInfo& metadata_rec) const
{
    BackupRootInfoList metadata_list;
    get_backuplist(metadata_list, flags.incpartials, 1, true );
    if (metadata_list.size() >= 1) {
        metadata_list.get(metadata_rec, 0);
        return true;
    }
    return false;
}








void utar_commands::verify_metadata_backups(BackupRootInfoList& lst) const
{
    
    BackupRootInfo bckup;
    for(size_t idx=0; idx < lst.size(); idx++) {
        lst.get(bckup, idx);
        if (bckup.getBackupType() == tbackuptype::metadata) {
            return;
        }
    }

    
    BackupRootInfo metadata_rec;
    if (get_metadata_backup(metadata_rec)) {
        lst.erase(lst.end());
        lst.add(metadata_rec);
        Out->msg(INFO, "Adding Metadata Backup %s to list of backups to replicate.", *metadata_rec.getSavesetId().image());
    }
    else {
        
        if (lst.size() > 1) {
            lst.erase(lst.end());
        }
    }
}


const bool path2direlemp_table::add_table_entry(const upath& path, const DIRELEMp &dep)
{
    upath key_path;

    if (!convert_path_to_key(path, key_path)) {
        
        return false;
    }

    path2direlemp_table_itr entry = path_table.find(key_path);
    if (entry == path_table.end()) {
        
        DIRELEMp cached_dep(dep);
        entry = path_table.insert(entry, std::make_pair(key_path, cached_dep));
        

        if (entry == path_table.end()) {
            
            
            return false;
        }

    } else if (backstreamdir_msg2) {
        
        
        DB->msg("path2direlemp_table::add_table_entry: Path '%s' already exists in table.  Could be a hardlink.", *path.image());
    }
    return true;
}





const bool path2direlemp_table::lookup(const upath &lookup_path, DIRELEMp &dep) const
{
    upath key_path;

    if (!convert_path_to_key(lookup_path, key_path)) {
        
        return false;
    }

    const_path2direlemp_table_itr entry = path_table.find(key_path);
    if (entry == path_table.end()) {
        
        return false;

    } else {
        
        dep = new DIRELEM(*entry->second);
    }

    return true;
}







const bool path2direlemp_table::convert_path_to_key(const upath &lookup_path, upath &key_path) const
{
    
    
    
    
    
    if (lookup_path.numelems() < 3) {
        
        return false;
    }

    
    
    ustring first_elem(lookup_path.get(0));
    if (first_elem == "directory") {
        first_elem = "d";
    } else if (first_elem == "file") {
        first_elem = "f";
    } else {
        
        return false;
    }

    
    key_path = upath(first_elem) / lookup_path.slice(1, 2);

    
    return true;
}


bool utar_commands::get_starting_location(const upath &inode_search_path, location &starting_loc, DIRELEMp &dep, const hashcode &roothash) const {
    if (netapp_direlemp_cache.lookup(inode_search_path, dep)) {
        DB->msg("utar_commands::get_starting_location: Returning location from cache for '%s'",
                *inode_search_path.image());
        starting_loc = dep->get_location();
        return true;
    } else {
        starting_loc = location(location::media::gsan, roothash);
        dep = new DIRELEM;
        
        
        return false;
    }
}




















#include "common.h"
#include "debug.h"
#include "restdataproducer.h"
#include "todoelem.h"
#include "context.h"
#include "chunktype.h"
#include "restpipe.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "output.h"
#include "runstage.h"
#include "tunivchunktype.h"
#ifdef USEADE
#include "ade_mgrx.h"
#endif
#include "compelem.h"


#define msg1 ((xflag[1]&0x10)!=0) 
#define msg2 ((xflag[1]&0x20)!=0) 

restdataproducer::restdataproducer(cycle *parent, 
                                   const hashcode& hash_,
                                   const fileoffset& datasize_,
                                   consumer * const callback_,
                                   const bool process_in_order_,
                                   const ustring& msgid_,
                                   const dpns dpninx_)
  : bicycle(parent),
    ADERestore(parent->main),
    tailoffset(0),
    logicaloffset(datasize_),
    buffered(0),
    highwater(0),
    elemlist(NULL),
    requested_hash(hash_),
    datasize(datasize_),
    callback(callback_),
    process_in_order(process_in_order_),
    terminated(false),
    msgid(msgid_),
    dpninx(dpninx_)
{
    assert(NULL != callback);

    if (msg1) DB->msg("restdataproducer for '%s': ::restdataproducer for %s inorder:%d with a %s callback",
                      *msgid, *requested_hash.partialimage(), process_in_order, typeid(*callback).name());

    
    
    elem_t *e = new elem_t(hash_, 0, datasize_);
    restpipe *c = new restpipe(this, requested_hash, 0, e->buf, &e->ctype, dpninx);
    inflight[c] = e;
    nforked++;

    if (process_in_order) {
        elemlist = e;
    }

    c->noop();
}



void restdataproducer::init() {
    assert(false); 
}



void
restdataproducer::spawn_subcycles(elem_t *e)
{
    assert(NULL != e);

    if (msg1) DB->msg("restdataproducer for '%s': ::spawn_subcycles for %s, buffered:%s highwater:%s", 
                      *msgid, *e->image(), *buffered.image(), *highwater.image());

    
    
    
    
    
    
    
    elem_t *prev = e->prev;
    elem_t *firstnew(NULL), *lastnew(NULL);

    fileoffset startbyte = e->startbyte;
    fileoffset lastendoff = 0;
    compelem comp(e->ctype);
    for (int off = 0; off < e->buf.size(); ) {
        bool first = (off == 0);
        comp.init(e->buf, off); 
        bool last = (off >= e->buf.size());

        const hashcode dirComp = comp.gethash();
        const fileoffset dirAtomicStartByte = startbyte + lastendoff;       
        const fileoffset dirAtomicEndByte = startbyte + comp.getendoff();   

        elem_t *tmpe = new elem_t(dirComp, dirAtomicStartByte, dirAtomicEndByte);
        lastendoff = comp.getendoff();

        
        
        bigint64 priority = tmpe->endbyte.value();
        restpipe *child = new restpipe(this, tmpe->h, priority, tmpe->buf, &tmpe->ctype, dpninx);

        std::pair<cycle_to_elem_t::iterator, bool> insert_result = inflight.insert(std::make_pair(child, tmpe));
        assert(insert_result.second == true); 

        if (msg2) DB->msg("restdataproducer::spawn_subcycles inflight %p -> %s, priority %"LL"d, nforked:%d ncollected:%d",
                          child, *tmpe->image(), priority, nforked, ncollected);
        
        if (first) firstnew = tmpe;
        if (last) lastnew = tmpe;

        if (last && (logicaloffset == fileoffset::unknown)) logicaloffset = comp.getendoff();

        
        if (elemlist) {
            tmpe->prev = prev;
            if (prev) prev->next = tmpe;
            
            if (first && elemlist && (prev == NULL)) {
                assert(e == elemlist);
                elemlist = tmpe;
            }
            
            if (last) {
                tmpe->next = e->next;
                if (e->next) e->next->prev = tmpe;
            }
            
            prev = tmpe;
        }

        child->noop();
        nforked++;
    }

    if (elemlist) {
        
        
        
        
        
        
        
        elem_t *P = e->prev;
        elem_t *N = e->next;
        assert(firstnew);
        assert(lastnew);
        assert(firstnew->prev == P);
        if (P) assert(P->next == firstnew);
        assert(lastnew->next == N);
        if (N) assert(N->prev == lastnew);
        
        
        
        if (!P) {
            assert(elemlist == firstnew);
            assert(elemlist != e);
        }
    }

    buffered -= e->buf.size();
    delete e;
}

bool 
restdataproducer::flushable(elem_t *e)
{
    if (NULL == e) return false;

    if (terminated) {
        return e->done;
    }

    return (e->done && (tailoffset == e->startbyte));
}

restdataproducer::elem_t*
restdataproducer::remove_elem(elem_t *p)
{
    if (!p) return NULL;

    elem_t *prev, *next;
    prev = p->prev;
    next = p->next;
    if (prev) prev->next = next;
    if (next) next->prev = prev;
    if (elemlist == p) {
        assert(prev == NULL);
        elemlist = next;
    }
    return next;
}

void
restdataproducer::flush_ready_buffers()
{
    
    
    if (terminated) {
        if (msg1) DB->msg("flush_ready_buffers while terminated with elemlist: %s", (elemlist ? *elemlist->image() : "(nil)"));
        elem_t *p = elemlist;
        while (p) {
            if (flushable(p)) {
                elem_t *n = remove_elem(p);
                buffered -= p->buf.size();
                delete p;
                p = n;
            } else {
                p = p->next;
            }
        }

        
        
        return;
    }

    
    if (msg1) DB->msg("flush_ready_buffers with elemlist: %s", (elemlist ? *elemlist->image() : "(nil)"));
    while (!terminated && flushable(elemlist)) {
        
        
        
        elem_t *p = elemlist;
        remove_elem(elemlist);

        assert((p->endbyte == fileoffset::unknown) || (p->buf.size64() == (p->endbyte - p->startbyte)));
        if (msg2) DB->msg("  p %s tailoffset:%s", *p->image(), *tailoffset.image());
        callback->rdpconsume(p->buf, p->startbyte, this);
        tailoffset += p->buf.size();
        buffered -= p->buf.size();
        delete p;
    }

    if (msg1) DB->msg("  out of while loop with elemlist %s tailoffset:%s", 
                      (elemlist ? *elemlist->image() : "NULL"), *tailoffset.image());
}

void 
restdataproducer::process_data(elem_t *e)
{
    assert(NULL != e);

    if (msg1) DB->msg("restdataproducer for '%s': ::process_data for %s tailoffset:%s, buffered:%s highwater:%s", 
                      *msgid, *e->image(), *tailoffset.image(), *buffered.image(), *highwater.image());

    
    if (elemlist) {
        assert(tailoffset <= e->startbyte);

        if (tailoffset == e->startbyte) {
            assert(elemlist == e);
            assert(e->prev == NULL);
        }

        flush_ready_buffers();
    } else {
        assert(e->prev == NULL);
        assert(e->next == NULL);

        if (!terminated) {
            callback->rdpconsume(e->buf, e->startbyte, this);
        } else {
            
        }

        buffered -= e->buf.size();
        delete e;
    }
}


void
restdataproducer::check_elemlist() const
{
    const elem_t *e = elemlist;
    while (NULL != e) {
        if (! (e->startbyte < e->endbyte)) {
            Out->msg(ERR, "e->startbyte must be less than e->endbyte: %s", *e->image());
        }
        if (e->done && (e->buf.size64() != (e->endbyte - e->startbyte))) {
            Out->msg(ERR, "e->done means buf size must == (end -- start): %s", *e->image());
        }
        if (e->next && (e->endbyte != e->next->startbyte)) {
            Out->msg(ERR, "e->end must == e->next->start: %s, %s", *e->image(), *e->next->image());
        }
        e = e->next;
    }
}

void restdataproducer::childdone(cycle *child) {
    if (child) ncollected++;
    restpipe *rdpchild = dynamic_cast<restpipe*>(child);
    if (NULL == rdpchild) {
        set_error(true, ustring::sprintf("restdataproducer for '%s': child cycles must be restpipe objects",
                                         *msgid));
        if (nforked == ncollected) notifyparent();
        return;
    }

    cycle_to_elem_t::iterator iter(inflight.find(rdpchild));
    if (iter == inflight.end()) {
        set_error(true, ustring::sprintf("restdataproducer for '%s': got childdone %p, but no entry exists for that child in our inflight table", 
                                         *msgid, rdpchild));
        if (nforked == ncollected) notifyparent();
        return;
    }

    elem_t *e = iter->second;
    inflight.erase(iter);
    if (NULL == e) {
        set_error(true, ustring::sprintf("restdataproducer for '%s': found entry in inflight for child cycle %p, but the elem_t* in the entry is NULL", 
                                         *msgid, rdpchild));
        if (nforked == ncollected) notifyparent();
        return;
    }
    buffered += e->buf.size();
    if (buffered > highwater) highwater = buffered;
    e->done = true;

    if (terminated) {
        if (msg1) DB->msg("restdataproducer for '%s': ::childdone terminated, so ignoring %s bytes of %s data from child %p",
                          *msgid, *e->buf.size64().image(), (e->ctype.is_anycomposit()?"composit":"atomic"), child);
        buffered -= e->buf.size();
        remove_elem(e);
        delete e;
    } else {
        if (e->ctype.is_anycomposit()) {
            spawn_subcycles(e);
        } else {
            process_data(e);
        }
    }

    
    

    if (nforked == ncollected) {
        flush_ready_buffers();

        if (msg1) DB->msg("restdataproducer for '%s': ::childdone, has nforked == ncollected == %d, elemlist:%p buffered:%s highwater:%s", 
                          *msgid, nforked, elemlist, *buffered.image(), *highwater.image());
        if (inflight.size() != 0) {
            set_error(true, ustring::sprintf("restdataproducer for '%s': all spawned cycles are complete, but we still have cycle->elemlist entries in our inflight map",
                                             *msgid));
            
        }
        if (NULL != elemlist) {
            set_error(true, ustring::sprintf("restdataproducer for '%s': all spawned cycles are complete, but we have unflushed buffer elements", *msgid));
            for (elem_t *tmp = elemlist; tmp!=NULL; tmp = tmp->next) {
                DB->msg("    %s", *tmp->image());
            }
        }
        notifyparent();
    }
}




restdataproducer::~restdataproducer() 
{
    if (msg1) DB->msg("restdataproducer for '%s': ::~restdataproducer %p buffered:%s highwater:%s inflight.size():%"Z"d",
                      *msgid, this, *buffered.image(), *highwater.image(), inflight.size());
    while (! inflight.empty()) {
        cycle_to_elem_t::iterator i(inflight.begin());
        DB->msg("  %p -> %s", i->first, *(i->second->image()));
        delete i->second;
        inflight.erase(i);
    }
}

void restdataproducer::terminate()
{
    if (!terminated) {
        if (msg1) DB->msg("restdataproducer for '%s': ::terminate for %p with buffered:%s highwater:%s inflight.size():%"Z"d",
                          *msgid, this, *buffered.image(), *highwater.image(), inflight.size());
        terminated = true;
        flush_ready_buffers();
    }
}

#if !defined(REPLCOMP_H_INCLUDED)
#define REPLCOMP_H_INCLUDED












#include "cycle.h"


class replcomp : public replcycle {
public:
    replcomp(replcycle *parent, hashcode& myhash, fileref& listing,
             const bool can_cancel, const chunktype ctype,
             const ustring& name, const epoch_t filetime, const int traverse_depth,
             workelem* info, const bool search_sysinfo=false);
    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~replcomp();
    SAFEPOOLALLOC(replcomp);
private:
    hashcode& myhash;
    fileref& listing;
    fileref listingnew;  
    int nextoffnew;
    const bool can_cancel;
    const chunktype ctype;
    const ustring name;
    const epoch_t filetime;
    const int traverse_depth;

    int childcount;
    bool modified_data;

    int computedoff;
    fileoffset computed_lastoff;
    bool spawn_sysinfo;
    const bool search_sysinfo;

};

#endif
#if !defined(AXIONFS_DIRELEM_H_INCLUDED)
#define AXIONFS_DIRELEM_H_INCLUDED












#include <map>

#include <sys/types.h>
#include <sys/stat.h>

#include "common.h"
#include "platform.h"
#include "direlem.h"
#include "fileref.h"

#define USE_FULLPATH 0   

class context;


class axionfsDIRELEM : public DIRELEM {
public:
    axionfsDIRELEM(context *main_);
    axionfsDIRELEM(const DIRELEM& direlem);
    ~axionfsDIRELEM();

    axionfsDIRELEM *enter(const ustring &name, bool is_dir, mode_t mode);

    void write(const fileref &data, bool ismetadata=false);
    int truncate(off_t size);
    int close(bool ismetadata=false);
    struct stat64 stat() const { return statbuf; }

    int mknod(const ustring &filename, mode_t mode) { if (!is_directory()) return -ENOENT; enter(filename, false, mode); return 0; }
    int mkdirr(const ustring &dirname, mode_t mode) { if (!is_directory()) return -ENOENT; enter(dirname, true, mode); return 0; }
    int symlink(const ustring &name, const ustring &linkto);

    int chmod(mode_t mode) { return 0; }
    int chown(uid_t uid, gid_t gid) { return 0; }
    int rename(const char *to) { return 0; }

    int unlink(const char *target) { return 0; }
    int rmdir(const char *target) { return 0; }

    void keys(undoo::vector<ustring>& res) const;
    axionfsDIRELEM *lookup(const ustring& name);

    void set_fullpath(const ustring& path);
    const ustring fullpath() const;

    void set_hasmetadata() { hasmetadata = true; }
    bool get_hasmetadata() const { return hasmetadata; }

    
    void dump_image(int depth) const;

    SAFEPOOLALLOC(axionfsDIRELEM);

 private:
    bool initfrommetadata();
    bool initfromdefaults();

    
    DEFINE_STL_MAP_TYPE(ustring, axionfsDIRELEM *) subnodes; 

    context *main; 

    
    
    fileref contents;
    struct stat64 statbuf;

    
    
    
    fileref metadata;
    bool hasmetadata;
};

#endif





















#include "common.h"
#include "debug.h"
#include "restpipe.h"
#include "restdata.h"
#include "todoelem.h"
#include "context.h"
#include "ade_mgrx.h"

#define RESTPIPE_DEBUGMSG ((xflag[11]&1)!=0)



restpipe::restpipe(bicycle *parent_,
                   const hashcode& hash,     
                   bigint64 cycle_priority_, 
                   fileref& resdata,         
                   chunktype* ctypep_,      
                   const dpns dpninx_)
    : bicycle(parent_),
      ADERestore(parent_->main),
      ctypep(ctypep_),
      blockProvider(NULL),
      adeMgr(NULL)
{
    if (parent_->main->ADEChunkerEnabled()) adeMgr = parent_->main->getAdeMgr();

    dataProvider.setup(this, this);
    
    this->hash = hash;
    this->info.data = resdata;
    
    this->info.startbyte = 0;
    this->info.endbyte   = 0;
    this->info.checkrange = false;
    this->info.rawmode = true;
    this->info.dpninx = dpninx_;
    
    if(RESTPIPE_DEBUGMSG) DB->msg("restpipe::restpipe name:'%s' start:%.0f endbyte:%.0f  to-stdout:%d",
            *this->info.direlem.fullpath().image(), info.startbyte.dvalue(), info.endbyte.dvalue(), flags.to_stdout);

    
    todoEnqueueInsert(TODO_CHUNK, this, cycle_priority_);
}

restpipe::restpipe(bicycle *parent_, const hashcode& hash, fileref& resdata, bool todo_chunk_priority,
                   fileoffset startoff, fileoffset endoff, bool rawmode, chunktype *ctypep_, const dpns dpninx_)
  : bicycle(parent_),
    ADERestore(parent_->main),
    ctypep(ctypep_),
    blockProvider(NULL),
    adeMgr(NULL)
{
    if (parent_->main->ADEChunkerEnabled()) adeMgr = parent_->main->getAdeMgr();

    dataProvider.setup(this, this);
    
    this->hash = hash;
    this->info.data = resdata;
    
    this->info.startbyte = startoff;
    this->info.endbyte   = endoff;
    this->info.checkrange = this->info.endbyte > fileoffset(0);
    this->info.rawmode = rawmode;       
    this->info.dpninx = dpninx_;
    
    if(adeMgr != NULL && this->info.checkrange) {    
        blockProvider = new BlockProvider(cycle::main);
        blockProvider->setup(this, this);
    }
    if(RESTPIPE_DEBUGMSG) DB->msg("restpipe::restpipe name:'%s' start:%.0f endbyte:%.0f  to-stdout:%d",
            *this->info.direlem.fullpath().image(), info.startbyte.dvalue(), info.endbyte.dvalue(), flags.to_stdout);

    
    todoEnqueue(todo_chunk_priority?TODO_CHUNK:TODO_FILE, this); 
};




restpipe::restpipe(bicycle *parent_, fileref& resdata, const DIRELEM* direlem, bool todo_chunk_priority,
		   const fileoffset startoff, const fileoffset endoff, ucontainer::basep containerp, const dpns dpninx_)
  : bicycle(parent_),
    ADERestore(parent_->main),
    ctypep(NULL),
    blockProvider(NULL),
    adeMgr(NULL)
{
    if (parent_->main->ADEChunkerEnabled()) adeMgr = parent_->main->getAdeMgr();

    dataProvider.setup(this, this);
    
    this->hash = direlem->file_hash();
    
    this->info.direlem = *direlem;
    this->info.data = resdata;
    
    this->info.startbyte = startoff;
    this->info.endbyte   = endoff;
    this->info.checkrange = this->info.endbyte > fileoffset(0);
    this->info.rawmode = false;
    this->info.path = direlem->fullpath(); 
    this->info.container = containerp;
    this->info.dpninx = dpninx_;
    
    if(adeMgr != NULL && this->info.checkrange) {    
        blockProvider = new BlockProvider(cycle::main);
        blockProvider->setup(this, this);
    }
    if(RESTPIPE_DEBUGMSG) DB->msg("restpipe::restpipe name:'%s' start:%.0f endbyte:%.0f to-stdout:%d containerp:%s",
        *this->info.direlem.fullpath().image(), info.startbyte.dvalue(), info.endbyte.dvalue(), flags.to_stdout, (containerp.isnull()? "NULL" : "defined"));
    
    todoEnqueue(todo_chunk_priority?TODO_CHUNK:TODO_FILE, this); 
}




restpipe::~restpipe()
{
    if(blockProvider != NULL) {
        delete blockProvider;
        blockProvider = NULL;
    }
}

void restpipe::init() {
    if(adeMgr != NULL) {
        
        
        
        
        if(blockProvider != NULL) {
            const bigint64 startOffset = info.startbyte.value();
            const bigint64 firstblockSize(info.endbyte.value() - this->info.startbyte.value() + 1); 
            blockProvider->getChangeBlockData(info, hash, startOffset, firstblockSize, 128*1024);
            if(RESTPIPE_DEBUGMSG) DB->msg( "restpipe::init() '%s' offset=%s, block size=%s", *info.direlem.fullpath().image(), *tostr(startOffset), *tostr(firstblockSize));
        }
        else {
            dataProvider.getFileData(hash, info);
        }
    } else {
        cycle *child;
        bool isatomic = false;  
        const location loc(info.direlem.get_location());
        bool use_container(false);

        
        
        
        
        
        
        
        
        
        
        if ( info.direlem.file_hash() == hashcode::zero &&
            loc.getMedia() > location::media::gsan &&
            !loc.isFromCatalog()
            ) {
             use_container=true;
        }

        
        if(use_container && !info.container.isdefined()) {
            info.container = main->open_container_for_read(loc);
            if(info.container.isnull()) {
                DB->msg("restpipe::init failed to open container for %s", loc.image().tostr());
                set_error(true, "Failed to open container for read: NULL container");
                notifyparent();
                return;
            }
        }
        if(RESTPIPE_DEBUGMSG) DB->msg("restpipe::init creating restdata, use_container=%s", use_container?"true":"false");
        child = new restdata(this, hash, ctypep, isatomic, info, use_container);
    }
}





void restpipe::handleData(fileoffset offset, fileref& restoreData)
{
    assert(adeMgr != NULL);
    info.exportdata(offset, restoreData); 
    main->addprogbytes(context::restorestats, restoreData.size());
}





void restpipe::handleBlockData(fileoffset offset, fileref& restoreData)
{
    assert(adeMgr != NULL);
    if(RESTPIPE_DEBUGMSG) DB->msg( "restpipe::handleBlockData() '%s', offset=%"LL"d, size=%d", *info.direlem.fullpath().image(), offset.value(), restoreData.size());
    
    
    
    const fileoffset newOffset = offset - info.startbyte.value();
    info.exportdata(newOffset, restoreData); 
    main->addprogbytes(context::restorestats, restoreData.size());
}






void restpipe::blockDataComplete(bigint64 startOffset)
{
    assert(adeMgr != NULL);
    if(RESTPIPE_DEBUGMSG) DB->msg( "restpipe::blockDataComplete() '%s', offset=%"LL"d", *info.direlem.fullpath().image(), startOffset);
    blockProvider->closeInstance();
    childdone(NULL);
}





void restpipe::childdone(cycle *child) {
    if(has_error())
        DB->msg("restpipe childdone, error=%d\n", has_error());

    notifyparent();
}





void restpipe::setErrorResponse(msgerrors lastError_)
{
    this->set_error(true, "");
    DB->msg( "restpipe::setErrorResponse() -- restore error, returned data is corrupted. '%s'", *info.direlem.fullpath().image());
    notifyparent(); 
}

















#include "common.h"
#include "debug.h"
#include "output.h"
#include "repldata.h"
#include "repldir.h"
#include "replcomp.h"
#include "msgpack_c.h"
#include "backstate.h"
#include "hash_cache.h"
#include "filename_cache.h"
#include "timer.h"
#include "statistic.h"
#include "runstage.h"
#include "ade_mgrx.h"
#include "compelem.h"
#include "workelem.h"

#define repldata_dbmsg ((xflag[19]&8) != 0)

#define SRC_DPN dpn0
#define DST_DPN dpn1


#define DST_IS_PRESENT 1
#define SRC_GET_DATA 2
#define DST_ADD_DATA 3

static statistic p_cachehit;
static statistic f_cachehit;
static statistic ispresentmiss;
static statistic ispresenthit;
static statistic getdata;
static statistic adddata;

void repldata::report() {
    Out->msg(STATS, "<6154>Replication timing statistics:");
    Out->msg(STATS, "<6155>   hashcache hit     %s", *p_cachehit.ximage());
    Out->msg(STATS, "<7677>   rechunkcache hit  %s", *f_cachehit.ximage());
    Out->msg(STATS, "<6156>   dst ispresenthit  %s", *ispresenthit.ximage());
    Out->msg(STATS, "<6157>   dst ispresentmiss %s", *ispresentmiss.ximage());
    Out->msg(STATS, "<6158>   src getdata       %s", *getdata.ximage());
    Out->msg(STATS, "<6159>   dst adddata       %s", *adddata.ximage());
}



















repldata::repldata(replcycle *parent, const hashcode& hash_, const int sliceoff_,
                   const bool can_cancel_, const double rsize_, const ustring& name_,
                   chunktype ctype_, const epoch_t filetime_, const int traverse_depth_,
                   workelem* info_, cycle* starter, const bool destroy_workelem_,
                   bool search_sysinfo_, replroot* rootcycle_)
  : replcycle(parent, NULL, info_),
    rhash(hash_),
    oldhash(hash_),
    can_cancel(can_cancel_),
    rsize(rsize_),
    name(name_),
    ctype(ctype_),   
    filetime(filetime_),
    traverse_depth(traverse_depth_),
    starttime(0.0),
    destroy_workelem(destroy_workelem_),
    search_sysinfo(search_sysinfo_),
    rootcycle(rootcycle_),
    sysinfo_comp_off(sliceoff_)
{
    this->offset = fileoffset(sliceoff_);       
    if(repldata_dbmsg) {
        const ustring in_sysinfo(migration_sysinfo_write ? "(in .system_info)" : "");
        Out->msg(INFO, "<7916>repldata::repldata%s - The hashoff (or this->offset) = %s with sliceoff_ = %d, "
                       "traverse_depth = %d, atomic_depth = %d, name = %s, search_sysinfo = %d",
                        in_sysinfo.tostr(), *((this->offset).image()), sliceoff_, traverse_depth, getAtomicDepth(), *name, search_sysinfo);
    }
    this->hash = hashcode::empty;               
    phase = 0;
    redocount = 0;
    composit_size = 0;

    
    
    if(flags.reportonly && parent && (traverse_depth == 0) && (getAtomicDepth() < 0) && (xflag[19]&32768)==0)
        count_atomic_depth = true;

    
    if(starter)
        starter->setnext(TODO_CHUNK, this, -traverse_depth);
    else
        main->add_insert(TODO_CHUNK, this, -traverse_depth);         
}

void repldata::init() {
    
    hash_cache *hashes = main->state->hashes;
    
    if(!migration_sysinfo_write && hashes != NULL && hashes->is_present_and_update_tag(rhash, getThreadNbr())) {
        
        
        
      bool ddr_to_ddr_data = (ddrindexfrombackup > 0) &&  
	                     (flags.destination_data == client_config_flags::same_destination) &&  
	                     !name.equal(UNDOO_DIRECTORY_NAME);  
        if(xflag[19]&64)DB->msg("replicate::init(): - cache says rhash %s is on target", *rhash.partialimage());
        if(!ddr_to_ddr_data) {  
            update_stats(context::backupstats, stats::hashcache, chunktype::atomic, rsize);
            update_stats(context::restorestats, stats::hashcache, chunktype::atomic, rsize);
        }
        hash = rhash;
        if(repldata_dbmsg)DB->msg(DBTXT("repldata::init() - rhash(hash) = %s, rsize = %f"), *rhash.partialimage(), rsize);
        notifyparent();
        p_cachehit.enter(0);
        return;
    }

    
    
    
    
    if(can_cancel && !uapp::staging().canRun()) {
        if(repldata_dbmsg) DB->msg("repldata: Cancelling rhash %s, returning hash %s", *rhash.partialimage(), *hash.partialimage());
        notifyparent();
        return;
    }

    phase = DST_IS_PRESENT;
    message m;
    msgpack_c::hashispresent hip(m);
    hip.arg(PACK, rhash);
    starttime = timer::now();
    
    if (flags.ignoreispresent || info->rechunk || migration_sysinfo_write) {
        m.setresponse(MSG_ERR_MISC);
        m.setthread(DST_DPN);
        response(m);
        return;
    }
    main->getAdeMgr()->remoteAsyncCall(m, this, DST_DPN);
}

void repldata::send_get_data(hashcode &hash)
{
    phase = SRC_GET_DATA;
    message m;
    msgpack_c::gethashdata ghd(m);
    int userid = 0;  
    time_t prefetchtime = 0;  
    ghd.arg(PACK, hash, userid, prefetchtime);
    main->getAdeMgr()->remoteAsyncCall(m, this, SRC_DPN);
}

void repldata::show_data(fileref &data, const ustring &msg, hashcode &computed_hash)
{
    if (DB->messages_on) {
        DB->msg(DBTXT("%s (addr "PTRINTFMT", requested %s, actual %s, %d bytes)"), *msg, (ptrint)data.start(), *rhash.partialimage(), *computed_hash.partialimage(), data.size());
        data.hexdump(true);
        DB->msg(" ");
    }

}

void repldata::response(message& outargs) {
    
    bool ddr_to_ddr_data = (ddrindexfrombackup > 0) &&  
                           (flags.destination_data == client_config_flags::same_destination) &&  
                           !name.equal(UNDOO_DIRECTORY_NAME);  
    switch(phase) {
    case DST_IS_PRESENT: {
        
        if(outargs.isgoodresponse()) {
            ispresenthit.enter(timer::now() - starttime);
            if(main->state->hashes != NULL) {
                
                
                
	        if(xflag[19]&64)DB->msg("replicate::response(): - save rhash %s to main->state->hashes", *rhash.partialimage());
                if(DIRELEM::is_recent(filetime) || ctype.is_dir() || ctype.is_anycomposit() || flags.reportonly)
                    main->state->hashes->enter(rhash, getThreadNbr());
            }
            
            
            
            if(!ddr_to_ddr_data) {  
                update_stats(context::backupstats, stats::ispresent, chunktype::atomic, rsize);
                update_stats(context::restorestats, stats::ispresent, chunktype::atomic, rsize);
            }
            hash = rhash;
            if(repldata_dbmsg)DB->msg(DBTXT("repldata::response() DST_IS_PRESENT - rhash(hash) = %s, rsize = %f"), *rhash.partialimage(), rsize);
            notifyparent();
            return;
        }

        if(flags.reportonly && (traverse_depth == getAtomicDepth()) && !count_atomic_depth && ((xflag[19]&32768)==0)) {
            update_stats(context::backupstats, stats::sent, chunktype::atomic, rsize);
            update_stats(context::restorestats, stats::sent, chunktype::atomic, rsize);
            hash = rhash;
            if(main->state->hashes)
                main->state->hashes->enter(rhash, getThreadNbr());
            if(repldata_dbmsg)DB->msg(DBTXT("repldata::response() reportonly - rhash(hash) = %s"), *rhash.partialimage());
            notifyparent();
            return;
        }

        if(outargs.getthread() != DST_DPN) {
            set_error(true, ustring::sprintf(DBTXT("bad dpnindex in repldata DST_IS_PRESENT: %d"), outargs.getthread()));
            notifyparent();
            return;
        }
        ispresentmiss.enter(timer::now() - starttime);
        starttime = timer::now();
        send_get_data(rhash);
        break;
    }
    case SRC_GET_DATA: {
        getdata.enter(timer::now() - starttime);
        if(outargs.iserrorresponse()) {
	    msgerrors err=outargs.responsecode();
            if ((err == MSG_ERR_TIMEOUT)||(err == MSG_ERR_CANCEL)) {
                set_error(true, ustring::sprintf(DBTXT("aborting repldata SRC_GET_DATA: %s %s"), *outargs.ximage(), *name));
                uapp::staging().startTermination(EXIT_MISC, "aborting repldata in SRC_GET_DATA");
            }
            else
                set_error(true, ustring::sprintf(DBTXT("bad response in repldata SRC_GET_DATA: %s"), *outargs.ximage()));
            notifyparent();
            return;
        }
        if(outargs.getthread() != SRC_DPN) {
            set_error(true, ustring::sprintf(DBTXT("bad dpnindex in repldata SRC_GET_DATA: %d"), outargs.getthread()));
            notifyparent();
            return;
        }

        msgpack_c::gethashdata ghd(outargs);
        int cachelevel;   
        ghd.res(UNPACK, ctype, data, cachelevel);

        
        hashcode chash(data);
        if(repldata_dbmsg)DB->msg(DBTXT("repldata::response() SRC_GET_DATA - compare rhash = %s with chash(data): %s. ctype = %s"), *rhash.partialimage(), *chash.partialimage(), *ctype.image());
        if (chash != rhash || redocount) {
            DB->msg(DBTXT("GET_HASH_DATA: redo:%d kind:%s data=%p size:%d  computed %s, requested %s, msg.hash %s"),
                    redocount, *ctype.image(), data.start(), data.size(), *chash.partialimage(), *rhash.partialimage(), *outargs.body().hash.partialimage());

            if (chash != rhash) {
                Out->msg(WARN, "<6428>Retrieved incorrect data from source: redo:%d kind:%s size:%d  computed %s, requested %s, msg.hash %s",
                         redocount, *ctype.image(), data.size(), *chash.partialimage(), *rhash.partialimage(), *outargs.body().hash.partialimage());
                show_data(data, "Incorrect data", chash);
                if (++redocount <= REDOLIMIT) {
                    starttime = timer::now();
                    send_get_data(rhash);                       
                    break;
                }
                set_error(true, ustring::sprintf(DBTXT("Computed hash does not equal requested hash (redo:%d, kind:%s, size:%d, requested=%s, chash=%s) (%s)"),
                                                 redocount, *ctype.image(), data.size(), *chash.partialimage(), *rhash.partialimage(), *name));
                childdone(NULL);
                return;
            }
            show_data(data, "Correct data", chash);
        }
        
        if(!ddr_to_ddr_data) update_stats(context::restorestats, stats::sent, ctype, data.size());

        if(ctype.is_anycomposit()) {
            cycle *child;
            if(flags.pluginid.kind() == pidtype::migrate) {
                child = new replcomp(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info, search_sysinfo); 
            } else {
                child = new replcomp(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info); 
            }
            child->noop();
        } else if(ctype.is_dir_atomic()) {
            cycle* child;
            if(info->rechunk) {
                if(flags.pluginid.kind() == pidtype::migrate) {
                    
                    
                    if((traverse_depth == 0) && (rootcycle)) {
                        DB->msg("Root hash is atomic, set comp_root_hash to false to NOT search .system_info.");
                        search_sysinfo = false; 
                        rootcycle->set_comp_root_hash(false);
                        child = new migratedir(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info, sysinfo_comp_off); 
                    } else {
                        child = new migratedir(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info, sysinfo_comp_off, search_sysinfo); 
                    }

                } else {
                    child = new migratedir(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info); 
                }

                if(repldata_dbmsg) DB->msg("repldata::response SRC_GET_DATA - create child %p of migratedir, rhash = %s, name = %s",
                                           child, *rhash.partialimage(), *name);
            }
            else
                child = new repldir(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info);   
            child->noop();

        } else {
            if(ctype.is_extatomic() && flags.reportonly && count_atomic_depth && ((xflag[19]&32768)==0)) {
                setAtomicDepth(traverse_depth);   
                count_atomic_depth = false;       
                DB->msg(DBTXT("repldata::response() max atomic depth = %d"), traverse_depth);
            }
            childdone(NULL);
        }
        break;
    }
    case DST_ADD_DATA: {
        adddata.enter(timer::now() - starttime);
        msgerrors err = outargs.responsecode();
        if(err != MSG_ERR_NONE && err != MSG_ERR_UNNECESSARY) {
            if ((err == MSG_ERR_TIMEOUT) || (err == MSG_ERR_CANCEL)) {
                set_error(true, ustring::sprintf(DBTXT("aborting repldata DST_ADD_DATA: %s %s"), *outargs.ximage(), *name));
                uapp::staging().startTermination(EXIT_MISC, "aborting repldata in DST_ADD_DATA");
            }
            else
                set_error(true, ustring::sprintf(DBTXT("bad response in repldata DST_ADD_DATA: %s %s"), *outargs.ximage(), *name));
            notifyparent();
            return;
        }
        if(outargs.getthread() != DST_DPN) {
            set_error(true, ustring::sprintf(DBTXT("bad dpnindex in repldata DST_ADD_DATA: %d"), outargs.getthread()));
            notifyparent();
            return;
        }
        
        
        if(!ddr_to_ddr_data) update_stats(context::backupstats, stats::sent, ctype, data.size());

        
        if(uapp::staging().canRun() && !has_error() && rhash != hashcode::empty && (ctype.is_anycomposit() || ctype.is_dir_atomic())) {
            if(main->state->hashes) main->state->hashes->enter(rhash, getThreadNbr());
        }

        hash = rhash;           
        if(ctype.is_anycomposit() && ctype.is_dir() && info->rechunk)  
            size = composit_size;
        else
            size = data.size();

        if(repldata_dbmsg)DB->msg("repldata::response() DST_ADD_DATA - rhash(hash) = %s, size = %d", *rhash.partialimage(), size.ivalue());
        notifyparent();
        break;
    }
    default:
        set_error(true, ustring::sprintf("bad case in repldata: %d", phase));
        notifyparent();
        return;
    }
}

void repldata::childdone(cycle *child) {
    if(phase != SRC_GET_DATA) {
        set_error(true, ustring::sprintf("bad phase in repldata childdone: %d", phase));
        DB->msg("repldata::childdone return because of phase != SRC_GET_DATA");
        notifyparent();
        return;
    }
    if(has_error()) {
        
        DB->msg("repldata::childdone return because of error");
        notifyparent();
        return;
    }
    if(info->rechunk && ((unsigned int)data.size() > main->getmaxchunksize(DST_DPN, ctype))) {
        set_error(true, ustring::sprintf("chunk too large in repldata childdone: maxsize=%u chunksize=%u, ctype=%s",
                                         main->getmaxchunksize(DST_DPN, ctype), data.size(), *ctype.image()));
        DB->msg("repldata::childdone return because of rechunk or data.size too big %d", data.size());
        notifyparent();
        return;
    }

    
    if(search_sysinfo && (flags.pluginid.kind() == pidtype::migrate)) {
        DB->msg("repldata::childdone search childdone, notify parent");
        notifyparent();
        return;
    }


    if(flags.reportonly){
        update_stats(context::backupstats, stats::sent, ctype, data.size());
        hash = rhash;
        if(main->state->hashes) {
            main->state->hashes->enter(rhash, getThreadNbr());
            if(xflag[19]&64)DB->msg("replicate::childdone(): - save rhash %s to main->state->hashes.", *rhash.partialimage());
        }
        if(parent && (traverse_depth > 0) && ((xflag[19]&32768)==0)) {
	        ((replcycle*)parent)->setAtomicDepth(getAtomicDepth());
        }

        if(repldata_dbmsg)DB->msg("repldata::childdone return because of reportonly. max atomic depth = %d, \"datasize = %d, rsize = %f\"", getAtomicDepth(), data.size(), rsize);
        notifyparent();
        return;
    }

    if(repldata_dbmsg) DB->msg("repldata::childdone ctype = %s ckind = %d, child = %p, rhash = %s, name = %s, rechunk = %s datasize = %s",
                                *ctype.image(), ctype.ckind(), child, *rhash.partialimage(), *name, info->rechunk?"true":"false", tostr(data.size()).tostr());
    if(ctype.is_anycomposit() && info->rechunk)  {  
        chunktype ctypenew = chunktype::recipe8;    
        if(ctype.is_dir()) {
            ctypenew.set_dir();
            composit_size = child->size.ivalue();
        }
        ctype = ctypenew;
    }
    
    phase = DST_ADD_DATA;
    message m;
    msgpack_c::addhashdata ahd(m);
    ahd.arg(PACK, rhash, ctype, data);
    starttime = timer::now();
    main->getAdeMgr()->remoteAsyncCall(m, this, DST_DPN);
}

repldata::~repldata() {
    if(info && destroy_workelem) {    
        delete info;
        info = NULL;
    }
}





void replreportdata::report() {
  Out->msg(STATS, "<11124>Replication report timing statistics:");
  Out->msg(STATS, "<6155>   hashcache hit     %s", *p_cachehit.ximage());
  Out->msg(STATS, "<6158>   src getdata       %s", *getdata.ximage());
}











replreportdata::replreportdata(replcycle *parent, const hashcode& hash_, const int sliceoff_,
			       const bool can_cancel_, const double rsize_, const ustring& name_,
			       chunktype ctype_, const epoch_t filetime_, const int traverse_depth_,
                   workelem* info_, bool destroy_workelem)
  : replcycle(parent, NULL, info_),
    rhash(hash_),
    can_cancel(can_cancel_),
    rsize(rsize_),
    name(name_),
    ctype(ctype_),   
    filetime(filetime_),
    traverse_depth(traverse_depth_),
    starttime(0.0),
    destroy_workelem(destroy_workelem)
{
    this->offset = fileoffset(sliceoff_);       
    if(repldata_dbmsg)DB->msg(DBTXT("replreportdata::replreportdata() - The hashoff (or this->offset) = %f with sliceoff_ = %d, traverse_depth = %d, atomic_depth = %d"),
                                   ((this->offset).dvalue()), sliceoff_, traverse_depth, getAtomicDepth());
    this->hash = hashcode::empty;               
    phase = 0;
    redocount = 0;
    childcount = 0;
    ghi_available = (main->getdpnmaxmessage(dpn0) >= GET_HASH_INFO) && ((xflag[19]&2097152)==0);

    
    
    if(parent && (traverse_depth == 0) && (getAtomicDepth() < 0) && (xflag[19]&32768)==0)
        count_atomic_depth = true;

    
    main->add_insert(TODO_CHUNK, this, -traverse_depth);         
}





void replreportdata::init() {
    
    hash_cache *hashes = main->state->hashes;
    if(hashes != NULL && hashes->is_present_and_update_tag(rhash, getThreadNbr())) {
        
        
        
        if(xflag[19]&64)DB->msg("replreportdata::init(): - cache says rhash %s is on target", *rhash.partialimage());
        update_stats(context::backupstats, stats::hashcache, chunktype::atomic, rsize);
        update_stats(context::restorestats, stats::hashcache, chunktype::atomic, rsize);
        hash = rhash;
        if(repldata_dbmsg)DB->msg(DBTXT("replreportdata::init() - rhash(hash) = %s"), *rhash.partialimage());
        notifyparent();
        p_cachehit.enter(0);
        return;
    }

    
    
    
    
    if(can_cancel && !uapp::staging().canRun()) {
        DB->msg("replreportdata: Cancelling rhash %s, returning hash %s", *rhash.partialimage(), *hash.partialimage());
        notifyparent();
        return;
    }

    phase = DST_IS_PRESENT;
    message m;
    msgpack_c::hashispresent hip(m);
    hip.arg(PACK, rhash);
    starttime = timer::now();
    if (flags.ignoreispresent) {        
        m.setresponse(MSG_ERR_MISC);    
        m.setthread(DST_DPN);
        response(m);
        return;
    }
    main->getAdeMgr()->remoteAsyncCall(m, this, DST_DPN);
}





void replreportdata::send_get_data(hashcode &hash)
{
    phase = SRC_GET_DATA;
    message m;
    if(ghi_available) {
        
        msgpack_c::gethashinfo ghi(m);
        msgpack_c::gethashinfo::flags flg = (msgpack_c::gethashinfo::flags)(ghi.ghi_getcompdetail | ghi.ghi_getatomdetail);
        ghi.arg(PACK, flg, hash);
    }
    else {
        msgpack_c::gethashdata ghd(m);
        int userid = 0;  
        time_t prefetchtime = 0;  
        ghd.arg(PACK, hash, userid, prefetchtime);
    }
    main->getAdeMgr()->remoteAsyncCall(m, this, SRC_DPN);
}

void replreportdata::show_data(fileref &data, const ustring &msg, hashcode &computed_hash)
{
    if (DB->messages_on) {
        DB->msg(DBTXT("%s (addr "PTRINTFMT", requested %s, actual %s, %d bytes)"), *msg, (ptrint)data.start(), *rhash.partialimage(), *computed_hash.partialimage(), data.size());
        data.hexdump(true);
        DB->msg(" ");
    }
}





void replreportdata::response(message& outargs) {
    switch(phase) {
    case DST_IS_PRESENT: {
        
        if(outargs.isgoodresponse()) {
            ispresenthit.enter(timer::now() - starttime);
            if(main->state->hashes != NULL) {
                
                
                
                if(xflag[19]&64)DB->msg("replreportdata::response(): - save rhash %s to main->state->hashes", *rhash.partialimage());
                if(DIRELEM::is_recent(filetime) || ctype.is_anycomposit())
                    main->state->hashes->enter(rhash, getThreadNbr());
            }
            
            
            
            update_stats(context::backupstats, stats::ispresent, chunktype::atomic, rsize);
            update_stats(context::restorestats, stats::ispresent, chunktype::atomic, rsize);
            hash = rhash;
            if(repldata_dbmsg)DB->msg(DBTXT("replreportdata::response() DST_IS_PRESENT - rhash(hash) = %s"), *rhash.partialimage());
            notifyparent();
            return;
        }

        if(outargs.getthread() != DST_DPN) {
            set_error(true, ustring::sprintf(DBTXT("bad dpnindex in replreportdata DST_IS_PRESENT: %d"), outargs.getthread()));
            notifyparent();
            return;
        }

        
        
        if((traverse_depth == getAtomicDepth()) && !count_atomic_depth && ((xflag[19]&32768)==0) && !ghi_available){
            const unsigned int bit_mask = (1<<flags.capacity_match_bits) - 1;
            hash = rhash;
            if((rhash[0]&bit_mask) == 0) {
	        update_stats(context::backupstats, stats::sent, chunktype::atomic, rsize);
	        update_stats(context::restorestats, stats::sent, chunktype::atomic, rsize);
                if(main->state->hashes)
	            main->state->hashes->enter(rhash, getThreadNbr());
            }
            if(repldata_dbmsg) DB->msg(DBTXT("replreportdata::response() reportonly - rhash(hash) = %s"), *rhash.partialimage());
            notifyparent();
            return;
        }

        ispresentmiss.enter(timer::now() - starttime);
        starttime = timer::now();
        send_get_data(rhash);
        break;
    }
    case SRC_GET_DATA: {
        getdata.enter(timer::now() - starttime);
        if(outargs.iserrorresponse()) {
            msgerrors err=outargs.responsecode();
            if ((err == MSG_ERR_TIMEOUT)||(err == MSG_ERR_CANCEL)) {
	    set_error(true, ustring::sprintf(DBTXT("aborting replreportdata SRC_GET_DATA: %s %s"), *outargs.ximage(), *name));
	    uapp::staging().startTermination(EXIT_MISC, "aborting replreportdata in SRC_GET_DATA");
            }
            else
	        set_error(true, ustring::sprintf(DBTXT("bad response in replreportdata SRC_GET_DATA: %s"), *outargs.ximage()));
            notifyparent();
            return;
        }
        if(outargs.getthread() != SRC_DPN) {
            set_error(true, ustring::sprintf(DBTXT("bad dpnindex in replreportdata SRC_GET_DATA: %d"), outargs.getthread()));
            notifyparent();
            return;
        }

        if(repldata_dbmsg) DB->msg("replreportdata::response() GET_HASH_INFO available = %s, match bit = %d.", ghi_available?"true":"false", flags.capacity_match_bits);
        if(ghi_available && flags.ignoreispresent) {
            
            msgpack_c::gethashinfo ghi(outargs);
            msgpack_c::gethashinfo::resultvect rslts;
            msgpack_c::gethashinfo::flags flg = ghi.ghi_getcompdetail;
            ghi.res(UNPACK, flg, ctype, rslts);
            
            int lastdataoff = 0;
            fileoffset lastsliceoff(0);
            data.free();
            data.initlist(static_cast<int> (rslts.size()*(sizeof(hashcode) + 8)));
            if(repldata_dbmsg) DB->msg("match bit = %d", flags.capacity_match_bits);
            const unsigned int bit_mask = (1<<flags.capacity_match_bits) - 1;
            for(unsigned int i = 0; i< rslts.size(); i++) {
                if(repldata_dbmsg) DB->msg(DBTXT("result item %d, image = %s"), (int)i, *rslts[i].image());
                if(rslts[i].type.is_extatomic() || rslts[i].type.is_atomic()) {
                    
                    if((rslts[i].hash[0]&bit_mask)==0) {
                        hash_cache *hashes = main->state->hashes;
                        if(hashes != NULL) {
                            if(hashes->is_present_and_update_tag(rslts[i].hash, getThreadNbr()))
                                update_stats(context::restorestats, stats::hashcache, rslts[i].type, +(rslts[i].size));
                            else {
                                hashes->enter(rslts[i].hash, getThreadNbr());
                                update_stats(context::restorestats, stats::sent, rslts[i].type, +(rslts[i].size));
                                if(repldata_dbmsg)
                                    DB->msg(DBTXT("result item %d, offset = %d, lastdataoff = %d, result hash %s"),
                                                  (int)i, rslts[i].offset.ivalue(), lastdataoff, *rslts[i].hash.partialimage());
                            }
		        }
                    }
                }
                else if(rslts[i].type.is_anycomposit()){    
                    double chunksize = rslts[i].offset.dvalue() - lastsliceoff.dvalue();
                    lastsliceoff = rslts[i].offset;
                    if(repldata_dbmsg)DB->msg(DBTXT("result item %d, end offset = %f, result hash %s, result type size = %d"),
                                          i, rslts[i].offset.dvalue(), *rslts[i].hash.partialimage(), compelem::getsize(rslts[i].type));
                    cycle *child = new replreportdata(this, rslts[i].hash, lastdataoff, can_cancel, chunksize, name, rslts[i].type, filetime, traverse_depth+1, info);
                    child->noop();
                    childcount++;
                    if(repldata_dbmsg)DB->msg(DBTXT("result item %d, end offset %f, result hash %s, comptype %s"),
                                              i, rslts[i].offset.dvalue(), *rslts[i].hash.partialimage(), *rslts[i].type.image());
                }

                if(ctype.is_anycomposit()) {
                    compelem elem(ctype);
                    elem.sethash(rslts[i].hash);
                    elem.setendoff(rslts[i].offset, false);
                    data.append(elem.getdata());
                    lastdataoff += elem.getdata().size();
                    update_stats(context::restorestats, stats::sent, ctype, elem.getdata().size());
                }
            }
            if(rslts[0].type.is_extatomic() || rslts[0].type.is_atomic()) {    
	        childcount++;
	        childdone(NULL);
            }
            if(repldata_dbmsg) DB->msg(DBTXT("replreportdata::response() SRC_GET_DATA - rhash: %s"), *rhash.partialimage());
        }
        else {
            msgpack_c::gethashdata ghd(outargs);
            int cachelevel;   
            ghd.res(UNPACK, ctype, data, cachelevel);
        }

        if(data.size() == 0)  
            return;

        
        hashcode chash(data);
        if(repldata_dbmsg)DB->msg(DBTXT("replreportdata::response() SRC_GET_DATA - compare rhash = %s with chash(data): %s. ctype = %s"), *rhash.partialimage(), *chash.partialimage(), *ctype.image()\
			      );
        if (chash != rhash || redocount) {
            DB->msg(DBTXT("GET_HASH_DATA: redo:%d kind:%s data=%p size:%d  computed %s, requested %s, msg.hash %s"),
	            redocount, *ctype.image(), data.start(), data.size(), *chash.partialimage(), *rhash.partialimage(), *outargs.body().hash.partialimage());

            if (chash != rhash) {
                Out->msg(WARN, "<6428>Retrieved incorrect data from source: redo:%d kind:%s size:%d  computed %s, requested %s, msg.hash %s",
                               redocount, *ctype.image(), data.size(), *chash.partialimage(), *rhash.partialimage(), *outargs.body().hash.partialimage());
                show_data(data, "Incorrect data", chash);
                if (++redocount <= REDOLIMIT) {
                    starttime = timer::now();
                    send_get_data(rhash);                       
                    break;
                }
                set_error(true, ustring::sprintf(DBTXT("Computed hash does not equal requested hash (redo:%d, kind:%s, size:%d, requested=%s, chash=%s) (%s)"),
                                                 redocount, *ctype.image(), data.size(), *chash.partialimage(), *rhash.partialimage(), *name));
                childdone(NULL);
                return;
            }
            show_data(data, "Correct data", chash);
        }
        
        if(!ghi_available) {
            if(ctype.is_anycomposit()) {
	            update_stats(context::restorestats, stats::sent, ctype, data.size());
	            cycle *child = new replcomp(this, rhash, data, can_cancel, ctype, name, filetime, traverse_depth, info);  
	            child->noop();
            } else {
	        if(ctype.is_extatomic() && count_atomic_depth && ((xflag[19]&32768)==0)) {
	            setAtomicDepth(traverse_depth);   
	            count_atomic_depth = false;       
	            DB->msg(DBTXT("replreportdata::response() max atomic depth = %d"), traverse_depth);
	        }
	        childdone(NULL);
            }
	}
        break;
    }
    default:
        set_error(true, ustring::sprintf(DBTXT("bad case in repldata: %d"), phase));
        notifyparent();
        return;
    }
}

void replreportdata::childdone(cycle *child) {
    if(phase != SRC_GET_DATA) {
        set_error(true, ustring::sprintf(DBTXT("bad phase in replreportdata childdone: %d"), phase));
        DB->msg(DBTXT("replreportdata::childdone return because of phase != SRC_GET_DATA"));
        notifyparent();
        return;
    }
    if(has_error()) {
        
        DB->msg(DBTXT("replreportdata::childdone return because of error"));
        notifyparent();
        return;
    }

    if(!ghi_available || (--childcount == 0)) {
        const unsigned int bit_mask = (1<<flags.capacity_match_bits) - 1;
        if(!ghi_available) {
            if((rhash[0]&bit_mask) == 0)
	        update_stats(context::backupstats, stats::sent, ctype, data.size());
            if(parent && (traverse_depth > 0) && ((xflag[19]&32768)==0))
                ((replcycle*)parent)->setAtomicDepth(getAtomicDepth());
            if(repldata_dbmsg)DB->msg(DBTXT("replreportdata::childdone return because of reportonly. max atomic depth = %d, \"datasize = %d, rsize = %f\""), getAtomicDepth(), data.size(), rsize);
        }
        hash = rhash;
        if(main->state->hashes && ((rhash[0]&bit_mask) == 0)) {
            main->state->hashes->enter(rhash, getThreadNbr());
            if(xflag[19]&64)DB->msg("replreportdata::childdone(): - save rhash %s to main->state->hashes.", *rhash.partialimage());
        }

        DB->msg(DBTXT("replreportdata::childdone call notifyparent(), then return"));
        notifyparent();
    }
    else
        DB->msg(DBTXT("replreportdata::childdone return, but NOT calling notifyparent() childcount = %d."), childcount);
    return;

}

replreportdata::~replreportdata() {
    if(destroy_workelem) {    
        delete info;
        info = NULL;
    }
}


#if !defined(RESTSSLICEFILE_H_INCLUDED)
#define RESTSSLICEFILE_H_INCLUDED












#include "cycle.h"
#include "layout.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "fileoffset.h"
#include "utar_flags_info.h"
#include "hashcode.h"
#include "ade_restore.h"
#include "emctarpipe.h"




class restsslicefile : public bicycle, nsAdeLib::ADERestore {
public:
    restsslicefile(bicycle           *parent,
                   const hashcode&    hash,
                   DIRELEM&           direlem,
                   cycle             *starter = NULL,
                   ucontainer::basep  rest_container = NULL);

    virtual void init();
    
    virtual void handleData(fileoffset foOffset, fileref& restoreData);
    virtual void childdone(cycle *child);
    virtual ~restsslicefile();

    SAFEPOOLALLOC(restsslicefile);

protected:
    restelem info;

private:
    bool process_header_buffer(const fileref& buf, DIRELEMp &realde,
                               const MetadataId &metadataid, const fileoffset &sz, bool erronads, bool erronpad);

    
    bool process_ufs64data_phase();

    cycle *restore_section(data_regions::section_t sectiontype, bool fromend, fileref &outslice, ustring &errmsg);

    
    
    void restore_realh_data(fileoffset offset, fileoffset hdrsizetoread);

    
    
    
    void write_zeros_to_slice(fileref &sliceref);

    void process_emctar_reg_to_lnk(const ustring &realfullpath);

    bool decrementfilecount;

    
    int phase;

    
    
    emctarpipe *ppipe_control;

    
    
    data_regions::endoffsets_t eoff;

    hashcode reghash; 

    
    
    
    fileref tmpbuf;
    DIRELEMp tmpde;

    
    bool islnk;
    bool isfirst;
    DIRELEMp realde;
    fileref  realbuf;
    fileref tmprealbuf;
    MetadataId real_metadataid;
    hashcode realh;
    fileoffset realsize;
    fileoffset realhdrsize;
    fileoffset m_ufs64_data_start;
    location real_loc;
    ubigint64 dir_offset;
    bool have_full_header;

    
    bool use_container;
    bool is_real_file;

    bool setactivelimit;

    
    const bool catalog_enabled;
};

#define UFS64DATA_SIZE_OF_LENGTH_SECTION 12

#endif

#if !defined(RESTNOFILTER_H_INCLUDED)
#define RESTNOFILTER_H_INCLUDED












#include "restfile.h"
#include "restelem.h"
#include "chunktype.h"
#include "fileoffset.h"
#include "volinfo.h"

class direlem;

class restnofilter : public restfile {
public:
    
    restnofilter(bicycle         *parent,
                 const hashcode&  hash,
                 DIRELEM&         direlem,
                 ucontainer::basep container,
                 cycle           *starter = 0,
                 const volinfo   vinfo = volinfo(),
                 fileoffset      startoff=fileoffset(0),
                 fileoffset      endoff=fileoffset(0)
                 );

    
    virtual void init();

    
    virtual void childdone(cycle *child);

    
    virtual ~restnofilter();

    SAFEPOOLALLOC(restnofilter);
protected:
    
    
    fileoffset calculate_raw_size(const chunktype ct, const fileref& topmost) const;

    
    bool is_known_hash(const hashcode& hash) const;

    
    chunktype ctype;

    
    bool have_created_restfile;
private:

    
    
    bool scan_object_with_getobj(const location &objectloc, fileoffset &datasize);

    
    bool scan_object_with_getdata(const location &objectloc, fileoffset &datasize);
};

#endif













#include "common.h"
#include "debug.h"
#include "output.h"
#include "parsestream_base.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"

#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "avpx_ext.h"
#include "filenames.h"

#include "exportstream_xml.h"
#include "ddr_interface.h"
#include "backavpaxstream.h"
#include "backavpaxobj.h"
#include "udirelem.h"
#include "nbackdata.h"

#define msg1  ((xflag[2]&2048)!=0)   





backavpaxstream::backavpaxstream(BackCycle* parent_, context* main, workelem *info_,
                                 parsestream_base *parser_, const int traverse_depth,
                                 exportstream_xmlp& infop, direlemp_list_type_sp delist_sp, const unsigned objflags_) :
    BackCycle(parent_, info_),
    ADEBackup(parent->main),
    m_objname(info && !info->direlemp.isnull() ? info->direlemp->name() : ustring()),
    m_isdir(info && !info->direlemp.isnull() ? info->direlemp->is_directory() : false),
    traverse_depth(traverse_depth), objflags(objflags_), parser(parser_),
    m_delist_sp(delist_sp), listing_output(false),
    found_object(false), found_backupexport_metainfo(!infop.isnull()), exportstream_infop(infop)
{
    if(msg1) DB->msg(DBTXT("backavpaxstream::backavpaxstream() constructor parent:%p this:%p is_dir:%d parser:%p traverse_depth:%d"), parent, this, m_isdir, parser, traverse_depth);
    assert(parser || (objflags & flag_should_output_listing)); 
    assert(info);  
    if (info == NULL) {
        Out->Abort("Null information pointer");
        return;
    }
    assert(!info->direlemp.isnull());
    assert(m_delist_sp);
}

backavpaxstream::~backavpaxstream()
{
    if(msg1) DB->msg(DBTXT("backavpaxstream::~backavpaxstream destructor parent:%p this:%p parser:%p traverse_depth:%d"), parent, this, parser, traverse_depth);
    if(objflags & flag_delete_parser) {
        
        delete parser;
    }
    if (info && !info->isapi) delete info;
    info = 0;
}

void backavpaxstream::init()
{
    if(msg1) DB->msg(DBTXT("backavpaxstream::init parent:%p this:%p is_dir:%d depth:%d info->direlemp:%s"),
                     parent, this, m_isdir, traverse_depth, *info->direlemp->fullpath().image());

    childdone(0);
}

void backavpaxstream::childdone(cycle *child)
{
    if(child) {
        ncollected++;
    }

    if(msg1) DB->msg(DBTXT("backavpaxstream::childdone parent:%p this:%p is_dir:%d child:%p nforked=%d ncollected=%d"),
                     parent, this, m_isdir, child, nforked, ncollected);

    if(parser) {
        
        DIRELEMp obj_direlemp;
        fileref altdata, stubdata;
        altdata = fileref::empty;
        stubdata = fileref::empty;
        if(parser->getentry(obj_direlemp, altdata, stubdata)) {
            if(!obj_direlemp.isnull()) {
                if(msg1) DB->msg("backavpaxstream::childdone(): getentry returned '%s'", *obj_direlemp->name());

                
                if(altdata.size() > 0) {
                    const udirelem::meta exportmetainfo(udirelem::meta::pmt_backupexport_metainfo);
                    if (!m_paxrecs.parse(altdata)) {
                        DB->msg("backavpaxstream::childdone(): Unable to parse paxrecs");
                    } else if(!found_backupexport_metainfo &&
                              (check_headflag(PAX_HEADFLAGS_METADATA, m_paxrecs) || obj_direlemp->name() == exportmetainfo.image())) {
                        const ustring metaname(obj_direlemp->name());
                        if(found_object) {
                            Out->msg(ERR, "<12512>Stream level metadata (%s) found after a stream object was parsed", *metaname);
                        }

                        if(msg1) DB->msg("backavpaxstream::childdone(): Found stream specific metadata - %s", *metaname);

                        fileref metadata;
                        metadata.initmem(obj_direlemp->file_size().ivalue());
                        if(parser->getdata(obj_direlemp->file_size().value(), metadata, "stream metadata") == obj_direlemp->file_size().value()) {
                            if(msg1) DB->msg("backavpaxstream::childdone(): Retrieved data");
                        }

                        
                        if(!parser->getentry(obj_direlemp, altdata, stubdata) || obj_direlemp->name() != metaname) {
                            Out->msg(ERR, "<12513>Error parsing stream level metadata (%s)", *metaname);
                        }

                        if(flags.dtoexportstream && udirelem::meta::value(metaname) == udirelem::meta::pmt_backupexport_metainfo) {
                            
                            if(found_backupexport_metainfo) {
                                Out->msg(ERR, "<12514>Stream contains multiple backup export metainfos");
                            } else {
                                found_backupexport_metainfo = true;
                            }

                            const exportstream_xmlp metainfop(new exportstream_xml(metadata));
                            if(metainfop.isnull() || !metainfop->valid()) {
                                Out->msg(ERR, "<12515>Invalid xml in stream backup export metainfo");
                            } else {
                                
                                exportstream_infop = metainfop;

                                
                                
                                if(!flags.nemoresurrect) {
                                    if(!exportstream_infop->is_backup_supported()) {
                                        Out->msg(FATAL, "The specified backup is not supported for AER import.");
                                        uapp::staging().startTermination(EXIT_MISC, "Invalid backup");
                                    }
                                }
                            }
                        }

                        
                        return childdone(child);
                    } else {
                        if(flags.dtoexportstream && !found_backupexport_metainfo) {
                            Out->msg(ERR, "<12511>Stream does not contain backup export metainfo");
                            
                            found_backupexport_metainfo = true;
                        }

                        obj_direlemp->set_stdin();       

                        workelem *w = new workelem(info, obj_direlemp->fullpath(), obj_direlemp);
                        w->streamslice = parser->datasize(obj_direlemp, obj_direlemp->file_size());      

                        backavpaxobj *paxobj = new backavpaxobj(this, main, w, parser, traverse_depth+1, altdata, exportstream_infop, objflags & flag_subcycle_mask);
                        paxobj->noop();
                        nforked++;

                        if(msg1) DB->msg("backavpaxstream::childdone(): Created backavpaxobj for '%s' '%s'", *obj_direlemp->fullpath().image(), *obj_direlemp->name());

                        
                        m_delist_sp->push_back(obj_direlemp);

                        
                        found_object = true;
                    }
                }
            }

            return;
        }
    }

    
    if((objflags & flag_should_output_listing) && !listing_output && m_delist_sp->size() > 0) {
        fileoffset datasize(0);
        const fileref listing(build_listing(datasize, flags.inode));

        
        
        

        workelem *w = new workelem(NULL, listing);
        cycle *datachild = new nbackdata(this, w, fileoffset(0), true   );
        datachild->noop();

        nforked++;

        listing_output = true;
    }

    if(nforked == ncollected) {
        
        if(flags.nemoresurrect) {
            DataDomainSysInfo sysinfo;
            if(!getAdeMgr()->write_ddrfilesxml(&sysinfo)) {
                if(msg1) DB->msg("backavpaxstream::childdone(): getAdeMgr()->write_ddrfilesxml() returned false");
            }
            
        }

        
        notifyparent();

        
        
        return;
    }
}


fileref backavpaxstream::nextdatablock(bool& suppress_requeue)
{
    if(msg1) DB->msg(DBTXT("backavpaxstream::nextdatablock"));
    return fileref();
}


ubigint64 backavpaxstream::get_headflags(const paxrec& paxrecs) const
{
    ubigint64 ret(0);

    ubigint64 headflags(0);
    if(paxrecs.get_u64(PAXKEY_HEADFLAGS, headflags)) {
        
        ret = headflags;
    }

    return ret;
}


fileref backavpaxstream::build_listing(fileoffset& totalsize, const bool flags_inode) const
{
    
    fileref listing;

    
    
    
    
    
    
    
    listing.initlist(int(m_delist_sp->size()) * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    for(size_t i = 0; i < m_delist_sp->size(); i++) {
        
        DIRELEMp ldep((*m_delist_sp)[i]);
        if(!ldep.isnull()) {
            
            main->layout_direlem(*ldep, listing, false, true, flags_inode);

            
            totalsize += ldep->file_size();
            if(!ldep->is_directory() && !ldep->is_internal()) {
                main->getstatsobj(context::backupstats)->add_filecount(1);
            }
        }
    }

    return listing;
}


bool backavpaxstream::check_headflag(const ubigint64 flag, const paxrec& paxrecs) const
{
    return ((get_headflags(paxrecs) & flag) != 0);
}












#include "common.h"
#include "debug.h"
#include "restmain.h"
#include "utar_commands.h"
#include "restdirpart.h"        
#include "mediadesc.h"
#include "backstate.h"
#include "platerror.h"
#include "filerefx.h"
#include "restroot.h"
#include "restroot2backupdir.h"
#include "avspawn.h"
#include "filenames.h"
#include "restdumpstream.h"
#include "BackupRootInfo.h"

#if SYSTEM_WINDOWS
    #include "wss_sis_manager.h"
#endif

#define restoremain_msg ((xflag[22]&16777216)!=0)       

using briutils::get_toplevel_de;

restoremain::restoremain(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const ustring& _target) :
    utarcmd(_utarcmd),
    main(_hfsInfo.main),
    hfsInfo(_hfsInfo),
    backupInfo(_backupInfo),
    flags(_flags),
    restoretarget(_target),
    isSaveas(false),
    restOptionErr(false)
{
}

restoremain::~restoremain(void)
{
}

























void restoremain::build_restorelist(stringlist& fromlist, fileoffset& estimatedsize)
{
    DIRELEM toplevel_de(get_toplevel_de(backupInfo, hfsInfo));
    stringlist newlist;

    for(int i = 0; i<fromlist.size(); i++) {
        DIRELEM de(toplevel_de);

        if (restoremain_msg) DB->msg("restoremain::build_restorelist frompath='%s', restoretarget='%s'", *fromlist[i], *restoretarget);

        ustring frompath(fromlist[i].strip());

        
        if (!utarcmd->get_frompath(frompath)) {
            
            continue;
        }
        
        
        
        


        if(!flags.backup_prefix.isempty()) {
            frompath = flags.backup_prefix.concat(frompath, DIRSEP);
            DB->msg("restoremain::build_restorelist appending prefix('%s') to from path", *frompath);
        }

        
        
        if (i == 0 && frompath.isempty()) {
            newlist.push_back(frompath);
            continue;
        }

        const pidtype currpid = utarcmd->get_currpid();
        if(!frompath.isempty() && (flags.streamformat_out != utar_flags_enums::streamformat_dump)) {
            upath from_upath(frompath);
            ustring errdisc;
            if (!utarcmd->get_direlem(backupInfo.getRootLocation(), from_upath, de, errdisc)) {
                if (errdisc.equal(message::err_image(MSG_ERR_PRIV_FAIL))) {
                    Out->msg(ERR, "<10669>Insufficient privilege to restore \"%s\".", *frompath);
                    DB->msg("restoremain::build_restorelist: path \"%s\" Error (%s)", *frompath, *errdisc);
                    
                    continue;
                }
                bool is_cross_platform = false;
                ustring entified_from;
                if(!MULTIPATH_RESTORE || ((xflag[22]&16) && fromlist.size()==1)) {  
                    
                    is_cross_platform = (currpid.os() == pidtype::os_celerra || currpid.os() == pidtype::os_isilon ||
                        currpid.os() == pidtype::os_netapp || currpid.os() == pidtype::os_zfs) &&
                        utarcmd->find_entified_name (backupInfo.getRootLocation().getHash(), frompath, entified_from, (currpid.os() == pidtype::os_netapp));
                        
                }

                if(is_cross_platform) {
                    if (!utarcmd->get_direlem(backupInfo.getRootLocation(), (upath)entified_from, de, errdisc)) {
                        Out->msg(ERR, "<12482>Entified name of path \"%s\" not found in %s backup. (%s)",
                                      *frompath,
                                      (utarcmd->get_currpid().os() == pidtype::os_celerra) ? "celerra" :
                                      (utarcmd->get_currpid().os() == pidtype::os_isilon)  ? "isilon" :
                                      (utarcmd->get_currpid().os() == pidtype::os_zfs) ? "zfs" : "netapp",
                                      *errdisc);
                        DB->msg("restoremain::build_restorelist (entified from) path \"%s\" not found", *entified_from);
                        
                        continue;
                    }
                    DB->msg("utar_commands::restoreme path \"%s\" found match after entify", *entified_from);
                    Out->msg(WARN, "<12483>Restoring from a Celerra/VNX/Isilon/NetApp NDMP backup. Not all metadata will be restored, including but not limited to ACLs and alternate datastreams.");
                    if (currpid.os() != pidtype::os_netapp) {
                       from_upath = (upath)entified_from;
                       newlist.push_back(entified_from);   
                    }
                    else {  
                        from_upath = (upath)frompath;
                        newlist.push_back(frompath);
                    }
                }
                else {
                    DB->msg("restoremain::build_restorelist path not found in backup. list[%d]=%s (%s)", i, *frompath, *errdisc);
                    Out->msg(ERR, "<5195>Path \"%s\" not found in backup. (%s)", *frompath, *errdisc);
                    
                    continue;
                }
            } else {
                estimatedsize += de.file_size();
                
                if(de.is_directory() && ((MULTIPATH_RESTORE && ((xflag[22]&16)==0)) || (fromlist.size()!=1))) {
                    from_upath.set_end_dirsep(true);
                    if(de.is_guid_volume())
                        frompath = from_upath.image().strip(ustring::STRIP_LEADING, DIRSEP);  
                    else {
                        
                        frompath = from_upath.image();
                    }
                }
                
                
                
                newlist.push_back(frompath);  
                                              
            }

            
            if ((!MULTIPATH_RESTORE || (xflag[22]&16)) && fromlist.size()==1 && !de.is_directory()) {

                upath target_upath(restoretarget);
                if(flags.streamformat_out==utar_flags_enums::streamformat_emctar) {
                    
                    from_upath.set_end_dirsep(false);
                    target_upath.set_end_dirsep(false);

                    
                    ustring filename = from_upath.stripdir();
                    
                    
                    
                    
                    
                    bool reset_both = (from_upath == target_upath);
                    frompath = from_upath.parentdir().image();
                    if (reset_both)
                        restoretarget = frompath;
                    DB->msg("restoremain::build_restorelist rewrote to frompath='%s', target='%s'", *frompath, *restoretarget);
                    
                    newlist.push_back(frompath);
                    
                    main->state->excludes.clear_list();
                    main->state->excludes.enter_single("**", exclude::user);

                    
                    bool exact = true, check_case = true;
                    main->state->includes.setup(exact, check_case);
                    main->state->includes.clear_list();
                    main->state->includes.enter_exact(filename, exclude::user);

                    
                    flags.no_recursion = true;

                    DB->msg("restoremain::build_restorelist exluding '**' and including '%s'", *filename);
                }
                else if(isSaveas) {
                    saveastargetfilename = target_upath.stripdir();           
                    restoretarget = target_upath.parentdir().image();   
                    DB->msg("restoremain::build_restorelist SaveAs restoretarget='%s' and targetfilename='%s'", *restoretarget, *saveastargetfilename);
                }
            }
            
            if (flags.streamformat_out==utar_flags_enums::streamformat_emctar) utarcmd->get_infofile(backupInfo);

        } else if (utarcmd->get_infofile(backupInfo))
            estimatedsize = fileoffset((bigint64)utarcmd->get_infofile_size());
    }

    fromlist = newlist;	
}









bool restoremain::check_restoresize(const fileoffset& estimatedsize) const
{
    
    if (flags.checkrestoresize && !flags.mapi) {
        
        ustring checkpath(restoretarget);
        fileoffset freespace(-1);
        
        
        if (!(checkpath.isempty() ||
            DIRELEM::querydirectoryexists((upath)checkpath) ||
            DIRELEM::queryfileexists((upath)checkpath))) {
            
            while(!checkpath.isempty()) {
                bool is_vmware = false;
#ifdef SYSTEM_UNIX_LINUX
                is_vmware = is_vmwfs();
                if(is_vmware)    
                freespace = getvmfsfreespace(*checkpath);
#endif
                if(!is_vmware)
                
                freespace = file_system_info::getfreebytes((upath)checkpath);   
                if (freespace >= fileoffset(0)) break;
                checkpath = checkpath.get_dotdot();
            }
        }
        
        

        
        if (freespace < fileoffset(0) || estimatedsize <= fileoffset(0)) {
            
            Out->msg(WARN, "Unable to determine if there is enough disk space for the specified restore.");
        } else if (freespace < estimatedsize) {
            Out->msg(FATAL,  "<5293>Not enough free space in %s for restore (%.0fK free is less than %.0fK).  Use --checkrestoresize=false to override.",
                                    *checkpath, freespace.dvalue()/1024, estimatedsize.dvalue()/1024);
            return false;
        } else {
            Out->msg(INFO, "Verified restore target space ok. freespace:%.0f estimate:%.0f checkpath:\"%s\"",
                           freespace.dvalue(), estimatedsize.dvalue(), *checkpath);
        }
    }
    return true;
}


void restoremain::uncify_target(void)
{
  
  
  
  
#if SYSTEM_WINDOWS
    if (hfsInfo.metaStore != NULL) {
        
        return;
    }
    if((xflag[10]&1048576) == 0) {
        const upath path(restoretarget);

        
        if(path.numelems() > 0 && path.get_start(upath::elem_unc_server) < 0) {
            
            const upath subpath(path.slice(0, 0));
            DIRELEM de(get_toplevel_de(backupInfo, hfsInfo));
            ustring errstr;
            if(utarcmd->get_direlem(backupInfo.getRootLocation(), subpath, de, errstr)) {
                if(de.is_unc_root()) {
                    
                    upath newpath;
                    if(path.has_begin_dirsep()) newpath.set_begin_dirsep();
                    for(int i = 0; i < path.numelems(); i++) {
                        ustring        elem;
                        upath::elemcat cat;

                        if(path.get(i, elem, cat)) {
                            newpath.push_back(elem,
                                              (i == 0 ? upath::elem_unc_server :
                                              (i == 1 ? upath::elem_unc_share : cat)));
                        }
                    }
                    newpath.set_end_dirsep(path.has_end_dirsep());

                    
                    restoretarget = newpath.image();
                }
            }
        }
    }
#endif
}












bool restoremain::check_xrest_option(const client_config_flags::restore_options_type option, const ustring& target, const assoc& srcdstlist)
{
    if(restoremain_msg)
        DB->msg("restoremain::check_xrest_option - restore destination option %d, target %s, save as list size %d",
		(int)option, *target, srcdstlist.size());
    switch(option) {
    case client_config_flags::restore_none:
    case client_config_flags::restore_multiple:
        if(!target.isempty() || (srcdstlist.size()>0)) return true;
        break;    
    case client_config_flags::restore_single:
        if(!target.isempty()) return true;
        break;
    case client_config_flags::restore_original:
    default:
        break;
    }
    return false;
}


















bool restoremain::check_restoreoption(const client_config_flags::restore_options_type option, assoc& srcdstlist)
{
    if(restoremain_msg)
        DB->msg("restoremain::check_restoreoption - restore destination option %d, target %s, save as list size %d", (int)option, *restoretarget, srcdstlist.size());
    switch(option) {
    case client_config_flags::restore_none:
        
        
        
        if(!restoretarget.isempty() && (srcdstlist.size() > 0 || flags.redirrestore)) {
            Out->msg(ERR, "Invalid flag combination, mixing '--target' and 'save-as' is not supported.");
            uapp::cancel(EXIT_BAD_FLAGS);
            return false;
        }
        break;
    case client_config_flags::restore_original:
        
        

        
        
        
        
        
        
        if((!restoretarget.isempty() || (srcdstlist.size() > 0 || flags.redirrestore)) && (flags.pluginid.kind() != pidtype::backupboost)) {
            Out->msg(WARN, "The '--target' and/or 'save-as' paths are ignored when restoring to 'original-destination'.");
            if(!restoretarget.isempty()) restoretarget = emptystring;
            if(srcdstlist.size() > 0) srcdstlist.clear();
        }
        break;
    case client_config_flags::restore_single:
        
        
        if(srcdstlist.size() > 0) {
            Out->msg(WARN, "The 'save-as' path(s) are ignored when restoring to 'single-destination'.");
            srcdstlist.clear();
        }
        break;
    case client_config_flags::restore_multiple:
        
        break;
    default:
        Out->msg(ERR, "Mandatory restore option not specified..");
        uapp::cancel(EXIT_BAD_FLAGS);
        return false;
    }

    DB->msg("restoremain::check_restoreoption - Success with option: %d, restoretarget='%s', saveas list size: %d",
             (int)option, *restoretarget, srcdstlist.size());
    return true;

}













bool restoremain::find_path_and_restore(const stringlist& frompaths, const ustring& target, bool multiple, const bool showerrormessage)
{
    DB->msg("restoremain::find_path_and_restore backupInfo=%s, frompath=%s, target=%s", *backupInfo.image(), frompaths.isempty() ? "" : *frompaths[0], *target);
    bool success(false);
    bool isdir(true);

    DB->msg("restoremain::find_path_and_restore target:%s multiple:%d, frompaths.size():%d are:",
            *target, multiple, frompaths.size());

    for (int i=0; i<frompaths.size(); i++) {
        const ustring s = frompaths[i];
        DB->msg("    %s", *s);
    }

    assert( !flags.replicate ); 

    
    if (flags.restoreprefetchmb > 0 && (flags.dtoexportstream || flags.isexplicit("restore-prefetch"))) {
        
        
        
        const int elems = flags.restoreprefetchmb * 1024;        
        Out->msg(INFO, 2, "Restore prefetcher enabled for %d MB", flags.restoreprefetchmb);
        DB->msg("Enabling restorecache to %d elements", elems);
        main->restorecache_enable(elems, true);
    } else {
        
        flags.restoreprefetchmb = 0;

        
        
        
        
        
        
        
        
        
        
        if (!main->restorecache_enabled()) {
            main->restorecache_enable(flags.restorecachesize);
        }

    }

    
    if (flags.restorebuffermb > 0) {
        Out->msg(INFO, 2, "Restore output buffering enabled for %d MB", flags.restorebuffermb);
    } else {
        
        flags.restorebuffermb = 0;
    }

    location useloc(backupInfo.getRootLocation());
    DIRELEM de;
    ustring errstr;
    bool backupfound(false);

    if(frompaths.isempty())
        return false;
    const pidtype currpid = utarcmd->get_currpid();
    const bool netapp_crossplatform = (currpid.os() ==  pidtype::os_netapp) &&
            (flags.streamformat_out == utar_flags_enums::streamformat_none) &&
            (!flags.netapp_raw);

    upath mypath;
    bool is_metadata (false);
    bool is_netapp_start(false);

    if(!frompaths[0].isempty()) {
        mypath = (upath)frompaths[0];
        is_metadata = (frompaths[0].contains(".system_info") != -1);

        
        
        
        is_netapp_start = (currpid.os() ==  pidtype::os_netapp) && flags.to_stdout &&
                    ((frompaths[0].length_in_chars() > 6) ?
                     (frompaths[0].substr(frompaths[0].length_in_chars()-6,6) == "/start") : false);

        
        if (netapp_crossplatform && !is_netapp_start && !flags.showlog && !is_metadata) {
            DB->msg("restmain::find_path_and_restore: netapp crossplatform, getting entified name for frompath[0]='%s'", *frompaths[0]);
            ustring netapp_ent_from;
            utarcmd->find_entified_name (backupInfo.getRootLocation().getHash(), mypath.image(), netapp_ent_from);
            mypath = (upath) netapp_ent_from;
        }

        
        
        
        if ( ((flags.streamformat_out == utar_flags_enums::streamformat_dump) && MULTIPATH_RESTORE) || 
             (netapp_crossplatform && !flags.showlog && !is_metadata && !is_netapp_start)) {
            mypath = (upath) mypath.get(0);
            DB->msg("restmain::find_path_and_restore: NetApp backup, trying volume '%s'", *mypath.image());
        }

        de = get_toplevel_de(backupInfo, hfsInfo);
        backupfound = utarcmd->get_direlem(backupInfo.getRootLocation(), mypath, de, errstr,
            (netapp_crossplatform && !flags.showlog && !is_metadata)? upath() : (upath)target);
        const location tmploc(de.get_location());
        if(tmploc.getMedia() > location::media::gsan) {
            
            location parentloc(tmploc.make_template(true));

            parentloc.set_enclosing_container(0);
            parentloc.set_emd_relative_path(mypath.parentdir());

            main->set_location_info("restmain::find_path_and_restore()1", parentloc, de);
        }

        if((frompaths.size() == 1) && (!MULTIPATH_RESTORE || (xflag[22]&16))) {
            if(!backupfound) {
                if(showerrormessage) {
                    
                    Out->msg(ERR, "<5187>Path \"%s\" not found in backup (errorcode %s).", *frompaths[0], *errstr);
                }
                    DB->msg("restoremain::find_path_and_restore (frompath) path \"%s\" not found errcode %s", *frompaths[0], *errstr);
                    return false;
            }

            if (flags.streamformat_out == utar_flags_enums::streamformat_dump && flags.ontap73acls && ((xflag[22] & 4194304) == 0)) {
                
                
                
                
                de = DIRELEM();
            } else {
                isdir = de.is_directory();
                useloc = location(backupInfo.getMedialoc(), de.file_hash());
                if(isSaveas && !saveastargetfilename.isempty()  && (currpid.os() !=  pidtype::os_netapp))  
                    de.set_fullpath(upath(target/saveastargetfilename));
            }
        }
    } else {
        
        const location parent_loc; 
        main->set_location_info("restoremain::find_path_and_restore()2", parent_loc, de);

    }

    DB->msg("restoremain::find_path_and_restore frompath=%s backupInfo=%s useloc=%s isdir=%d de.path=%s loc:%s",
            *frompaths[0], *backupInfo.image(), *useloc.image(), isdir, *de.fullpath().image(), *de.get_location().image());

    if ((flags.streamformat_out == utar_flags_enums::streamformat_tar) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_emctar) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_pax) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_avpax) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_cdsf) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_isilon) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_zfs) ||
        (flags.streamformat_out == utar_flags_enums::streamformat_savestream)) {
        mediadesc mediad(flags.media_out);
        const location::media::type media(mediad.getmedia());
        const ustring mediatypestr(location::media::image(media));
        
        if(!mediad.valid()) {
            Out->msg(FATAL, "Invalid media specified for media-out %s", *mediatypestr);
        } else {
            
            if(!mediad.authenticate(flags.sysdir, flags.vardir)) {
                Out->msg(FATAL, "Authentication failed for media-out %s", *mediatypestr);
            } else {
                
                if(isdir &&
                   (media == location::media::disk || media == location::media::magfs) &&
                   !mediad.getdirpath().isempty()) {

                    
                    const resource_identifier ri(hfsInfo,
                                                 main->determineClientID(hfsInfo),
                                                 main->getAdeMgr()->getHfsCreateTime(dpn0),
                                                 backupInfo,
                                                 flags,
                                                 DIRELEMp());

                    const ustring backupdirname(ri.backup_resource_path().stripdir());

                    restroot2backupdir *rst = new restroot2backupdir(backupInfo, useloc, *main, ri, mediad, backupdirname);
                    rst->noop();

                    
                    success = !main->loop();
                } else {
                    success = main->restore_tarpipe(useloc, utarcmd->get_uids(), utarcmd->get_gids(), flags.media_out, target, isdir);
                }
            }
        }
    }
    else if ((flags.streamformat_out == utar_flags_enums::streamformat_dump) ||
             (netapp_crossplatform && !flags.showlog && !is_metadata && !is_netapp_start)) {
        bool is_inode_dump= utarcmd->is_inode_dumpformat(useloc.getHash(), utarcmd->get_currpid());

        if (is_inode_dump) Out->msg(INFO, "<8743>Restoring from inode based method");
        else               Out->msg(INFO, "<8744>Reverting to old restore method");

        if (!netapp_crossplatform) {  
            DB->msg("restoremain::find_path_and_restore, preforming netapp restore");

            
            success = main->restore_dumppipe(useloc, flags.media_out, frompaths, isdir, de, is_inode_dump);
            DB->msg("restoremain::find_paths_and_restore, back from restore_dumppipe");
        } else {   
            DB->msg("restoremain::find_paths_and_restore, performing netapp cross-platform restore");
            if (!is_inode_dump) {
                Out->msg(ERR, "Cannot perform cross-platform restore on old-stype NetApp backup.");
                return false;
            }
            undoo::vector<upath> paths;

            assert(backupInfo.isFromGsan());    
            for (int i=0; i < frompaths.size(); i++) {
                ustring netapp_ent_from;
                utarcmd->find_entified_name (backupInfo.getRootLocation().getHash(), frompaths[i], netapp_ent_from);
                upath entpath(netapp_ent_from);
                entpath.pop_front();
                paths.push_back(entpath);
                DB->msg("restmain::find_paths_and_restore: converted frompaths[%d]='%s' to '%s'", i, *frompaths[i], *entpath.image());

            }
            const location myloc(de.get_location());
            bool is_ddr_bu = (myloc.getMedia() == location::media::ddr);
            bool passing_prefix = (flags.ndmp_prefix.isempty() && (is_ddr_bu));

            cycle *child = new restdumpstream(*main, (is_ddr_bu? backupInfo.getRootLocation() : useloc), de, upath(), paths, target,
                                              (passing_prefix ? mypath.image() : "") );
            child->noop();
            return !main->loop();
        } 

    } else if (flags.to_stdout) {    
        if(!frompaths[0].isempty()) {
            if(!backupfound) {
                Out->msg(ERR, "<5187>Path \"%s\" not found in backup (errorcode %s).", *frompaths[0], *errstr);
                DB->msg("restoremain::find_paths_and_restore (all) - path \"%s\" not found in backup (errorcode %s).", *frompaths[0], *errstr);
                return false;
            }
        }
        DB->msg("restoremain::find_paths_and_restore -  file path = %s, usehash = %s", *frompaths[0], *useloc.getHash().partialimage());
        if (isdir) {
            Out->msg(FATAL, "<5188>Extracting a directory to stdout is not supported.   Restore the directory to disk or use the --streamformat option to restore the directory as a stream.");
            return false;
        }
        bool bNtfsSourceToNonNtfsTarget = false;
        bool bMacOSXSourceToNonMacOSXTarget = false;

        
        
        if( flags.streaming_an_archive() || (xflag[15]&1)) {
            if( de.supportsADS() ) {
                  bNtfsSourceToNonNtfsTarget = true;
            } else if ( de.is_macosx_file() ) {
                bMacOSXSourceToNonMacOSXTarget = true;
            }
        }

        fileref res;
        if(flags.media_out.isempty()) {
            filerefx::initpipe(res, stdout, bNtfsSourceToNonNtfsTarget, bMacOSXSourceToNonMacOSXTarget);
        } else {
            
            
            filerefx::initpipesock(res, flags.media_out, bNtfsSourceToNonNtfsTarget, bMacOSXSourceToNonMacOSXTarget, true, true, flags.stream_timeoutsecs);
        }

        if(!flags.teeoutstream.isempty() && !flags.xdrctl) {    
            fileref f2;
            filerefx::initpipesock(f2, flags.teeoutstream, bNtfsSourceToNonNtfsTarget, bMacOSXSourceToNonMacOSXTarget, true);
            if (!f2.iserror()) {
                Out->msg(INFO, "<12484>Teeing output to %s", *flags.teeoutstream);
                filerefx::initpipeteeout(res, res, f2);
            }
        }

        
        
        
        fileoffset endoff( flags.restorefilelength <= 0 ? 0 : fileoffset(flags.restorefileoffset + flags.restorefilelength -1) );
#if 1
        success = utarcmd->restore_file(res, &de, fileoffset(flags.restorefileoffset), endoff);
#else
        success = main->restore_file(res, usehash, NULL, de.file_size(), fileoffset(flags.restorefileoffset), endoff);
#endif
        if(!flags.media_out.isempty() && !res.commit()) {  
            Out->msg(ERR, "<12485>Restored data might not be completely sent.");
        }
    } else if (isdir) {
        if((flags.args.size() > 1) && flags.parallel) {
            
            
            
            
            
            DB->msg("restmain::find_path_and_restore using new multipath mode, getting restroot, to do loadDirectory on it");
            restroot *restoreroot = utarcmd->get_dirRestRoot(main);
            de.set_fullpath(upath(target));   
            restoreroot->loadDirectoryTargetList(&de);
            return true; 
        }
        else {  
            DB->msg("restmain::find_path_and_restore using old context::restore_dir mode");
            
            
            
            if(useloc.getMetadataId() == backupInfo.getRootLocation().getMetadataId())
                de = get_toplevel_de(backupInfo, hfsInfo);
            else
                de.set_is_directory();
            const upath target_path(target);
            de.set_name(target_path.stripdir());
            de.set_fullpath(target_path);
            DB->msg("restmain::find_path_and_restore bug 43642 changed this to pass the direlem to context::restore_dir because we needed to do the set_location_info* here first, probably this will break something.");
            
            success = main->restore_dir(useloc, target_path, &de, de.get_location());  
        }
    } else {
        if((flags.args.size() > 1) && flags.parallel) {
            
            
            
            
            DB->msg("restmain::find_path_and_restore using multi-stream mode");
            restroot *restoreroot = utarcmd->get_dirRestRoot(main);
            de.set_is_directory(false);
            restoreroot->loadDirectoryTargetList(&de);
            return true; 
        }
        else {
            
            
            
            fileoffset endoff( flags.restorefilelength <= 0 ? 0 : fileoffset(flags.restorefileoffset + flags.restorefilelength -1) );

            DB->msg("restoremain::find_path_and_restore %s startoff:%s endoff:%s", *de.fullpath().image(), *(fileoffset(flags.restorefileoffset)).image(), *endoff.image());

            success = main->restore_one_file(useloc.getHash(), de, fileoffset(flags.restorefileoffset), endoff);
        }
    }
    if (!success) {
        Out->msg(ERR, "<5189>Error restoring path \"%s\" to \"%s\".", *frompaths[0], *target);
    }

    return success;
}









bool restoremain::is_vmwfs() const {
#if SYSTEM_UNIX_LINUX
    fileref vmf;
    vmf.initdisk("/etc/vmware-release");
    if(vmf.iserror()) {
        DB->msg("Cannot open vmware-release file");
        return false;
    }
    return true;
#endif
    return false;
}







fileoffset restoremain::getvmfsfreespace(const char *path) const {
    
    int ret = 0;
    fileoffset val = fileoffset(-1);
    static bool bexec = false;
    arglist args;
    args.exename("vdf");
    args.flag("-h");
    static fileref stdout_data, errors;
    if(!bexec) {
        ret = avspawn::run_and_wait(upath("/usr/sbin/vdf"), args, stdout_data, errors);
        if(ret == 0)
            bexec = true;
        else {
            ustring errs;
            errors.getdata(errs);
            Out->msg(WARN, "<7926>Error in geting vdf data - %s", *errs);
        }
    }
    if(bexec && (stdout_data.size() > 0)){
        ustring stdout_data_string;
        stdout_data.getdata(stdout_data_string);
        stringlist lines(stdout_data_string.split('\n'));
        for(int i = 0; i < lines.size(); i++) {
            if((lines[i].bytelength() <= ustring::sprintf("%s", path).bytelength()) && (strncmp(*lines[i], path, lines[i].bytelength()) == 0)) {
                DB->msg("restoremain::getvmfsfreespace next line %d values =  %s", i+1, *lines[i+1]);
                stringlist values(lines[i+1].split(' '));
                double dval = values[4].todouble();

                if(values[4].last() == 'T')
                    val = fileoffset((bigint64)(dval*1024*1024*1024*1024));
                else if (values[4].last() == 'G')
                    val = fileoffset((bigint64)(dval*1024*1024*1024));
                else if (values[4].last() == 'M')
                    val = fileoffset((bigint64)(dval*1024*1024));
                else if (values[4].last() == 'k')
                    val = fileoffset((bigint64)(dval*1024));
                else
                    val = fileoffset((bigint64)dval);
                DB->msg("restoremain::getvmfsfreespace available bytes(dval) = %f, val = %.0f", dval, val.dvalue());
                break;
            }
        }
    }
    return val;
}























singlepath_restore::singlepath_restore(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const ustring& _frompath, const ustring& _target) :
  restoremain(_utarcmd, _hfsInfo, _backupInfo, _flags, _target), restorefrompath(_frompath)
{

    
    
    
    if(!check_restoreoption(flags.restoreoption, flags.srcdstlist)) {
        restOptionErr = true;
        return;
    }

    ustring dst_path;
    
    if(flags.srcdstlist.size() > 0) {
        
        
        if (flags.pluginid.kind() == pidtype::backupboost) {
            upath unentifiedrespath(ndmp_unentify_volume(restorefrompath));
            unentifiedrespath.set_end_dirsep(true);
            dst_path = flags.srcdstlist.lookup(unentifiedrespath.image());
        }
        else {
            dst_path = flags.srcdstlist.lookup(restorefrompath);
        }
    }

    if(!dst_path.isempty()) {
        isSaveas = true;
        restoretarget = dst_path;
    }
    else if(flags.redirrestore){  
        
        
        ustring frompathtmp;
        restorefrompath.split(frompathtmp, dst_path, false, '=');
        if(!dst_path.isempty()) {
            if(dst_path.contains("=")>=0)
                Out->msg(ERR, "<12486>singlepath_restore: Redirected restore source/destination path %s does not support '=' in path string.", *restorefrompath);
            else {
                isSaveas = true;
                restorefrompath = frompathtmp;
                restoretarget = dst_path;
                DB->msg("singlepath_restore::singlepath_restore - frompath %s, dst_path %s", *restorefrompath, *dst_path);
            }
        }
    }

    if(flags.showlog && !main->set_ddr_loc_info_ignored(true))  
        DB->msg("singlepath_restore::singlepath_restore - ignore ddr location info for showlog");

    DB->msg("singlepath_restore::singlepath_restore - frompath %s, target %s", *restorefrompath, *restoretarget);
}

singlepath_restore::~singlepath_restore()
{
}




bool singlepath_restore::run(bool multiple) {

    if(restOptionErr)
        return false;

    stringlist fromlist;
    fromlist.push_back(restorefrompath);
    fileoffset estimatedsize;

    
    
    
    
    
    
    
    build_restorelist(fromlist, estimatedsize);

    
    

    
    if(fromlist.isempty())
        return false;

    restorefrompath=fromlist[0];


#if SYSTEM_WINDOWS
    
    
    if(!flags.showlog && (wss_sis_manager::sis_manager != NULL)) {
        if(!discover_sis_enabled_drives(restoretarget)) {
            Out->msg(WARN, "File '%s' could not be restored. If backup contains SIS links they will not be converted to regular files and will not be accessible. Otherwise, backup was done on a non-SIS enabled system and this warning message can be safely ignored.", CS_HASHES_FILE);
        }
    }
#endif

    if (flags.restorefilelength > ubigint64(0)) estimatedsize = fileoffset(flags.restorefilelength);

    
    if(!restorefrompath.isempty())             
        Out->msg(INFO, "<5291>Estimated size for \"%s\" is %s", *restorefrompath, *byteunits(estimatedsize.dvalue()));

    utar_commands::dirlistp topdirs = NULL;
    
    if (!(flags.streaming_an_archive() || flags.validate)) {
        if(!check_restoresize(estimatedsize)) {
            
            return false;
        }
        DB->msg("singlepath_restore::run about to call BuildRestoreTargetPath, restoretarget='%s'", *restoretarget);

        
        
        if (!restoretarget.isempty()) {
            DB->msg("singlepath_restore::run !restoretarget.isempty()");
            
            
            if(!utarcmd->mkdirpath_checkwrite(flags, restoretarget)) {
	            return false;
            }

            const pidtype currpid = utarcmd->get_currpid();
            if (flags.preservepaths) {
                
                DB->msg("singlepath_restore::run preservepaths is true");
                if(!BuildRestoreTargetPath(restorefrompath, false, topdirs))
                    return false;
            } else if (currpid.os() == pidtype::os_netapp) {   
                DB->msg("singlepath_restore::run calling BuildRestoreTargetPath for netapp");
                if(!BuildRestoreTargetPath("", true, topdirs))
                    return false;
            } else if (multiple) {
                DB->msg("singlepath_restore::run preservepaths is false");
                if(!BuildRestoreTargetPath(restorefrompath, true, topdirs))
                    return false;
            } else {
                DB->msg("singlepath_restore::run !preservepaths and !multiple");
            }
        }
        else {
            DB->msg("singlepath_restore::run restoretarget.isempty()");
            
            if (!BuildRestoreTargetPath(restorefrompath, false, topdirs))
                return false;
        }

        DB->msg("singlepath_restore::run target directory is %s", *restoretarget);

        if(restorefrompath.isempty()) {
            if (!flags.media_out.isempty()) {
                const ustring streamtxt(flags.media_out.isempty() ?
                                        "stdout" :
                                        ustring::sprintf("path '%s'", *flags.media_out));

                Out->msg(INFO, "<7262>Restoring backup in stream format '%s' to %s",
                                  *utar_flags_info::streamformat_image(flags.streamformat_out), *streamtxt);
            } else {
                Out->msg(INFO, "<5259>Restoring backup to directory \"%s\"", *restoretarget);
            }
        } else {
            Out->msg(INFO, "<5260>Restoring files from \"%s\" to directory \"%s\".", *restorefrompath, *restoretarget);
        }

        if (!restoretarget.isempty() && (flags.mapi == false && utarcmd->check_write(*restoretarget) != 0)) {
            platerror pe;
            Out->msg(ERR, "<6783>Cannot restore to \"%s\" (%s).  Possibly bad path or insufficient write privileges.", *restoretarget, *pe.description());
            return false;
        }
    }

    
    
    
    
    
    
    if( !flags.mapi ) {
        if( flags.permissions )
            umask(0);
    }

    
    uncify_target();

    
    
    
    
    bool success(find_path_and_restore(fromlist, restoretarget, multiple));
    if(multiple) {
        restroot *restoreroot = utarcmd->get_dirRestRoot();
        if(restoreroot != NULL) {
            restoreroot->pushPriorCloseParams(topdirs, restorefrompath, restoretarget);
        }
    }

#if SYSTEM_WINDOWS
    
    
    success = restore_sis_common_store(multiple) && success;
#endif

    
    
    
    
    if (multiple && (utarcmd->get_dirRestRoot() != NULL))
        return(success);
    return( utarcmd->finishRestore(success, topdirs, restorefrompath) );
}




































bool singlepath_restore::BuildRestoreTargetPath(const ustring& snappath, bool lastGsanElementOnly, utar_commands::dirlistp &head) {
    DB->msg("singlepath_restore::BuildRestoreTargetPath(backupInfo=%s, snappath='%s', target='%s', lastGsanElementOnly=%d)",
            *backupInfo.image(), *snappath, *restoretarget, lastGsanElementOnly);

    stringlist dirs(snappath.split(DIRSEP, true, true));        
    dirs.dump("BuildRestoreTargetPath dirs");
    location tmploc(backupInfo.getRootLocation());
    head = NULL;
    

    upath pathtarget(restoretarget);        
    bool skipnextelem(false);
    bool lastitemisfile = false;
    
    
    for(int i=0; i<dirs.size(); i++) {
        
        if(skipnextelem) {
            skipnextelem = false;
            continue;
        }
        ustring elemname(dirs[i]);
        DIRELEM de;
        ustring errdisc;

        if (restoremain_msg) DB->msg("singlepath_restore::BuildRestoreTargetPath() i=%d, tmphash='%s' curFrompathelement='%s'", i, *tmploc.image(), *elemname);

        if (!utarcmd->get_direlem(tmploc, upath(elemname), de, errdisc) || !de.is_directory()) {
            
            
            if(i == 0 && dirs.size() > 1) {
	            
	            const ustring concatelemname(elemname / dirs[1]);
	            if (utarcmd->get_direlem(tmploc, upath(concatelemname), de, errdisc) && de.is_directory()) {
	                
	                elemname = DIRELEM::normalize_path(concatelemname);
	                
	                skipnextelem = true;
                }
            }
            
            if(!skipnextelem) break;
        }

        
        
        if(!de.is_guid_volume() || (elemname != DIRSEPSTR))
            tmploc.setHash(de.file_hash());

        if (i == 0 && !flags.backup_prefix.isempty()) continue;  

        
        
        
        
        if (i == 0 && elemname == DIRSEPSTR && pathtarget.numelems() > 0) continue;
        if (lastGsanElementOnly && i < dirs.size()-1) continue; 
        if (isSaveas && i < dirs.size()-1)
            
            continue;

        if (isSaveas) {
            
            
        }
        else {
#if SYSTEM_WINDOWS
            if (pathtarget.numelems() > 0) {
                
                
                
                
                
                
                ustring undecorated_elemname(DIRELEM::convert_drive_letter(upath(elemname)));

                
                if (undecorated_elemname.bytelength() > 2 && undecorated_elemname.byteindex(0) == '\\' && undecorated_elemname.byteindex(1) == '\\') {
                    undecorated_elemname = undecorated_elemname.substr(2);
                }

                
                upath::elemcat cat = upath::elem_entry;
                if (pathtarget.numelems() == 1 && pathtarget.get_start(upath::elem_unc_server) == 0) {
                    
                    cat = upath::elem_unc_share;
                }
                
                else if (pathtarget.get(0) == ustring("?")) {
                    
                    const int numSegs = pathtarget.numelems();
                    if (numSegs == 1 && de.is_guid_volume()) {
                        
                        cat = upath::elem_volume;
                    }
                    else if ((numSegs == 1 || numSegs == 2 || numSegs == 3) && de.is_globalroot_volume()) {
                        
                        cat = upath::elem_globalroot_part;
                    }
                    
                }
                pathtarget.push_back(undecorated_elemname, cat);
            }
            else
#endif
            
            {
                
                
                
                if (de.is_unc_root()) {
                    
                    
                    ustring noslashelemname(elemname);
                    if(elemname.bytelength() > 2 && elemname.byteindex(0) == '\\' && elemname.byteindex(1) == '\\') {
                        noslashelemname = elemname.substr(2);
                    }
                    pathtarget.push_back(noslashelemname, upath::elem_unc_server);
                }
                else if (de.is_guid_volume()) {
                    
#if SYSTEM_WINDOWS
                    pathtarget.push_back(ustring("?"), upath::elem_wack_wack_prefix);
#endif
                    pathtarget.push_back(elemname, upath::elem_volume);
                }
                else if (de.is_globalroot_volume()) {
                    
#if SYSTEM_WINDOWS
                    pathtarget.push_back(ustring("?"), upath::elem_wack_wack_prefix);
#endif
                    pathtarget.push_back(elemname, upath::elem_globalroot_part);
                }
                
                
                
                
                
                else if (pathtarget.numelems() > 0) {
                    
                    pathtarget.push_back(elemname, upath::elem_entry);
                }
                else {
#if SYSTEM_WINDOWS
                    if (upath(snappath).is_absolute()) {
                        pathtarget.push_back(elemname, upath::elem_drive);
                    }
                    else {
                        pathtarget.push_back(elemname, upath::elem_entry);
                    }
#else
                    pathtarget.push_back(elemname, upath::elem_root);
#endif
                }
            }
        }   

        
        pathtarget.set_end_dirsep(false);
        de.set_fullpath(pathtarget);
        lastitemisfile = !de.is_directory();
        head = new utar_commands::dirlist(de, head);   
        DB->msg("* Determing whether we can/should/need to create (\"%s\")", *de.fullpath().image());

        if(flags.restore_acls_only) {
            if(!de.querydirectoryexists(de.fullpath())) {
                Out->msg(WARN, "<8746>Restore directory %s does not exist for ACL restore.", *de.fullpath().image());
                continue;    
            }
            if(!flags.existingdiraclrestore)
                flags.existingdiraclrestore = true;
        }
        bool diraclreset = flags.existingdiraclrestore && (i == (dirs.size()-1)); 

        if (de.is_reparsePoint()) {
            ReparsePoints::HandleReparsePointForRestore(de, flags.permissions, flags.to_stdout, flags.validate, flags.existingfileoverwriteoption,
                                        flags.restoreshortnames, flags.existingdiraclrestore, flags.interceptorCheck);
        }

        
        bool    bSecurityRemoved = false;
        bool    bFileWasOpen = false; 
        bool    bDirPreexisting = false;
        const bool bSuccess = de.createforrestore(flags.permissions,
                                        flags.to_stdout | flags.validate,
                                        true, 
                                        flags.restoreshortnames, 
                                        bSecurityRemoved,
                                        bFileWasOpen,
                                        bDirPreexisting,
                                        diraclreset); 

        if (!bSuccess) {
            if (bDirPreexisting) { 
                if (flags.restoreatreboot) { 
                    DB->msg("singlepath_restore::BuildRestoreTargetFromGsanPath: Pre-existing directory cannot be restored, path:\"%s\".",*pathtarget.image());
                } else {
                    Out->msg(WARN, "<7920>Pre-existing directory cannot be restored, path:\"%s\".",*pathtarget.image());
                }
            } else {
                ustring errmsg(errno ? ustring::sprintf(" (%s)", *platerror().description()) : "");
                Out->msg(FATAL, "<6781>Unable to create restore directory \"%s\"%s.   Possibly bad path or insufficient write privileges.", *pathtarget.image(), *errmsg );
                return false;
            }
        }
        if( bSecurityRemoved ) {
            main->adjustdirACLstripped();
        }
        if (bDirPreexisting) DB->msg("  -- Directory already exists");
        head->preexisting = bDirPreexisting;    
    }

    if(!isSaveas) {
        restoretarget = pathtarget.image();
    }
    else {
        
        if(lastitemisfile) {
            restoretarget = pathtarget.parentdir().image();
        }
        else {
            restoretarget = pathtarget.image();                 
        }
    }

    DB->msg("singlepath_restore::BuildRestoreTargetPath complete, snappath=%s restoretarget=%s",
            *snappath, *restoretarget);
    return true;
}

#if SYSTEM_WINDOWS

bool singlepath_restore::discover_sis_enabled_drives(const ustring& target) {
    
    if(wss_sis_manager::sis_manager != NULL) {
        
        upath destination_target(target, upath::kind_win, true);
        
        if(destination_target.numelems()>1) {
            destination_target = destination_target.slice(upath::elem_entry, true, false);
        }
        if(!wss_sis_manager::sis_manager->is_sis_enabled(destination_target.image())) {
            
            if(!wss_sis_manager::sis_manager->get_cs_hashes_file_exist()) {
                upath sis_hs_on_server(UNDOO_DIRECTORY_NAME);
                sis_hs_on_server.push_back(CS_HASHES_FILE);
                stringlist sis_hs_on_server_list;
                sis_hs_on_server_list.push_back(sis_hs_on_server.image());
                Out->msg(INFO, "Attempting to restore %s file. If successful, then backup was done on a Windows Storage Server with Windows SIS feature enabled.", CS_HASHES_FILE);
                
                if(false && find_path_and_restore(sis_hs_on_server_list, flags.vardir, false, false)) {
                    wss_sis_manager::sis_manager->set_cs_hashes_file_exist();
                    wss_sis_manager::sis_manager->set_sis_hs_path((upath)flags.vardir/CS_HASHES_FILE);
                } else {
                    DB->msg("singlepath_restore::discover_sis_enabled_drives: %s could not be restored from server", CS_HASHES_FILE);
                    return false;
                }
            }
        }
    }

    return true;
}
#endif

#if SYSTEM_WINDOWS
bool singlepath_restore::restore_sis_common_store(bool multiple) {
    
    
    
    bool success = true;
    if(wss_sis_manager::sis_manager != NULL) {
        if(wss_sis_manager::sis_manager->is_sis_enabled()) {
            DB->msg("Restoring common store file(s)");

            for(int i=0; i<wss_sis_manager::sis_manager->restored_sis_links.size(); i++) {
                ustring common_store_file;
                upath driveSIS(wss_sis_manager::sis_manager->restored_sis_links[i], upath::kind_win, true);
                driveSIS = driveSIS.slice(upath::elem_entry, true, false);
                wss_sis_manager::sis_manager->init_vol(driveSIS.image());
                wss_sis_manager::sis_manager->get_common_store_file(wss_sis_manager::sis_manager->restored_sis_links[i], common_store_file);

                
                if(!common_store_file.isempty()) {
                    ustring fname, dest;
                    common_store_file.split(dest, fname, true);

                    ustring volumeorg;
                    volumeorg = wss_sis_manager::sis_manager->mapped_links.lookup(wss_sis_manager::sis_manager->restored_sis_links[i]);
                    upath cs_file_path(volumeorg, upath::kind_win, true);
                    cs_file_path.push_back(CS_FOLDER);
                    cs_file_path.push_back(fname);
                    stringlist cs_file_paths;
                    cs_file_paths.push_back(cs_file_path.image());
                    success = find_path_and_restore(cs_file_paths, dest, multiple);
                    wss_sis_manager::sis_manager->restored_common_store_file(fname);
                }
	        }
        }
    }
    return success;
}
#endif


multipath_restore::multipath_restore(utar_commands* _utarcmd, const hfs_info_struct& _hfsInfo, const BackupRootInfo& _backupInfo, utar_flags_info& _flags, const stringlist& _frompaths, const ustring& _target) :
  restoremain(_utarcmd, _hfsInfo, _backupInfo, _flags, _target), restorefrompaths(_frompaths)
{
    if((main->target_path.bytelength() == 0) || (flags.args.size() == 0))
        flags.preservepaths = true;
    for(int k=0; k < restorefrompaths.size(); k++)
        DB->msg("multipath_restore: frompaths[%i] = \"%s \"", k, *restorefrompaths[k]);
}

multipath_restore::~multipath_restore()
{
}

bool multipath_restore::run(bool multiple) {
    fileoffset estimatedsize;
    if (flags.streamformat_out != utar_flags_enums::streamformat_dump) { 
        build_restorelist(restorefrompaths, estimatedsize);
    }

    if(restorefrompaths.size() == 0) {
        if(utarcmd->get_infofile(backupInfo))
            estimatedsize = fileoffset((bigint64)utarcmd->get_infofile_size());
    }
    else if (flags.streamformat_out==utar_flags_enums::streamformat_emctar)  
        utarcmd->get_infofile(backupInfo);

    if (flags.restorefilelength > ubigint64(0)) estimatedsize = fileoffset(flags.restorefilelength);
    Out->msg(INFO, "<8751>Estimated size is %s", *byteunits(estimatedsize.dvalue()));

    
    if (flags.streamformat_out == utar_flags_enums::streamformat_dump ||
        flags.streamformat_out == utar_flags_enums::streamformat_emctar ||
        flags.streamformat_out == utar_flags_enums::streamformat_isilon ||
        flags.streamformat_out == utar_flags_enums::streamformat_zfs) {
        
        
        
        
    } else if(!(flags.streaming_an_archive() || flags.validate)) {
        if(!check_restoresize(estimatedsize)) {
            
            return false;
        }

        
        if (!restoretarget.isempty()) {
            
            if(!utarcmd->mkdirpath_checkwrite(flags, restoretarget)) {
                return false;
            }
        }
        DB->msg("multipath_restore: target directory is %s", *restoretarget);

        
        log_restorelist(backupInfo.getRootLocation(), restoretarget, restorefrompaths);

        if (!restoretarget.isempty() && (flags.mapi == false && utarcmd->check_write(*restoretarget) != 0)) {
            platerror pe;
            Out->msg(ERR, "<6783>Cannot restore to \"%s\" (%s)", *restoretarget, *pe.description());
            return false;
        }
    } else if(flags.streaming_an_archive()) {
        
        log_restorelist(backupInfo.getRootLocation(), restoretarget, restorefrompaths);
    }

    
    
    
    if (flags.streaming_an_archive())
        main->state->targets.init(restorefrompaths, false, "", !flags.preservepaths);     
    else
        main->state->targets.init(restorefrompaths, false, restoretarget, !flags.preservepaths);

    
    
    
    
    
    
    if( !flags.mapi ) {
        if( flags.permissions )
            umask(0);
    }

    
    uncify_target();

    
    bool success_restored = find_path_and_restore(restorefrompaths, restoretarget, multiple);
    return log_restore_results(success_restored, main);
}










void multipath_restore::log_restorelist(const location& theloc, const ustring& target, const stringlist& list) {
    for(int i = 0; i<list.size(); i++) {
        if(!list[i].isempty()) {
            DIRELEM de(get_toplevel_de(backupInfo, hfsInfo));
            ustring errdisc;
            stringlist dirs(list[i].split(DIRSEP, true));
            if(flags.preservepaths)
                Out->msg(INFO, "<8747>Restoring files from \"%s\" will restore to \"%s\".", *list[i], *(target/list[i]));
            else if (!utarcmd->get_direlem(theloc, (upath)list[i], de, errdisc)) {
                Out->msg(ERR, "<5195>Path \"%s\" not found in backup. (%s)", *list[i], *errdisc);
                DB->msg("multipath_restore::log_restorelist path not found in backup. list[%d]=%s (%s)", i, *list[i], *errdisc);
                list[i] = "";
                continue;
            }
            else {
                if(de.is_directory()) {
                    if(list.size() > 1) {
                        upath lastfrelem(dirs[dirs.size() - 1]);
                        lastfrelem.set_end_dirsep(true);
                        Out->msg(INFO, "<8748>Files from \"%s\" will restore to \"%s\".", *list[i], *(target/lastfrelem.image()));
                    } else {
                        Out->msg(INFO, "<8748>Files from \"%s\" will restore to \"%s\".", *list[i], *target);
                    }
	            }
            }
	    }
        else {
            if (!flags.media_out.isempty()) {
                Out->msg(INFO, "<8749>Restoring backup in stream format '%s' will restore to path '%s'",
                               *utar_flags_info::streamformat_image(flags.streamformat_out), *flags.media_out);
            } else
                Out->msg(INFO, "<8750>Restoring backup will restore to \"%s\"", *target);
            break;
        }
    }
}







bool multipath_restore::log_restore_results(const bool success, const context* cmain) {
    bool ret(success);

    int warnings, errors, fatals;
    Out->get_total_counts(warnings, errors, fatals);
    
    ret &= (fatals == 0);

    ustring cmd;
    if (flags.validate)
        cmd = LOCTXT("Validate");
    else
        cmd = LOCTXT("Restore");
    if(!uapp::staging().canRun()) {
        Out->msg(WARN, "<5382>%"AVARG"s interrupted.", *cmd); 
        ret = false;
    } else if(! ret) {
        Out->msg(ERR, "<6546>%"AVARG"s failed", *cmd);
    } else {
        size_t  iDirACLLostCount = cmain->getdirACLstrippedcount();
        size_t  iFileACLLostCount = cmain->getfileACLstrippedcount();

        if( iDirACLLostCount && iFileACLLostCount ) {
            Out->msg(INFO, "<5542>Restore was not able to reapply security on %d directories and %d files due to lack of support in target file system",
                                  (int)iDirACLLostCount, (int)iFileACLLostCount);
        } else if( iDirACLLostCount ) {
            Out->msg(INFO, "<5543>Restore was not able to reapply security on %d directories due to lack of support in target file system",
                                  (int)iDirACLLostCount);
        } else if( iFileACLLostCount ) {
            Out->msg(INFO, "<5544>Restore was not able to reapply security on %d files due to lack of support in target file system",
                                  (int)iFileACLLostCount);
        }
        if(errors > 0)
            if (errors == 1)
                Out->msg(INFO, "<6547>%"AVARG"s completed with %d error", *cmd, errors);
            else
                Out->msg(INFO, "<6548>%"AVARG"s completed with %d errors", *cmd, errors);
        else
            Out->msg(INFO, "<6549>%"AVARG"s completed", *cmd);
    }
    return ret;
}

#if !defined(isilontar_history_H_INCLUDED)
#define isilontar_history_H_INCLUDED












#include "threadbase.h"
#include "vector.h"
#include "msgqueue.h"
#include "assoc.h"
#include "msgvect.h"
#include "namedpipe.h"
#include "usemaphore.h"
#include "histmap.h"
#include "utar_flags_info.h"

#include <map>

class message;
class context;
class BackCycle;

class isilontar_history
{
public:
    isilontar_history(context *main, upath fifopath, upath savehistpath);
    ~isilontar_history();

    void data_stream_done();
    void send(BackCycle* cycle, message& m);

    
    
    
    
    

    
    
    
    bool is_rhist_done() const { return readhist_thread->is_done; }
    
    
    
    
    size_t rhist_msg_count() const { return readhist_thread->msg_count; }

    SAFEALLOC(isilontar_history);

private:

    class readhist : public threadbase
    {
    public:
        readhist(msgqueue& todoqueue, upath fifopath, upath savehistpath, semaphore& histsem);
        ~readhist();
        void body();
        SAFEALLOC(readhist);

    private:
        friend class isilontar_history;

        msgqueue& todoqueue;
        namedpipe fifo;
        upath savehistpath;
        semaphore& histsem;
        bool is_done;
        size_t msg_count;
    };

    class processhist;
    class processhist : public threadbase
    {
    public:
        processhist(msgqueue& todoqueue, isilontar_history *parent_);
        ~processhist();
        void terminate();
        void mark_eof_history();
        SAFEALLOC(processhist);

    private:
        msgqueue& todoqueue;
        isilontar_history *parent;
        mtex todomut;
        typedef scalar<ndmp_inode64_t> inode_obj_t;
        tassoc<inode_obj_t, message> todoassoc;
        bool mainloopdone;
        bool todoqueue_terminated;

        
        
        
        
        
        
        struct dirrecord
        {
            dirrecord() : isdone(false), names(NULL) { names = new histvector_t(); }
            ~dirrecord() {  }
            ustring image() const { return ustring::sprintf("FIX: implement dirrecord::image"); }
            bool isdone; 
            
            histvector_t *names;
        };

        class historytree_class
        {
        public:
            historytree_class() : m(true), lastparentinode(0) {} 
            ~historytree_class();
            ndmp_inode64_t lastparent_done(); 

            
            ndmp_inode64_t enter_hist(processhist *ph, ndmp_inode64_t inode, ndmp_inode64_t parentinode, const ustring &name);

            
            
            
            
            
            
            histvector_t *get_names(ndmp_inode64_t inode, bool accept_unready = false);

            bool answer_ready(ndmp_inode64_t queryinode) const;

        protected:
            mtex m;
            typedef DEFINE_STL_MAP_TYPE(ndmp_inode64_t, dirrecord) nodemap;
            typedef nodemap::iterator iter;
            nodemap nodes;
            ndmp_inode64_t lastparentinode;
        };

        historytree_class historytree;

        
        void body();
        void handle_getndmpisilonhistlist(message &m);
        bool handle_ndmphistlistline(message &m);
        void postprocess_getndmpisilonhistlist(ndmp_inode64_t inode, message &m);
        void attempt_answer(ndmp_inode64_t inode);
        int  read_and_enter_xml(ustring oneline);

   private:
        void sendResponse(BackCycle* cycle, message &m);
   }; 

private:
    msgqueue     todoqueue;             
    semaphore    histsem;
    readhist*    readhist_thread;
    processhist* processhist_thread;


#if SYSTEM_UNIX_SCO || SYSTEM_UNIX_UNIXWARE
    public:
#else
#endif
    utar_flags_info& flags;
};

#endif
















#include "common.h"
#include "debug.h"
#include "hashserver.h"
#include "msgpack_c.h"
#include "timer.h"
#include "context.h"
#include "cycle.h"

hashserver::hashserver(int nthreads, context *main)
  : hashqueue('h', nthreads),
    threads(nthreads),
    inprocess(0)
{
    
    assert(!main->ADEChunkerEnabled());

    for(int i = 0; i < nthreads; i++) {
        hashthread *t = new hashthread(hashqueue, inprocess, main, i);
        threads.push_back(t);
        t->start();
    }
}

hashserver::~hashserver() {
    hashqueue.terminate();
    for(size_t i = 0; i < threads.size(); i++) {
        hashthread *t = threads[i];
        t->wait();
        delete t;        
    }
}

void hashserver::send(message& m) {
    inprocess++;
    hashqueue.enqueue(m);
}

hashserver::hashthread::hashthread(msgqueue& hashqueue_, safeint &inprocess_, context *main_, int index_)
  : hashqueue(hashqueue_),
    main(main_),
    index(index_),
    bytecount(0),
    inprocess(inprocess_)
{
    setdesc(ustring::sprintf("hsrv%d", index));
}

void hashserver::hashthread::terminate() {
}



void hashserver::hashthread::body() {
    sum_timer sumt;
    while(true) {
        bool terminated;
        message m = hashqueue.dequeue(terminated);
        if(terminated)
            break;
        assert(m.requestcode() == CLIENTONLY_COMPUTEHASH);

        msgpack_c::computehash ch(m);
        cycle *cy;
        chunktype ctype;
        ubigint64 cyp;
        fileref key_and_data;
        int compress;
        int clevel;
        int cpercent;
        int encryption;
        ch.arg(UNPACK, cyp, ctype, key_and_data, compress, clevel, cpercent, encryption);
        cy = (cycle*)(cyp);

        fileref key;
        fileref data;
        if(encryption != fileref::encmode_none) {
            
            
            assert(key_and_data.numchildren()==2);
            key  = key_and_data.getchild(0);
            data = key_and_data.getchild(1);
            assert(encryption >= 0 && encryption <= fileref::encmode_last);
            assert(key.size() == fileref::enckeysize[encryption]);
        } else {
            
            data = key_and_data;
        }

        if(compress || encryption != fileref::encmode_none) {
            
            assert(ctype.is_data_atomic());  
            int usize = data.size();
            bool met_maxpercent;                
          
            if(data.compress(cpercent, fileref::compressionlevels(clevel), fileref::compmodes(compress), fileref::encmodes(encryption), met_maxpercent, key))
                ctype = chunktype::extatomic;
          
            main->getstatsobj(context::backupstats)->add_compress(0 , data.size(), usize);
        }

        hashcode hash;
        data.binhash(hash);
        bytecount += data.size();

        if(ctype != chunktype::extatomic)
            data.free();   

        ch.res(PACK, hash, ctype, data);

        cy->enqueueResponse(cy, m, false);

        inprocess--;
        assert(+inprocess >= 0);

        sumt.check_cputime_update("hashserver");
    }
    if(bytecount > 0)
        Out->msg(STATS, "<6153>Hashing thread %d processed %s bytes\n", index, *commas(bytecount));
}

#if !defined(RESTDIRPART_H_INCLUDED)
#define RESTDIRPART_H_INCLUDED












#include "cycle.h"
#include "restelem.h"
#include "dumpcontext.h"
#include "restdir.h"
#include "ucontainer_base.h"








#define MULTIPATH_RESTORE ((xflag[22]&64)!=0 || (((xflag[22]&16)==0) && \
    flags.to_stdout && (flags.streamformat_out == utar_flags_enums::streamformat_emctar || \
    flags.streamformat_out == utar_flags_enums::streamformat_dump || \
    flags.streamformat_out == utar_flags_enums::streamformat_isilon || \
    flags.streamformat_out == utar_flags_enums::streamformat_zfs)))


class backdump;
class pipe_control;
class backview;
class restcomp;

#define skipfifoonrestore ((xflag[20]&1024)!=0 || flags.exclude_fifos_on_restore)


class restdirpart : public bicycle {
public:
    restdirpart(cycle               *parent, 
                const location&     _metadatalocation, 
                const restelem&     restinfo,
                cycle              *starter,
                int                 listingsize,
                restdir::Regulator *regulator = NULL
               );

    restdirpart(cycle              *parent,
                const location&     _metadatalocation,
                const restelem&     restinfo,
                const direlemp_list_type_sp&     direlems,
                cycle              *starter,
                restdir::Regulator *regulator = NULL
               );

    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~restdirpart();

    
    
    static int do_restore_dephashes(bicycle *parent,
                                    cycle* &prevchild,
                                    const restelem& linfo);

    SAFEPOOLALLOC(restdirpart);
private:
    
    void launch(const hashcode& hash, cycle *starter);
    void set_phase(int phasenum);
    bool process_listing_setup();
    bool process_listing();

    const location metadatalocation;
    
    
    dumpcontext*               pdumpcontext;
    dumpcontext::dirlistelem*  dumpdirlist;
    backdump*                  pbackdump;
    pipe_control*              ppipe_control;
    bool                       for_emctar;
    backview*                  pbackview;
    bool                       overwriteexistingSISlink;
    
    int                        listingOffset;
    int                        maxListingOffset;
    
    
    int                        container_entry_idx;

    cycle*                     previousChild;

    GetChildrenState_sp         catalog_state;

    
    
    
    
    
    
    
    
    
    
    


   
    
    
    DEFINE_STL_MAP_TYPE(location::tcontainerid, fileoffset) running_coverage_size;

    
    bool process_multipath_direlem(DIRELEMp direlem_p, ucontainer::basep container);
    bool process_direlem(DIRELEMp direlem_p, ucontainer::basep container);

    bool get_next_direlem_to_process(DIRELEMp& de);

    
    
    bicycle* createrestfile(DIRELEMp direlem_p, cycle *prevchild, ucontainer::basep container);

    
    
    
    bool queryshouldnotcreate(const DIRELEMp direlem_p) const;

#if SYSTEM_WINDOWS
    
    bool create_in_temp_for_restore(DIRELEMp direlem_p);
#endif

    bool HandleReparsePoint(DIRELEMp direlem_p) const;

    restelem info;

    
    
    int listingsize;
    int phase;
    restdir *rdc;

    restdir::Regulator *regulator;

    direlemp_list_type_sp  direlemList;
    direlemp_list_type::iterator direlemListIt;


};  

#endif  



























#include "common.h"
#include "debug.h"
#include "backtree.h"
#include "todoelem.h"
#include "context.h"
#include "chunktype.h"
#include "msgpack_c.h"
#include "utar_flags_info.h"
#include "connerror.h"
#include "output.h"
#include "backstate.h"
#include "tchunkinfolist.h"
#include "chunker.h"
#include "filename_cache.h"

#include "ade/ade_mgrx.h"
#include "hfs_info_struct.h"



#define backtree_msg ((xflag[2]&2)!=0)

bool backtree::checkrefs(int child_count) const {
    bool result = true;
    int count = 0;

    chunktype kind(tree->get_kind());

    if(kind.is_data_atomic())
        return true;

    fileref data(tree->get_data());
    const hashcode& mainhash = tree->get_hash();

    
    

    const char *start = data.start();
    unsigned offset = 0;
    unsigned datasize = data.size();
    while(offset < datasize) {
        if(offset + sizeof(hashcode) > datasize) {
            assert(false);
            return false;
        }

        count++;

        hashcode *hash;
        if(kind.is_dir_atomic())
            hash = &DIRELEM::get_hash_ref(data, offset);
        else
            hash = (hashcode *)(start + offset);

        if(*hash != hashcode::empty && *hash != hashcode::zero) {
            
            if( cache ) {
                if( cache->is_present_and_update_tag( *hash, cache::SINGLE_STREAM ) ) {
                    DB->msg("goodref %s main=%s kind=%s depth=%d", *(hash->image()), *mainhash.partialimage(), *kind.image(), tree->get_depth());
                } else {
                    DB->msg("badref  %s main=%s kind=%s depth=%d", *(hash->image()), *mainhash.partialimage(), *kind.image(), tree->get_depth());
                    result = false;
                }
            } else DB->bt_error( DBTXT("Missing cache in checkref call") );
        }

        if(kind.is_dir_atomic())
            offset += DIRELEM::get_direlem_size(data, offset);
        else if(kind.is_recipe2())
            offset += sizeof(COMPELEM2);
        else if(kind.is_recipe4())
            offset += sizeof(COMPELEM4);
        else if(kind.is_recipe8())
            offset += sizeof(COMPELEM8);
        else
            break;
    }
    if(offset != datasize) {
        assert(false);
        return false;
    }

    
    if( kind.is_anycomposit() && (count != child_count) ) {
        DB->msg( "count != child_count %d!=%d", count, child_count );
        assert(count==child_count);
    }
    return result;
}


backtree::backtree(BackCycle *parent, const dpns dpninx_, const bool ignorestats_) :
    BackCycle(parent), dpninx(dpninx_), ignorestats(ignorestats_)
{
    assert(!parent->main->ADEChunkerEnabled());

    inlookup = false;
    inlistlookup = false;
    didlistlookup = false;              
    ispresent = false;
    skipaddhashdata = false;
    doconsolidate = false;
    ncons = 0;
    tree = NULL;
    stats = NULL;
    cache = NULL;

    if( backtree_msg ) DB->msg( "backtree::backtree this=%p parent=%p", this, parent );
}

void backtree::setup(cycle* parent_, chunktree::node* tree_,
                   backstats* stats_, const filestatsref& fstats_,
                   hash_cache *cache_ )
{
    this->parent = parent_;
    this->tree = tree_;
    this->stats = stats_;
    this->fstats = fstats_;
    this->cache = cache_;

    if (parent){
        parent->nforked++;
        if( backtree_msg )
            DB->msg( "backtree::setup this=%p parent=%p nforked %d %s",
                     this, parent, parent->nforked, *tree->get_hash().partialimage() );
    }

    assert(!tree->node_sent);
    if (tree->node_sent) DB->msg("backtree::setup %s sending AGAIN!!!!!!", *tree->get_hash().partialimage());
}

backtree::~backtree() {
    
    if( backtree_msg ) DB->msg("backtree::~backtree" );
}

void backtree::init() {
    if(tree==NULL) { DB->msg(DBTXT("backtree init with no tree"));  return; } 
    if( backtree_msg ) DB->msg("backtree::init %s kind:%s", *tree->get_hash().partialimage(), *tree->kind.image());

    inlookup = true;

    if ( cache && cache->is_present_and_update_tag( tree->get_hash(), cache::SINGLE_STREAM) ) {
        if( backtree_msg ) DB->msg("backtree::init found %s this=%p", *tree->get_hash().partialimage(), this );
        tree->set_why(stats::hashcache);
        ispresent = true;
        if( tree->get_depth() <= main->state->hfs_send_depth )
            notifyparent();
        else childdone(NULL);  
        return;
    }

    static bool hfsAvail = main->getAdeMgr()->getHfsInfo(dpninx).isAvailable;
    if(flags.degenerate || !hfsAvail) {              
        tree->set_why(stats::sent);
        ispresent = true;
        if( cache ) cache->enter(tree->get_hash(), cache::SINGLE_STREAM);
        if( tree->get_depth() <= main->state->hfs_send_depth )
            notifyparent();
        else childdone(NULL);
        return;
    }

    message inargs;
    msgpack_c::hashispresent hip(inargs);
    hashcode hash = tree->get_hash();
    hip.arg(PACK, hash);
    if( backtree_msg ) DB->msg( "backtree::init ISPRESENT %s", *inargs.body().hash.partialimage() );

    if(flags.level0) {          
        inargs.setresponsecode(MSG_ERR_MISC);   
        response(inargs);
        return;
    }

    main->remotecall(this, inargs, dpninx);
}




bool backtree::hashispresentlist(message& m)
{
    
    
    
    if(flags.level0 || !flags.consolidate)
        return false;

    chunktype kind(tree->get_kind());
    if(!kind.is_anycomposit())
        return false;

    if(kind.is_dir())
        return false;

    if(main->getdpnmaxmessage(dpninx) < HASHLIST_IS_PRESENT)
        return false;

    msgpack_c::hashlistispresent::hashvect hashlist;

    int cnt=0;
    int nodes_skipped=0;
    chunktree::node *sib = tree->get_child();
    while(sib != NULL) {
        if(sib->shouldbesent()) {
            
            if ( cache && cache->is_present_and_update_tag( sib->get_hash(), cache::SINGLE_STREAM) ) {
                if( backtree_msg ) DB->msg("backtree::hashispresentlist removed cache-hit(#%d): %s", cnt, *sib->get_hash().partialimage());
                sib->set_why(stats::hashcache);
                nodes_skipped++;
            } else if (hashlist.contains(sib->get_hash())) {
                if( backtree_msg ) DB->msg("backtree::hashispresentlist removed dup(#%d): %s", cnt, *sib->get_hash().partialimage());
                sib->set_why(stats::hashcache); 
                nodes_skipped++;
            } else {
                hashlist.push_back(sib->get_hash());
            }
            cnt++;
        }
        sib = sib->get_sibling();
    }

    
    
    
    
    
    if(hashlist.empty())
        return false;

    
    
    ncollected += nodes_skipped;

    msgpack_c::hashlistispresent hlip(m);
    hashcode comphash(tree->get_hash());
    hlip.arg(PACK, comphash, hashlist);

    if( backtree_msg ) DB->msg( "backtree::hashispresentlist this=%p size=%d comphash=%s", this, int(hashlist.size()), *comphash.partialimage() );

    return true;
}


void backtree::saveispresent(const hashcode& hash, bool ispresent)
{
    chunktree::node *sib = tree->get_child();
    while(sib != NULL) {
        if(sib->shouldbesent() && sib->get_hash() == hash) {
            assert(nforked > 0);
            ncollected++;
            if( backtree_msg ) DB->msg("backtree::saveispresent this=%p hash=%s present=%d nforked=%d ncollected=%d", this, *hash.partialimage(), ispresent, nforked, ncollected);
            if(ispresent) {
                sib->set_why(stats::ispresent);
                if( cache ) {
                    cache->enter(hash, cache::SINGLE_STREAM);   
                    if( backtree_msg ) DB->msg("backtree::saveispresent cache enter this=%p hash=%s", this, *hash.partialimage());
                }
            }
            return;
        }
        sib = sib->get_sibling();
    }
    assert(false);
}









void backtree::saveaddcompdata()
{
    if (!cache) return;

    
    chunktree::node *sib = tree->get_child();
    while(sib != NULL) {
        if (sib->get_why() == stats::sent) {            
            const hashcode hash = sib->get_hash();
            cache->enter(hash, cache::SINGLE_STREAM);   
            if(backtree_msg) DB->msg("backtree::saveaddcompdata cache enter this=%p hash=%s", this, *hash.partialimage());
        }
        sib = sib->get_sibling();
    }
}

void backtree::response(message& outargs) {
    if( backtree_msg ) DB->msg("backtree::response %s inlookup:%d", *tree->get_hash().partialimage(), inlookup );

    if(inlookup) {  
        inlookup = false;
        if(!outargs.isnull() && outargs.isgoodresponse() && (!flags.ignoreispresent)) {  
            if( backtree_msg ) DB->msg("backtree::response this=%p tree=%p", this, tree );
            if( backtree_msg ) DB->msg("backtree::response %s hashispresent:true why=ispresent", *tree->get_hash().partialimage());
            tree->set_why(stats::ispresent);
            ispresent = true;

            if( backtree_msg )
                DB->msg( DBTXT("backtree::response %s about to call notifyparent, parent = %p"),
                         *tree->get_hash().partialimage(), parent );
            if( cache ) {
                cache->enter(tree->get_hash(), cache::SINGLE_STREAM);
                if( backtree_msg ) DB->msg("ispresent cache enter %s", *tree->get_hash().partialimage());
            } else if(flags.refcheck) DB->msg("***********************************No cache to enter %s", *tree->get_hash().partialimage() );
            if( tree->get_depth() <= main->state->hfs_send_depth )
                notifyparent();
            else childdone(NULL);
        } else {  
            if( backtree_msg )
                DB->msg("backtree::response %s not present(%s) ",
                        *tree->get_hash().partialimage(), *outargs.found_image());

            message inargs;
            if(hashispresentlist(inargs)) {
                inlistlookup = true;
                didlistlookup = true;
                main->remotecall(this, inargs, dpninx);
                return;
            }

            if (tree->get_depth() == main->state->hfs_send_depth) {
                

                
                doconsolidate = flags.consolidate && tree->issimplecomposite();

                if( backtree_msg ) DB->msg("backtree::response %s not present doconsolidate=%d ", *tree->get_hash().partialimage(), doconsolidate);
                chunktree::node *sib = tree->get_child();
                while(sib != NULL) {
                    
                    sib->send(doconsolidate, NULL); 
                    sib = sib->get_sibling();
                }
                
                
                
                
            }
            childdone(NULL);
            if( backtree_msg ) DB->msg("backtree::response %s not present nforked:%d", *tree->get_hash().partialimage(), nforked);
        }
    } else if(inlistlookup) {  
        inlistlookup = false;
        if( backtree_msg )
            DB->msg("backtree::response this=%p hash=%s list lookup (%s) ", this, *tree->get_hash().partialimage(), *outargs.found_image());

        assert(flags.consolidate);      

        if(outargs.isgoodresponse()) {
            msgpack_c::hashlistispresent hlip(outargs);
            msgpack_c::hashlistispresent::resultvect resultlist;
            hlip.res(UNPACK, resultlist);

            for(unsigned int i = 0; i < resultlist.size(); ++i)
                saveispresent(resultlist[i].hash, +resultlist[i].ispresent);

            
            doconsolidate = flags.consolidate && tree->issimplecomposite();

            if( backtree_msg ) DB->msg("backtree::response %s list lookup doconsolidate=%d ", *tree->get_hash().partialimage(), doconsolidate);
            childdone(NULL);
        }
        else {
            Out->msg(ERR, "<5775>Internal Error: backtree: bad response %s %d %s", *tree->get_hash().image(), +outargs.head().serial, *outargs.ximage());
            throw EXC_HFSERROR;
        }
    } else {  
        if( backtree_msg ) DB->msg("backtree::response %s add_hash_data (%s) why=sent", *tree->get_hash().partialimage(), *outargs.found_image());
        if(!outargs.isgoodresponse() &&
           (outargs.responsecode() == MSG_ERR_UNNECESSARY) ) {


            DB->msg( "backtree::response - enter unnecessary %d", +outargs.head().serial);
        } else if(outargs.isgoodresponse() || outargs.responsecode() == MSG_ERR_CANCEL) {
             static bool cancelmsgneeded = true;
             if(outargs.responsecode() == MSG_ERR_CANCEL && cancelmsgneeded)  { 
                cancelmsgneeded = false;
                Out->msg(WARN, "<7527>Cancel request from server" );
                if (main->state->fcache)
                    main->state->fcache->set_incomplete();
             }

            if(doconsolidate) {
                if( backtree_msg ) DB->msg("backtree::response %s doconsolidate", *tree->get_hash().partialimage());
                childdone(NULL);
                return;
            }

            if( cache ) {
                cache->enter(tree->get_hash(), cache::SINGLE_STREAM);
                if( backtree_msg ) DB->msg("addhashdata cache enter %s", *tree->get_hash().partialimage() );
                if(outargs.requestcode() == ADD_COMP_DATA) saveaddcompdata();
            } else if( flags.refcheck ) DB->msg("***********************************No cache to enter %s", *tree->get_hash().partialimage() );
        } else if( outargs.responsecode() == MSG_ERR_ENTER_INCOMPLETE && doconsolidate ) {
            if( backtree_msg ) DB->msg("backtree::response %s continue doconsolidate", *tree->get_hash().partialimage());
            childdone(NULL);
            return;
        } else if( outargs.responsecode() == MSG_ERR_TIMEOUT ) {        
            Out->msg(ERR, "<5774>Internal Error: backtree: ADD_HASH timeout error" );
            throw EXC_TIMEOUT;
        } else if( outargs.responsecode() == MSG_ERR_PRIV_FAIL ) {  
            Out->msg(ERR, "<5408>Unauthorized message detected." );
            throw EXC_PRIV_FAIL;
        } else {
            Out->msg(ERR, "<5775>Internal Error: backtree: bad response %s %d %s", *tree->get_hash().image(), +outargs.head().serial, *outargs.ximage());

            throw EXC_HFSERROR;
        }
        tree->set_why(stats::sent);
        notifyparent();
    }
}

bool backtree::buildconsolidated(message& inargs)
{
    if(!doconsolidate)
        return false;

    
    
    bool shouldsend = false;
    chunktree::node *sib = tree->get_child();
    while(sib != NULL) {
        if(sib->shouldbesent()) {
            shouldsend = true;
            break;
        }
        sib = sib->get_sibling();
    }

    
    
    
    if(!shouldsend) {
        doconsolidate = false;
        return false;
    }

    
    

    
    
    sib = tree->get_child();
    unsigned int nsibs = sib->get_sibcount();

    if( backtree_msg ) DB->msg("backtree::buildconsolidated %s ncons=%u nsibs=%u", *tree->get_hash().partialimage(), ncons, nsibs);

    
    
    tchunkinfolist chunks(nsibs+1);

    
    
    chunks.push_back(tree->get_datasize(), tree->get_kind(), tree->get_data());

    unsigned int cnt=0;
    while(sib != NULL) {
        if( backtree_msg ) DB->msg("backtree::buildconsolidated %s size=%u send=%d", *tree->get_hash().partialimage(), chunks.size(), sib->shouldbesent());
        if(chunks.size() >= ncons && sib->shouldbesent()) {
            if( backtree_msg )
                DB->msg("backtree::buildconsolidated %s currbytes=%u datasize=%d max=%u",
                        *tree->get_hash().partialimage(), chunks.currbytes(), sib->get_datasize(), message::maxmessagedatasize());

            if(chunks.currbytes() + sib->get_datasize() > message::maxmessagedatasize())
                break;

            chunks.push_back(sib->get_datasize(), sib->get_kind(), sib->get_data());
            sib->set_why(stats::sent);          
        }
        else
            chunks.push_empty();

        sib = sib->get_sibling();
        cnt++;
    }
    assert(sib != NULL || cnt==nsibs);

    
    
    ncons = chunks.size();

    msgpack_c::addcompdata acd(inargs);
    unsigned int chunktotal = nsibs+1;
    unsigned int chunkcount = ncons;
    hashcode hash = tree->get_hash();
    chunktype kind = tree->get_kind();
    fileref data(chunks.data());
    acd.arg(PACK, chunktotal, chunkcount, hash, data);

    
    
    if(chunks.size() == nsibs+1)
        doconsolidate = false;

    if( backtree_msg ) DB->msg("backtree::buildconsolidated %s chunktotal=%u chunkcount=%u kind=%s size=%d", *hash.partialimage(), chunktotal, chunkcount, *kind.image(), data.size());
    if( backtree_msg ) DB->msg("backtree::buildconsolidated %s prepared addcompdata nsibs=%u ncons=%u doconsolidate=%d", *hash.partialimage(), nsibs, ncons, doconsolidate);

    return true;
}

void backtree::childdone(cycle *child) {
    if( backtree_msg ) DB->msg("backtree::childdone this=%p child=%p", this, child );
    if( backtree_msg ) DB->msg("backtree::childdone tree=%p nforked:%d collected=%d collectdone=%d forksdone=%d", tree, nforked, ncollected, collectdone, forksdone  );

    if (backtree_msg && tree) DB->msg("backtree::childdone %s depth=%d", *tree->get_hash().partialimage(), tree->get_depth());

    if(! collectdone) {
        if(child==NULL) { 
            if( backtree_msg ) DB->msg( "backtree::childdone child==NULL => forksdone=true %p %s", this, *tree->get_hash().partialimage() );
            forksdone = true;
        } else {
            ncollected++;
            if( backtree_msg ) DB->msg( "backtree::childdone ncollected=%d", ncollected );
            
        }

        assert(ncollected <= nforked);
        if(forksdone && ncollected == nforked) {
            collectdone = true;
            if( ispresent ) {
                if( backtree_msg ) DB->msg( "backtree::childdone %s ispresent=true", *tree->get_hash().partialimage());
                notifyparent();
            } else if( skipaddhashdata ) {
                if( backtree_msg ) DB->msg( "backtree::childdone %s skipaddhashdata=true", *tree->get_hash().partialimage());
                notifyparent();
            } else {
                if( backtree_msg ) DB->msg( "backtree::childdone %s sending self doconsolidate=%d", *tree->get_hash().partialimage(), doconsolidate);
                if(flags.refcheck && !checkrefs(nforked)) {
                    assert( false );
                    throw EXC_CANCEL;
                    return;
                }

                message inargs;

                if(buildconsolidated(inargs)) {
                    if(doconsolidate)        
                        collectdone = false; 
                }
                else {
                    msgpack_c::addhashdata  addhashdata_message(inargs);
                    hashcode  hash = tree->get_hash();
                    chunktype kind = tree->get_kind();
                    fileref   data = tree->get_data();
                    addhashdata_message.arg(PACK, hash, kind, data);
                }

                main->remotecall(this, inargs, dpninx);
                if( backtree_msg ) DB->msg("backtree::childdone %s sent add_hash_data consolidate=%d", *tree->get_hash().partialimage(), doconsolidate);
            }
        }
    } else {
        if (backtree_msg) DB->msg("backtree::childdone %s ***************** BAD", tree ? *tree->get_hash().partialimage() : "<null tree>");
        assert(false);
        
    }
}

void backtree::notifyparent() {
    assert(ncollected==0 || ncollected == nforked);
    if( backtree_msg ) DB->msg( "backtree::notifyparent this=%p", this );
    if( backtree_msg ) DB->msg( "backtree::notifyparent tree=%p this=%p parent=%p nforked=%d ncollected=%d kind=%s", tree, this, parent, nforked, ncollected, *tree->get_kind().image() );
    if( backtree_msg ) DB->msg( "backtree::notifyparent %s parent:%p stats:%p fstats:%p", *tree->get_hash().partialimage(), parent, stats, fstats.getimpl());
    
    if (stats) {
        if( backtree_msg ) DB->msg("backtree::notifyparent %s calling treestats then delete", *tree->get_hash().partialimage());
        if(!ignorestats)tree->treestats(stats, stats::noreason, main->handling_system_info());
        if( backtree_msg ) DB->msg( DBTXT("backtree::notifyparent delete tree %p"), tree );
        tree->node_complete = true;
        if( ispresent || didlistlookup )                
            tree->delete_subordinate_cycles( false ); 
                                                      
        delete tree;  
        tree = NULL;
    }
    else {
        if( backtree_msg ) DB->msg("backtree::notifyparent %s stats", *tree->get_hash().partialimage());
        
        
        
        
    }
    if(parent) {
        if( backtree_msg ) DB->msg( "backtree::notifyparent()  parent->childdone(this) parent=%p", parent );
        parent->childdone(this);
    }

    if( backtree_msg ) DB->msg( "backtree::notifyparent(%p)  deleteself()", this);
    deleteself(); 
}



#if !defined(BACKSTREAM_H_INCLUDED)
#define BACKSTREAM_H_INCLUDED












#include "fileref.h"
#include "scalar.h"
#include "cycle.h"
#include "fileoffset.h"
#include "nbackdir.h"
#include "inode_table.h"
#include "hardlink_path_table.h"
#include "backupboost_interface.h"

class context;
class cycle;
class workelem;             
class utar_flags_info;
class upath;
class filemem;
class parsestream_base;
class exportstream_xmlp;




#define disable_cmr10_inflation ((xflag[22]&524288)==0)


class backstream : public BackCycle   
{

public:
  SAFEALLOC(backstream);

  backstream(BackCycle* parent_, context* main, workelem *info_,
             const ustring fromstream, exportstream_xmlp& infop,
             const location::tbackupid backupid = 0,
             BackupRootInfoList *backup_list_ = NULL, bool manual = false);

  virtual ~backstream();

  virtual void init();
  virtual void response(message& outargs);
  virtual void childdone(cycle *child);

private:

  
  backstream();

  
  void startbackstreamdir();

  
  
  bool populate_previous_location(const BackupRootInfo &prev_backup,
                                  const location::tbackupid &backupid,
                                  const ustring &prefix);

  
  parsestream_base *parser;

  
  
  
  inode_table inodetab;

  
  
  
  
  backupboost::hardlink_path_table hardlink_path_tab;

  
  
  
  backupboost::path2event_table bbeventlist;

  
  backupboost::backupboostutils bbutils;

  
  backupboost::target_session_result prev_result;

  enum phases { initial,       
                thread_cycle,  
                inodetabcheck, 
                avpaxstream,   
                stream,        
                done };

  phases phase;

  
  
  utar_flags_info vol_flags;

  
  
  exportstream_xmlp& exportstream_infop;

  
  location::tbackupid prev_backupid;

  
  BackupRootInfoList *backup_list;

  
  BackupRootInfo prev_backup;

  
  bool thread_started;

  
  bool manual;

  ubigint64 session_id;

  backupboost::backupboost_interface::lfs_handle token;

  static mtex bb_journal_mutex;
};


#endif

#if !defined(FILEDDR_H_INCLUDED)
#define FILEDDR_H_INCLUDED












#include "common.h"
#include "debug.h"
#include "filebase.h"
#include "fileslice.h"


#if DDRSUPPORTED

#include "ddrfs_reader.h"
#include "ddrfs_backup.h"
#include <stack>

class upath;






class fileddr : public filebase {
public:
    typedef enum _fileddrtype{ UNKNOWN,
                               READ_RESTORE, 
                               READ_BACKUP,  
                               WRITE_BACKUP  
                             } fileddrtype;

    fileddr(const DDR_HANDLE handle_,
            const ustring& containerlsu_,
            const ustring& containerpath_,
            const ustring& containername_);

    virtual ~fileddr();

    
    virtual const ustring desc() const { return "fileddr"; }

    
    virtual int size() const { return (int)tail.value(); }

    
    virtual fileoffset size64() const { return tail; }

    
    virtual bool contiguous() const { return false; }

    
    virtual char *start() { assert(false); return NULL; }

    
    virtual const char *start() const { assert(false); return NULL; }

    
    

    
    virtual void addhash(lowhash& c) const { assert(false); }

    
    

    
    

    
    virtual void getdata(void *res) const { assert(false); }

    
    virtual void setdata(const void *res) { assert(false); }

    
    virtual void clrdata() { assert(false); }

    
    virtual void getslice(int offset, int size, void *res) const { assert(false); }

    
    virtual void setslice(int offset, int size, const void *res) { assert(false); }

    
    virtual void clrslice(int offset, int size) { assert(false); }

    
    virtual void getslice64(fileoffset offset, int size, void *res) const { assert(false); }

    
    

    
    

    
    virtual char& operator[](int i) { assert(false); static char junk = 0; return junk; }

    
    virtual fileoffset tailoffset() const {
        return tail;
    }

    virtual bool isnullrange() const {
        return false;
    }

    
    virtual fileref makeslice(int offset, int size) { assert(false); return fileref(); }
    virtual fileref makeslice64(fileoffset offset, fileoffset size) { assert(false); return fileref(); }

    
    

    
    
    
    

    
    
    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    

    
    

    
    

    
    

    
    

    
    
    virtual bool inmemory(bool enable, bool memmap, bool random, unsigned int len) { return false; }

    
    

    
    
    

    
    

    
    

    
    

    
    
    virtual bool iserror(const filebase::errorseveritycode escThreshold = filebase::ERRCODE_WARN) const { return result != EXIT_OK; }

    
    virtual bool isshareerror() const { return false; }

    
    virtual bool canretry() const { return false; }

    virtual fileoffset offset() const = 0;
    virtual fileoffset offset64() const = 0;

    
    
    DDR_HANDLE get_ddrhandle() {return m_handle; };
    SAFEPOOLALLOC(fileddr);

  protected:
    int fsize;
    fileoffset tail;

    bool          debugMsgsOn;
    const ustring m_containerlsu;
    const ustring m_containername;
    const ustring m_containertype;
    bool          isclosed;
    exitcodes_t   result;
    unsigned int m_containerhandle;
    unsigned int m_checksumtype;
    const ustring m_containerpath;
    DDR_HANDLE m_handle; 
    fileddrtype m_fileddrtype;
};


class fileddrslice;
class fileddrwrite;






class fileddrread : public fileddr {
 public:
    
    
    fileddrread(const DDR_HANDLE handle_,
                const ustring &lsu_,
                const ustring &clientid_,
                const ubigint64 backupid_,
                const unsigned int streamindex);

    
    
    fileddrread(const DDR_HANDLE handle_,
                const ustring &lsu_,
                const ustring &clientid_,
                const ubigint64 backupid_,
                const unsigned int streamindex,
                const ddrfiles_xmlp ddrfilesxmlp_);

    
    fileddrread(const DDR_HANDLE handle_,
                const fileref& frwrite,
                const ustring &clientid_,
                const ubigint64 backupid_,
                const unsigned int streamindex,
                const ddrfiles_xmlp ddrfilesxmlp_);

    
    fileddrread(const DDR_HANDLE handle_,
                const fileref& frwrite,
                const ustring &lsu_,
                const ustring &absName_);

    virtual ~fileddrread();

    SAFEPOOLALLOC(fileddrread);

    
    virtual void getdata(void *res) const { assert(false); }

    
    virtual void getslice(int offset, int size, void *res) const { assert(false); }

    
    
    virtual void getslice64(fileoffset offset, int size, void *res) const;

    
    
    

    
    
    
    
    virtual int readfilenext(const size_t len, void* buf);

    
    
    
    
    virtual fileref makeslice(int offset, int size) { assert(false); return fileref(); }
    virtual fileref makeslice64( fileoffset offset,  fileoffset size,  tchecksum::tchecksumval* checksum);
    virtual fileref makeslice64( fileoffset offset,  fileoffset size);

    
    
    
    
    
    
    virtual fileoffset seek(const fileoffset offset, int whence = SEEK_SET);
    virtual bool is_seekable() const { return (m_r != NULL); }

    virtual fileoffset offset() const;
    virtual fileoffset offset64() const;

    int startchecksum(fileoffset& begin_offset);

    int endchecksum(  fileoffset& begin_offset,
                              fileoffset& length,
                              uint32_t* checksum);

    bool read(fileref &fr);
    unsigned int get_backup_handle() const { return m_backup_handle; };
    unsigned int get_container_index() const { return m_container_index; };
    fileref get_parent() const { return m_frw; };

 protected:
    const ddrfiles_xmlp m_ddrfilesxmlp;
    ubigint64           backupid;
    const ustring       &m_clientid;
    unsigned int        m_backup_handle;
    unsigned int        m_container_index;
    DDR_STREAM_HANDLE   m_wsh;
 private:
    ddrfs_readerp       m_r;
    fileref             m_frw; 
};



class fileddrwrite : public fileddr {
 public:
    fileddrwrite( const DDR_HANDLE handle_,  const ustring& containerlsu_,  const ustring& containerpath_,  const ustring& containername_);

    virtual ~fileddrwrite();

    SAFEPOOLALLOC(fileddrwrite);

    
    
    
    

    
    virtual void append(const void *elem, int length) { fileref buf; buf.initmem(elem, length); append(buf); }

    
    virtual void append(const univint n) {
        append(&n, sizeof(univint));
    }

    
    virtual void appendbyte(const char elem) {
        append(&elem, 1);
    }

    
    virtual void append(const fileref& f);

    
    int startchecksum(fileoffset& begin_offset);

    int endchecksum(  fileoffset& begin_offset,
                                           fileoffset& length,
                                           uint32_t* checksum);

    bool ddrstats(   const filebase::ddrfilestats kind,
                    ubigint64& stat,
                     const filebase::ddrstats_priority priority = filebase::DDRSTAT_PRIORITY_DEFAULT);

    virtual bool is_closeable() const { return true; }
    virtual bool is_closed() const { return isclosed; }
    virtual void close();

    
    virtual bool trace( uint16_t trace_type,
                        uint16_t payload_type,
                        const fileref& payload);

    virtual fileoffset offset() const;
    virtual fileoffset offset64() const;

    DDR_STREAM_HANDLE get_writestream_handle() { return m_wsh; };

    void associate(const ustring &prevBackupDir,
                   const ustring &backupid_,
                   const ddrfiles_xmlp &ddrfiles_ ,
                   unsigned int& backup_handle);

    void associate(const ustring &lsu,
                   const ustring &absName_,
                   const ustring &backupid_,
                   unsigned int& backup_handle);

    void disassociate(unsigned int backup_handle);

    unsigned int get_temp_backupID();
    unsigned int get_temp_streamID();

  private:
    ddrfs_backupp m_b;
    uint64_t m_filecount;
    DDR_STREAM_HANDLE m_wsh;
    unsigned int bid_count;
    unsigned int sid_count;
    fileoffset m_append_starting_offset;
    fileoffset m_currentoffset;

    bool create_ddrfs_backup();
};

class fileddrslice : public fileslice6464 {
 public:
    fileddrslice(const fileref& base, const fileref& frr, const int backup_handle_, const int container_handle_, const fileoffset &off, const fileoffset &sz,  uint32_t* checksum )
        : fileslice6464(base, off, sz), m_newoffset(off), m_checksum_is_valid(checksum != NULL), m_checksum(m_checksum_is_valid ? *checksum : 0), m_backup_handle(backup_handle_), m_container_handle(container_handle_), m_frr(frr)
    {
    }

    virtual ~fileddrslice() {}

    fileoffset get_slice_offset() { return offset(); };
    fileoffset get_slice_length() { return size64(); };

    int get_container_handle()    { return m_container_handle; };
    int get_backup_handle()       { return m_backup_handle; };

    bool get_slice_checksum(uint32_t* checksum)
    {
        if(!checksum) return false;

        if(m_checksum_is_valid){
            *checksum = m_checksum;
        }
        return m_checksum_is_valid;
    };

    void set_newoffset(fileoffset newoffset) { m_newoffset = newoffset; };
    fileoffset newoffset() { return m_newoffset; };
    fileref get_parent() { return m_frr; };

private:
    fileoffset     m_newoffset;
    const bool     m_checksum_is_valid;
    const uint32_t m_checksum;
    int            m_backup_handle;
    int            m_container_handle;
    fileref        m_frr; 
};

class fileddr_exception
{
public:
    explicit fileddr_exception(dd_errno_t errCode, const char* file, int line);
    fileddr_exception(dd_errno_t errCode, const char* description, const char* file, int line);
    fileddr_exception(const char* description, const char* file, int line);

    ustring Description() const;
    dd_errno_t ErrorCode() const;
    ustring File() const;
    int Line() const;

    SAFEPOOLALLOC(fileddr_exception);
private:
    dd_errno_t _errCode;
    ustring   _desc;
    ustring   _file;
    int      _line;
};

#endif 

#endif
#include <iostream>
#include <algorithm>

#include "common.h"
#include "debug.h"
#include "zfstarstream.h"
#include "paxndmp.h"
#include "file.h"
#include "ndmp_volume_entification.h"

using namespace std;





















































#define msg1 ((xflag[02] & 8192) != 0)
#define msg2 ((xflag[02] & 16384) != 0)

namespace zfstarstream
{
const int INITIAL_PEEKBUFFER_SIZE = 8 * 1024 * 1024;
const int MAX_PEEKDATA_BUFSIZE = 64 * 1024 * 1024;
const ustring MAGIC_LABEL = "ustar  ";
const ustring METADATA_LABEL = "NDMPUTF8MAGIC";

ustring typeflag2str(unsigned char typeflag)
{
    ustring str;

    switch (typeflag) {
        case LF_NONE:
            str = "none";
            break;
        case LF_NORMAL:
            str = "file";
            break;
        case LF_LINK:
            str = "link";
            break;
        case LF_SYMLINK:
            str = "symlink";
            break;
        case LF_CHR:
            str = "character device";
            break;
        case LF_BLK:
            str = "block device";
            break;
        case LF_DIR:
            str = "directory";
            break;
        case LF_FIFO:
            str = "fifo";
            break;
        case LF_CONTIG:
            str = "contiguous file";
            break;
        case LF_HUMONGUS:
            str = "humongus file";
            break;
        case LF_LONGLINK:
            str = "long link";
            break;
        case LF_LONGNAME:
            str = "long name";
            break;
        case LF_MULTIVOL:
            str = "multi volume";
            break;
        case LF_VOLHDR:
            str = "tape volume header";
            break;
        case LF_ACL:
            str = "acl";
            break;
        case LF_XATTR:
            str = "xattr";
            break;
        default:
            str = "UNKNOWN";
            break;
    }

    return str;
}

ustring thmarker2str(unsigned char thmarker)
{
    ustring str;

    switch (thmarker) {
        case TH_NONE:
            str = "none";
            break;
        case TH_REGULAR:
            str = "begin regular file";
            break;
        case TH_SPECIAL:
            str = "begin special file";
            break;
        case TH_DIRECTORY:
            str = "begin directory";
            break;
        case TH_ATTRIBUTE:
            str = "begin extended attr file";
            break;
        case TH_HUGEFILE:
            str = "begin subfile within humongus file";
            break;
        default:
            str = "UNKNOWN";
            break;
    }

    return str;
}

int get_padding(bigint64 datasize, int blocksize)
{
    return ((int)(blocksize - (datasize % blocksize)) % blocksize);
}

zfstar_ctx::zfstar_ctx()
{
    clear();
}

void zfstar_ctx::clear()
{
    tarstate = ZFS_TAR_NONE;
    hdrstate = S_NONE;
    typeflag = LF_NONE;
    thmarker = TH_NONE;
    filebytesremaining = 0;
    hdrbytesremaining = 0;
    endoffset = 0;
}

ustring zfstar_ctx::image() const
{
    ustring statestr;

    switch (tarstate) {
    case ZFS_TAR_HEADER:
        statestr = "zfs_tar_header";
        break;
    case ZFS_TAR_PRIMARY:
        statestr = "zfs_tar_primary";
        break;
    case ZFS_TAR_PADDING:
        statestr = "zfs_tar_padding";
        break;
    case ZFS_TAR_HUMONGUS:
        statestr = "zfs_tar_humongus";
        break;
    case ZFS_TAR_EXTENDED:
        statestr = "zfs_tar_extended";
        break;
    case ZFS_TAR_DONE:
        statestr = "zfs_tar_done";
        break;
    default:
        statestr = "UNKNOWN";
        break;
    }

    return ustring::sprintf("state:%s fbytesremaining:%s startpos:%s",
                            *statestr, *filebytesremaining.image(),
                            *endoffset.image());
}




header::header()
{
    clear();
}

header::header(const fileref& buf)
{
    initialize(buf);
}

void header::clear()
{
    state = ets_hdr_uninitialized;
    pathname = "";
    mode = 0;
    uid = 0;
    gid = 0;
    size = 0;
    mtime = 0;
    chksum = 0;
    typeflag = LF_NONE;
    linkpath = "";
    magic = "";
    uname = "";
    gname = "";
    devmajor = "";
    devminor = "";
    hlinkino = 0;
    prefix = "";
    thprimary = "";
    thversion = 0;
    thmarker = 0;
    thinode = 0;
    thnlink = 0;
}

void header::initialize(const fileref& buf)
{
    clear();

    const int FIELD_SIZE_TOTAL = TH_NLINK_FIELD_OFFSET + TH_NLINK_FIELD_LEN;

    if (buf.size() < FIELD_SIZE_TOTAL) {
        state = ets_hdr_insufficientdata;
        return;
    }

    pathname   = ( parsestream_base::extractstring2  (buf,  NAME_FIELD_OFFSET,      NAME_FIELD_LEN        ));
    mode       = ( parsestream_base::extractulong    (buf,  MODE_FIELD_OFFSET,      MODE_FIELD_LEN,      8));
    uid        = ( parsestream_base::extractulong    (buf,  UID_FIELD_OFFSET,       UID_FIELD_LEN,       8));
    gid        = ( parsestream_base::extractulong    (buf,  GID_FIELD_OFFSET,       GID_FIELD_LEN,       8));
    size       = ( parsestream_base::extractubigint64(buf,  FILE_SIZE_FIELD_OFFSET, FILE_SIZE_FIELD_LEN, 8));
    mtime      = ( parsestream_base::extractulong    (buf,  MTIME_FIELD_OFFSET,     MTIME_FIELD_LEN,     8));
    chksum     = ( parsestream_base::extractulong    (buf,  CHKSUM_FIELD_OFFSET,    CHKSUM_FIELD_LEN,    8));
    typeflag   = ( parsestream_base::extractuchar    (buf,  TYPEFLAG_OFFSET                               ));
    linkpath   = ( parsestream_base::extractstring2  (buf,  LINKNAME_FIELD_OFFSET,  LINKNAME_FIELD_LEN    ));
    magic      = ( parsestream_base::extractstring2  (buf,  MAGIC_FIELD_OFFSET,     MAGIC_FIELD_LEN       ));
    uname      = ( parsestream_base::extractstring2  (buf,  UNAME_FIELD_OFFSET,     UNAME_FIELD_LEN       ));
    gname      = ( parsestream_base::extractstring2  (buf,  GNAME_FIELD_OFFSET,     GNAME_FIELD_LEN       ));
    devmajor   = ( parsestream_base::extractstring2  (buf,  DEVMAJOR_FIELD_OFFSET,  DEVMAJOR_FIELD_LEN    ));
    devminor   = ( parsestream_base::extractstring2  (buf,  DEVMINOR_FIELD_OFFSET,  DEVMINOR_FIELD_LEN    ));
    if ( typeflag == LF_LINK ) {
        
        hlinkino   = ( parsestream_base::extractulong    (buf,  HLINK_INO_FIELD_OFFSET, HLINK_INO_FIELD_LEN, 8));
    }
    prefix     = ( parsestream_base::extractstring2  (buf,  PREFIX_FIELD_OFFSET,     PREFIX_FIELD_LEN      ));
    thprimary  = ( parsestream_base::extractstring2  (buf,  TH_PRIMARY_FIELD_OFFSET, TH_PRIMARY_FIELD_LEN  ));
    thprimary  = ustring(""); 
    thversion  = ( parsestream_base::extractuchar    (buf,  TH_VERSION_FIELD_OFFSET                       ));
    thmarker   = ( parsestream_base::extractuchar    (buf,  TH_MARKER_FIELD_OFFSET                        ));
    thinode    = ( parsestream_base::extractubigint64(buf,  TH_INODE_FIELD_OFFSET,  TH_INODE_FIELD_LEN, 10));
    thnlink    = ( parsestream_base::extractulong    (buf,  TH_NLINK_FIELD_OFFSET,  TH_NLINK_FIELD_LEN, 10));

    if (msg2)
        dump();

    
    if (!magic.equal(MAGIC_LABEL)) {
        if (typeflag == 0 && mode == 0 && mtime == 0 && size == 0 && chksum == 0) {
            if (allzerobytes(buf.start(), BLOCKSIZE)) {
                state = ets_hdr_zeroblock;
                return;
            }

            state = ets_hdr_badvalues;
            return;
        }

        state = ets_hdr_badmagic;
        return;
    }

    
    unsigned short cchksum = calculate_checksum(buf);

    if (chksum != cchksum) {
        errmsg = ustring::sprintf("checksum %u (%o octal) does not match calculated chksum %u (%o octal)",
                                  chksum, chksum, cchksum, cchksum);
        state = ets_hdr_badchksum;
        return;
    }

    state = ets_hdr_good;
}



void header::get_header_buf(fileref& headerbuf)
{
    pax_header pax_hdr;
    memset(&pax_hdr, 0, sizeof(pax_hdr));
    snprintf(pax_hdr.pathname, sizeof(pax_hdr.pathname), "%s", pathname.tostr());

    unsigned int mode_mask = 0;

#ifdef S_IFDIR
    mode_mask |= S_IFDIR;
#endif
#ifdef S_IFCHR
    mode_mask |= S_IFCHR;
#endif
#ifdef S_IFBLK
    mode_mask |= S_IFBLK;
#endif
#ifdef S_IFREG
    mode_mask |= S_IFREG;
#endif
#ifdef S_IFIFO
    mode_mask |= S_IFIFO;
#endif
#ifdef S_IFLNK
    mode_mask |= S_IFLNK;
#endif
#ifdef S_IFSOCK
    mode_mask |= S_IFSOCK;
#endif

    mode = mode & ~mode_mask;

    snprintf(pax_hdr.mode, sizeof(pax_hdr.mode), "%06o ", mode);
    snprintf(pax_hdr.uid, sizeof(pax_hdr.uid), "%06o ", uid);
    snprintf(pax_hdr.gid, sizeof(pax_hdr.gid), "%06o ", gid);
    snprintf(pax_hdr.size, sizeof(pax_hdr.size), "%lo ", size);
    snprintf(pax_hdr.mtime, sizeof(pax_hdr.mtime), "%lo", mtime);
    pax_hdr.typeflag = typeflag;
    snprintf(pax_hdr.linkpath, sizeof(pax_hdr.linkpath), "%s", linkpath.tostr());
    snprintf(pax_hdr.magic, sizeof(pax_hdr.magic), "%s", magic.tostr());
    snprintf(pax_hdr.uname, sizeof(pax_hdr.uname), "%s", uname.tostr());
    snprintf(pax_hdr.gname, sizeof(pax_hdr.gname), "%s", gname.tostr());
    snprintf(pax_hdr.u.dev.major, sizeof(pax_hdr.u.dev.major), "%s", devmajor.tostr());
    snprintf(pax_hdr.u.dev.minor, sizeof(pax_hdr.u.dev.minor), "%s", devminor.tostr());

    if ( (hlinkino > 0) && (typeflag == LF_LINK) ) {
        snprintf(pax_hdr.u.hlinkino, sizeof(pax_hdr.u.hlinkino), "%lo ", hlinkino);
    }

    memset(pax_hdr.thprimary, '\0', sizeof(pax_hdr.thprimary)); 
    snprintf(pax_hdr.prefix, sizeof(pax_hdr.prefix), "%s", prefix.tostr());
    pax_hdr.thversion = thversion;
    pax_hdr.thmarker = thmarker;
    if (thinode > 0)
        snprintf(pax_hdr.thinode, sizeof(pax_hdr.thinode), "%llu", (long long unsigned int)thinode);
    if (thnlink > 0)
        snprintf(pax_hdr.thnlink, sizeof(pax_hdr.thnlink) , "%lu", thnlink);
    headerbuf.initmem(sizeof(pax_hdr));
    headerbuf.clrdata();
    headerbuf.setslice(0, sizeof(pax_hdr), &pax_hdr);
    snprintf(pax_hdr.chksum, sizeof(pax_hdr.chksum),
            "%6o", calculate_checksum(headerbuf)); 
                                                   
    pax_hdr.chksum[CHKSUM_FIELD_LEN-1] = ' ';
    headerbuf.setslice(CHKSUM_FIELD_OFFSET, sizeof(pax_hdr.chksum), pax_hdr.chksum);
}


unsigned short header::calculate_checksum(const fileref& buf)
{
    if (buf.size() < BLOCKSIZE)
        return 0;
    const int a = CHKSUM_FIELD_OFFSET;
    
    const char* clearchksumfield = "        "; 
    unsigned short chksum = 0;
    const unsigned char* p = (const unsigned char*)buf.start();
    for (int i = 0; i < BLOCKSIZE; i++) {
        if (i >= a && i < a + 8) {
            chksum += clearchksumfield[i - a];
        } else {
            chksum += p[i];
        }
    }
    return chksum;
}

ubigint64 header::get_padded_size() const
{
    return size + get_padding(size);
}

bool header::is_tar_hardlink() const
{
    return (typeflag == LF_LINK) || (typeflag != LF_DIR && thnlink > 1);
}

bool header::allzerobytes(const char* p, size_t n)
{
    for (size_t i = 0; i < n; i++)
        if (p[i] != 0) return false;
    return true;
}

bool header::iszeroblock() const
{
    return state == ets_hdr_zeroblock;
}

bool header::isgood() const
{
    return state == ets_hdr_good;
}

bool header::is_special_file() const
{
    return typeflag == LF_SYMLINK || typeflag == LF_CHR ||
           typeflag == LF_BLK || typeflag == LF_FIFO;
}

bool header::is_long_name() const
{
    return typeflag == LF_LONGNAME;
}

ustring header::image() const
{
    return ustring::sprintf("state:%s pathname:%s mode:%d uid:%u gid:%u size:%"LL"u mtime:%lu chksum:%u "
                            "typeflag:%u magic:%s uname:%s gname:%s devmajor:%u devminor:%u hlinkino:%lu "
                            "prefix:%s thprimary:%s thversion:%u thmarker:%c thinode:%"LL"u thnlink:%lu%s",
                            *stateimage(), *pathname, mode, uid, gid, size, mtime, chksum, typeflag,
                            *magic, *uname, *gname, devmajor.toint(), devminor.toint(),
                            hlinkino, *prefix, *thprimary, thversion, thmarker, thinode, thnlink,
                            *(errmsg.isempty() ? errmsg : ustring::sprintf(" errormsg:%s", *errmsg)));
}

void header::dump() const
{
    DB->msg(" zfstarstream::parser header, state '%s' errmsg '%s'", *stateimage(), *errmsg);
    DB->msg(" pathname:    '%s'", *pathname);
    DB->msg(" mode:        %u (%x hex, %o oct)", mode, mode, mode);
    DB->msg(" uid:         %u", uid);
    DB->msg(" gid:         %u", gid);
    DB->msg(" size:        %"LL"u (%"LL"x hex, %"LL"o oct)", size, size, size);
    datetime dt(mtime, true);
    DB->msg(" mtime:       %lu (%s)", mtime, *dt.imageTZ(true) );
    DB->msg(" chksum:      %u", chksum);
    DB->msg(" typeflag:    %u ('%c', '%s')", typeflag, (char)typeflag, *typeflag2str(typeflag) );
    DB->msg(" linkpath:    '%s'", *linkpath);
    DB->msg(" magic:       '%s'", *magic);
    DB->msg(" uname:       '%s'", *uname);
    DB->msg(" gname:       '%s'", *gname);
    DB->msg(" devmajor:    %s", *devmajor);
    DB->msg(" devminor:    %s", *devminor);
    DB->msg(" hlinkino:    %lu", hlinkino);
    DB->msg(" prefix:      '%s'", *prefix);
    DB->msg(" thprimary:   '%s'", *thprimary);
    DB->msg(" thversion:   %u", thversion);
    DB->msg(" thmarker:    %u ('%c', '%s')", thmarker, (char)thmarker, *thmarker2str(thmarker));
    DB->msg(" thinode:     %"LL"u (%"LL"x hex)", thinode, thinode);
    DB->msg(" thnlink:     %lu", thnlink);
}

ustring header::stateimage() const
{
    ustring res = "(none)";

    switch (state) {
    case ets_hdr_uninitialized:
        res = ustring("uninitialized");
        break;
    case ets_hdr_insufficientdata:
        res = ustring("insufficientdata");
        break;
    case ets_hdr_badmagic:
        res = ustring("badmagic");
        break;
    case ets_hdr_badchksum:
        res = ustring("badchksum");
        break;
    case ets_hdr_zeroblock:
        res = ustring("zeroblock");
        break;
    case ets_hdr_badvalues:
        res = ustring("badvalues");
        break;
    case ets_hdr_good:
        res = ustring("good");
        break;
    default:
        res = ustring::sprintf("unknownstate_%d", state);
        break;
    }

    return res;
}



parser::parser(const ustring& streamdesc,
               const int streamformat,
               const int blocksize,
               const int stream_timeoutsecs,
               const unsigned objflags_,
               const ustring& input_tee_streamdesc,
               utar_flags_info* flags_)
    : parsestream(streamdesc, streamformat, blocksize, stream_timeoutsecs, objflags_, input_tee_streamdesc),
      pax_hdr(), marks(), tarctx(), flags(flags_), found_zero_block(false), empty_stream(true), eof(false),
      totalfiledatasize(0), bytesread(0)
{
    peekeddata.initmem(INITIAL_PEEKBUFFER_SIZE);
    peekstart = 0;
    peekend = 0;

    if (flags != NULL)
        set_start_time(flags->start_timestamp);
}

parser::~parser()
{
}


void parser::read_all_zeros()
{
    bigint64 datainsize;
    fileref zeroheader;

    int zero_block_count = 2;
    do {
        datainsize = getdata(blocksize, zeroheader, "zero_bytes");
        zero_block_count++;
        
        
        
    } while ((datainsize > 0) && (zero_block_count < 4096));
}

bool parser::check_empty_block(bool& founderror)
{
    bytesread = peekdata(blocksize, peekbuffer, "header");

    if (bytesread != blocksize) {
        errormsg = ustring::sprintf("End of stream should be signaled by 2 empty blocks. "
                                    "Attempted read of 512 bytes to verify second empty block returned %"LL"d bytes.",
                                    bytesread);
        founderror = true;
        return false;
    }

    pax_hdr.initialize(peekbuffer);
    if (!pax_hdr.iszeroblock()) {
        errormsg = "End of stream should be signaled by 2 empty blocks. "
                   "Found one empty block, but second block is not empty.";
        founderror = true;
        return false;
    }

    hit_eof = true;
    read_all_zeros();
    return true;
}




bool parser::check_eof(bool& founderror)
{
    if (hit_eof) {
        founderror = false;
        return true;
    }

    if (found_zero_block || (!found_zero_block && pax_hdr.iszeroblock()))
        return check_empty_block(founderror);

    empty_stream = false;
    founderror = false;

    return false;
}

bool parser::is_empty_stream() const
{
    return empty_stream;
}

bool parser::check_hardlink_exists()
{
    return hardlinkinodes.defined(pax_hdr.thinode);
}

bool parser::is_first_hlink()
{
    return pax_hdr.is_tar_hardlink() && !check_hardlink_exists();
}



void parser::set_tar_hardlink(DIRELEMp& de)
{
    if (!pax_hdr.is_tar_hardlink())
        return;
    intobj existing_val;
    if (hardlinkinodes.enter_if_undef(pax_hdr.thinode, pax_hdr.thnlink-1, existing_val))
        return;
    de->set_tar_hardlink(true);
    existing_val = existing_val-1;
    if (existing_val == 0) {
        hardlinkinodes.remove(pax_hdr.thinode);
    } else {
        hardlinkinodes.enter(pax_hdr.thinode, existing_val);
    }
}

bool parser::is_peekbuffer_empty()
{
    return peekstart == peekend;
}

bool parser::is_humongus_file() const
{
    return humongus_hdr.typeflag == LF_HUMONGUS;
}

ubigint64 parser::file_size() const
{
    return totalfiledatasize;
}





bool parser::path_changed(const ustring& curpath)
{
    
    
    
    ustring pathstr = ndmp_unentify_volume_plus_path(curpath);
    upath realpath(pathstr, upath::kind_unix, true);
    if (realpath.has_end_dirsep())
        realpath.set_end_dirsep(false);
    upath fullpath(fullpathstr, upath::kind_unix, true);
    if (fullpath.has_end_dirsep())
        fullpath.set_end_dirsep(false);
    if (fullpath.image().equal(realpath.image()))
        return false;
    return true;
}






void parser::set_path(const ustring& curpath)
{
    
    
    
    ustring pathstr = ndmp_unentify_volume_plus_path(curpath);
    if (humongus_hdr.typeflag == LF_HUMONGUS) {
        ustring datastr;
        humongus_data.getslice(0, (int)humongus_hdr.size, datastr);
        stringlist slist = datastr.split(' ');
        datastr = slist[0] + " " + pathstr;
        int datalen = datastr.bytelength();
        int paddedlen = datalen + get_padding(datalen);
        humongus_hdr.size = datalen;
        humongus_data.initmem(paddedlen);
        humongus_data.clrdata();
        humongus_data.setslice(0, datalen, datastr.tostr());
    } else {
        int pathlen = pathstr.bytelength();
        if (pathlen < NAME_FIELD_LEN) {
            if (longname_hdr.typeflag == LF_LONGNAME) {  
                if (acl_hdr.typeflag == LF_NONE)
                    pax_hdr.thmarker = longname_hdr.thmarker;
                longname_hdr.clear();
                longname_data = fileref();
            }
            pax_hdr.pathname = pathstr;
        } else {
            if (longname_hdr.typeflag == LF_NONE) {
                longname_hdr = pax_hdr;
                longname_hdr.pathname = LONGNAME_LABEL;
                longname_hdr.typeflag = LF_LONGNAME;
                if (acl_hdr.typeflag == LF_NONE) {
                    longname_hdr.thmarker = pax_hdr.thmarker;
                    pax_hdr.thmarker = TH_NONE;
                }
                pax_hdr.pathname = LONGNAME_LABEL;
            }
            longname_hdr.size = pathlen;
            longname_data.initmem(pathlen + get_padding(pathlen));
            longname_data.clrdata();
            longname_data.setslice(0, pathlen, pathstr.tostr());
        }
    }
}




void parser::get_header_image(fileref& hdrimage, bool skipaclhdr)
{
    fileref buf;
    hdrimage.initlist(0);
    if (metadata_hdr.pathname.equal(METADATA_LABEL)) {
        metadata_hdr.get_header_buf(buf);
        hdrimage.append(buf);
        hdrimage.append(metadata_blob);
    }
    
    
    if (acl_hdr.typeflag == LF_ACL && !skipaclhdr) {
        acl_hdr.get_header_buf(buf);
        hdrimage.append(buf);
        hdrimage.append(acl_data);
    }
    if (longname_hdr.typeflag == LF_LONGNAME) {
        longname_hdr.get_header_buf(buf);
        hdrimage.append(buf);
        hdrimage.append(longname_data);
    }
    if (longlink_hdr.typeflag == LF_LONGLINK) {
        longlink_hdr.get_header_buf(buf);
        hdrimage.append(buf);
        hdrimage.append(longlink_data);
    }
    if (humongus_hdr.typeflag == LF_HUMONGUS) {
        humongus_hdr.get_header_buf(buf);
        hdrimage.append(buf);
        hdrimage.append(humongus_data);
    } else if (pax_hdr.typeflag != LF_NONE) {
        pax_hdr.get_header_buf(buf);
        hdrimage.append(buf);
    }
}

bool parser::get_next_header()
{
    if (is_peekbuffer_empty()) {
        bytesread = peekdata(blocksize, peekbuffer, "header");
        if (bytesread != blocksize)
            return false;
    } else {
        peekbuffer = peekeddata.makeslice64(peekstart, peekend - peekstart);
    }

    pax_hdr.initialize(peekbuffer);

    bool founderror;
    if (check_eof(founderror)) {
        eof = true;
        return true;
    }

    if (founderror)
        return false;

    
    if (!pax_hdr.isgood()) {
        errormsg = ustring::sprintf("Found bad pax header at %s: %s", *bytepos.image(), *pax_hdr.errormsg());
        Out->msg(ERR, "Data stream error encountered: %s", *errormsg);
        uapp::staging().startTermination(EXIT_ABORT, "invalid pax header found while parsing backup data stream");
        return false;
    }

    totalfiledatasize = (pax_hdr.typeflag == LF_NORMAL || is_first_hlink()) ? pax_hdr.size : 0;
    if (pax_hdr.is_special_file())
        totalfiledatasize = 0;
    fullpathstr = pax_hdr.pathname;
    tarctx.endoffset += blocksize;
    tarctx.typeflag = pax_hdr.typeflag;

    return true;
}

bool parser::get_metadata_block()
{
    bigint64 datasize = pax_hdr.get_padded_size();
    bytesread = peekdata(datasize, peekbuffer, "metadatablock");
    if (bytesread != datasize) {
        errormsg = ustring::sprintf("Problem reading metadata block, only %"LL"d bytes read of %"LL"u bytes", bytesread, datasize);
        return false;
    }
    metadata_hdr = pax_hdr;
    metadata_blob = peekbuffer.makeslice64(0, bytesread);
    tarctx.endoffset += datasize;

    bytesread = peekdata(blocksize, peekbuffer, "header");
    if (bytesread != blocksize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %d bytes", bytesread, blocksize);
        return false;
    }

    pax_hdr.initialize(peekbuffer);
    if (!pax_hdr.isgood()) {
        errormsg = ustring::sprintf("Found bad pax header at %s: %s", *bytepos.image(), *pax_hdr.errormsg());
        Out->msg(ERR, "Data stream error encountered: %s", *errormsg);
        uapp::staging().startTermination(EXIT_ABORT, "invalid pax header found while parsing backup data stream");
        return false;
    }

    if (pax_hdr.thversion > 0) {
        errormsg = ustring::sprintf("ZFS data stream version %u is not supported.  Version 0 currently supported.", pax_hdr.thversion);
        Out->msg(ERR, "Data stream version error: %s", *errormsg);
        uapp::staging().startTermination(EXIT_ABORT, "unsupported data stream format");
        return false;
    }

    totalfiledatasize = (pax_hdr.typeflag == LF_NORMAL || is_first_hlink()) ? pax_hdr.size : 0;
    fullpathstr = pax_hdr.pathname;
    tarctx.endoffset += blocksize;
    tarctx.typeflag = pax_hdr.typeflag;

    return true;
}

bool parser::get_acl_header()
{
    bigint64 datasize = pax_hdr.get_padded_size();
    bytesread = peekdata(datasize, peekbuffer, "datablock");
    if (bytesread != datasize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %"LL"d bytes", bytesread, datasize);
        return false;
    }
    acl_hdr = pax_hdr;
    acl_data = peekbuffer.makeslice64(0, bytesread);

    bytesread = peekdata(blocksize, peekbuffer, "header");
    if (bytesread != blocksize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %d bytes)", bytesread, blocksize);
        return false;
    }

    pax_hdr.initialize(peekbuffer);
    if (!pax_hdr.isgood()) {
        errormsg = ustring::sprintf("Found bad pax header at %s: %s", *bytepos.image(), *pax_hdr.errormsg());
        Out->msg(ERR, "Data stream error encountered: %s", *errormsg);
        uapp::staging().startTermination(EXIT_ABORT, "invalid pax header found while parsing backup data stream");
        return false;
    }

    totalfiledatasize = (pax_hdr.typeflag == LF_NORMAL || is_first_hlink()) ? pax_hdr.size : 0;
    if (pax_hdr.is_special_file())
        totalfiledatasize = 0;
    fullpathstr = pax_hdr.pathname;
    tarctx.endoffset += (datasize + blocksize);
    tarctx.typeflag = pax_hdr.typeflag;

    return true;
}

bool parser::get_humongusfile_header()
{
    bigint64 datasize = pax_hdr.get_padded_size();
    bytesread = peekdata(datasize, peekbuffer, "datablock");
    if (bytesread != datasize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %"LL"d bytes", bytesread, datasize);
        return false;
    }
    ustring datastr;
    peekbuffer.getslice(0, (int)pax_hdr.size, datastr);
    stringlist slist = datastr.split(' ');
    fullpathstr = slist[1];
    totalfiledatasize = slist[0].toint64();
    if (pax_hdr.is_tar_hardlink() && check_hardlink_exists())
        totalfiledatasize = 0;
    tarctx.endoffset += datasize;
    tarctx.typeflag = pax_hdr.typeflag;
    humongus_hdr = pax_hdr;
    humongus_data = peekbuffer.makeslice64(0, bytesread);
    return true;
}

bool parser::get_longname_header(bool islink)
{
    bigint64 datasize = pax_hdr.get_padded_size();
    bytesread = peekdata(datasize, peekbuffer, "datablock");
    if (bytesread != datasize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %"LL"d bytes", bytesread, datasize);
        return false;
    }

    if (islink)
    {
        longlink_hdr = pax_hdr;
        longlink_data = peekbuffer.makeslice64(0, bytesread);

        
        
        
        
        
        
        
        peekbuffer.getslice(0, (int)pax_hdr.size, linkpathstr);
        if (linkpathstr.last() == '\0') {
            linkpathstr = linkpathstr.substr(0, linkpathstr.bytelength() - 1);
        }

        if (msg1)
            DB->msg("zfstarstream::get_longname_header linkpathstr='%s'", *linkpathstr);
    }
    else
    {
        longname_hdr = pax_hdr;
        longname_data = peekbuffer.makeslice64(0, bytesread);

        
        
        peekbuffer.getslice(0, (int)pax_hdr.size, fullpathstr);
        if (fullpathstr.last() == '\0') {
            fullpathstr = fullpathstr.substr(0, fullpathstr.bytelength() - 1);
        }

        if (msg1)
            DB->msg("zfstarstream::get_longname_header fullpathstr='%s'", *fullpathstr);
    }

    bytesread = peekdata(blocksize, peekbuffer, "header");
    if (bytesread != blocksize) {
        errormsg = ustring::sprintf("Problem reading header record data, only %"LL"d bytes read of %d bytes)", bytesread, blocksize);
        return false;
    }

    pax_hdr.initialize(peekbuffer);
    if (!pax_hdr.isgood()) {
        errormsg = ustring::sprintf("Found bad pax header at %s: %s", *bytepos.image(), *pax_hdr.errormsg());
        Out->msg(ERR, "Data stream error encountered: %s", *errormsg);
        uapp::staging().startTermination(EXIT_ABORT, "invalid pax header found while parsing backup data stream");
        return false;
    }

    totalfiledatasize = (pax_hdr.typeflag == LF_NORMAL || is_first_hlink()) ? pax_hdr.size : 0;
    if (pax_hdr.is_special_file())
        totalfiledatasize = 0;
    tarctx.endoffset += (datasize + blocksize);
    tarctx.typeflag = pax_hdr.typeflag;

    if (islink)
    {
        if ( pax_hdr.pathname.substr(0, LONGNAME_PREFIX.bytelength() ) != LONGNAME_PREFIX )
        {
            fullpathstr = pax_hdr.pathname;
        }
    }

    return true;
}

void parser::clear()
{
    clearmarks();
    tarctx.clear();
    metadata_hdr.clear();
    pax_hdr.clear();
    acl_hdr.clear();
    longname_hdr.clear();
    longlink_hdr.clear();
    humongus_hdr.clear();
    metadata_blob.free();
    acl_data.free();
    longname_data.free();
    longlink_data.free();
    humongus_data.free();
}

bool parser::getentry(DIRELEMp& de, fileref& altdata, fileref& stubdata)
{
    
    
    
    
    
    backdataconsumer::producer::consumed_size = 0;

    if (msg1) {
        DB->msg(" ");
        DB->msg("getentry >>>> ");
    }

    if (parsestream_base::getentry(de, altdata, stubdata))
        return true;

    if (at_eof())
        return false;

    clear();

    if (hit_eof || !uapp::staging().canRun()) {
        DB->msg("parser::getentry returning false with hit_eof:%d %s", hit_eof, *uapp::staging().getRunStageImage());
        return false;
    }

    if (!get_next_header())
        return false;

    if (eof)
        return false;

    if (pax_hdr.pathname.equal(METADATA_LABEL)) {
        if (!get_metadata_block())
            return false;
    }

    if (tarctx.typeflag == LF_ACL) {
        if (!get_acl_header())
            return false;
    }

    if (tarctx.typeflag == LF_LONGNAME) {
        if (!get_longname_header(false ))
            return false;
    }

    if (tarctx.typeflag == LF_LONGLINK) {
        if (!get_longname_header(true ))
            return false;
    }

    if (tarctx.typeflag == LF_HUMONGUS) {
        if (!get_humongusfile_header())
            return false;
    }

    if (!set_direlem(de)) {
        Out->msg(INFO, "parser::getentry returning false for set_direlem() failure");
        return false;
    }

    set_primary_end_offsets();

    tarctx.tarstate = ZFS_TAR_HEADER;

    accumulate_max_mtime(pax_hdr.mtime, de);

    if (msg1)
        DB->msg(" ");

    return true;
}






















void parser::set_primary_end_offsets()
{
    mark_end_offset(ZFS_TAR_HEADER);
    if (totalfiledatasize > 0) {
        if (tarctx.typeflag == LF_HUMONGUS)
            return;
        tarctx.endoffset += totalfiledatasize;
        mark_end_offset(ZFS_TAR_PRIMARY);
        tarctx.endoffset += get_padding(totalfiledatasize);
        mark_end_offset(ZFS_TAR_PADDING);
        tarctx.filebytesremaining = totalfiledatasize + get_padding(totalfiledatasize);
    } else {
        mark_end_offset(ZFS_TAR_PRIMARY);
    }
}

bool parser::set_direlem(DIRELEMp& de)
{
    ustring pathstr = fullpathstr;
    upath pathfull = upath(pathstr, upath::kind_unix, true);
    if (pathfull.has_end_dirsep())
        pathfull.set_end_dirsep(false);

    de = new DIRELEM;
    de->initialize(pax_hdr.mtime, pax_hdr.mtime, pax_hdr.mtime, totalfiledatasize, ATTR_EXTENDED, pathstr.stripdir());
    de->set_inode_number64(pax_hdr.thinode);
    de->set_hard_links((unsigned int)pax_hdr.thnlink);
    de->set_fullpath(pathfull);

    if (msg1)
        DB->msg("zfstarstream::parser de fullpath='%s'", *de->fullpath().image());

    unsigned char temp_typeflag = pax_hdr.typeflag;
    bool invalid_typeflag = false;

    switch (temp_typeflag) {
    case LF_HUMONGUS:
        set_tar_hardlink(de);
#ifdef S_IFREG
        pax_hdr.mode |= S_IFREG;
#endif
        break;
    case LF_NORMAL:
#ifdef S_IFREG
        pax_hdr.mode |= S_IFREG;
#endif
        break;
    case LF_LINK:
#ifdef S_IFREG
        pax_hdr.mode |= S_IFREG;
#endif
        set_tar_hardlink(de);
        break;
    case LF_SYMLINK:
#ifdef S_IFLNK
        pax_hdr.mode |= S_IFLNK;
#endif
        set_tar_hardlink(de);
        break;
    case LF_CHR:
    case LF_BLK:
    case LF_FIFO:
    {
#if defined(S_IFCHR) && defined(S_IFBLK) && defined(S_IFIFO)
        unsigned int tmp_flag = (temp_typeflag == PAXNDMP_CHRTYPE) ? S_IFCHR :
                                (temp_typeflag == PAXNDMP_BLKTYPE) ? S_IFBLK : S_IFIFO;
        pax_hdr.mode |= tmp_flag;
#endif
        dev_t device = ((pax_hdr.devmajor.toint() & 0xff) << 8) | (pax_hdr.devminor.toint() & 0xff);
#ifdef makedev
        device = makedev(pax_hdr.devmajor.toint(), pax_hdr.devminor.toint());
#else
        DB->msg("zfstarstream::parser should really be using makedev(devmajor, devminor) to synthesize rdev value.");
#endif
        if (msg1)
            DB->msg("zfstarstream::parser for special file '%s' setting rdev:%lu", *pathstr, (ubigint64)device);

	    
        
        de->set_device_number(static_cast<unsigned int> (device));

        de->set_hash(hashcode::zero);
		set_tar_hardlink(de);
        break;
    }
    case LF_DIR:
#ifdef S_IFDIR
        pax_hdr.mode |= S_IFDIR;
#endif
        if (msg1)
            DB->msg("zfstarstream::parser Found directory '%s'", *pathstr);

        de->set_is_directory();
        break;
    default:
        invalid_typeflag = true;
        Out->msg(ERR, "Stream error: Invalid file type:%d(%c) name:%s", pax_hdr.typeflag, pax_hdr.typeflag, *pathstr);
        break;
    }

    de->set_unix_attributes(pax_hdr.mode, pax_hdr.uid, pax_hdr.gid);

    zero_alignpos();

    return !hit_eof && !invalid_typeflag;
}

bigint64 parser::flushtonextheader()
{
    DB->msg("zfstarstream::parser::flushtonextheader starting at %s with %s peeked bytes, context:%s",
            *bytepos.image(), *(peekend - peekstart).image(), *tarctx.image());

    bigint64 bytesflushed = 0, readbytes = 0;

    const size_t tmpsize = 4096;
    fileref tmp;
    tmp.initmem(tmpsize);

    while ((readbytes = parser::readdata(tmp.start(), tmpsize)))
        bytesflushed += readbytes;

    return bytesflushed;
}


void parser::parsehumongusfile(void* bufp, size_t n)
{
    if (tarctx.hdrstate == S_READ_HDR) {
        size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
        bytesread = peekdata(size, peekbuffer, "header");
        peekbuffer.getslice(0, (int)size, bufp);
        tarctx.hdrbytesremaining -= size;
        if (tarctx.hdrbytesremaining == 0) {
            peekbuffer = peekeddata.makeslice64(peekstart, peekend - peekstart);
            pax_hdr.initialize(peekbuffer);
            fileoffset datasize = pax_hdr.get_padded_size();
            tarctx.hdrbytesremaining = datasize;
            tarctx.thmarker = pax_hdr.thmarker;
            if (pax_hdr.typeflag == LF_NORMAL) {
                tarctx.endoffset += (datasize + blocksize);
                tarctx.hdrstate = S_WRITE_DATA;
            } else if (pax_hdr.typeflag == LF_LONGNAME) {
                tarctx.endoffset += (datasize + blocksize);
                tarctx.hdrstate = S_WRITE_EXT_DATA;
            } else if (pax_hdr.typeflag == LF_LONGLINK) {
                tarctx.endoffset += (datasize + blocksize);
                tarctx.hdrstate = S_WRITE_EXT_DATA;
            } else if (pax_hdr.typeflag == LF_XATTR) {
                mark_end_offset(ZFS_TAR_PRIMARY);
                tarctx.endoffset += (datasize + blocksize);
                tarctx.tarstate = ZFS_TAR_EXTENDED;
                tarctx.hdrstate = S_WRITE_DATA;
            }
            peekend = peekstart = 0;
        }
    } else if (tarctx.hdrstate == S_WRITE_DATA) {
        size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
        bytesread = parsestream::readdata(bufp, size);
        tarctx.hdrbytesremaining -= bytesread;
        if (tarctx.hdrbytesremaining == 0) {
            tarctx.hdrbytesremaining = blocksize;
            tarctx.hdrstate = S_READ_HDR;
        }
    } else if (tarctx.hdrstate == S_WRITE_EXT_DATA) {
        size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
        bytesread = parsestream::readdata(bufp, size);
        tarctx.hdrbytesremaining -= bytesread;
        if (tarctx.hdrbytesremaining == 0) {
            tarctx.hdrbytesremaining = blocksize;
            tarctx.hdrstate = S_READ_EXT_HDR;
        }
    } else if (tarctx.hdrstate == S_READ_EXT_HDR) {
        size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
        bytesread = peekdata(size, peekbuffer, "header");
        peekbuffer.getslice(0, (int)size, bufp);
        tarctx.hdrbytesremaining -= size;
        if (tarctx.hdrbytesremaining == 0) {
            peekbuffer = peekeddata.makeslice64(peekstart, peekend - peekstart);
            pax_hdr.initialize(peekbuffer);
            fileoffset datasize = pax_hdr.get_padded_size();
            tarctx.hdrbytesremaining = datasize;
            if (pax_hdr.typeflag == LF_NORMAL) {
                fileoffset datasize = pax_hdr.get_padded_size();
                tarctx.endoffset += (datasize + blocksize);
                tarctx.hdrstate = S_WRITE_DATA;
            }
            peekend = peekstart = 0;
        }
    }
}

void parser::parse_extattr_hdr(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = peekdata(size, peekbuffer, "extattrhdr");
    tarctx.hdrbytesremaining -= size;
    if (tarctx.hdrbytesremaining == 0) {
        fileoffset bufsize = peekend - peekstart;
        peekbuffer = peekeddata.makeslice64(peekstart, bufsize);
        pax_hdr.initialize(peekbuffer);
        if (pax_hdr.thmarker == TH_ATTRIBUTE) {
            peekeddata.getslice64(peekstart, (int)bufsize.value(), bufp);
            fileoffset datasize = pax_hdr.get_padded_size();
            tarctx.hdrbytesremaining = datasize;
            tarctx.endoffset += (datasize + blocksize);
            tarctx.hdrstate = S_WRITE_DATA;
            peekend = peekstart = 0;
        } else {
            bytesread = 0;
            found_zero_block = pax_hdr.iszeroblock();
            tarctx.tarstate = ZFS_TAR_DONE;
            mark_end_offset(ZFS_TAR_EXTENDED);
        }
    }
}

void parser::parse_extattr_data(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = parsestream::readdata(bufp, size);
    tarctx.hdrbytesremaining -= bytesread;
    if (tarctx.hdrbytesremaining == 0) {
        tarctx.hdrbytesremaining = blocksize;
        tarctx.hdrstate = S_READ_EXT_HDR;
    }
}

void parser::parse_extattr_exthdr(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = peekdata(size, peekbuffer, "extattrhdr");
    peekbuffer.getslice(0, (int)size, bufp);
    tarctx.hdrbytesremaining -= size;
    if (tarctx.hdrbytesremaining == 0) {
        peekbuffer = peekeddata.makeslice64(peekstart, peekend - peekstart);
        pax_hdr.initialize(peekbuffer);
        fileoffset datasize = pax_hdr.get_padded_size();
        tarctx.hdrbytesremaining = datasize;
        tarctx.endoffset += (datasize + blocksize);
        peekend = peekstart = 0;
        if (pax_hdr.typeflag == LF_NORMAL) {
            tarctx.hdrstate = S_WRITE_EXT_DATA;
        }
        else if (pax_hdr.typeflag == LF_LONGNAME) {
            tarctx.hdrstate = S_LONGNAME_DATA;
        }
        else if (pax_hdr.typeflag == LF_LONGLINK) {
            tarctx.hdrstate = S_LONGNAME_DATA;
        }
    }
}

void parser::parse_extattr_extdata(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = parsestream::readdata(bufp, size);
    tarctx.hdrbytesremaining -= bytesread;
    if (tarctx.hdrbytesremaining == 0) {
        tarctx.hdrbytesremaining = blocksize;
        tarctx.hdrstate = S_READ_HDR;
        if (bytesread == 0)
            parse_extattr_hdr(bufp, n);
    }
}

void parser::parse_extattr_longhdr(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = peekdata(size, peekbuffer, "extattrhdr");
    peekbuffer.getslice(0, (int)size, bufp);
    tarctx.hdrbytesremaining -= size;
    if (tarctx.hdrbytesremaining == 0) {
        peekbuffer = peekeddata.makeslice64(peekstart, peekend - peekstart);
        pax_hdr.initialize(peekbuffer);
        fileoffset datasize = pax_hdr.get_padded_size();
        tarctx.hdrbytesremaining = datasize;
        tarctx.endoffset += (datasize + blocksize);
        tarctx.hdrstate = S_WRITE_EXT_DATA;
        peekend = peekstart = 0;
    }
}

void parser::parse_extattr_longdata(void* bufp, size_t n)
{
    size_t size = std::min(n, (size_t)tarctx.hdrbytesremaining.value());
    bytesread = parsestream::readdata(bufp, size);
    tarctx.hdrbytesremaining -= bytesread;
    if (tarctx.hdrbytesremaining == 0) {
        tarctx.hdrbytesremaining = blocksize;
        tarctx.hdrstate = S_LONGNAME_HDR;
    }
}



void parser::parse_extattr(void* bufp, size_t n)
{
    if (tarctx.hdrstate == S_READ_HDR) {
        parse_extattr_hdr(bufp, n);
    } else if (tarctx.hdrstate == S_WRITE_DATA) {
        parse_extattr_data(bufp, n);
    } else if (tarctx.hdrstate == S_READ_EXT_HDR) {
        parse_extattr_exthdr(bufp, n);
    } else if (tarctx.hdrstate == S_WRITE_EXT_DATA) {
        parse_extattr_extdata(bufp, n);
    } else if (tarctx.hdrstate == S_LONGNAME_HDR) {
        parse_extattr_longhdr(bufp, n);
    } else if (tarctx.hdrstate == S_LONGNAME_DATA) {
        parse_extattr_longdata(bufp, n);
    }
}








bigint64 parser::readdata(void* bufp, size_t n)
{
    if (tarctx.tarstate == ZFS_TAR_HEADER) {
        if (outputfrombuffer(bufp, n)) {
            if (tarctx.typeflag == LF_NORMAL) {
                if (totalfiledatasize > 0) {
                    tarctx.tarstate = ZFS_TAR_PRIMARY;
                } else {
                    tarctx.hdrbytesremaining = blocksize;
                    tarctx.tarstate = ZFS_TAR_EXTENDED;
                    tarctx.hdrstate = S_READ_HDR;
                }
            } else if (tarctx.typeflag == LF_LINK) {
                if (totalfiledatasize > 0)
                    tarctx.tarstate = ZFS_TAR_PRIMARY;
                else {
                    tarctx.hdrbytesremaining = blocksize;
                    tarctx.tarstate = ZFS_TAR_EXTENDED;
                    tarctx.hdrstate = S_READ_HDR;
                }
            } else if (tarctx.typeflag == LF_HUMONGUS) {
                if (totalfiledatasize > 0) {
                    tarctx.hdrbytesremaining = blocksize;
                    tarctx.tarstate = ZFS_TAR_HUMONGUS;
                    tarctx.hdrstate = S_READ_HDR;
                } else {
                    tarctx.tarstate = ZFS_TAR_DONE;
                }
            } else if (tarctx.typeflag == LF_DIR) {
                tarctx.hdrbytesremaining = blocksize;
                tarctx.tarstate = ZFS_TAR_EXTENDED;
                tarctx.hdrstate = S_READ_HDR;
            }
        }
    } else if (tarctx.tarstate == ZFS_TAR_PRIMARY) {
        if (outputfromstream(bufp, n, tarctx.filebytesremaining)) {
            tarctx.hdrbytesremaining = blocksize;
            tarctx.tarstate = ZFS_TAR_EXTENDED;
            tarctx.hdrstate = S_READ_HDR;
        }
    } else if (tarctx.tarstate == ZFS_TAR_HUMONGUS) {
        parsehumongusfile(bufp, n);
    } else if (tarctx.tarstate == ZFS_TAR_EXTENDED) {
        parse_extattr(bufp, n);
    } else {
        bytesread = 0;
    }

    return bytesread;
}

bool parser::outputfromstream(void* bufp, size_t n, fileoffset& bytesremaining)
{
    size_t bitesize = std::min(n, (size_t)bytesremaining.value());
    bytesread = parsestream::readdata(bufp, bitesize);
    bytesremaining -= bytesread;
    if (bytesremaining == 0)
        return true;
    return false;
}

bool parser::outputfrombuffer(void* bufp, size_t n)
{
    fileoffset peekremaining(peekend - peekstart);
    bytesread = std::min(n, (size_t)peekremaining.value());
    if (bytesread) {
        peekeddata.getslice64(peekstart, (int)bytesread, bufp);
        peekstart += bytesread;
        if (peekstart == peekend) {
            peekend = peekstart = 0;
            return true;
        }
    }
    return false;
}

bigint64 parser::peekdata(const bigint64 size, fileref& data, const ustring& desc)
{
    bigint64 result = parsestream::getdata(size, data, desc);

    if (result > 0) {
        if (msg1)
            DB->msg("parser::peekdata parser::getdata(%"LL"d, data, %s) at bytepos:%s returned %"LL"d",
                    size, *desc, *bytepos.image(), result);

        accommodate_peek_size((size_t)size);
        peekeddata.setslice(peekend.ivalue(), data);
        peekend += result;

        if (msg1)
            DB->msg("parser::peekdata now has data in range (%s -> %s) in peekeddata, total buffer size %s",
                    *peekstart.image(), *peekend.image(), *peekeddata.size64().image());
    } else {
        if (msg1)
            DB->msg("parser::peekdata parser::getdata(%"LL"d, data, %s) returned %"LL"d", size, *desc, result);
    }

    return result;
}

void parser::mark_end_offset(zfstar_state newstate)
{
    fileoffset offset(tarctx.endoffset);

    switch (newstate) {
    case ZFS_TAR_HEADER:
        marks.push_back(std::make_pair(data_regions::header, offset));
        break;
    case ZFS_TAR_PRIMARY:
        marks.push_back(std::make_pair(data_regions::primarydata, offset));
        break;
    case ZFS_TAR_PADDING:
        marks.push_back(std::make_pair(data_regions::padding, offset));
        break;
    case ZFS_TAR_EXTENDED:
        marks.push_back(std::make_pair(data_regions::ads, offset));
        break;
    case ZFS_TAR_DONE:
        marks.push_back(std::make_pair(data_regions::misc, offset));
        break;
    case ZFS_TAR_HUMONGUS:
    case ZFS_TAR_NONE:
        break;
    }
}

void parser::recordmarks(DIRELEMp& de)
{
    if (de.isnull())
        return;

    if (msg1)
        DB->msg("parser::recordmarks for %s, %s", *de->fullpath().image(), *data_regions::image_endoffsets(marks));

    dirrec_pack::regions drp(de.getimpl());
    drp.set(marks);
}

void parser::non_celerrai18n() const
{
}

void parser::celerrai18n() const
{
}

void parser::clearmarks()
{
    if (msg1)
        DB->msg("parser::clearmarks, bytepos=%s", *bytepos.image());

    marks.clear();
    tarctx.endoffset = 0;
}






bool parser::accommodate_peek_size(size_t n)
{
    fileoffset newsize = peekeddata.size64();

    while (peekend + n > newsize)
        newsize += peekeddata.size64();

    
    if (newsize > MAX_PEEKDATA_BUFSIZE) {
        
        return false;
    }

    fileref tmp;
    tmp.initmem(newsize.ivalue());
    
    tmp.setslice64(peekstart, (peekend - peekstart).ivalue(), peekeddata.start() + peekstart.value());
    peekeddata = tmp;

    return true;
}

fileref parser::nextdatablock(bool& suppress_requeue)
{
    suppress_requeue = false;
    fileref result, buf;
    int bufsize = 128 * 1024;  
    buf.initmem(bufsize);
    bytesread = readdata(buf.start(), bufsize);

    if (bytesread) {
        if (msg1)
            DB->msg("parser::nextdatablock returning %"LL"d bytes for read of %d", bytesread, bufsize);
        result = buf.makeslice(0, (int)bytesread);
    } else {
        if (msg1)
            DB->msg("parser::nextdatablock found 0 bytes remaining, returning null fileref");
    }

    return result;
}

} 

#if !defined(RESTCOMP_H_INCLUDED)
#define RESTCOMP_H_INCLUDED












#include "cycle.h"
#include "restelem.h"

class backappend;


class restcomp : public cycle {
public:
    restcomp(cycle *parent, restelem& restinfo, fileref& srclist, 
             fileref& hintdata, chunktype ckind, bigint64 prior, 
             fileoffset offset = fileoffset(0),
             backappend *root_file_cycle = NULL );

    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~restcomp();
    SAFEPOOLALLOC(restcomp);
private:
    restelem info;     
    fileref srclist;   
    fileref hintdata;
    chunktype ckind;
    int childcount;
    bigint64 prior;
    backappend *root_file_cycle;
    bool done;
    bool isbig_composite(const chunktype ckind, fileref composite);
};

#endif
















#include "common.h"
#include "debug.h"
#include "restonefile.h"
#include "restfile.h"
#include "restlink.h"
#include "todoelem.h"
#include "volinfo.h"

#if SYSTEM_WINDOWS    
#include "ntsecurity.h"
#include "utar_commands.h"
#include "utar_flags_enums.h"
#include "wss_sis_manager.h"
#include "ade_mgrx.h"
#endif

#define sis_feature_enabled ((xflag[22]&262144)==0)

restonefile::restonefile(const hashcode& hash, context& main_, DIRELEM& direlem, ucontainer::basep container,
                         fileoffset startoff, fileoffset endoff )
  : multivolumeroot(&main_, *main_.getTodoQueue(), false ),
    bicycle(NULL, &main_)
{
    
    setasroot(this);
    cycle *child = NULL;

    
    if( direlem.is_device_file_mknode_only() ) {
        if(!flags.validate) {
            DB->msg(DBTXT("restore device file: %s"), *direlem.fullpath().image());
            
            if( flags.permissions && flags.restoresystem )
                direlem.set_file_attributes(flags.permissions);
            else
                Out->msg(WARN, "<5081>Special file '%s' not restored.  Use --restoresystem as root to restore", *direlem.fullpath().image());
        }
        childdone(NULL);
    } else if(direlem.is_symlink()) {
        DB->msg(DBTXT("restore sym link: %s"), *direlem.fullpath().image());
        #if SYSTEM_UNIX
            child = new restlink(this, hash, direlem.fullpath().image(), direlem, NULL);
        #else
            childdone(NULL);
        #endif
    } else {
        volinfo vinfo;
#if SYSTEM_WINDOWS
        vinfo = VolumeInfo::getVolInfo(direlem.fullpath());

        if((wss_sis_manager::sis_manager != NULL) && direlem.get_reparseType() == REPARSE_SIS) {
            
            
            const bool overwriteexistingSISlink = ((flags.existingfileoverwriteoption == utar_flags_enums::existowrite_always)
                                                    || (flags.existingfileoverwriteoption == utar_flags_enums::existowrite_newest));

            if(!ReparsePoints::restore_sislink(direlem, overwriteexistingSISlink)) {
                if(!sis_feature_enabled)
                    childdone(NULL);
            }
            if(!wss_sis_manager::sis_manager->is_sis_enabled()) {

                DIRELEM de_alt;
                upath common_store_file_path;

                wss_sis_manager::sis_manager->collect_common_store_file_name(common_store_file_path);

                hashcode cs_hash;
                if(!wss_sis_manager::sis_manager->lookup_cs_file_hash(common_store_file_path.image(), cs_hash)) {
                    Out->msg(WARN, "<10683>Failed to lookup SIS common Store file: %s", *de_alt.fullpath().image());
                    todoEnqueue(TODO_DONE);
                }

                
                
                child = new restfile(this, cs_hash, direlem, container, NULL, vinfo, startoff, endoff);
            } else {
                
                child = new restfile(this, hash, direlem, container, NULL, vinfo, startoff, endoff);
            }
        } else
#endif  
        {
            child = new restfile(this, hash, direlem, container, NULL, vinfo, startoff, endoff);
        }
    }
}
void restonefile::childdone(cycle *child) {
    todoEnqueue(TODO_DONE);
    notifyparent();
}

restonefile::~restonefile() {
}




















#include "common.h"
#include "debug.h"
#include "workelem.h"

void workelem::set_defaults() {         
    streamslice = 0;
    size = 0;
    prefetchqueue = NULL;
    dpninx = dpn0;
    usechunkcache = true;
    isapi = false;
    isdir = false;
    hold_data = false;
    changeblock = false;

    cb_append = false;
    setParentHash = true;
    ignoreStats = false;
    domorph = false;

    use_container = false;

    st = NULL;
    sb = NULL;
}

workelem::workelem(const workelem &srcelem)
    : path(srcelem.path),
      direlemp(srcelem.direlemp),
      fstats(srcelem.fstats),
      data(srcelem.data),
      streamslice(srcelem.streamslice),
      size(srcelem.size),
      changeblockoff(srcelem.changeblockoff),
      prefetchqueue(srcelem.prefetchqueue),
      resulthash(srcelem.resulthash),
      dpninx(srcelem.dpninx),
      usechunkcache(srcelem.usechunkcache),
      isapi(srcelem.isapi),
      isdir(srcelem.isdir),
      hold_data(srcelem.hold_data),
      changeblock(srcelem.changeblock),
      cb_append(srcelem.cb_append),
      setParentHash(srcelem.setParentHash),
      ignoreStats(srcelem.ignoreStats),
      domorph(srcelem.domorph),
      use_container(srcelem.use_container),
      container(srcelem.container),
      st(srcelem.st),
      sb(srcelem.sb),
      running_coverage_size(srcelem.running_coverage_size)
{
}















workelem::workelem(const workelem *parentelem, const upath& path_, DIRELEMp direlemp_, const filestatsref& fstats_)
    : path(path_), direlemp(direlemp_), fstats(fstats_)
{
    set_defaults();
    if (parentelem) {
        use_container = parentelem->use_container;
        container = parentelem->container;
    }
    assert(!direlemp.isnull());
    usechunkcache = direlemp->is_recent();
}

workelem::workelem(const workelem* parentelem, const upath& path_, DIRELEMp direlemp_)
    : path(path_), direlemp(direlemp_)
 {
    set_defaults();
    assert(!direlemp.isnull());
    usechunkcache = direlemp->is_recent();
    if (parentelem) {
        fstats = parentelem->fstats;
        use_container = parentelem->use_container;
        container = parentelem->container;
    } else {
        fstats = filestatsref();
        use_container = false;
        container = ucontainer::basep();
    }
}


workelem::workelem(bool rechunk_, DIRELEMp direlem_, ucontainer::basep ucontainer_) : direlemp(direlem_), prefetchqueue(NULL), rechunk(rechunk_), container(ucontainer_)
{
    set_defaults();
}












workelem::workelem(const workelem* parentelem, const upath& path_, DIRELEMp direlemp_, const filestatsref& fstats_, const fileref& data_)
    : path(path_), direlemp(direlemp_), fstats(fstats_), data(data_), rechunk(false)
{
    set_defaults();
    if (parentelem) {
        use_container = parentelem->use_container;
        container = parentelem->container;
    }
    assert(!direlemp.isnull());
    usechunkcache = direlemp->is_recent();
}






workelem::workelem(const workelem* parentelem, const fileref& data_) : data(data_)
{
    set_defaults();
    if (parentelem) {
        use_container = parentelem->use_container;
        container = parentelem->container;
    }
    direlemp = new DIRELEM;
    use_container = false;
    container = ucontainer::basep();
}


workelem::workelem(const workelem* parentelem, const upath& path_)   : path(path_)
{
    set_defaults();
    if (parentelem) {
        use_container = parentelem->use_container;
        container = parentelem->container;
    }
    direlemp = new DIRELEM;
    
    
}


workelem::workelem(const workelem* parentelem, const DIRELEMp direlemp_) : direlemp(direlemp_)
{
    assert(!direlemp.isnull());
    set_defaults();
    if (parentelem) {
        use_container = parentelem->use_container;
        container = parentelem->container;
    }
    path = direlemp->fullpath();
    
    
}

workelem::~workelem() {}

#if !defined(zfstar_history_H_INCLUDED)
#define zfstar_history_H_INCLUDED












#include "threadbase.h"
#include "vector.h"
#include "msgqueue.h"
#include "assoc.h"
#include "msgvect.h"
#include "namedpipe.h"
#include "usemaphore.h"
#include "histmap.h"
#include "utar_flags_info.h"

#include <map>

class message;
class context;
class BackCycle;

class zfstar_history
{
public:
    zfstar_history(context *main, upath fifopath, upath savehistpath);
    ~zfstar_history();

    void data_stream_done();
    void send(BackCycle* cycle, message& m);

    
    
    
    
    

    
    
    
    bool is_rhist_done() const { return readhist_thread->is_done; }
    
    
    
    
    size_t rhist_msg_count() const { return readhist_thread->msg_count; }

    SAFEALLOC(zfstar_history);

private:

    class readhist : public threadbase
    {
    public:
        readhist(msgqueue& todoqueue, upath fifopath, upath savehistpath, semaphore& histsem);
        ~readhist();
        void body();
        SAFEALLOC(readhist);

    private:
        friend class zfstar_history;

        msgqueue& todoqueue;
        namedpipe fifo;
        upath savehistpath;
        semaphore& histsem;
        bool is_done;
        size_t msg_count;
    };

    class processhist;
    class processhist : public threadbase
    {
    public:
        processhist(msgqueue& todoqueue, zfstar_history *parent_);
        ~processhist();
        void terminate();
        void mark_eof_history();
        SAFEALLOC(processhist);

    private:
        msgqueue& todoqueue;
        zfstar_history *parent;
        mtex todomut;
        typedef scalar<ndmp_inode64_t> inode_obj_t;
        tassoc<inode_obj_t, message> todoassoc;
        bool mainloopdone;
        bool todoqueue_terminated;

        
        
        
        
        
        
        struct dirrecord
        {
            dirrecord() : isdone(false), names(NULL) { names = new histvector_t(); }
            ~dirrecord() {  }
            ustring image() const { return ustring::sprintf("FIX: implement dirrecord::image"); }
            bool isdone; 
            
            histvector_t *names;
        };

        class historytree_class
        {
        public:
            historytree_class() : m(true), lastparentinode(0) {} 
            ~historytree_class();
            ndmp_inode64_t lastparent_done(); 

            
            ndmp_inode64_t enter_hist(processhist *ph, ndmp_inode64_t inode, ndmp_inode64_t parentinode, const ustring &name);

            
            
            
            
            
            
            histvector_t *get_names(ndmp_inode64_t inode, bool accept_unready = false);

            bool answer_ready(ndmp_inode64_t queryinode) const;

        protected:
            mtex m;
            typedef DEFINE_STL_MAP_TYPE(ndmp_inode64_t, dirrecord) nodemap;
            typedef nodemap::iterator iter;
            nodemap nodes;
            ndmp_inode64_t lastparentinode;
        };

        historytree_class historytree;

        
        void body();
        void handle_getndmpzfshistlist(message &m);
        bool handle_ndmphistlistline(message &m);
        void postprocess_getndmpzfshistlist(ndmp_inode64_t inode, message &m);
        void attempt_answer(ndmp_inode64_t inode);
        int  read_and_enter_xml(ustring oneline);

   private:
        void sendResponse(BackCycle* cycle, message &m);
   }; 

private:
    msgqueue     todoqueue;             
    semaphore    histsem;
    readhist*    readhist_thread;
    processhist* processhist_thread;


#if SYSTEM_UNIX_SCO || SYSTEM_UNIX_UNIXWARE
    public:
#else
#endif
    utar_flags_info& flags;
};

#endif

#if !defined(NDMP_HISTORY_H_INCLUDED)
#define NDMP_HISTORY_H_INCLUDED












#include "threadbase.h"
#include "vector.h"
#include "msgqueue.h"
#include "assoc.h"
#include "msgvect.h"
#include "namedpipe.h"
#include "usemaphore.h"
#include "histmap.h"
#include "utar_flags_info.h"

#include <map>

class message;
class context;
class BackCycle;


class ndmp_history {
public:
    ndmp_history(context *main,
                 upath fifopath, upath savehistpath);
    void data_stream_done();

    ~ndmp_history();

    void send(BackCycle* cycle, message& m);

    
    
    
    
    
    bool directory_complete(unsigned int directory_inodenum);

    
    
    
    bool is_rhist_done() const { return readhist_thread->is_done; }
    
    
    
    
    size_t rhist_msg_count() const { return readhist_thread->msg_count; }

    SAFEALLOC(ndmp_history);


#if SYSTEM_WINDOWS
#else
private:
#endif

    class readhist : public threadbase {
    public:
        
        readhist(msgqueue& todoqueue, upath fifopath, upath savehistpath, semaphore& histsem);
        ~readhist();

        void body();

        SAFEALLOC(readhist);

#if SYSTEM_WINDOWS
#else
    private:
#endif
        friend class ndmp_history;

        msgqueue& todoqueue;
        
        namedpipe fifo;
        upath savehistpath;
        semaphore& histsem;
        bool is_done;
        size_t msg_count;
    };

    class processhist;
    class processhist : public threadbase {
    public:
        processhist(msgqueue& todoqueue, ndmp_history *parent_);
        ~processhist();

        void terminate();
        bool delete_inode_old(unsigned int inodenum);
        bool delete_child_inodes(unsigned int inodenum);
        void mark_eof_history();

        SAFEALLOC(processhist);


#if SYSTEM_WINDOWS
#else
    private:
#endif

        msgqueue& todoqueue;
        ndmp_history *parent;
        
        tassoc<ustring, message> todoassoc;
        
        
        

        bool      mainloopdone;
        bool      todoqueue_terminated;

      
        class element_child_list;
        typedef scalar<uint> uintobj;
        typedef scalar<element_child_list *> childptrobj;
        typedef undoo::vector<childptrobj> childvector;          
        class element_child_list { 
        public:
            element_child_list(unsigned int inode_=0, 
                               unsigned int parentinode_=2,
                               ustring elemname_="");
            ustring image() const;

            ustring elemname; 
            unsigned int inodenum;
            unsigned int parentinodenum;
            unsigned int link_count;
            unsigned int nchildrendone; 
            bool done;                  
            ustring streamoffset;       
            childvector childlist;      
            SAFEPOOLALLOC(element_child_list);
        };
        class historytree_class {
        public:
            historytree_class() : 
                inode2offset(16768), off2elem(2048), 
                assert_error_count1(0), assert_error_count2(0), assert_error_count3(0), assert_error_count_limit(5) {}
            ~historytree_class();

            int enter_hist(processhist *ph, unsigned int inode, unsigned int parentinode, const ustring &name);
            int enter_node(processhist *ph, unsigned int inode, const ustring &streamoffset, unsigned int links);
            bool mark_dir_done(processhist *ph, unsigned int inode);
            void process_getndmphistlist(processhist *ph, const ustring &streamoffset, int nchildren);
            bool delete_child_elems(unsigned int inode); 
            bool islocked() { return m.islocked(); }
            void get_element_path(unsigned int inode, ustring &path);

            element_child_list *remove_dir_entry(const ustring &streamoffset);
        protected:
            mtex m;
            typedef std::multimap<uintobj, element_child_list *> nodemap;
            typedef nodemap::iterator iter;
            typedef std::pair<iter, iter> rngiter;
            nodemap nodes;

            
            
            
            
            
            
            tassoc<uintobj, ustring> inode2offset;

            
            
            typedef tassoc<ustring, element_child_list*> streamoff_to_elem;
            streamoff_to_elem off2elem;

            ubigint64 assert_error_count1;
            ubigint64 assert_error_count2;
            ubigint64 assert_error_count3;
            ubigint64 assert_error_count_limit;

        };
        historytree_class historytree;

      
        void body();
        void handle_getndmphistlist(message &m);
        void handle_ndmphistlistline(message &m, int &curparent, int &prevparent);
        void postprocess_getndmphistlist(ustring &streamoffset, message &m);

        
        size_t get_childname_list3(const element_child_list *elem, histmap* childlist, hlhistmap *hardlinklist, const undoo::vector<ustring> *hardlinknamesp);

        bool mark_dir_done(const unsigned int parentnum)
            { return historytree.mark_dir_done(this, parentnum); }

        int  read_and_enter_xml(ustring oneline);

   public:      
        bool check_complete(element_child_list *pelem); 
   private:
        void sendResponse(BackCycle* cycle, message &m);
   }; 
private:
    msgqueue     todoqueue;             
    semaphore    histsem;
    readhist*    readhist_thread;
    processhist* processhist_thread;


#if SYSTEM_UNIX_SCO || SYSTEM_UNIX_UNIXWARE
    public:
#else
#endif
    utar_flags_info& flags;
};

#endif
#if !defined(CYCLE_TEST_H_INCLUDED)
#define CYCLE_TEST_H_INCLUDED











#include "common.h"
#include "debug.h"
#include "cycle.h"
#include "timer.h"
#include "context.h"
#include "restelem.h"
#include "restdata.h"
#include "chunktype.h"
#include "restdataproducer.h"
#include "restdirlistproducer.h"
#include "restdirlist.h"


class cycle_test;

class cycletest_root : public cycle
{
public:
    cycletest_root(context *main_) : cycle(NULL, main_), activetest(NULL) {}
    virtual ~cycletest_root() {}

    virtual void childdone(cycle *child);

    cycle_test * activetest;        
};




class cycle_test {
 public:
    cycle_test(const utar_flags_info& flags_, context *main_, timer *testtimes_) 
        : flags(flags_), main(main_), root(new cycletest_root(main_)), testtimes(testtimes_) 
    {
        root->activetest = this;
    }
    virtual ~cycle_test() {}

    virtual cycle *spawn() = 0;

    virtual void childdone(cycle * child) { };
    virtual bool check_result(cycle *c) = 0;

 protected:
    const utar_flags_info& flags;
    context *main;
    cycletest_root *root;
    timer *testtimes;
};





class restdata1 : public cycle_test {
 public:
    restdata1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~restdata1() {}

    virtual cycle *spawn();
    virtual void childdone(cycle *child);
    virtual bool check_result(cycle *c);

 protected:
    DIRELEM de;
    chunktype ctype;
    fileref answer;
    restelem info;
};





class restdataproducer1 : public cycle_test, restdataproducer::consumer {
 public:
    restdataproducer1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~restdataproducer1() {}

    
    
    virtual cycle *spawn();

    
    
    virtual bool check_result(cycle *c);

    
    virtual void rdpconsume(const fileref& buf, const fileoffset& startoff, restdataproducer * const producer);

 protected:
    
    unsigned int consume_count;
    fileoffset byte_count;
};





class restdirlistproducer1 : public cycle_test, restdirlistproducer::consumer {
 public:
    restdirlistproducer1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~restdirlistproducer1() {}

    
    
    
    virtual cycle *spawn();

    
    
    virtual bool check_result(cycle *c);

    
    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer);

 protected:
    bool inorder;
    unsigned int consume_count;
    size_t direlem_count;
};


class restdirlistproducer2 : public restdirlistproducer1 {
 public:
    restdirlistproducer2(const utar_flags_info& flags, context *main_, timer *cycletimes_)
        : restdirlistproducer1(flags, main_, cycletimes_) 
    { inorder = false; }

    virtual ~restdirlistproducer2() {}
};


class restdirlist1 : public cycle_test {
 public:
    restdirlist1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~restdirlist1() {}

    
    
    virtual cycle *spawn();

    
    
    virtual bool check_result(cycle *c);

 protected:
    name_to_direlemp_table listing;
    unsigned int consume_count;
    size_t direlem_count;
};


class restdirelem1 : public cycle_test {
 public:
    restdirelem1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~restdirelem1() {}

    
    
    virtual cycle *spawn();

    void childdone(cycle * child);

    
    
    virtual bool check_result(cycle *c);

 protected:
    unsigned int consume_count;
    direlemp_list_type answers;
    DIRELEM de;
    int casing;

};





#include "persistentlock.h"

class persistentlock1 : public cycle_test {
 public:
    persistentlock1(const utar_flags_info& flags, context *main_, timer *testtimes_);
    virtual ~persistentlock1() {}

    virtual cycle *spawn();
    
    virtual bool check_result(cycle *c);

 protected:
    persistentlock pl;
};

#endif 
#if !defined(RESTROOT2BACKUPDIR_H_INCLUDED)
#define RESTROOT2BACKUPDIR_H_INCLUDED












#include "cycle.h"
#include "ade/ade_multivolume.h"
#include "resource_identifier.h"
#include "mediadesc.h"

class avpaxpipe;

class restroot2backupdir : public multivolumeroot, public bicycle {
public:
    SAFEALLOC(restroot2backupdir);

    
    restroot2backupdir(const BackupRootInfo& _backuprootinfo, const location& _metadataLocation, context& main_,
                       const resource_identifier& ri_, const mediadesc& mediad_, const ustring& backupdirname,
                       const DIRELEM *de = NULL, const location& parentdataloc = location());

    
    virtual void init();

    
    virtual void childdone(cycle *child);

    virtual ~restroot2backupdir();

private:
    
    void close_and_delete_pipe_control_object(avpaxpipe*& pcpref);

    
    avpaxpipe* init_avpaxpipe_control(const ustring& containername) const;

    
    void generate_backup_info_and_system_info_container(const name_to_direlemp_table& top_level_list);

    
    
    bool restore_backup_contents(undoo::vector<ustring>::const_iterator& names_iterator,
                                 const name_to_direlemp_table& direlem_table);

    
    
    
    
    
    
    hashcode retrieve_file_extents_hash(const DIRELEMp dep, upath& path) const;

    
    
    
    
    
    bool check_resource_on_media(const upath& backup_resource_path, const upath& backup_object_path, upath& container_path) const;

    
    void add_container(location::tcontainerid containerid, location::tformat::type containerformat, const ustring& containerpath,
                       const upath& objectpath, bool content_only);

    
    
    
    
    bool initmediafileref(fileref& fr, const ustring& filepath, bool writeobject = true, const ustring& basefilepath = ustring()) const;

    
    
    
    
    bool initmediafilerefpipe(fileref& fr, const ustring& filepath, const ustring& basefilepath = ustring()) const;

    
    const BackupRootInfo backuprootinfo;

    
    const resource_identifier backup_resource_identifier;

    
    const mediadesc mediad;

    
    
    const ustring basepath;

    
    const location metadataloc;

    
    enum phases {
        phase_construction                   = 0,
        phase_retrieving_top_level_list      = 1,
        phase_restoring_system_info          = 2,
        phase_restoring_backup_contents      = 3,
        phase_restoring_outofstream_files    = 4,
    };
    phases phase; 

    
    name_to_direlemp_table top_level_list;
    undoo::vector<ustring> top_level_list_names;
    undoo::vector<ustring>::const_iterator names_iterator;

    
    direlemp_list_type outofstream_objlist;
    direlemp_list_type::const_iterator outofstream_obj_iterator;
    fileref outofstream_extentsdata;

    
    avpaxpipe* system_info_pipe_control;
    avpaxpipe* backup_pipe_control;

    
    ddrfiles_xml containers;
    
    location::tcontainerid next_container_id;
};

#endif
#if !defined(PERSISTENTLOCK_H_INCLUDED)
#define PERSISTENTLOCK_H_INCLUDED




















#include <vector>


#include "persistentobj.h"
#include "clientpersistent.h"
#include "message.h"
#include "hashcode.h"
#include "synccall.h"

class sock;
class synccall;



class persistentlockconnection : public persistentobj::connection {
  public:
    persistentlockconnection(synccall& sync_) : sync(sync_) {}
    virtual ~persistentlockconnection() { }

    
    virtual message sendcommand(message& m, const hashcode& hash) { return sync.call(m); }

  private:
    synccall& sync;
};

class persistentlock
{
  public:
    persistentlock(context* main, const ustring& account, const ubigint64 backupid);
    ~persistentlock() { if (conn) delete conn; };

    bool lockit();
    bool unlock();

    SAFEALLOC(persistentlock);

  private:
    bool        error;          
    persistentlockconnection* conn;
    hashcode    lockhash;       
    bool        is_locked;      
    ubigint64   lockits;        
    ubigint64   unlocks;        
};

#endif


















#include "common.h"
#include "ustring.h"
#include "debug.h"
#include "runstage.h"
#include "output.h"
#include "replicate.h"
#include "context.h"
#include "utar_commands.h"
#include "hash_cache.h"
#include "filename_cache.h"
#include "synccall.h"
#include "acntmngr.h"
#include "backstate.h"
#include "sessionprogress.h"
#include "tretentiontype.h"
#include "expirepolicy.h"
#include "mctypes.h"

#include "repldata.h"
#include "replroot.h"
#include "uwrapper.h"
#include "ade_mgrx.h"
#include "timer.h"
#include "sessionprofile.h"
#include "regexpr.h"
#include "ddr_interface.h"
#include "workelem.h"
#include "mediadesc.h"

#include "unixpasswd.h"
#include "platerror.h"
#include "restroot2backupdir.h"
#include "auto_ptr.h"




#define MAX_SESSIONS_PER_REPLPROGRESS 25

#define disable_generating_sysinfo_files ((xflag[31]&1024)!=0)
#define migrate_backup_all_versions ((xflag[31]&8388608)!=0)
#define disable_pool_cache_deletion ((xflag[31]&16777216)!=0)

replicate::replicate(context* main_, utar_flags_info& flags_, utar_flags_info& dstflags_) :
    main(main_), flags(flags_), dstflags(dstflags_),
    replsrc_progress_vect(MAX_SESSIONS_PER_REPLPROGRESS),
    repldst_progress_vect(MAX_SESSIONS_PER_REPLPROGRESS)
{
}

replicate::~replicate()
{
    if (!hashcachefilename.isnull() && !disable_pool_cache_deletion) {
        
        DB->msg("replicate::~replicate: deleting temporary cache file '%s'", *hashcachefilename);
        uwrapper::uunlink(hashcachefilename);
    }
}

void replicate::flush_repl_progress(xml_messagev &vect, dpns dpninv) {
    if (vect.size() > 0 ) {
        
        
        
        
        DB->sender->sendstats(dpninv, "REPLICATE_BACKUPS", vect, false, false);
        vect.clear();
    }
}












void replicate::log_replprogress(const sessionprogress& start_prog,     
                                 const sessionprogress& cur_prog,       
                                 unsigned int newid,                    
                                 const ustring& sessname,               
                                 const prectime& snapuptime,            
                                 const bigint64& snapupsize,            
                                 const unsigned int origid,             
                                 const cidtype& cid,                    
                                 const ustring&  encrypt,               
                                 const prectime& expiretime,            
                                 const tretentiontype& retention,       
                                 const tbackuptype& backuptype,         
                                 const int plugin_num,                  
                                 const ustring& label,                  
                                 const repl_serverinfo replservers[])   
{
    sessionprogress end_prog = cur_prog - start_prog;
    end_prog.set_terminated_and_id(uapp::staging().getExitCode(), newid);

    xml_messagep mess(end_prog.genxml((int)::time(0), (double)snapupsize, sessname));
    mess->enter(sessionprogress::pattr_image(sessionprogress::pa_snapctime), snapuptime.hexstr());
    mess->enter(sessionprogress::pattr_image(sessionprogress::pa_srcsnapupid), origid);
    mess->enter(sessionprogress::pattr_image(sessionprogress::pa_path),     replservers[dpn0].serverpath.isempty() ? flags.path    : replservers[dpn0].serverpath);
    mess->enter(sessionprogress::pattr_image(sessionprogress::pa_hostname), replservers[dpn0].serveraddr.isempty() ? flags.hfsaddr : replservers[dpn0].serveraddr);

    
    mess->enter("cid",           cid.image());
    mess->enter("encrypt",       encrypt);
    mess->enter("expires",       expiretime.toUnixTime());
    mess->enter("retentiontype", retention.image());
    mess->enter("backuptype",    backuptype.image());
    mess->enter("userbackuptype",backuptype.enduserimage());
    mess->enter("pidnum",        plugin_num);
    mess->enter("label",         label);
    mess->enter("servertype",    replservers[dpn0].servertype);
    if(!replservers[dpn0].ddrhostname.isempty())
        mess->enter("ddrhostname", replservers[dpn0].ddrhostname);
    if(!replservers[dpn0].snapupid.isempty())
        mess->enter(sessionprogress::pattr_image(sessionprogress::pa_snapupid), replservers[dpn0].snapupid);
    mess->enter("type", "replsrc");

    
    xml_messagep dstmess = mess->clone();
    dstmess->enter(sessionprogress::pattr_image(sessionprogress::pa_path),     replservers[dpn1].serverpath.isempty() ? dstflags.path    : replservers[dpn1].serverpath);
    dstmess->enter(sessionprogress::pattr_image(sessionprogress::pa_hostname), replservers[dpn1].serveraddr.isempty() ? dstflags.hfsaddr : replservers[dpn1].serveraddr);
    dstmess->enter("servertype", replservers[dpn1].servertype);
    if(!replservers[dpn0].ddrhostname.isempty())    
        dstmess->enter("ddrhostname", replservers[dpn1].ddrhostname);
    if(!replservers[dpn1].snapupid.isempty())
        dstmess->enter(sessionprogress::pattr_image(sessionprogress::pa_snapupid), replservers[dpn1].snapupid);
    dstmess->enter("type", "repldst");

    
    
    mess->children.push_back(dstmess->clone());
    replsrc_progress_vect.push_back(mess->clone());
    if(replsrc_progress_vect.size() >= MAX_SESSIONS_PER_REPLPROGRESS)
        flush_repl_progress(replsrc_progress_vect, dpn0);

    if (dstflags.degenerate)
        return;  

    
    
    mess->children.pop_back();
    dstmess->children.push_back(mess);
    repldst_progress_vect.push_back(dstmess);
    if(repldst_progress_vect.size() >= MAX_SESSIONS_PER_REPLPROGRESS)
        flush_repl_progress(repldst_progress_vect, dpn1);
}


bool replicate::check_chunker_settings()
{
    const int dst_maxchunksize = main->getmaxchunksize(dpn1, chunktype::atomic);

    
    
    if(!flags.isexplicit("minchunksize"))  flags.minchunksize  = dstflags.minchunksize;
    if(!flags.isexplicit("threshold"))     flags.threshold     = dstflags.threshold;
    if(!flags.isexplicit("maxchunksize"))  flags.maxchunksize  = dstflags.maxchunksize;

    Out->msg(INFO, "<7678>Chunker settings: --minchunksize=%d, --threshold=%d, --maxchunksize=%d, --fixedatomsize=%d",
             flags.minchunksize, flags.threshold, flags.maxchunksize, flags.fixedatomsize );

    DB->msg(DBTXT("Chunker settings: compress=%d, clevel=%d, cpercent=%d"), flags.compress, flags.clevel, flags.cpercent);

    if(!(0 < flags.minchunksize && flags.minchunksize < flags.threshold && flags.threshold < flags.maxchunksize)) {
        Out->msg(ERR, "<7679>Invalid chunker settings (minchunksize=%d, threshold=%d, maxchunksize=%d)",
                 flags.minchunksize, flags.threshold, flags.maxchunksize);
        return false;
    }

    if(flags.fixedatomsize >0 &&
       !(flags.minchunksize < flags.fixedatomsize && flags.fixedatomsize < flags.maxchunksize)) {
        Out->msg(ERR, "<7680>Invalid fixed chunker settings (minchunksize=%d, fixedatomsize=%d, maxchunksize=%d)",
                 flags.minchunksize, flags.fixedatomsize, flags.maxchunksize);
        return false;
    }

    if(!dstflags.degenerate && (flags.maxchunksize > dst_maxchunksize)) {
        Out->msg(ERR, "<7681>Setting of --maxchunksize=%d exceeds destination server maximum of %d bytes",
                 flags.maxchunksize, dst_maxchunksize);
        return false;
    }

    
    flags.dpnmaxatomchunksize = flags.maxchunksize;

    return true;
}









rhlLabel replicate::truncate_label(const rhlLabel &src, const bool is_dublin_or_later) {
    ustring ustr(src.image());

    if(!is_dublin_or_later)
        return src;

    if(ustr.bytelength() > MAX_LABEL_LEN) {
        ustring labelstr;
        ustring timestr;
        ustr.split(labelstr, timestr, true, '-');
        if(timestr.isdecstring() && ((labelstr.bytelength()- ustr.bytelength() + MAX_LABEL_LEN) > 0)) {
            labelstr = labelstr.substr(0, labelstr.bytelength()- ustr.bytelength() + MAX_LABEL_LEN);
            ustr = labelstr + "-" + timestr;
	}
        else
            ustr = ustr.substr(0, MAX_LABEL_LEN);
    }
    rhlLabel truncatelabel(*ustr, NULL, src.get_aux1(), src.get_aux2());
    truncatelabel.set_taghash(src.get_taghash());       

    return truncatelabel;
}







bool replicate::is_media_backupdir_valid(mediadesc& mediaoutd, bool& media_error)
{
    bool ret(false);

    if(!flags.media_out.isempty()) {
        mediadesc tmpmediad(flags.media_out);
        const location::media::type media(tmpmediad.getmedia());
        const ustring mediatypestr(location::media::image(media));

        
        ret = true;

        
        media_error = true;
        if(!tmpmediad.valid()) {
            Out->msg(FATAL, "Invalid media specified for media-out %s", *mediatypestr);
        } else {
            
            if(!tmpmediad.authenticate(flags.sysdir, flags.vardir)) {
                Out->msg(FATAL, "Authentication failed for media-out %s", *mediatypestr);
            } else {
                
                flags.restoreprefetchmb = 0;

                
                flags.rechunk = tristateflag::st_disable;

                
                mediaoutd = tmpmediad;

                
                media_error = false;
            }
        }
    }

    return ret;
}


































bool replicate::run(BackupRootInfoList &backups, utar_commands* utarCmds) {
    
    
    
    
    
    
    
    
    

    DB->msg("context::replicate++");
    debug::scopemsg sm("context::replicate--");
    const dpns dstdpn = dpn1;   

    main->set_dpn_statstype(dpn0, context::restorestats);
    main->set_dpn_statstype(dpn1, context::backupstats);

    
    bool media_error(false);

    
    mediadesc mediaoutd;
    const bool replicating_to_media_out_backupdir(is_media_backupdir_valid(mediaoutd, media_error));
    if(replicating_to_media_out_backupdir) {
        if(media_error) {
            
            return false;
        }
        
        
        dstflags.degenerate = true;
    }

    hfs_info_struct *src_hfs_info = &main->getAdeMgr()->getHfsInfo(dpn0); 

    DB->msg("Sorting list of backups");
    backups.sort(BackupRootInfoList::SortOldToNew);

    DB->msg("Done sorting list of backups");
    ustring hostname(src_hfs_info->blk.path.self().tostr());
    Out->msg(INFO, "<5667>%s backups found for client \"%s\"", *::tostr(backups.size()), *hostname);
    if(backups.empty() && flags.clearcache && flags.reportonly && dstflags.degenerate) {
        ustring cachefile = ustring(flags.vardir)/ustring("p_backend-reportonly.dat");
        if(uwrapper::uunlink(cachefile) == 0)
            Out->msg(INFO, "<5654>Deleted cache file %s", *cachefile);
	    else
            Out->msg(WARN, "<10770>Delete of cache file %s failed", *cachefile);
    }

#if 000
    
    if (flags.maxpending == 0) {  
       main->maxpending += 0; 
       main->min_maxpending = 10;             
    }
#endif

    const int src_maxchunksize = main->getmaxchunksize(dpn0, chunktype::atomic);
    const int dst_maxchunksize = main->getmaxchunksize(dpn1, chunktype::atomic);

    
    
    bool rechunk_requested = (flags.rechunk == tristateflag::st_enable);
    if ((flags.rechunk == tristateflag::st_default) && !dstflags.degenerate && (flags.destination_data == client_config_flags::same_destination)) {
        rechunk_requested = (src_maxchunksize != dst_maxchunksize);
    }

    DB->msg(DBTXT("rechunk_requested = %d, src_maxchunksize = %d, dst_maxchunksize = %d"), rechunk_requested, src_maxchunksize, dst_maxchunksize);

    const bool migrate_request = (flags.destination_data != client_config_flags::same_destination);
    
    assert(!flags.chunkntfsstreams);

    if (rechunk_requested) {
        Out->msg(INFO, "<7682>User data will be re-chunked as it is replicated (source max=%d, dest max=%d)",
                 src_maxchunksize, dst_maxchunksize);
        if(!check_chunker_settings()) {
	        uapp::staging().startTermination(EXIT_BAD_FLAGS, "failed chunker settings");    
            return false;
        }
    }

    
    synccall dstsync(*main, dstdpn);

    
    

    hfs_info_struct dst_hfs_info = main->getAdeMgr()->getHfsInfo(dpn1);
    dst_hfs_info.sync      = &dstsync; 

    hashcode src_metahash = main->get_metadata_roothash(*src_hfs_info);
    if(src_metahash != hashcode::zero)  
                                        
        main->remove_old_metadata(dst_hfs_info, src_metahash);

    roothashlist dstsnapups;
    bool incl_partial = false;
    if(!dstflags.degenerate && (xflag[13]&256) == 0) {    
        DB->msg(DBTXT("Getting list of snapups on DST"));
        acntmngr dstacnt(dst_hfs_info.sync);
        msgerrors rslt;

        
        incl_partial = flags.incpartials && dstflags.ddrenabled && (dstflags.ddrindex > 0) &&
                       (flags.destination_data == client_config_flags::same_destination);

        
        rslt = dstacnt.getBackups(dstsnapups, dst_hfs_info.blk, dst_hfs_info.auth, 0, 0, 0, incl_partial, (dstflags.ddrindex > 0));

        if(rslt!=MSG_ERR_NONE) {
            Out->msg(ERR, "<6651>Failed to retrieve backup list from DST (error code %d %s).", rslt, *message::err_image(rslt));
            uapp::staging().startTermination(EXIT_CONNECT, "failed to retrieve backup list");     
            return false;
        }
        ustring targetname(src_hfs_info->blk.path.self().tostr());
        Out->msg(INFO, "<7250>Client \"%s\" has %d backups on target (%s)", *targetname, dstsnapups.cnt(), *dstflags.hfsaddr);
    }

    
    backstats replstats;
    
    
    if((!dstflags.degenerate) && (main->getdpnmaxmessage(dstdpn) < ACTIVESTRIPELIST)){
        flags.consolidate = false;
        DB->msg(DBTXT("The target server is older than Eureka, consolidate is disabled."));
    }

    
    
    
    
    const bool source_is_dublin_or_later = (main->getdpnmaxmessage(dpn0) >= STRIPECONVERSION);
    bool target_is_dublin_or_later = false;
    if(!dstflags.degenerate) {
        target_is_dublin_or_later = (main->getdpnmaxmessage(dstdpn) >= STRIPECONVERSION);
        if(!target_is_dublin_or_later) dstflags.workorderid = widtype::nah.image();

        
        
        
        main->sessinfo[dstdpn].addsrchost(flags.hfsaddr);  
        if(! main->startsession(main->sessinfo[dstdpn], dstdpn, "repldst", "", dstflags, main->my_clientid, widtype(dstflags.workorderid), NULL, true, "repldst")) {
            uapp::staging().startTermination(EXIT_MISC, "session start failed");     
            return false;
        }
    }
    stringlist emptylist;
    backstate state(emptylist, false, flags.parallel_type);
    main->state = &state;

    int errorcount = 0;         
    time_t dpn0ctime = main->getAdeMgr()->getHfsCreateTime(dpn0);
    time_t dpn1ctime = 0;
    if(!replicating_to_media_out_backupdir && !(flags.reportonly && dstflags.degenerate))    
        dpn1ctime = main->getAdeMgr()->getHfsCreateTime(dstdpn);


    if(dpn0ctime != 0 && (dpn0ctime == dpn1ctime) && (xflag[6]&1024)==0) {
        Out->msg(ERR, "<5698>Source (%s) and destination (%s) DPNs are the same!  Replication ABORTING.", *flags.hfsaddr, *dstflags.hfsaddr);
        errorcount++;
    }

    
    main->getAdeMgr()->getSessionProfile()->disableUploadStats();


    int i = 0;
    int replcount = 0;
    int alreadypresentcount = 0;
    double repllooptime = 0;
    BackupRootInfo one_backup;
    hostinfo host;
    undoo::auto_ptr<RegExpr> labpat;

    if(!flags.label_pat.isempty()) labpat = new RegExpr(flags.label_pat, REG_EXTENDED|REG_NOSUB|REG_ICASE);

    while(uapp::staging().canRun() && (errorcount==0 || xflag[6]&512) && backups.get(one_backup, i++)) {  
        if(!one_backup.isUsed()) continue;        

        const roothashlistrec one_hash     = one_backup.getrootrec();
        const hashcode tophash             = one_hash.getRoot();
        
	    
        
        
        rhlLabel fulllabel                 = truncate_label(one_hash.getLabel(), target_is_dublin_or_later);
        const unsigned int labelnum        = one_hash.getLabelnum();
        const bigint64 totsize             = one_hash.getTotalBytes(source_is_dublin_or_later); 
        roothashflags hashflags            = one_hash.getFlags();
        const prectime expiretime          = one_hash.getExpires();
        const prectime timestamp           = one_hash.getMtime();
        tddrindex ddrIndexFromBackup       = one_hash.getDDRIndex();

        const bool isencrypted             = hashflags.isencrypted;
        const bool backup_ispartial        = one_hash.isPartial();
        const int  plugin_num              = hashflags.plugin_num;
        
        
        bool rechunk                       = rechunk_requested && !isencrypted;  

        const tretentiontype retentiontype = one_hash.getRetentionType();  
        const tbackuptype    backuptype    = one_hash.getBackupType();

        bool usehashcache(true);
        const pidtype backup_plugin_pid(plugin_num);

        
        const ustring clientId = main->determineClientID(*src_hfs_info);
        const resource_identifier ri(*src_hfs_info,
                                     clientId,
                                     main->getAdeMgr()->getHfsCreateTime(dpn0),
                                     one_backup,
                                     flags,
                                     DIRELEMp());

        if(dstflags.degenerate && !replicating_to_media_out_backupdir)
            flags.ignoreispresent = true;    

        
        
        
        if (flags.destination_data == client_config_flags::gsan_to_ddr && disable_generating_sysinfo_files)
            hashflags.setDirectRestoreAllowed(false);
        else
            hashflags.setDirectRestoreAllowed(true);

        
        
        
        
        if(rechunk_requested && !rechunk && !migrate_request)
            Out->msg(WARN, "<7686>Backup #%d is encrypted and cannot be re-chunked, normal replication will be used", labelnum);

        if(migrate_request) { 
	    if(((ddrIndexFromBackup > 0) && (flags.destination_data == client_config_flags::gsan_to_ddr)) ||
	       ((ddrIndexFromBackup <= 0) && (flags.destination_data == client_config_flags::ddr_to_gsan)))
                rechunk = false;  
	    else
                rechunk = true;   
        }

        if(!flags.ignoreispresent) {
            if(replicating_to_media_out_backupdir) {
                
                if(mediaoutd.subdirectory_exists(ri.backup_resource_path())) {
                    Out->msg(INFO, "Backup #%d is already present on output media", labelnum);
                    alreadypresentcount++;
                    continue;
                }
            } else {
                
                if( dstsnapups.ispresent(tophash, timestamp) ) {  
                    Out->msg(INFO, 3, "<7683>Backup #%d is already present on target (hash and timestamp)", labelnum);
                    DB->msg("replicate::run() - Backup #%d is already present on target (hash - %s and timestamp)", labelnum, *tophash.partialimage());
                    alreadypresentcount++;
                    continue;
                }

                if( rechunk_requested && dstsnapups.searchPrecision(timestamp) != -1) {  
                    Out->msg(INFO, 3, "<7684>Backup #%d is already present on target (timestamp)", labelnum);
                    DB->msg("replicate::run() - Backup #%d is already present on target (timestamp)", labelnum);
                    alreadypresentcount++;
                    continue;
                }

                int dstsnapup_idx = dstsnapups.searchAll(timestamp);        
                if(dstsnapup_idx >= 0) {  
                    roothashlistrec dst_hashrec;
                    if(dstsnapups.get(dst_hashrec, dstsnapup_idx) &&
                       (((ddrIndexFromBackup <= 0) && (dst_hashrec.getDDRIndex() > 0)) ||  
                        ((ddrIndexFromBackup > 0) && (dst_hashrec.getDDRIndex() <= 0)))) { 
                        
                        ustring data_space = ustring::sprintf("%s", (ddrIndexFromBackup <= 0)?"data domain repository":"avamar data storage");
                        Out->msg(INFO, 3, "Backup #%d is already present on target %s (timestamp)", labelnum, *data_space);
                        DB->msg("replicate::run() - Backup #%d is already present on target %s (timestamp)", labelnum, *data_space);
                        alreadypresentcount++;
                        continue;
                    } else {
                        
                        DB->msg("replicate::run() - Backup #%d is not present on target (timestamp)", labelnum);
                    }
                }

                if((ddrIndexFromBackup > 0) && dstsnapups.searchAll(timestamp)>=0){    
                    Out->msg(INFO, "Backup(DDR) #%d is already present on target (timestamp)", labelnum);
                    alreadypresentcount++;
                    continue;
                }

                if( !rechunk && main->getAdeMgr()->hashIsPresentSync(dstdpn, tophash) ) {
                    if(xflag[13]&256) {    
                        Out->msg(INFO, "Backup %d is already on target (hash - %s), but not for this account. Skip the backup", labelnum, *tophash.partialimage());
                        alreadypresentcount++;                           
                        continue;
                    }
                    Out->msg(INFO, "<6653>Backup %d is already on target server, but not for this account", labelnum);
                    usehashcache = false;
                }

                if(flags.destination_data == client_config_flags::gsan_to_ddr && ddrIndexFromBackup > 0) {
                    Out->msg(WARN, "Skipping backup %d as it is already on the Data Domain", labelnum);

                    
                    if(!(flags.migrate_dd_continue)) {
                        errorcount++;
                    }
                    continue;
                }
            }
        }

        
        
        main->backupvers = tversion();
        
        
        if(utarCmds->get_infofile(one_backup)) {
            utarCmds->display_snapup_version_info(one_backup);
        }

        
        
        const bool use_raw_container = replcycle::should_use_raw_containers(main->get_avtar_version_that_created_backup(),
                                                                            backup_plugin_pid);
        
        {
            
            utar_commands::migrateinfo_fr = fileref();
            utar_commands::workresults_fr = fileref();

            if(migrate_request) { 
                const upath migrateinfo_path(UNDOO_DIRECTORY_NAME "/" MIGRATEINFO_FILENAME);
                const upath workresults_path(UNDOO_DIRECTORY_NAME "/" WORKRESULTS_FILENAME);

                {
                    const context::prep_for_sysinfo context_is_prepped(*main);
                    fileref migrateinfo_data;
                    if(utarCmds->get_sysinfo_file(one_backup, migrateinfo_data, migrateinfo_path)) {
                        ustring strdata;

                        migrateinfo_data.getdata(strdata);
                        DB->msg("Retrieved file '%s' from gsan %s", *migrateinfo_path.image(), *strdata);

                        utar_commands::migrateinfo_fr = migrateinfo_data;
                    }

                    fileref workresults_data;
                    if(utarCmds->get_sysinfo_file(one_backup, workresults_data, workresults_path)) {
                        ustring strdata;

                        workresults_data.getdata(strdata);
                        DB->msg("Retrieved file '%s' from gsan %s", *workresults_path.image(), *strdata);

                        utar_commands::workresults_fr = workresults_data;
                    }
                }
            }
        }

        exportstream_xmlp backup_infop(NULL);
        DB->msg("replicate::run plugin id = %d, workorder %d", flags.pluginid.kind(), !DB->workorder.isnull());
        
        
        if(flags.destination_data == client_config_flags::gsan_to_ddr) {
            backup_infop = new exportstream_xml(MIGRATEINFO);
            if((flags.pluginid.kind() == pidtype::migrate) || (xflag[31]&524288)!=0) {
                
                const xml_messagep xml_migrateinfo_cmd(new xml_message(exportstream_xml::section(exportstream_xml::section::commandline).image()));
                const xml_messagep commandp = parsedflags_to_xml(flags.parsed_flags, exportstream_xml::section(exportstream_xml::section::commandline).image());
                xml_migrateinfo_cmd->children.push_back(commandp);
                const xml_messagep secondp = parsedflags_to_xml(dstflags.parsed_flags, REPLDESTFLAG);
                xml_migrateinfo_cmd->children.push_back(secondp);
                backup_infop->add_section(exportstream_xml::section::commandline, xml_migrateinfo_cmd);
                if(!DB->workorder.isnull()) {
                    
                    xml_messagep xml_migrateinfo_wo(new xml_message(exportstream_xml::section(exportstream_xml::section::workorder).image()));
                    xml_migrateinfo_wo->entervalue(DB->workorder);
                    backup_infop->add_section(exportstream_xml::section::workorder, xml_migrateinfo_wo);
                }
            }
            
            const xml_messagep xml_migrateinfo_bk = utarCmds->backuprootinfo_to_xml(one_backup, true);
            
            xml_migrateinfo_bk->enter(BACKUPROOT, tophash.image());
            backup_infop->add_section(exportstream_xml::section::backup, xml_migrateinfo_bk);
            if(!backup_infop->is_backup_equal_or_newer_to(tversion::fallbrook_client) && !migrate_backup_all_versions) {
                Out->msg(INFO, 3, "Backup #%d is created with Avamar version older than Fallbrook release", labelnum);
                DB->msg("replicate::run() - Backup #%d is created by client before Fallbrook", labelnum);
                continue;
            }
        }

        
        
        tretentiontype rtype(flags.retentiontype);
        if(!retentiontype.matches(rtype.tochar()))
        {
            Out->msg(INFO, 3, "<7685>Backup #%d has different retention (%s != %s)", labelnum,
                    *retentiontype.image(), *rtype.image());
            continue;
        }

        prectime new_etime(expiretime);  

        if(!flags.expirepolicy.isempty()) {  
            
            new_etime = expirepolicy::get_policy_expire( flags.expirepolicy, timestamp, retentiontype);
        } else if ((flags.expires != 0) && (!flags.expiredelta.isempty())) {
            Out->msg(ERR, "Replication only accepts either 'expires' or 'expire-delta' flag, not both");
            return false;
        } else if(flags.expires != 0) {
            bool ok;
            const prectime etime = prectime::evalExpiresTime(flags.expires, ok);
            if(!ok) Out->msg(ERR, "Invalid expiration value specified (%"LL"u) -- Expiration is unmodified", flags.expires);
            if(etime.isTimestamp())
                new_etime = etime;
            else if (new_etime != 0)                
                new_etime = new_etime + etime;
        } else if(!flags.expiredelta.isempty() && (expiretime > prectime::now())) {  
            long expdelta;
            expireperiod::periodtypes seltype;
            if (!expireperiod::parse_period(*flags.expiredelta, seltype, expdelta)) {
                return false;
            }
            ubigint64 val_exptime;
            
            if(!expireperiod::calculate_expdelta_period(expiretime, seltype, expdelta, val_exptime))
                return false;
            new_etime = val_exptime;
        }

        if((new_etime > 0)&&(new_etime < prectime::now())) {  
            Out->msg(INFO, 3, "Backup #%d has expired with expiration date %s", labelnum, *new_etime.dtstr());
            continue;
        }

        
        tbackuptype btype(flags.backuptype);
        if((btype != tbackuptype::unknown) && (backuptype != btype)) {
            Out->msg(INFO, 3, "<10771>Backup #%d has different type (%s != %s)", labelnum,
                *backuptype.image(), *btype.image());
            continue;
        }

        
        if(!flags.label.isempty() && fulllabel.image() != flags.label)
            continue;

        
        if(labpat.get() && (fulllabel.image().isempty() || !labpat->is_match(fulllabel.image())))
            continue;

        
        if(incl_partial && (ddrIndexFromBackup <= 0)) {
            Out->msg(INFO, 3, "Partial backup replication is only for DDR backups. Backup #%d is not a ddr backup.", labelnum);
            continue;
        }

        if(!dstflags.degenerate) {
            message m( INITUSERINFO );
            m.body().hash = tophash;
            m = dstsync.call(m, 0);
        }

        
        if(migrate_request && use_raw_container) usehashcache = false;

        
        if( state.hashes == NULL && state.fcache == NULL && usehashcache && ! flags.nocache && ! flags.vardir.isempty() ) {
            
            
            ustring suffix;
            if(flags.reportonly) {
	        if(dstflags.degenerate)
                    suffix = ustring("backend-reportonly.dat");
                else
                    suffix = ustring::sprintf("%s-%d-reportonly.dat", *dstflags.hfsaddr, (int)main->getAdeMgr()->getHfsCreateTime(dstdpn));
            }
            else
                suffix = gen_cache_suffix(dstflags.hfsaddr, flags.hfsaddr, hostname, '-', flags.labelnum);
            DB->msg("replicate::run: cache base name '%s', labelnum %d", *suffix, flags.labelnum);

            
            if(uwrapper::umkdir(flags.vardir,0777) != 0)
                DB->msg("Unable to create directory '%s'", *flags.vardir);

            
            
            
            
            
            
            if (rechunk && (xflag[18]&128)==0) {        
                const ustring f_cachename(ustring("f_")+suffix);
                ustring file_cache_filename = cache::makecachename(flags.vardir, "", f_cachename, FILENAME_CACHE_FILENAME);
                convert_cache_filename(file_cache_filename, src_hfs_info, true);
                Out->msg(INFO, "<7687>Loading file cache %s", *(flags.vardir/f_cachename));

                state.fcache = new filename_cache(main, file_cache_filename, flags.paging_cache || dstflags.ddrenabled,  0, false);
                if(state.fcache->iserror()) {
                    if(state.fcache->isshareerror()) {
                        Out->msg(ERR, "<7688>File cache file for \"%s\" is locked, probably due to another replication -- Aborting", *hostname);
                        errorcount++;
                        delete state.fcache;
                        state.fcache = NULL;
                        continue;
                    } else
                        Out->msg(FATAL, "<7689>Unable to open file cache in directory '%s'", *flags.vardir);
                    delete state.fcache;
                    state.fcache = NULL;
                }

                bool need_to_repair_cache = false;
                if(state.fcache != NULL && ! state.fcache->checkversion(flags.oktoclear, need_to_repair_cache)) {
                    if(state.fcache != NULL)
                        return false;           
                    DB->msg(DBTXT("deleting file cache"));
                    delete state.fcache;
                    state.fcache = NULL;
                }

                if(state.fcache != NULL) {
                    state.fcache->choose_root_tag(flags.checkcache,  false, true, dstdpn);
                }

            } else {                            
                const ustring p_cachename(ustring("p_")+suffix);
                ustring hash_cache_filename = cache::makecachename(flags.vardir, "", p_cachename, HASH_CACHE_FILENAME);
                if(!flags.reportonly) {
                    convert_cache_filename(hash_cache_filename, src_hfs_info, false);
                }
                if (flags.labelnum != 0)
                    hashcachefilename = hash_cache_filename;    
                Out->msg(INFO, "<5688>Loading hash cache %s", *hash_cache_filename);

                if(flags.replicate) flags.paging_cache = false; 
                state.hashes = new hash_cache(main, hash_cache_filename);
                state.hashes->setversionoffset(1);   
                if(state.hashes->iserror()) {
                    if(state.hashes->isshareerror()) {
                        Out->msg(ERR, "<6044>Cache file for \"%s\" is locked, probably due to another replication -- Aborting", *hostname);
                        errorcount++;
                        delete state.hashes;
                        state.hashes = NULL;
                        continue;
                    } else
                        Out->msg(FATAL, "<5225>Unable to open hash cache in directory '%s'", *flags.vardir);
                    delete state.hashes;
                    state.hashes = NULL;
                }

                bool need_to_repair_cache = false;
                if(state.hashes != NULL && ! state.hashes->checkversion(flags.oktoclear, need_to_repair_cache)) {
                    if(state.hashes != NULL)
                        return false;           
                    DB->msg(DBTXT("deleting hashes"));
                    delete state.hashes;
                    state.hashes = NULL;
                }
                
                
                
                
                if(flags.replicate && uwrapper::uaccess(hash_cache_filename, R_OK|W_OK) == 0 &&
                                               uwrapper::uchmod(hash_cache_filename, 0664) == 0) {

#ifdef SYSTEM_UNIX_LINUX
                    
                    if(uwrapper::ustat("/usr/local/avamar/bin/gsan", NULL, 0) == 0) {
                        struct STATSTRUCT hash_file_info;
                        if(uwrapper::ustat(hash_cache_filename,&hash_file_info,sizeof(struct STATSTRUCT)) == 0) {
                            unixpasswd pwd("admin");
                            gid_t admin_gid = pwd.gid();
                            if(hash_file_info.st_gid != admin_gid) {
                                
                                if(admin_gid == ((gid_t) -1)) {
                                    Out->msg(ERR, "User 'admin' doesn't exist");
                                }
                                else if(uwrapper::uchown(hash_cache_filename, hash_file_info.st_uid, admin_gid) != 0) {
                                    const platerror pe(platerror::use_clib);
                                    Out->msg(WARN, "Unable to chown cache file %s (%s)", *hash_cache_filename, *pe.description());
                                }
                            }
                        } else {
                            const platerror pe(platerror::use_clib);
                            Out->msg(ERR, "Can't stat cache file %s (%s)",*hash_cache_filename, *pe.description());
                        }
                    }
#endif
                } else {
                    if(flags.replicate) {
                        const platerror pe(platerror::use_clib);
                        Out->msg(WARN, "Unable to chmod and chown hash cache file %s (%s)", *hash_cache_filename, *pe.description());
                    }
                }

                if(state.hashes != NULL)
                    state.hashes->choose_root_tag(flags.checkcache,  flags.reportonly, true, dstdpn);
            }

        } else {
            if( state.hashes != NULL && !flags.reportonly) {    
                
                DB->msg(DBTXT("Using choose_root_tag to get new root_tag"));
                state.hashes->choose_root_tag(flags.checkcache,  false, false, dstdpn);
            }

            if(state.fcache != NULL) {
                state.fcache->choose_root_tag(flags.checkcache,  false, false, dstdpn);
            }
        }

        const sessionprogress start_prog(main->getAdeMgr()->getSessionProfile()->gatherStats(dstdpn, true));

        

        Out->msg(INFO, "<6654>Replicating backup %d, Label \"%s\", %s", labelnum, *fulllabel.image(), *byteunits((double)totsize));

        const ustring sessname(ustring::sprintf("%s#%d", *hostname, labelnum));
        const ustring sessprefix(sessname+"::");
        
        
        
        
        
        
        
        repl_serverinfo repl_servers[maxdpns]; 
        if(main->getAdeMgr() != NULL) {        
            ADEMgrX* adeMgr = main->getAdeMgr();
            
            
            
            
            if(((ddrIndexFromBackup > 0) || (flags.destination_data == client_config_flags::gsan_to_ddr)) && (!(flags.reportonly && dstflags.degenerate))) { 
                
                if(!dstflags.isexplicit("ddr-index") && (flags.destination_data != client_config_flags::ddr_to_gsan) && !replicating_to_media_out_backupdir) {    
                                                           
                    Out->msg(ERR, "<10772>The target server doesn't have repository attached for DDR replication.");
                    if(flags.destination_data == client_config_flags::gsan_to_ddr) {
                        Out->msg(ERR, "The target server doesn't have repository attached for DDR migration. Procrss abort.");
                        return false;
                    }
                    errorcount++;
                    continue;
                }
                
                repl_servers[0].serveraddr = flags.hfsaddr;
                repl_servers[0].serverpath = flags.path;
                int result;
                if(ddrIndexFromBackup > 0) {
                    repl_servers[0].servertype="DD";  
                    result = adeMgr->loginDDRWithIndex(flags.path, ddrIndexFromBackup, true, true);
                } else {
                    repl_servers[0].servertype="Avamar";  
                    result = adeMgr->loginDDRWithIndex(dstflags.path, dstflags.ddrindex, true, true);
                }

                if(result != EXIT_OK) {
                    Out->msg(ERR, "<10773>The DDR could not be connected with, index=%d.", ddrIndexFromBackup);
                    errorcount++;
                    continue;
                } else if(replicating_to_media_out_backupdir) {
                    flags.ddrenabled = true;
                }
                
                
                
                
                if(!replicating_to_media_out_backupdir) {
                    repl_servers[1].serveraddr = dstflags.hfsaddr;
                    repl_servers[1].serverpath = dstflags.path;
                    if((ddrIndexFromBackup > 0) && (flags.destination_data == client_config_flags::ddr_to_gsan))
                        repl_servers[1].servertype="Avamar";
                    else
                        repl_servers[1].servertype="DD";
                }
                if(adeMgr->isDDRenabled()) { 
                    DataDomainSysInfo ddrSysInfo;
                    ddrSysInfo.labelnum = (int)labelnum;
                    ddrSysInfo.fileName = DATADOMAINFILES_FILENAME;
                    ddrSysInfo.hexBackupTime = +timestamp;

                    if(flags.destination_data != client_config_flags::gsan_to_ddr) {  
                        const bool filePresent = utarCmds->get_ddrfiles_xml(one_backup, ddrSysInfo.fileName, ddrSysInfo.ddrfilesData);
                        hfs_info_struct& hfs_info(adeMgr->getHfsInfo(dpn0));
                        ddrSysInfo.clientID = hfs_info.clientidhash.image();
                        if (!filePresent) {
                            
                            
                            
                            int ddrHandle = 0;
                            adeMgr->get_ddrhandle(ddrHandle);
                            ddrfiles_xmlp ddrfiles(ddr_interface::get_ddr_files(ddrHandle, hfs_info.clientidhash.image(), location::tbackupid(timestamp)));

                            if (!ddrfiles.isnull()) {
                                DB->msg("replicate::run() read ddr_files.xml from ddr\n%s\n", *ddrfiles->simage());
                                ddrSysInfo.ddrfilesData.initmem(ddrfiles->simage());
                            } else {
                                Out->msg(ERR, "<10774>A DDR replicate was specified, but no '.system_info/%s' file was found on the Avamar server, nor was the file found on the Data Domain server",
                                         DATADOMAINFILES_FILENAME);
                                errorcount++;
                                continue;
                            }
                        }
                    }
                    else {
                        hfs_info_struct& hfs_info(adeMgr->getHfsInfo(dpn1));
                        ddrSysInfo.clientID = hfs_info.clientidhash.image();
                    }

                    DB->msg("replicate::run() DDR replicate of labelnum=%d, ddrIndex=%d, hextime=0x%"LL"x, hash=%s", ddrSysInfo.labelnum, ddrIndexFromBackup, ddrSysInfo.hexBackupTime, *tophash.partialimage());
                    adeMgr->setSysInfo(ddrSysInfo);
                    adeMgr->setDDRSysInfo(ddrSysInfo);

                    
                    DataDomainLoginArgs ddrLogin;
                    for(int i = 0; i < maxdpns; i++) {
                        ddrLogin.dpninx = (dpns)i;
                        if(adeMgr->getDDRLoginInfo(ddrLogin)) {
                            DB->msg("replicate::run() adeMgr->getDDRLoginInfo successful logged in %s (dpn%d)",
                                     *ddrLogin.server, ddrLogin.dpninx);
                            
                            repl_servers[i].ddrhostname = ddrLogin.server;
                        }
                        else
                            Out->msg(WARN, "<10775>dpn%d: The DDR host name is not available for index=%d.", i, ddrIndexFromBackup);
                    }
                }
                else {
                    Out->msg(ERR, "<10773>The DDR could not be connected with, index=%d.", ddrIndexFromBackup);
                    errorcount++;
                    continue;
                }
            }
            else {
                if(ddrIndexFromBackup > 0 && !replicating_to_media_out_backupdir) { 
                    if(xflag[27]&128)        
                        Out->msg(WARN, "<12123>The backup %d, Label \"%s\", is ddr backup. Backend capacity report will not include DDR data size.", labelnum, *fulllabel.image());
                    else {
                        Out->msg(ERR, "<12124>Backend capacity report does not support Data Domain backup(Label number: %d, Label \"%s\"). Operation aborted.", labelnum, *fulllabel.image());
                        DB->msg("To skip ddr backup data, use --x27=128 flag.");
                        uapp::staging().startTermination(EXIT_ABORT, "backend capacity report doesn't support Data Domain backup");
                        errorcount++;
                        continue;
                    }
                }

                if(!replicating_to_media_out_backupdir) {
                    for(int i = 0; i < maxdpns; i++) {
                        repl_servers[i].servertype= ustring("Avamar");
                        repl_servers[i].ddrhostname = ustring("");
                    }
                } else {
                    repl_servers[0].servertype = (ddrIndexFromBackup > 0) ? "DD" : "Avamar";
                    repl_servers[0].serveraddr = flags.hfsaddr;
                    repl_servers[0].serverpath = flags.path;

                    repl_servers[1].servertype = location::media::image(mediaoutd.getmedia());
                    repl_servers[1].serveraddr = mediaoutd.getserver();

                    const upath backuppath(ri.backup_resource_path());
                    repl_servers[1].serverpath = backuppath.parentdir().image();
                    repl_servers[1].snapupid   = backuppath.stripdir();
                    repl_servers[0].snapupid   = backuppath.stripdir();
                }
                
                
            }
        }

        
        workelem *info = NULL;
        upath rootpath("");
        DIRELEMp rootdirelemp(new DIRELEM(rootpath));
        rootdirelemp->set_is_root_directory();
        ucontainer::basep container = NULL;

        if(rechunk) {
            if(flags.destination_data == client_config_flags::gsan_to_ddr) {  
                if(!use_raw_container)  
                    container = main->initnextucontainer(rootdirelemp, false);
            }
            else if (flags.destination_data == client_config_flags::ddr_to_gsan)
                main->set_location_info("replicate::run()", location(), *rootdirelemp);
        }
        info = new workelem(rechunk, rootdirelemp, container);
        hashcode replhash(tophash);
        repllooptime = timer::now();

        
        
        
        
        
        const upath final_backupdir_path(ri.backup_resource_path());
        const upath backupdir_parent_path(final_backupdir_path.parentdir());
        const ustring backupdir_name(final_backupdir_path.stripdir());
        const ustring backupdir_tmpname(ustring::sprintf(".tmp_%d_%s_", DB->currthread(), datetime().image_nosep().tostr()) + backupdir_name);

        if(!replicating_to_media_out_backupdir) {

            
            
            

            replroot *rst = new replroot(replhash, *main, sessprefix, ddrIndexFromBackup, info, backup_infop, (flags.pluginid.kind() == pidtype::migrate)); 

            rst->noop();
        } else {
            
            restroot2backupdir *rst = new restroot2backupdir(one_backup, one_backup.getRootLocation(), *main, ri, mediaoutd, backupdir_tmpname);
            rst->noop();
        }

        
        
        bool looperror = main->loop();        
        repllooptime = timer::now() - repllooptime;
        if(xflag[19]&64)DB->msg("replicate::run() - main->loop: %d using %f seconds", i, repllooptime/1000);

        
        
        
        if(replicating_to_media_out_backupdir) {
            
            const upath fullsrcpath(upath(mediaoutd.getdirpath()) / backupdir_parent_path / backupdir_tmpname);
            
            const ustring desired_name(looperror ? backupdir_tmpname.replace(".tmp", ".del") : backupdir_name);

            DB->msg("replicate::run() - rename '%s' to '%s'", *fullsrcpath.image(), *desired_name);

            
            if(!mediaoutd.rename(fullsrcpath, desired_name)) {
                if(!looperror) {
                    
                    Out->msg(ERR, "Unable to rename tmp backup directory after replication");
                    
                    looperror = true;
                } else {
                    
                    Out->msg(INFO, "Unable to rename tmp backup directory to del directory after replication");
                }
            }
        }

        DB->msg("replicate::run looperror:%d errorcount:%d %s", looperror, errorcount, *uapp::staging().getRunStageImage());

        
        univuns idnum = 0;

        
        if (looperror) {
            errorcount++;
            delete state.hashes;  
            state.hashes = NULL;
            delete state.fcache;
            state.fcache = NULL;
            if (xflag[6]&512) {
                Out->msg(INFO, "<5991>Error found in backup number %d, skipping to next backup", labelnum);
            } else {
                Out->msg(INFO, "<5992>Error found in backup number %d", labelnum);
            }
            continue;

        }
        
        else if (uapp::staging().canRun(RSTAGE_WRAPUP) && (!uapp::staging().isExitAbort())) {
            const bool is_modified = (replhash != tophash);
            const bool is_partial  = (is_modified && (!uapp::staging().isExitOkay()));

            DB->msg("replicate::run - is_partial: \"%s\", tophash = %s, replhash = %s", is_partial?"true":"false", *tophash.partialimage(), *replhash.partialimage());
            bigint64 snapupsize(totsize);
            if(is_partial) snapupsize = (bigint64)main->getstatsobj(main->get_dpn_statstype(dstdpn))->get_filebytes_prog();     

            bool retval = false;
            if(replicating_to_media_out_backupdir) {
                replcount++;
            }
            else if (flags.noroothash || flags.reportonly) {
                if (!dstflags.degenerate) Out->msg(WARN, "<7919>Data may be reclaimed by GC since replicated roothash was not entered, or replication is in reportonly mode");
                replcount++;
            } else {
                
                ubigint64 dst_timestamp = is_partial?0:+timestamp;                      
                ubigint64 dst_etime = 0;
                ustring errmsg;
                
                unsigned int status = backup_ispartial? RHL_UPDATE_BEGIN:RHL_UPDATE_ONETIME;   
                if(is_partial) status = RHL_UPDATE_BEGIN;                               
                DB->msg("replicate::run() - is backup partial = %d, partial replication = %d, status = %d",
                      backup_ispartial, is_partial, status);

                if(main->getAdeMgr()->hashIsPresentSync(dstdpn, replhash)) {            
                    
                    
                    if (!info->container.isnull() && (flags.destination_data == client_config_flags::gsan_to_ddr) && disable_generating_sysinfo_files) {
                        DB->msg("replicate::run() calling finalizeucontainer(%p, true) before sealing backup with gsan", info->container.getimpl());
                        main->finalizeucontainer(info->container, true);
                    }
                    if (is_partial && (ddrIndexFromBackup > 0)) { 
                        
                        
                        
                        
                        
                        
                        hashflags.ddrindex = 0;
                    }
                    
                    DB->msg("replicate::run() - Backup #%d new expiration date: %s, original backup expiration date: %s",
                             labelnum, *new_etime.dtstr(), *expiretime.dtstr());
                    if((flags.rechunk == tristateflag::st_enable) || migrate_request)
                        hashflags.ddrindex = dstflags.ddrindex;

                    
                    
                    hashflags.tiering = 0;
#if 1
                    retval = main->getAdeMgr()->commitBackup.addtoplevel2(dstdpn, replhash, &replstats, dst_timestamp, dst_etime,
                                                              idnum, errmsg, fulllabel, status, new_etime, snapupsize, hashflags, "", is_partial);
                    if(retval && (flags.destination_data == client_config_flags::gsan_to_ddr))  
                        retval = main->getAdeMgr()->renameDDRTempToFinal(false, true);
#else
                    if(dst_etime != 0) {
                        retval = false;
                    }
                    retval = false;
#endif
                }
                else    
                    DB->msg(DBTXT("replicate: final roothash not present on target server -- Backup is not being recorded on target server."));

                if(!retval) {
                    Out->msg(ERR, "<5672>Could not record backup on target server (%s)", *errmsg);

                    if (migrate_request && (flags.destination_data == client_config_flags::gsan_to_ddr)) {
                        hfs_info_struct& hfs_info = main->getAdeMgr()->getHfsInfo(dstdpn);

                        acntmngr acnt(hfs_info.sync);
                        const blktraj block(hfs_info.blk);  
                        const authid  auth(hfs_info.auth);
                        const msgerrors rslt = acnt.delBackup(block, auth, dst_timestamp, false, true);

                        if (rslt == MSG_ERR_NONE) {
                            Out->msg(INFO, "Deleted backup %s", *tostr(dst_timestamp));
                        } else {
                            Out->msg(WARN, "Unable to delete invalid backup %s", *tostr(dst_timestamp));
                        }

                        if((xflag[6]&512)==0) {
                            errorcount++;         
                            continue;
                        }
                    } else {
                        if((xflag[6]&512)==0) errorcount++;         
                    }
                } else {
                    datetime dst_timestamp_nice(dst_timestamp);
                    
                    if (is_partial || backup_ispartial)
                        Out->msg(INFO, "<5673>PARTIAL Backup #%u timestamp %"AVDATE"s %s created", +idnum, *dst_timestamp_nice.image(), *datetime::TzDst.av_tzname);
                    else if (is_modified)
                        Out->msg(INFO, "Re-chunked Backup #%u timestamp %"AVDATE"s %s created", +idnum, *dst_timestamp_nice.image(), *datetime::TzDst.av_tzname);
                    else
                        Out->msg(INFO, "Backup #%u timestamp %"AVDATE"s %s created", +idnum, *dst_timestamp_nice.image(), *datetime::TzDst.av_tzname);
                    if(!is_partial) replcount++;
                }
            }

            
            
            
            if (state.hashes != NULL && !flags.reportonly) {
                DB->msg(DBTXT("replicate: setting final roothash in hash cache"));
                const int count = (int)replstats.get_filecnt(stats::sent);    
                state.hashes->set_root_tag( replhash, count, TIME32(0) );
            }
            if (state.fcache != NULL) {
                DB->msg(DBTXT("replicate: setting final roothash in file cache"));
                const int count = (int)replstats.get_filecnt(stats::sent);    
                state.fcache->set_root_tag( replhash, count, TIME32(0), dstflags.ddrindex, retval? +timestamp : +prectime(0) );
            }

            sendEvent(clientId, replicating_to_media_out_backupdir ? tostr(timestamp, 16) : tostr(labelnum), !retval);
        }
        
        
        
        sessionprogress stats = main->getAdeMgr()->getSessionProfile()->gatherStats(dstdpn, true);
        log_replprogress(start_prog, stats, idnum, sessname, timestamp, totsize, labelnum, main->my_clientid, flags.encrypt,
                         expiretime, retentiontype, backuptype, plugin_num, fulllabel.image(), repl_servers);

        if(info) {
            DB->msg("replicate::run() delete info for backup #%d, %s",  labelnum, *fulllabel.image());
            delete info;
        }
    } 

    
    flush_repl_progress(replsrc_progress_vect, dpn0);
    flush_repl_progress(repldst_progress_vect, dpn1);

    if(flags.reportonly && (flags.capacity_match_bits>0) && ((xflag[19]&32768) == 0))
        main->getstatsobj(context::restorestats)->multiple_by(stats::sent, 1<<flags.capacity_match_bits, chunktype::extatomic);

    
    
    if (state.hashes != NULL && errorcount==0 && uapp::staging().canRun()) {
        
        Out->msg(INFO, "<7690>Updating hash cache file");
        state.hashes->close_cache();
        delete state.hashes;
        state.hashes = NULL;
    }

    if (state.fcache != NULL && errorcount==0 && uapp::staging().canRun()) {
        Out->msg(INFO, "<7691>Updating file cache file");
        state.fcache->close_cache();
        delete state.fcache;
        state.fcache = NULL;
    }

    main->state = NULL; 

    if(!flags.allsnapups && replcount+alreadypresentcount+errorcount==0) {
        Out->msg(ERR, "<5674>Could not locate requested backup for replication");
    } else {
        Out->msg(INFO, "<5675>Replicated %d of %s backups (%d error%s) for client \"%s\"",
                 replcount, *::tostr(backups.size()), errorcount, (errorcount==1)?"":"s", *hostname);
    }

    if(flags.reportonly)
        replreportdata::report();
    else
        repldata::report();

    if(!uapp::staging().canRun()) {
        Out->msg(ERR, "<6655>Replicate interrupted.");
    } else if(errorcount) {
        Out->msg(ERR, "<6656>Replicate failed");
    }

    return errorcount==0;
}










void replicate::convert_cache_filename(ustring &cachename, hfs_info_struct *src_hfs_info, const bool file_cache) {
    ustring cachepath;
    ustring cachename_tmp(cachename);  
    const ustring hostname(src_hfs_info->blk.path.image().strip(ustring::STRIP_BOTH, DIRSEP).replace(DIRSEP, "-"));  
    const ustring suffix = gen_cache_suffix(dstflags.hfsaddr, flags.hfsaddr, hostname, '_', flags.labelnum);
    if(file_cache) {
        cachepath = cache::makecachename(flags.vardir, "", ustring("f_")+suffix, FILENAME_CACHE_FILENAME);
        if(flags.paging_cache) {
            cachepath = cachepath.substr(0, cachepath.bytelength() - 4) + ustring("2.dat");
            cachename_tmp = cachename_tmp.substr(0, cachename_tmp.bytelength() - 4) + ustring("2.dat");
        }
    } else {
        cachepath = cache::makecachename(flags.vardir, "", ustring("p_")+suffix, HASH_CACHE_FILENAME);
    }

    struct stat buf;
    if((stat(*cachename_tmp, &buf) == 0) && (rename(*cachename_tmp, *cachepath) == 0)) {  
        
        Out->msg(INFO, "Cache file \"%s\" has been updated to \"%s\".", *cachename_tmp, *cachepath);
        DB->msg("replicate::convert_cache_filename() - cache file name is renamed from \"%s\" to \"%s\"", *cachename_tmp, *cachepath);
    } else {
        Out->msg(INFO, "Replicator starts with cache file \"%s\".", *cachepath);
        DB->msg("replicate::convert_cache_filename() - \"%s\" either does not exist or could not be renamed", *cachename_tmp);
    }

    cachename = cachepath;  
}







xml_messagep replicate::parsedflags_to_xml(const ustring &parsed_flags, const ustring xml_header) {
    const xml_messagep commandp(new xml_message(xml_header));
    commandp->enter(exportstream_xml::attr(exportstream_xml::attr::flags).image(), parsed_flags);

    return commandp;
}


void replicate::sendEvent(const ustring& clientId, const ustring& backupId, bool success) const {

    if (main->client_ctl_statep.isnull()) {
        DB->msg("replicate::sendEvent client_ctl_statep is null");
        return;
    }

    if (!flags.report_targets_done) {
        DB->msg("replicate::sendEvent --report_targets_done is false");
        return;
    }

    DB->msg("replicate::sendEvent sending backup_replicated event");
    const ustring details = ustring::sprintf("%s:%s", *clientId, *backupId);
    const ctl_message::ctl_event target_done_event(flags, 
                                     ctl_message::ctl_event::backup_replicated, 
                                     details,
                                     success ? "succeeded" : "failed"); 

    const ctl_queue::rettype ret = main->client_ctl_statep->enq_send(target_done_event.getmessage());
    if (ret == ctl_queue::enqueued_ret) {
        DB->msg("replicate::sendEvent succeeded");
    }
    else {
        DB->msg("replicate::sendEvent failed");
    }
}

ustring replicate::gen_cache_suffix(const ustring& dsthfsaddr, const ustring& srchfsaddr, const ustring& hostname, const char sepchar, int labelnum ) const
{
    ustring label;
    if (labelnum != 0)
        label = ustring::sprintf("%d-", labelnum);
    return ustring::sprintf("%s%s-%s%c%s.dat", *label, *dsthfsaddr, *srchfsaddr, sepchar, *hostname);
}















#include "backupboostutils.h"
#include "uwrapper.h"
#include "platerror.h"
#include "utar_commands.h"
#include "filenames.h"
#include "filemap.h"

#if SYSTEM_WINDOWS
    #include <winsock2.h>
#endif
#if !SYSTEM_WINDOWS
#include "processlock.h"
#endif

using namespace backupboost;
using namespace std;

#define backstream_msg      ((xflag[2]&8192)!=0)











const bool backupboostutils::preprocess(inode_table &inodetab,
                                  hardlink_path_table &pathtab,
                                  path2event_table &bbeventlist,
                                  utar_flags_info *flags)
{
    
    backupboost_parser parser(flags->media_in, 0, flags->teeinstream);

    
    
    hardlink_event_list hl_create_list;
    
    hardlink_event_list hl_orphan_and_modified_list;
    
    hardlink_event_list hl_delete_list;
    
    
    hardlink_event_list hl_ref_path_list;
    
    hardlink_event_list dir_delete_list;
    
    directory_rename_list dir_rename_list;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    while (1) {
        bbevent eventinfo;
        ubigint64 inode;
        upath path_1;
        upath path_2;
        if (!parser.getentry(eventinfo, inode, path_1, path_2)) {
            DB->msg("backupboostutils::preprocess: No more events to read.");
            break;

        } else if (eventinfo.get_type() == bbevent::type_E) {
            
            
            
            
            

        } else {
            
            
            
            
            bool add_to_main_event_list(true);

            
            if (backstream_msg) DB->msg("Event read: event_code:'%s', node_kind:'%s', hardlink:'%s', inode:'%s', path_1:'%s', path_2:'%s'",
                                        *bbevent::image(bbevent::event_code(eventinfo.get_code())),
                                        *bbevent::image(bbevent::node_kind(eventinfo.get_kind())),
                                        eventinfo.is_hardlink() ? "HL": "",
                                        *tostr(inode), *path_1.image(), *path_2.image());

            if (eventinfo.is_hardlink()) {
                switch (eventinfo.get_type()) {

                
                
                case (bbevent::type_c):
                case (bbevent::type_C): {
                    
                    add_to_main_event_list = false;

                    
                    
                    hl_event_list_entry hl_entry(eventinfo, inode, path_1);
                    
                    hl_create_list.add_entry(hl_entry);
                    
                    
                    if (!path_2.isempty()) {
                        hl_entry.path = path_2;
                        hl_ref_path_list.add_entry(hl_entry);
                    }
                    break;
                }

                
                
                case (bbevent::type_O):
                case (bbevent::type_M): {
                    
                    add_to_main_event_list = false;

                    
                    hl_event_list_entry hl_entry(eventinfo, inode);
                    hl_orphan_and_modified_list.add_entry(hl_entry);
                    break;
                }

                
                
                case (bbevent::type_d):
                case (bbevent::type_D): {
                    
                    hl_event_list_entry hl_entry(eventinfo, inode, path_1);
                    hl_delete_list.add_entry(hl_entry);
                    break;
                }

                default: {}
                } 

            } else {
                
                if (eventinfo.get_type() == bbevent::type_R) {
                    
                    
                    if (!dir_rename_list.add_list_entry(path_2, inode, eventinfo, path_1)) {
                        
                        DB->msg("backupboostutils::preprocess: Failed to add entry to directory rename list. event_code:'%s', inode:'%s', old path:'%s', new path:'%s'",
                                *bbevent::image(bbevent::event_code(eventinfo.get_code())),
                                *tostr(inode), *path_2.image(), *path_1.image());
                        return false;
                    }

                } else if (eventinfo.is_dir() && eventinfo.get_type() == bbevent::type_D){
                    
                    hl_event_list_entry dir_entry(eventinfo, inode, path_1);
                    dir_delete_list.add_entry(dir_entry);
                }
            }

            if (add_to_main_event_list) {
                
                if (!bbeventlist.add_table_entry(path_1, inode, eventinfo)) {
                    
                    DB->msg("backupboostutils::preprocess: Failed to add entry to main event list. event_code:'%s', node_kind:'%s', hardlink:'%s', inode:'%s', path_1:'%s', path_2:'%s'",
                            *bbevent::image(bbevent::event_code(eventinfo.get_code())),
                            *bbevent::image(bbevent::node_kind(eventinfo.get_kind())),
                            eventinfo.is_hardlink() ? "HL": "",
                            *tostr(inode), *path_1.image(), *path_2.image());
                } else {
                    
                    
                }
            }
        }
    } 

    
    if (backstream_msg) {
        ustring list_name;
        list_name = "HARDLINK CREATE";
        hl_create_list.dump(list_name);
        list_name = "HARDLINK ORPHAN AND MODIFIED";
        hl_orphan_and_modified_list.dump(list_name);
        list_name = "HARDLINK DELETE";
        hl_delete_list.dump(list_name);
        list_name = "HARDLINK REFERENCE PATH";
        hl_ref_path_list.dump(list_name);
        list_name = "DIRECTORY DELETE";
        dir_delete_list.dump(list_name);
        dir_rename_list.dump();
    }


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    upath old_path;
    upath new_path;
    ubigint64 inode;
    bbevent eventinfo;
    int subtype(bbevent::subtype_none);

    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table before processing any event lists"); 
        pathtab.dump();
    }
    
    
    
    
    
    dir_rename_list.init_next_entry();
    
    while (dir_rename_list.get_next_entry(old_path, inode, eventinfo, new_path)) {
        
        
        std::set<ubigint64> hardlink_inodes;
        inodetab.collect_hardlink_inodes(inode, hardlink_inodes);

        
        std::set<ubigint64>::iterator itr(hardlink_inodes.begin());
        while (itr != hardlink_inodes.end()) {
            
            
            
            pathtab.update_paths(*itr, old_path, new_path);
            itr++;
        }
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing \"R\" events"); 
        pathtab.dump();
    }

    
    
    
    hl_ref_path_list.init_next_entry();
    
    while (hl_ref_path_list.get_next_entry(eventinfo, inode, new_path)) {
        
        
        pathtab.add_path_entry(inode, new_path, bbevent::event_subtype(eventinfo.get_subtype()));
        
        
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing reference path events"); 
        pathtab.dump();
    }

    
    
    dir_delete_list.init_next_entry();
    
    while (dir_delete_list.get_next_entry(eventinfo, inode, new_path)) {
        
        
        std::set<ubigint64> hardlink_inodes;
        inodetab.collect_hardlink_inodes(inode, hardlink_inodes);

        
        std::set<ubigint64>::iterator itr(hardlink_inodes.begin());
        while (itr != hardlink_inodes.end()) {
            
            
            pathtab.prune_subtree_paths(*itr, new_path);
            itr++;
        }
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing directory \"D\" events"); 
        pathtab.dump();
    }

    
    
    
    hl_delete_list.init_next_entry();
    
    while (hl_delete_list.get_next_entry(eventinfo, inode, new_path)) {
        
        
        pathtab.remove_path_entry(inode, new_path, bbevent::event_subtype(eventinfo.get_subtype()));
        
        
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing \"d\" events"); 
        pathtab.dump();
    }

    
    
    
    hl_create_list.init_next_entry();
    
    while (hl_create_list.get_next_entry(eventinfo, inode, new_path)) {
        
        
        pathtab.add_path_entry(inode, new_path, bbevent::event_subtype(eventinfo.get_subtype()));
        
        
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing \"c\" and \"C\" events"); 
        pathtab.dump();
    }

    
    
    
    hl_orphan_and_modified_list.init_next_entry();
    
    while (hl_orphan_and_modified_list.get_next_entry(eventinfo, inode, new_path)) {
        
        pathtab.set_modified(inode, bbevent::event_subtype(eventinfo.get_subtype()));
        
        
    }
    if (backstream_msg) {
        DB->msg("\n"); 
        DB->msg("backupboostutils::preprocess: Hardlink path table after processing \"O\" and \"M\" events"); 
        pathtab.dump();
    }


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    pathtab.init_next_modified_path();

    size_t link_count(0);
    
    while (pathtab.get_next_modified_path(inode, new_path, subtype, link_count)) {
        
        eventinfo.set_code(bbevent::event_code(bbevent::event_M));
        
        
        subtype &= ~bbevent::subtype_M;  
        eventinfo.set_subtype(bbevent::event_subtype(subtype));

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if (!eventinfo.is_lnk()) {
            eventinfo.set_kind(bbevent::node_reg);
        }
        eventinfo.set_hardlink((link_count > 1) ? true : false);

        
        
        bbeventlist.add_table_entry(new_path, inode, eventinfo, true );
    }

    
    return true;
}






const bool backupboostutils::prepare_incremental(utar_flags_info &vol_flags,
                                                 utar_commands &uc,
                                                 const BackupRootInfoList &backup_list,
                                                 BackupRootInfo &prev_backup,
                                                 target_session_result &prev_result,
                                                 inode_table &inodetab,
                                                 hardlink_path_table &pathtab)
{
    bool attempt_full = false;
    BackupRootInfo one_backup;
    ustring volume_name(ndmp_unentify_volume(vol_flags.ndmp_prefix));

    
    
    base_sequencenum = vol_flags.labelnum;

    if (base_sequencenum > 0) {
        
        BackupRootInfoList filtered_backup_list;
        if ((!uc.filter_backuplist(backup_list, "", "", base_sequencenum, SavesetId(""), filtered_backup_list)) ||
            (filtered_backup_list.size() != 1)) {
            
            Out->msg(ERR, "Manually specified backup with labelnum '%d' was not found in list of previous backups.", base_sequencenum);
            return false;

        } else if (!filtered_backup_list.get(one_backup, 0)) {
            
            Out->msg(ERR, "Unable to retrieve backup information for labelnum '%d'.", base_sequencenum);
            return false;
        }

        
        
        if (!validate_incremental_base(vol_flags, volume_name, uc, one_backup, prev_result)) {
            
            Out->msg(ERR, "Manually specified backup with labelnum '%d' is not suitable for backup.", base_sequencenum);
            return false;
        }

    } else {
        
        if (!select_incremental_base(vol_flags, volume_name, uc, backup_list, one_backup, prev_result)) {
            
            attempt_full = true;
        }
    }

    
    
    
    fileref raw_inode_table;
    
    raw_inode_table.initlist(10 * 1024);
    if (!attempt_full) {
        const ustring inode2hash_path = uc.get_sysinfo_path("backupboostutils::prepare_incremental", one_backup, true, vol_flags.ndmp_prefix) / INODE2HASH_TABLE_FILENAME;
        if (!uc.get_sysinfo_file(one_backup, raw_inode_table, upath(inode2hash_path))) {
            
            
            Out->msg(WARN, "Unable to find inode2hash for backup labelnum): %d.", base_sequencenum);
            attempt_full = true;

        } else {
            
            if (!inodetab.parse(raw_inode_table)) {
                
                
                Out->msg(WARN, "Unable to parse inode2hash table from backup labelnum): %d.", base_sequencenum);
                attempt_full = true;
            }
        }
    }

    if (!attempt_full) {
        fileref xml_image;
        
        xml_image.initlist(10 * 1024);
        const ustring hardlink2path_path = uc.get_sysinfo_path("backupboostutils::prepare_incremental", one_backup, true, vol_flags.ndmp_prefix) / HARDLINK_PATH_TABLE_FILENAME;
        if (!uc.get_sysinfo_file(one_backup, xml_image, upath(hardlink2path_path))) {
            
            
            Out->msg(WARN, "Unable to find hardlink2path for backup labelnum): %d.", base_sequencenum);
            attempt_full = true;

        } else {
            
            if (!pathtab.parse(xml_image)) {
                
                
                Out->msg(WARN, "Unable to parse hardlink2path table from backup labelnum): %d.", base_sequencenum);
                attempt_full = true;

            } else {
                
                DB->msg("backupboostutils::prepare_incremental: hardlink2path table contents from backup labelnum %d.", base_sequencenum);
                pathtab.dump();
            }
        }
    }

    if (attempt_full) {
        
        
        if (vol_flags.backupboostmode == utar_flags_enums::bb_synthetic_full_only) {
            
            Out->msg(ERR, "Full backups have been disabled, and no suitable base backup was found to generate a synthetic full for '%s'.",
                     *volume_name);
            return false;

        } else {
            Out->msg(INFO, "No suitable base backup was found to generate a synthetic full for '%s', performing a full backup instead.",
                     *volume_name);
            vol_flags.incremental = false;
            vol_flags.backupboostmode = utar_flags_enums::bb_force_level0_full;
        }

    } else {
        
        Out->msg(INFO, LOCTXT("Using backup with labelnum %d as the base for this incremental"), base_sequencenum);
        
        vol_flags.labelnum = base_sequencenum;
        
        prev_backup = one_backup;
    }

    return true;
}





const bool backupboostutils::select_incremental_base(const utar_flags_info &vol_flags,
                                                     const ustring &volume_name,
                                                     utar_commands &uc,
                                                     const BackupRootInfoList &backup_list,
                                                     BackupRootInfo &one_backup,
                                                     backupboost::target_session_result &prev_result)
{
    base_sequencenum = -1;

    
    for (size_t i = 0; i < backup_list.size(); i++) {
        
        if (!backup_list.get(one_backup, i)) {
            
            DB->msg("backupboostutils::select_incremental_base: Unable to retrieve backup information for index '%s'.", *tostr(i));
            return false;
        }

        if (validate_incremental_base(vol_flags, volume_name, uc, one_backup, prev_result)) {
            
            DB->msg("backupboostutils::select_incremental_base: Found valid base backup with labelnum '%d'.", base_sequencenum);
            return true;
        }
    }

    
    return false;
}





const bool backupboostutils::validate_incremental_base(const utar_flags_info &vol_flags,
                                                       const ustring &volume_name,
                                                       utar_commands &uc,
                                                       const BackupRootInfo &one_backup,
                                                       backupboost::target_session_result &prev_result)
{
    int labelnum(one_backup.getSavesetId().image().toint());

    target_work_results work_results;

    
    if (!uc.get_work_results(one_backup, work_results)) {
        DB->msg("backupboostutils::validate_incremental_base: Unable to retrieve workresults for labelnum=%d.", labelnum);
        return false;

    } else {
        
        
        if (!work_results.get_session_result(volume_name, prev_result)) {
            DB->msg("backupboostutils::validate_incremental_base: Unable to find '%s' in workresults for labelnum=%d.",
                    *volume_name, labelnum);
            return false;
        }
    }

    
    
    
    
    
    
    
    
    const ustring session_id_time_file(vol_flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILENAME);

#if !SYSTEM_WINDOWS
    const ustring lock_file(vol_flags.vardir / CLIENTLOGS_DIRECTORY / SESSION_ID_TIME_FILELOCK);
    processlock lock_obj(lock_file);

    
    
    
    const int max_tries(60);
    int tries(0);
    while (!lock_obj.checkandobtainlock()) {
        if (++tries > max_tries) {
            Out->msg(WARN, "Unable to get access to file '%s' for mapping "
                           "session IDs to session times of mount '%s'",
                           *session_id_time_file, *volume_name);
        }
        Out->msg(INFO, "File '%s' for mapping session IDs to session times of mount '%s' is "
                       "locked, waiting for release with '%d' tries remaining.",
                       *session_id_time_file, *volume_name, max_tries - tries);
        uapp::sleep(1000);
    }
#endif

    
    
    if (!uc.getHfsInfoStruct().main->session_id_time_table.parse(session_id_time_file))
        Out->msg(WARN, "Unable to parse file '%s' for mapping session IDs to session times", *session_id_time_file);

    
    
    const upath mount_path(volume_name);
    ubigint64 session_time(0);
    if (!uc.getHfsInfoStruct().main->session_id_time_table.get_session_time(mount_path,
                                                                            prev_result.session_id,
                                                                            session_time)) {
        Out->msg(INFO, "BackupBoost validate incremental base unable to get session time "
                "for session id: %s of target: %s",
                *tostr(prev_result.session_id), *volume_name);
        return false;
    }

    if (session_time != prev_result.backup_time) {
        Out->msg(INFO, "Backupup time from Avamar workresults.xml does not match the time from "
                       "BackupBoost journal for labelnum: %d of target: %s",
                       labelnum, *volume_name);
        return false;
    }

    
    base_sequencenum = labelnum;
    return true;
}







const bool path2event_table::add_table_entry(const upath& path, const ubigint64 inode,
                                             const bbevent& eventinfo,
                                             const bool add_dir_elements )
{
    const int elem_count(path.numelems());
    path2event_table_itr entry = event_table.begin();

    if (add_dir_elements && (elem_count > 1)) {
        
        
        
        
        
        
        
        const int dir_elem_count(elem_count-1);
        int path_elem_index(0);
        bool found_missing_elem(false);

        
        upath test_path(path.slice(0,path_elem_index));

        
        
        
        
        
        while (!found_missing_elem && (path_elem_index < dir_elem_count)) {
            entry = event_table.find(test_path);
            if (entry == event_table.end()) {
                
                
                
                found_missing_elem = true;

            } else {
                
                path_elem_index++;
                
                
                if (path_elem_index < dir_elem_count) {
                    test_path += upath(path.get(path_elem_index));
                }
            }
        }

        if (found_missing_elem) {
            
            if (backstream_msg) DB->msg("path2event_table::add_table_entry: Adding missing path elments for '%s', starting with '%s'",
                                        *path.image(), *test_path.image());

            
            
            while (path_elem_index < dir_elem_count) {
                
                
                bbevent dummy_event;
                dummy_event.set_code(bbevent::event_code(bbevent::event_b));
                dummy_event.set_kind(bbevent::node_kind(bbevent::node_dir));
                dummy_event.set_hardlink(false);  
                const ubigint64 dummy_inode(0);
                event_list_entry dummy_entry(dummy_event, dummy_inode);
                event_entry_list_t dummy_list;
                dummy_list.push_back(dummy_entry);
                entry = event_table.insert(entry, std::make_pair(test_path, dummy_list));

                if (entry == event_table.end()) {
                    
                    
                    return false;
                }

                path_elem_index++;
                
                
                if (path_elem_index < dir_elem_count) {
                    test_path += upath(path.get(path_elem_index));
                }
            }
        }
    }

    
    event_list_entry new_entry(eventinfo, inode);

    entry = event_table.find(path);
    if (entry == event_table.end()) {
        
        
        event_entry_list_t event_list;
        entry = event_table.insert(entry, std::make_pair(path, event_list));  

        if (entry == event_table.end()) {
            
            
            return false;
        }

    } else if (backstream_msg) {
        
        
        DB->msg("path2event_table::add_table_entry: Path '%s' already exists in table (inode:%s, event:%s).  Adding new entry (inode:%s, event:%s).",
                *path.image(), *tostr(entry->second[0].inode),
                *bbevent::image(bbevent::event_code(entry->second[0].event_info.get_code())),
                *tostr(inode), *bbevent::image(bbevent::event_code(eventinfo.get_code())));
    }

    
    entry->second.push_back(new_entry);

    return true;
}



void path2event_table::remove_table_entry(const upath path)
{
    path2event_table_itr entry = event_table.find(path);
    if (entry == event_table.end()) {
        
        DB->msg("path2event_table::remove_table_entry: No entry in table for path '%s'", *path.image());

    } else {
        event_table.erase(entry);
    }
}



void  path2event_table::dump() const
{
    DB->msg(">>>>> DUMPING CONTENTS OF PATH-TO-EVENT TABLE (%s Entries) <<<<<", *tostr(event_table.size()));
    DB->msg("  'event code' : 'kind' : 'inode' : 'hardlink' : 'path'");
    for (const_path2event_table_itr entry = event_table.begin(); entry != event_table.end(); entry++) {
        for (size_t list_index = 0; list_index != entry->second.size(); list_index++) {
            bbevent event_info(entry->second[list_index].event_info);
            DB->msg("  '%s' : '%s' : '%s' : '%s' : '%s'",
                    *bbevent::image(bbevent::event_code(event_info.get_code())),
                    *bbevent::image(bbevent::node_kind(event_info.get_kind())),
                    *tostr(entry->second[list_index].inode),
                    entry->second[list_index].is_hardlink() ? "HL" : "",
                    *entry->first.image());
        }
    }
}





const bool path2event_table::get_next_entry(event_list_entry &event, upath &path)
{
    if (current_table_itr == event_table.end()) {
        
        return false;

    } else {
        path = current_table_itr->first;
        event = current_table_itr->second[current_list_index];

        
        
        
        current_list_index++;
        if (current_list_index == current_table_itr->second.size()) {
            
            
            current_table_itr++;
            current_list_index = 0;
        }
        return true;
    }
}



void  hardlink_event_list::dump(ustring &list_name) const
{
    DB->msg(">>>>> DUMPING CONTENTS OF %s EVENT LIST (%s Entries) <<<<<", *list_name, *tostr(event_list.size()));
    DB->msg("  'event code' : 'inode' : 'path'");
    for (size_t i = 0; i != event_list.size(); i++) {
        DB->msg("  '%s' : '%s' : '%s'",
                *bbevent::image(bbevent::event_code(event_list[i].event_info.get_code())),
                *tostr(event_list[i].inode),
                *event_list[i].path.image());
    }
}





const bool hardlink_event_list::get_next_entry(bbevent &eventinfo, ubigint64 &inode, upath &path)
{
    if (current_list_itr == event_list.end()) {
        
        return false;

    } else {
        eventinfo = current_list_itr->event_info;
        inode = current_list_itr->inode;
        path = current_list_itr->path;
        current_list_itr++;
        return true;
    }
}



const bool directory_rename_list::add_list_entry(const upath& key_path, const ubigint64 inode,
                                                 const bbevent &eventinfo, const upath &new_path)
{
    dir_rename_list_itr entry = rename_list.find(key_path);
    if (entry != rename_list.end()) {
        
        DB->msg("directory_rename_list::add_list_entry: Path '%s' alrady exists in table.", *key_path.image());
    } else {
        
        hl_event_list_entry new_entry(eventinfo, inode, new_path);
        entry = rename_list.insert(entry, std::make_pair(key_path, new_entry));  

        if (entry == rename_list.end()) {
            
            
            return false;
        }
    }
    return true;
}



void  directory_rename_list::dump() const
{
    DB->msg(">>>>> DUMPING CONTENTS OF DIRECTORY RENAME LIST (%s Entries) <<<<<", *tostr(rename_list.size()));
    DB->msg("  'event code' : 'inode' : 'old path' : 'new path'");
    for (const_dir_rename_list_itr entry = rename_list.begin(); entry != rename_list.end(); entry++) {
        DB->msg("  '%s' : '%s' : '%s' : '%s'",
                *bbevent::image(bbevent::event_code(entry->second.event_info.get_code())),
                *tostr(entry->second.inode), *entry->first.image(), *entry->second.path.image());
    }
}






const bool directory_rename_list::get_next_entry(upath &old_path, ubigint64 &inode,
                                                 bbevent &eventinfo, upath &new_path)
{
    if (current_list_itr == rename_list.begin()) {
        
        return false;

    } else {
        
        current_list_itr--;

        old_path = current_list_itr->first;
        inode = current_list_itr->second.inode;
        eventinfo = current_list_itr->second.event_info;
        new_path = current_list_itr->second.path;
        return true;
    }
}


backupboost_parser::backupboost_parser(const ustring& streamdesc,
                         const int stream_timeoutsecs,
                         const ustring& input_tee_streamdesc 
) :
    fd(myopen_streamdesc(streamdesc, -1, stream_timeoutsecs)),
    fd_is_socket(uwrapper::is_socket_streamdesc(streamdesc)),
    fd_input_tee(uwrapper::open_streamdesc(input_tee_streamdesc, true, stream_timeoutsecs)),
    fd_stream(NULL),
    current_line(""),
    line_count(0),
    byte_count(0)
{
    if (backstream_msg) DB->msg("backupboost_parser::backupboost_parser fd=%d", fd);
    if (fd >= 0) {
        fd_stream = fdopen(fd, "r");
    }
}


#if SYSTEM_WINDOWS
  #define CLOSESOCKET(x) ::closesocket(x)
#else
  #define CLOSESOCKET(x) ::close(x)
#endif

backupboost_parser::~backupboost_parser()
{
    Out->msg(INFO, "Stream complete: %s events (%s bytes) read from stream", *tostr(line_count), *tostr(byte_count));
    int res = 0;
    if (fd_stream != NULL) {
        res = fclose(fd_stream);
        DB->msg("backupboost_parser::~backupboost_parser fclose(fd:%d) returned %d", fd, res);
    } else {
        if (!fd_is_socket) {
            res = close(fd);
        } else {
            res = CLOSESOCKET(fd);
        }
        if (res == 0) {
            DB->msg("backupboost_parser::~backupboost_parser close(fd:%d) returned %d", fd, res);
        } else {
            DB->msg("backupboost_parser::~backupboost_parser close(fd:%d) returned %d: %s",
                    fd, res, *platerror().description());
        }
    }

    if (fd_input_tee > 0) {
            DB->msg( "backupboost_parser::~backupboost_parser  close(fd_input_tee=%d)", fd_input_tee );
        close(fd_input_tee);
    }
}




const bool backupboost_parser::getentry(bbevent& eventinfo, ubigint64& inode, upath& path_1, upath& path_2)
{
    if (!readdata()) {
        
        if (backstream_msg) DB->msg("backupboost_parser::getentry: No more data to read.");
        return false;
    }

    
    
    
    
    stringlist fields(current_line.split(BB_DELIMITER));
    const size_t field_count(fields.size());
    if (field_count < 4 || field_count > 6) {
        
        
        
        DB->msg("backupboost_parser::getentry: Wrong number of fields. Input line: '%s'", *current_line);
        return false;
    } else {
        
    }

    
    
    if (fields.size() > 3) {
        
        if (fields[3] == HL_FLAG) {
            eventinfo.set_hardlink(true);
        } else if (fields[3] != "") {
            
            DB->msg("backupboost_parser::getentry: Unexpected HL field value: '%s'", *fields[3]);
        }
    }

    
    
    
    char type_field(fields[0].byteindex(0));
    

    
    
    int valid_subtype_mask(bbevent::subtype_none);

    
    
    switch (type_field) {
    case 'B': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_B));
        valid_subtype_mask = bbevent::subtype_AX;
        break;
    }
    case 'E': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_E));
        valid_subtype_mask = bbevent::subtype_none;
        break;
    }
    case 'D': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_D));
        valid_subtype_mask = bbevent::subtype_none;
        break;
    }
    case 'C': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_C));
        valid_subtype_mask = bbevent::subtype_none;
        break;
    }
    case 'r': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_r));
        valid_subtype_mask = bbevent::subtype_AX;
        break;
    }
    case 'R': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_R));
        valid_subtype_mask = bbevent::subtype_AX;
        break;
    }
    case 'd': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_d));
        if (eventinfo.is_hardlink()) {
            
            valid_subtype_mask = bbevent::subtype_MAX;
        } else {
            valid_subtype_mask = bbevent::subtype_none;
        }
        break;
    }
    case 'c': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_c));
        
        
        
        valid_subtype_mask = bbevent::subtype_MAX;
        break;
    }
    case 'M': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_M));
        valid_subtype_mask = bbevent::subtype_AX;
        break;
    }
    case 'O': {  
        eventinfo.set_type(bbevent::event_type(bbevent::type_O));
        valid_subtype_mask = bbevent::subtype_MAX;
        
        
        if (!eventinfo.is_hardlink()) {
            eventinfo.set_hardlink(true);
            DB->msg("backupboost_parser::getentry: HL field (value: '%s') should have indicated a hardlink", *fields[3]);
        }
        break;
    }
    default:  {
        
        Out->Abort("Invalid event code ('%s')' in journal listing", *fields[0]);
        return false;
    }
    }

    
    
    int subtype(bbevent::subtype_none);
    
    
    
    int count(fields[0].length_in_chars());
    for (int i = 1; i < count; i++) {
        char subtype_field(fields[0].byteindex(i));
        switch (subtype_field) {
        case 'M': {  
            subtype |= bbevent::subtype_M;
            break;
        }
        case 'A': {  
            subtype |= bbevent::subtype_A;
            break;
        }
        case 'X': {  
            subtype |= bbevent::subtype_X;
            break;
        }
        default:  {
            
            Out->Abort("Invalid event code ('%s')' in journal listing", *fields[0]);
            return false;
        }
        }
    }
    
    
    
    if (subtype == (subtype & valid_subtype_mask)) {  
        
        eventinfo.set_subtype(bbevent::event_subtype(subtype));
    } else {
        
        Out->Abort("Invalid event code ('%s')' in journal listing", *fields[0]);
        return false;
    }

    
    
    if (fields[1] == NODE_REG)         {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_reg));
    } else if (fields[1] == NODE_DIR)  {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_dir));
    } else if (fields[1] == NODE_LNK)  {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_lnk));
    } else if (fields[1] == NODE_BDEV) {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_bdev));
    } else if (fields[1] == NODE_CDEV) {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_cdev));
    } else if (fields[1] == NODE_SOC)  {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_soc));
    } else if (fields[1] == NODE_FIFO) {  
        eventinfo.set_kind(bbevent::node_kind(bbevent::node_fifo));
    } else {
        
        Out->Abort("Invalid node kind ('%s')' in journal listing", *fields[1]);
        return false;
    }
    
    
    if ((eventinfo.is_reg() && !eventinfo.is_valid_reg_type()) ||
        (eventinfo.is_dir() && !eventinfo.is_valid_dir_type()) ||
        (eventinfo.is_lnk() && !eventinfo.is_valid_lnk_type())) {
        Out->Abort("'%s' is not a valid event type for kind '%s' in journal listing",
                   *bbevent::image(bbevent::event_type(eventinfo.get_type())),
                   *bbevent::image(bbevent::node_kind(eventinfo.get_kind())));
        return false;
    }

    
    
    if (fields[2].isnumericstring()) {
        inode = fields[2].touint64();
    } else {
        Out->Abort("Invalid inode number ('%s')' in journal listing", *fields[2]);
        return false;
    }

    
    if (field_count > 4) {
        
        path_1 = upath(fields[4]);
    }

    
    if (field_count == 6) {
        
        path_2 = upath(fields[5]);
    }

    return true;
}





const bool backupboost_parser::readdata()
{
    if (fd_stream == NULL) {
        Out->msg(INFO, "No input stream to read");
        return false;
    }

    char buf[2048];
    char *s(NULL);

    current_line = "";  

    
    
    bool found_eol(false);
    while (!found_eol) {
        if(fgets(buf, sizeof(buf), fd_stream) == NULL) {
            
            return (current_line != "");
        }

        size_t buf_len = strlen(buf);
        if (buf_len > 0) {
            
            if( fd_input_tee > 0 ) { 
                bigint64 writesize = ::write(fd_input_tee, buf, (int)buf_len);
                DB->msg( "backupboost_parser::readdata ::write(fd_input_tee( %d, , '%s' )='%s'", fd_input_tee, *tostr(buf_len), *tostr(writesize));
            }

            byte_count += buf_len;
            s = buf;
            if (current_line == "") {
                
                
                while(*s == ' ' || *s == '\t')
                    s++;
            }

            
            if ((buf_len > 0) && (buf[buf_len-1] == '\n')) {
                found_eol = true;
                
                buf[buf_len-1] = '\0';
            }

            
            current_line += s;
        }
        if (current_line == "") {
            
            
            found_eol = false;
        }
    }
    line_count++;

    
    
    
    
    
    
    if ((current_line.first() == 'A') ||
        (current_line.first() == 'X')) {
        if (backstream_msg) DB->msg("backupboost_parser::readdata: Pre-pending \"M\" to event code in event '%s'", *current_line);
        current_line = (ustring)"M" + current_line;
    }
    return true;
}



#if SYSTEM_WINDOWS
    #include "tchar.h"    
    #define TOPENFUN _topen
    #define OPENMOD (_O_RDONLY | _O_BINARY)
#else
    #define TOPENFUN open
    #define OPENMOD O_RDONLY
#endif





const int backupboost_parser::myopen_streamdesc(const ustring& streamdesc, const int streamfd, const int stream_timeoutsecs) const
{
    int ret(0);

    
    if (!streamdesc.isempty()) {
        
        ustring pipedesc(streamdesc);

        
        ret = uwrapper::open_streamdesc(pipedesc, false, stream_timeoutsecs);
        if (ret < 0) {
            
            ret = TOPENFUN(*upath(pipedesc).patht("open"), OPENMOD);
        }
        if (ret < 0) {
            Out->msg(ERR, "<6977>Could not open input stream '%s'", *pipedesc);
        }
    } else {
        
        
        if(streamfd >= 0) {
            ret = streamfd;
        }
    }

    return ret;
}


const int DEFAULT_WORK_RESULTS_VERSION = 1;

target_work_results::target_work_results()
    : work_results_mtex(false),
      ddr_index(0),
      version(DEFAULT_WORK_RESULTS_VERSION)
{
}

target_work_results::~target_work_results()
{
    results.clear();
}

bool target_work_results::parse(const ustring& work_results_string)
{
    return parse(new xml_message(work_results_string, true));
}

bool target_work_results::parse(const xml_messagep& work_results_xml)
{
    if (!work_results_xml->getcommand().equal("work_results")) {
        DB->msg("target_work_results::parse() xml does not contain the 'work_results' keyword");
        return false;
    }

    version = work_results_xml->getint("version");
    
    if (version != DEFAULT_WORK_RESULTS_VERSION) {
        DB->msg("target_work_results::parse() unsupported workresults version format: %d", version);
        return false;
    }

    ddr_index = work_results_xml->getint("ddr_index");
    avtar_version = work_results_xml->getstring("avtar_version");

    
    results.clear();
    for (size_t i = 0; i < work_results_xml->children.size(); i++) {
        xml_messagep backup(work_results_xml->children[i]);
        target_session_result result;
        result.target = backup->getstring("target");
        result.backup_mode = backup->getstring("backup_mode");
        result.session_id = backup->getint("session_id");
        result.backup_time = backup->getint("backup_time");
        result.exit_code = backup->getint("exit_code");
        results.push_back(result);
    }

    return true;
}

xml_messagep target_work_results::to_xml() const
{
    xml_messagep work_results = new xml_message("work_results");
    work_results->enter("ddr_index", ddr_index);
    work_results->enter("avtar_version", avtar_version);
    work_results->enter("version", version);

    
    
    for (session_results::const_iterator it = results.begin(); it != results.end(); it++) {
        const target_session_result result(*it);
        xml_messagep backup = new xml_message("backup");
        backup->enter("target", result.target);
        backup->enter("backup_mode", result.backup_mode);
        backup->enter("session_id", result.session_id);
        backup->enter("backup_time", result.backup_time);
        backup->enter("exit_code", result.exit_code);
        work_results->children.push_back(backup);
    }
    return work_results;
}

ustring target_work_results::image() const
{
    return to_xml()->simage();
}

bool target_work_results::is_empty() const
{
    return results.empty();
}

void target_work_results::set_avtar_version(const ustring& avtar_version_)
{
    scope s(work_results_mtex);
    avtar_version = avtar_version_;
}

void target_work_results::set_ddr_index(int ddr_index_)
{
    scope s(work_results_mtex);
    ddr_index = ddr_index_;
}

void target_work_results::set_version(int version_)
{
    scope s(work_results_mtex);
    version = version_;
}

ustring target_work_results::get_avtar_version() const
{
    return avtar_version;
}

int target_work_results::get_ddr_index() const
{
    return ddr_index;
}

int target_work_results::get_version() const
{
    return version;
}

void target_work_results::add_result(const target_session_result& session_result)
{
    scope s(work_results_mtex);
    results.push_back(session_result);
}

int target_work_results::get_final_exitcode() const
{
    int exit_code = EXIT_OK;
    for (results_iterator it = results.begin(); it != results.end(); it++) {
        const target_session_result result(*it);
        DB->msg("Backup results for target '%s': avtar returned: '%s' (%d)",
                result.target.tostr(),
                *ExitCode::getExitDescription((exitcodes_t)result.exit_code),
                result.exit_code);
        if (result.exit_code != EXIT_OK) {
            exit_code = result.exit_code;
            break;
        }
    }
    return exit_code;
}

bool target_work_results::get_session_result(const ustring& target, target_session_result& session_result) const
{
    for (size_t i = 0; i < results.size(); i++) {
        const target_session_result result(results[i]);
        upath result_target(result.target);
        upath backup_target(target);
        if (result_target.compare(backup_target)) {
            session_result = result;
            return true;
        }
    }
    return false;
}

void target_work_results::list_backups(stringlist& backup_list) const
{
    backup_list.clear();
    for (session_results::const_iterator it = results.begin(); it != results.end(); it++) {
        const target_session_result result(*it);
        if (!result.target.isempty()) {
            bool already_added(false);
            for (int i = 0; i < backup_list.size(); i++) {
                if (backup_list[i].equal(result.target)) {
                    already_added = true;
                    break;
                }
            }
            if (!already_added) {
                backup_list.push_back(result.target);
            }
        }
    }
}



















bool journal_session_id_time_t::parse(const ustring& in_file)
{
    ustring err_msg;
    xml_messagep session_id_time_xmlp(xml_message::read_xmlfile(in_file, err_msg));
    if (session_id_time_xmlp.isnull())
        return false;

    if (!session_id_time_xmlp->getcommand().equal("session_id_time_list"))
        return false;

    session_id_time_map.clear();

    xml_messagev target_list(session_id_time_xmlp->getchildlist("target_entry"));
    for (size_t i = 0; i < target_list.size(); i++) {
        xml_messagep target_entry(target_list[i]);
        const upath target(target_entry->getstring("target"));
        xml_messagev session_id_time_list(target_entry->getchildlist("session_id_time_entry"));

        for (size_t j = 0; j < session_id_time_list.size(); j++) {
            xml_messagep session_id_time_entry(session_id_time_list[j]);
            const ustring session_id_str(session_id_time_entry->getstring("session_id"));
            const ustring session_time_str(session_id_time_entry->getstring("session_time"));
            add_session_entry(target, session_id_str.touint64(), session_time_str.touint64());
        }
    }
    return true;
}



bool journal_session_id_time_t::image(const ustring& out_file) const
{
    FILE* file = fopen(*out_file, "w");
    if (!file)
        return false;

    xml_messagep session_id_time_xml = new xml_message("session_id_time_list");
    session_id_time_map_citr_t session_id_time_map_citr = session_id_time_map.begin();
    for (; session_id_time_map_citr != session_id_time_map.end(); session_id_time_map_citr++) {
        const upath target(session_id_time_map_citr->first);
        xml_messagep target_entry = new xml_message("target_entry");
        target_entry->enter("target", target.image());

        session_id_time_list_citr_t session_id_time_list_citr = session_id_time_map_citr->second.begin();
        for (; session_id_time_list_citr != session_id_time_map_citr->second.end(); session_id_time_list_citr++) {
            xml_messagep session_id_time_entry = new xml_message("session_id_time_entry");
            session_id_time_entry->enter("session_id", session_id_time_list_citr->first);
            session_id_time_entry->enter("session_time", session_id_time_list_citr->second);
            target_entry->children.push_back(session_id_time_entry);
        }
        session_id_time_xml->children.push_back(target_entry);
    }
    fprintf(file, "%s", *session_id_time_xml->simage());
    fclose(file);
    return true;
}


void journal_session_id_time_t::add_session_entry(const upath &key_path, ubigint64 session_id, ubigint64 session_time)
{
    session_id_time_map_itr_t search_it = session_id_time_map.find(key_path);
    if (search_it != session_id_time_map.end()) {
        search_it->second.push_back(std::make_pair(session_id, session_time));
    } else {
        session_id_time_list_t session_id_time_list;
        session_id_time_list.push_back(std::make_pair(session_id, session_time));
        session_id_time_map.insert(std::make_pair(key_path, session_id_time_list));
    }
}


bool journal_session_id_time_t::get_session_entry(const upath &key_path, const ubigint64 search_time, ubigint64& session_id) const
{
    int index = get_latest_session_index(key_path, search_time);
    if (index < 0)
        return false;
    session_id_time_map_citr_t search_it(session_id_time_map.find(key_path));
    const session_id_time_list_t& session_id_time_list(search_it->second);
    session_id = session_id_time_list[index].first;
    return true;
}


bool journal_session_id_time_t::get_session_time(const upath& key_path, const ubigint64 session_id, ubigint64& session_time) const
{
    session_id_time_map_citr_t search_it(session_id_time_map.find(key_path));
    if (search_it == session_id_time_map.end())
        return false;

    const session_id_time_list_t& session_id_time_list(search_it->second);
    for (int i = 0; i < (int)session_id_time_list.size(); i++) {
        const session_id_time_entry_t& session_id_time_entry(session_id_time_list[i]);
        if (session_id == session_id_time_entry.first) {
            session_time = session_id_time_entry.second;
            return true;
        }
    }

    return false;
}


bool journal_session_id_time_t::remove_session_entries(const upath &key_path, const ubigint64 search_time)
{
    int index = get_latest_session_index(key_path, search_time);
    if (index < 0)
        return false;

    session_id_time_map_itr_t search_it(session_id_time_map.find(key_path));
    session_id_time_list_t& session_id_time_list(search_it->second);
    session_id_time_list_itr_t start(session_id_time_list.begin());
    session_id_time_list_itr_t end(start + index + 1);
    session_id_time_list.erase(start, end);

    if (session_id_time_list.empty())
        session_id_time_map.erase(key_path);

    return true;
}


int journal_session_id_time_t::get_latest_session_index(const upath& key_path, const ubigint64 search_time) const
{
    int index = -1;
    session_id_time_map_citr_t search_it = session_id_time_map.find(key_path);
    if (search_it == session_id_time_map.end())
        return index;

    const session_id_time_list_t& session_id_time_list(search_it->second);
    for (int i = 0; i < (int)session_id_time_list.size(); i++) {
        const session_id_time_entry_t& session_id_time_entry(session_id_time_list[i]);
        if (search_time >= session_id_time_entry.second)
            index = i;
        else
            break;
    }
    return index;
}


void journal_session_id_time_t::remove_target_entry(const upath& key_path)
{
    session_id_time_map.erase(key_path);
}



















#include "common.h"
#include "debug.h"
#include "backstate.h"
#include "runstage.h"
#include "utar_flags_info.h"
#include "filenames.h"
#include "output.h"
#include "dirwalk.h"

#if SYSTEM_WINDOWS
#include "ntsecurity.h"
#include "uwstring.h"
#include <string>
#include "vhdinfo.h"
#include "wservice.h"
#include "subscript.h"
#include "file_system_info.h"
#define sis_feature_enabled ((xflag[22]&262144)==0)
#endif

#define WILDCHAR '*'
#define skipwildcardexpand     ((xflag[21]&8) != 0)
#define skipreplacevars        ((xflag[21]&32768) != 0)

#define USERDOCVAR "#USERDOCS#"

#if SYSTEM_WINDOWS
    
    static upath makePath(const ustring& path);

    
    static int AddToExcludes(const backstate::GetLongPathNamefp getlongpathnamefp, const ustring& keyName, const ustring& keyVal, exclude& excludes);
#endif

backstate::backstate(stringlist args, bool validate_includes, const int grouptype, bool warn_on_missing_target,
                     const stringlist *pathmap, bool fakeprogress) :
    numthreads(0),
    hfs_send_depth(0),
    sessionid(0),
    targets(grouptype),
    excludes(true),
    includes(false),
    cache_excludes(true),
    ddr_blocks(true),
    stream_out_excludes(true),
    hashes(NULL),
    fcache(NULL),
    snaptype(FILESYSTEM),       
    pid_of_backup(pidtype::none),
    needs_direlem_init(true),
    valid(false)
{
    const stringlist processed_paths = replace_vars(args);
    const stringlist paths = backstate::expand_paths(processed_paths);
    valid = targets.init(paths, validate_includes, pathmap, warn_on_missing_target, !fakeprogress);
    if(!valid) Out->msg(ERR, "<8012>Error in path list: %s.  Correct path list before retrying.", *targets.errmsg);
}


exitcodes_t backstate::enter_exclude_include_lists(utar_flags_info& flags, bool ignoredefaultexcludes, bool isbackup) {

  
    
    if (!ignoredefaultexcludes) {
        if (!enter_default_excludes(flags)) {
            Out->msg(FATAL, "<5218>Unable to enter default exclude list");
            return EXIT_EXCLUDELIST;
        }
    }

    
    if (!excludes.parse_file(flags.excludelist_file)) {
        Out->msg(FATAL, "<5439>Unable to enter exclude list");
        return EXIT_EXCLUDELIST;
    }

    if (!flags.excludelist.isempty()) {
        for (int i=0; i < flags.excludelist.size(); i++) {
            if(targets.includelist().isempty() || check_valid_path(targets.includelist(), flags.excludelist[i]))  
                excludes.enter_single(flags.excludelist[i], exclude::user);                        
            else {
                DB->msg(DBTXT("Exclude pattern \"%s\" ignored because it does not match any backup paths"), *flags.excludelist[i]);
                if (isbackup) Out->msg(WARN, "<8456>Exclude pattern \"%s\" is superfluous because it does not match any backup paths; ignored.", *flags.excludelist[i]);
                flags.excludelist[i] = "";      
            }
	}
    }

    
    if (!flags.stream_out_excludes.isempty()) {
        for (int i=0; i < flags.stream_out_excludes.size(); i++) {
#if SYSTEM_WINDOWS
            const ustring pattern(flags.stream_out_excludes[i].strip(ustring::STRIP_LEADING, DIRSEP));
#else
            const ustring pattern(flags.stream_out_excludes[i]);
#endif
            stream_out_excludes.enter_single(pattern, exclude::streamout);
	}
    }

#if SYSTEM_WINDOWS
    
    
    
    if (flags.extract && flags.restoreatreboot && flags.onlinefsrestore &&
        (win_os_version_info::is_windows_Vista_or_newer())) {

        
        ustring windows_dir = subscript::expand_environment_strings(WINDOWS_DIRECTORY);

        
        ustring windows_config_dir = windows_dir + WINDOWS_CONFIG_DIRECTORY;

        Out->msg(INFO, "Windows system config directory \"%s\" will be excluded from restore", *windows_config_dir);
        excludes.enter_single(windows_config_dir, exclude::user);

        
        ustring windows_servicing_dir = windows_dir + WINDOWS_SERVICING_DIRECTORY;

        Out->msg(INFO, "Windows servicing directory \"%s\" will be excluded from restore", *windows_servicing_dir);
        excludes.enter_single(windows_servicing_dir, exclude::user);
    }

    
    
    
    if (((snaptype == FILESYSTEM) || (snaptype == VSS)) &&
        (flags.exclude_csv) &&   
        (win_os_version_info::is_windows_7_or_newer())) {

        
        if ((!flags.extract) && (!flags.list)) { 
            
            
            
            
            ustring csvpath;
            if (win_os_version_info::is_server() &&
               wservice::is_csv_service_installed(csvpath)) {
                
                
                file_system_info::set_csv_mount(csvpath);

                
                
                
                
                if ((((flags.args).size()) == 1) && (csvpath.equal(targets.root))) {
                    Out->msg(ERR, "<8628>Cluster Shared Volumes installed on the system, Backup of just ClusterStorage path %s is not allowed",
                    *csvpath);
                    
                    return EXIT_MISC;
                } else {
                     Out->msg(WARN, "<8629>Cluster Shared Volumes installed on the system, ClusterStorage path %s will be excluded from backup",
                     *csvpath);

                    excludes.enter_single(csvpath, exclude::user);
                }
            } else
                DB->msg("Cluster Shared Volumes NOT installed on the system");
        }

        
        
        int status(enter_vhd_excludes(flags));
        if (status != 0) {
            DB->msg("Cannot create exclude pattern for Virtual Hard Disk files");
        }
    }
#endif

    
    
    
    if (!includes.parse_file(flags.includelist_file)) {
        Out->msg(FATAL, "<5248>Unable to enter include list");
        return EXIT_INCLUDELIST;
    }

    if (!flags.includelist.isempty()) {
        for (int i=0; i < flags.includelist.size(); i++) {
            if((!isbackup) || check_valid_path(flags.excludelist, flags.includelist[i]))
                includes.enter_single(flags.includelist[i], exclude::user);
            else
                Out->msg(WARN, "<8457>Include pattern \"%s\" is superfluous because it does not match any exclude patterns; ignored.",
                         *flags.includelist[i]);
        }
    }

#if SYSTEM_WINDOWS
    
    if (flags.create && win_os_version_info::is_server_2012_or_newer()) {
        
        if (!flags.windowsOptimizedBackup) {
            excludes.enter_single("System Volume Information\\Dedup\\*", exclude::system);
        }
        else {
            
            
            
            includes.enter_single("System Volume Information\\Dedup\\ChunkStore\\*", exclude::system);
            includes.enter_single("System Volume Information\\Dedup\\Settings\\*", exclude::system);
            excludes.enter_single("System Volume Information\\Dedup\\State\\*", exclude::system);
            excludes.enter_single("System Volume Information\\Dedup\\Logs\\*", exclude::system);
        }
        
        excludes.enter_single("System Volume Information\\ResumeKeyFilter.Store", exclude::system);
    }
#endif

    
    if (!ddr_blocks.parse_file(flags.ddr_blocklist_file)) {
        Out->msg(FATAL, "<9910>Unable to enter ddr block list");
        return EXIT_DDRBLOCKLIST;
    }
    if(!flags.ddr_blocklist.isempty()) {
        for(int i = 0; i <flags.ddr_blocklist.size(); i++) {
#if SYSTEM_WINDOWS
            ddr_blocks.enter_single(flags.ddr_blocklist[i].strip(ustring::STRIP_LEADING, DIRSEP), exclude::user); 
#else
            ddr_blocks.enter_single(flags.ddr_blocklist[i], exclude::user);                                       
#endif
        }
    }

    excludes.print_totals();
    includes.print_totals();
    return EXIT_OK;
}


exitcodes_t backstate::enter_targets_exclude_include_lists(utar_flags_info& flags, bool ignoredefaultexcludes) {

  
    
    if (!targets.valid) {
        Out->msg(ERR, "<5306>Invalid backup list: %s", *targets.errmsg);
        targets.dump();
        return EXIT_TARGETLIST;
    }
    DB->msg(DBTXT("roots to back up:"));
    targets.dump();

    return enter_exclude_include_lists(flags, ignoredefaultexcludes);
}

#if SYSTEM_WINDOWS

int backstate::enter_vhd_excludes(utar_flags_info& flags) {

    
    std::vector<vhdnode *> vhdnodes;
    int ret = vhdinfo::get_vhd_dependency_info(vhdnodes);
    if (ret != 0) {
        Out->msg(INFO, "<8630>Cannot get Storage Dependency for Virtual Hard Disks on the system, ret=%d", ret);
        return ret;
    }

    if (!vhdnodes.empty()) {

        
        stringlist targetlist(targets.includelist());

        
        for (std::vector<vhdnode *>::iterator itor = vhdnodes.begin();
            itor != vhdnodes.end();
            itor++) {

            
            ustring vhdpath = (*itor)->getvhdpath();
            ustring depvolume = (*itor)->getdependentvolume();

            
            
            if ((targetlist.size() == 1) && (vhdinfo::is_vhd_file(targets.root))) {
                
                bool mounted_vhd_file = false;

                
                
                if (flags.extract && (vhdpath.stdseparators() == targets.root)) 
                    mounted_vhd_file = true;
                else if (!flags.extract && (vhdpath == targets.root)) 
                    mounted_vhd_file = true;

                if (mounted_vhd_file) {
                    Out->msg(ERR, "<8631>Target path %s is attached to the system as %s. Please detach it.",
                                        *vhdpath, *depvolume);
                    
                    return EXIT_MISC;
                }
            } else {
                Out->msg(INFO, "<8632>Discovered Natively attached Virtual Hard Disk %s for the file system path %s",
                                                *depvolume, *vhdpath);
                excludes.enter_single(vhdpath, exclude::user);

                
                if (!flags.backup_mounted_vhds) {
                    Out->msg(INFO, "<8633>Backup Natively Attached Virtual Hard Disks option is OFF. Backup will skip mounted VHD volume %s",
                                    *depvolume);
                    DB->msg("Backup will skip mounted Virtual Hard Disk volume %s", *depvolume);

                    excludes.enter_single(depvolume, exclude::user);
                }
            }
        }

        
        vhdinfo::delete_vhd_nodes(vhdnodes);

    } else
        DB->msg("NOT discovered any Natively Attached Virtual Hard Disk on the system");

    return ret;
}
#endif


bool backstate::enter_default_excludes(utar_flags_info& flags) {

#if SYSTEM_WINDOWS
    
    
    
    if (flags.exclude_filesnottobackup == true)
    {
        enter_registry_excludes(HKEY_LOCAL_MACHINE, "local machine");
        return true;
    }
#endif

     
     if (!flags.logfilename.isempty())
         excludes.enter_single(flags.logfilename, exclude::none);

    
    if (snaptype != FILESYSTEM) return true;

    

#if SYSTEM_WINDOWS
    enter_registry_excludes(HKEY_LOCAL_MACHINE, "local machine");

    enter_registry_excludes(HKEY_CURRENT_USER, "user");

    
    if( win_os_version_info::is_windows_7_or_newer())
        excludes.enter_single("System Volume Information\\Syscache.hve*", exclude::system);

    
    if ((xflag[5]&2048)==0)             
        excludes.enter_single("Temporary Internet Files\\", exclude::system); 

    
    if ((xflag[5]&4096)==0) {           
        excludes.enter_single("outlook.ost", exclude::system);
        excludes.enter_single("outlook\\*.ost", exclude::system);
    }
#endif

#if SYSTEM_UNIX









    excludes.enter_single("/proc/", exclude::system);   








   if(!flags.permissions)
       excludes.enter_single("/dev/", exclude::system);    

#if SYSTEM_UNIX_SOLARIS
    excludes.enter_single("/devices/", exclude::system);
#endif

#endif

    
    
    
    excludes.enter_single(".snapshot/", exclude::system); 

    
    
    
    
    
    
    if (flags.exclude_cachefile) {
        ustring cache_file_pattern("*p_cache.dat");
        cache_excludes.enter_single(cache_file_pattern, exclude::cachefile);
        cache_file_pattern = "*f_cache.dat";
        cache_excludes.enter_single(cache_file_pattern, exclude::cachefile);
        cache_file_pattern = "*f_cache2.dat";
        cache_excludes.enter_single(cache_file_pattern, exclude::cachefile);
    } else if (!flags.vardir.isempty()) {
        ustring cache_file_pattern = ustring::sprintf("%s/p_cache.dat", *flags.vardir);
        excludes.enter_single(cache_file_pattern, exclude::system);
        cache_file_pattern = ustring::sprintf("%s/f_cache.dat", *flags.vardir);
        excludes.enter_single(cache_file_pattern, exclude::system);
        cache_file_pattern = ustring::sprintf("%s/f_cache2.dat", *flags.vardir);
        excludes.enter_single(cache_file_pattern, exclude::system);
    }
    return true;
}



#if SYSTEM_WINDOWS
void backstate::GatherRegKeyValues(const backstate::GetLongPathNamefp getlongpathnamefp, const ustring& value_name, const TCHAR *value, DWORD value_size, exclude *excludes, int& added_count, const stringlist& targets)
{
    
    
    
    for( size_t i = 0; i < value_size; i += (lstrlen(&value[i]) + 1) )
    {

        
        
        
        if( i >= value_size/2 || value[i] == 0 )
        { 
            break;  
        }

        
        
        
        
        
        
        
        
        
        
        
        
        const TCHAR * theValue = &(value[i]);
        const ustring rawVal = ustring(encodings::utf8, theValue).lower();

        const ustring UserProfileMacro("%userprofile%");
        int idx = rawVal.contains(UserProfileMacro);     
        if (idx == 0) { 
            const stringlist users = ntsecurity::get_local_profile_paths(true);
            for (int i  = 0; i < users.size(); i++) {
                const ustring whatToAdd = rawVal.replace(UserProfileMacro, users[i]);
                added_count += AddToExcludes(getlongpathnamefp, value_name, whatToAdd, *excludes);
            }
        }
        else {
            const ustring VolumeMacro("%allvolumes%");
            idx = rawVal.contains(VolumeMacro);     
            if (idx == 0) {  
                
                const undoo::vector<ustring> volumes = file_system_info::get_fs_paths_list();
                for (size_t i = 0; i < volumes.size(); i++) {
                    const ustring whatToAdd = rawVal.replace(VolumeMacro, volumes[i]);
                    added_count += AddToExcludes(getlongpathnamefp, value_name, whatToAdd, *excludes);
                }
            }
            else {
                
                TCHAR buf[1024];
                int res = ::ExpandEnvironmentStrings( theValue, 
                    buf,         
                    sizeof(buf) / sizeof(*buf) );

                
                const ustring whatToAdd = ustring(encodings::utf8, buf).chop(' ');
                added_count += AddToExcludes(getlongpathnamefp, value_name, whatToAdd, *excludes);
            }
        }

    }
}


int AddToExcludes(const backstate::GetLongPathNamefp getlongpathnamefp, const ustring& keyName, const ustring& keyVal, exclude& excludes) {
    
    
    
    
    
    
    
    ustring value = keyVal;
    if( getlongpathnamefp )
    {
        const int dirsepindex = value.findback(value.bytelength() - 1, '\\');

        if( dirsepindex >= 0 )
        { 
            if( dirsepindex != 0 )
            { 
                const uwstring dir(encodings::filesystem, value.substr(0, dirsepindex));

                WCHAR wszLong[1024];
                
                
                int res = (*getlongpathnamefp)( *dir, 
                    wszLong, 
                    sizeof(wszLong) / sizeof(*wszLong) );

                if( res != 0 )
                {
                    value = ustring(encodings::filesystem, wszLong) + value.substr(dirsepindex);
                }
            }
        }
    }

    
    
    
    if(keyName.equal("BITS_metadata") && value == "?")
    {
        Out->msg(WARN, "<6022>Skipping %s exclude string. Microsoft Knowledge Base Article - 883357 bug", *keyName);
        return 0;
    }

    
    if(value.hasChar('?'))
    {
        DB->msg("Skipping exclude \"%s\" containing undecipherable chars: \"%s\"", *keyName, *value);
        return 0;
    }

    excludes.enter_single(value, exclude::system, false);
    DB->msg( "Excluding %38s - %s", *keyName, *value );
    return 1;
}
















upath makePath(const ustring& path)
{
    
    ustring str = path.replace(ustring(" /s"), ustring());

    
    const ustring wackStar = ustring("\\*");
    if (str.substr(str.length_in_chars() - wackStar.length_in_chars()) == wackStar) {
        str = str.substr(0, str.length_in_chars() - wackStar.length_in_chars());
    }

    
    return upath(str);
}


    
    
    void backstate::enter_registry_excludes(HKEY hkey, const ustring& keytext)
    {
        const ustring backup_exclude_key_str("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup");
        DB->msg("Excluding items in %s registry - %s", *keytext, *backup_exclude_key_str);

        HKEY backup_exclude_key;
        int res =  ::RegOpenKeyEx(hkey, *backup_exclude_key_str.to_utstring(), 0, KEY_READ, &backup_exclude_key );
        if( res != ERROR_SUCCESS ) {

        } else {
            int added = 0;
            FILETIME lpftLastWriteTime;
            DWORD MaxValueLen = 0;
            DWORD MaxValueNameLen = 0;
            DWORD Values = 0;
            DWORD SubKeys = 0;
            DWORD MaxSubKeyLen = 0;
            DWORD MaxClassLen = 0;
            TCHAR class_str[256];
            DWORD class_str_size = sizeof(class_str) / sizeof(*class_str);

            res = ::RegQueryInfoKey( backup_exclude_key,                
                class_str,          
                &class_str_size,    
                NULL,               
                &SubKeys,           
                &MaxSubKeyLen,      
                &MaxClassLen,       
                &Values,            
                &MaxValueNameLen,   
                &MaxValueLen,       
                NULL,               
                &lpftLastWriteTime  ); 
            if( res == ERROR_SUCCESS ) {

                
                HMODULE hlib = NULL;
                
                WCHAR wszTmp[MAX_PATH +1];

                UINT uBytesReturned = ::GetSystemDirectoryW( wszTmp, MAX_PATH );
                if( (uBytesReturned != 0) && (uBytesReturned < MAX_PATH) ) {
                    if( wszTmp[ uBytesReturned - 1] == '\\' ) {
                        wszTmp[ uBytesReturned - 1] = 0;
                    }
                    wcscat(wszTmp, L"\\kernel32.dll");
                    hlib = ::LoadLibraryExW( wszTmp,NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
                }

                GetLongPathNamefp getlongpathnamefp = NULL;
                if(hlib)
                    getlongpathnamefp = (GetLongPathNamefp)::GetProcAddress(hlib, "GetLongPathNameW");    

                DWORD index = Values;
                while( index > 0 ) {
                    DWORD Type;
                    TCHAR value_name[1024];
                    TCHAR value[1024];
                    DWORD value_size = sizeof(value); 
                    DWORD value_name_size = sizeof(value_name) / sizeof(*value_name);

                    res = ::RegEnumValue(
                        backup_exclude_key,     
                        index - 1,              
                        value_name,             
                        &value_name_size,       
                        NULL,                   
                        &Type,                  
                        (unsigned char *)value, 
                        &value_size  );         

                    index--;
                    if( res != ERROR_SUCCESS ) {
                        DB->msg("backstate::enter_registry_excludes: RegEnumValue returned %d, skipping entry", res);
                        continue;
                    }

                    const ustring vname(encodings::filesystem, value_name);     

                    if( Type != REG_MULTI_SZ ) {
                        DB->msg("backstate::enter_registry_excludes: Skipping registry entry \"%s\", type=%d is not REG_MULTI_SZ", *vname, Type);
                        continue;
                    }

                    if (sis_feature_enabled) {
                        
                        if (vname == "SINGLE INSTANCE STORAGE") {
                            DB->msg("backstate::enter_registry_excludes: Skipping registry entry \"%s\" SIS feature enabled.", *vname);
                            continue;
                        }
                    }

                    if (snaptype == VSS && keytext.lower() == "local machine") {
                        bool skip_registry_entry(false);

                        if (vname.upper() == "CERTIFICATE AUTHORITY") {
                            
                            
                            
                            skip_registry_entry = true;
                        }
                        else if (vname.upper() == "NTDS") {
                            
                            
                            
                            skip_registry_entry = true;
                        }
                        else {
                            
                            
                            
                            
                            
                            const stringlist tokens = vname.split(' ');

                            if ((tokens[0].upper() == "ADAM") && (tokens[tokens.size()-1].upper() == "WRITER")) {
                                
                                
                                
                                skip_registry_entry = true;
                            }
                        }

                        
                        if (skip_registry_entry) {
                            DB->msg("backstate::enter_registry_excludes: Not excluding registry entry \"%s\" for Disaster Recover Backup", *vname);
                            continue;
                        }
                    }
                    
		            
                    GatherRegKeyValues( getlongpathnamefp, vname, value, value_size, &excludes, added, targets.includelist());

                } 

                if(hlib)
                    ::FreeLibrary(hlib);

                if (added)
                    Out->msg(INFO, "<5438>Loaded %d exclude patterns from Windows %s registry", added, *keytext);
            }

            res = ::RegCloseKey(backup_exclude_key);
        }
    }

#endif










bool backstate::check_valid_path(const stringlist list, const ustring actual_path)
{
    if(xflag[20]&2)    
        return true;

    if(list.isempty() || actual_path.isempty())
        return false;

    return exclude::search_pattern(actual_path, list);
}






stringlist backstate::replace_vars(const stringlist &paths)
{
#if SYSTEM_WINDOWS
    if (skipreplacevars) return paths;

    stringlist new_paths;
    for (int i = 0; i < paths.size(); i++) {
        ustring newpath = paths[i];
        if (newpath.contains(USERDOCVAR) == 0) { 
            ustring userdocvar;
            if (win_os_version_info::is_windows_Vista_or_newer())
                userdocvar = ustring("%Public%");
            else
                userdocvar = ustring("%AllUsersProfile%");
            ustring userdocfolder = subscript::expand_environment_strings(userdocvar);
            Out->msg(INFO, "<9911>Translating %s based on environment variable %s: %s",
                USERDOCVAR, *userdocvar, *userdocfolder);
            userdocfolder = userdocfolder.get_dotdot();
            newpath = paths[i].replace(USERDOCVAR, userdocfolder);
            Out->msg(INFO, "<9912>Replacing %s with %s", *paths[i], *newpath);
        }
        new_paths.push_back(newpath);
    }
    return new_paths;
#else
    return paths;
#endif

}







stringlist backstate::expand_paths(const stringlist &paths)
{
#if SYSTEM_WINDOWS || SYSTEM_UNIX_MACOSX
    if (skipwildcardexpand) return paths;

    stringlist new_paths;
    int pos;
    for (int i = 0; i < paths.size(); i++) {
        bool expanded = false;
        pos = paths[i].contains(ustring(WILDCHAR, 1));
        if (pos != -1) { 
            if (DIRELEM::queryexists(upath(paths[i])))
                Out->msg(DEBUG, "backstate::expand_paths() path %s exists; not expanding", *paths[i]);
            else if (paths[i].contains(ustring(WILDCHAR, 1), pos + 1) != -1) 
                Out->msg(INFO, "<9913>Not expanding %s, found multiple wildcards", *paths[i]);
            else {
                Out->msg(INFO, "<9914>Expanding %s", *paths[i]);
                ustring parent, rest, full_path = paths[i].stdseparators();
                full_path.split(parent, rest, false, WILDCHAR);
                if (parent.isnull() || parent.last() != '/' || (!rest.isnull() && rest.first() != '/'))
                    Out->msg(INFO, "<9915>Not expanding %s, wildcard must signify full directory or file name", *paths[i]);
                else {
                    Out->msg(DEBUG, "Looking for directories in %s", *parent);
                    upath parent_path(parent);
                    ELEMID elemid(parent_path);
                    dirwalk dir(elemid, true, false, false, NULL, NULL);
                    const ustring direrr(dir.geterror());
                    if (!direrr.isempty())
                        Out->msg(WARN, "<9916>Error opening directory path %s - %s", *parent, *direrr);
                    else {
                        DIRELEM elem;
                        while (dir.getnext(elem)) {
                            if (!elem.is_dot_or_dot_dot() && !elem.is_reparsePoint()) {
                                ustring path = parent + elem.name() + rest;
                                if (DIRELEM::queryexists(upath(path))) {
                                    Out->msg(INFO, "<9917>Adding %s to the target list", *path);
                                    new_paths.push_back(path);
                                    expanded = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!expanded) new_paths.push_back(paths[i]);
    }
    return new_paths;
#else
    return paths;
#endif
}



#if !defined(EXPORTSTREAM_XML_H_INCLUDED)
#define EXPORTSTREAM_XML_H_INCLUDED












#include "xml_message.h"
#include "ddrfiles_xml.h"
#include "location.h"
#include "tversion.h"

class roothashlistrec;
class roothashflags;
class rhlLabel;

class exportstream_xml : public countptr {
public:
  SAFEALLOC(exportstream_xml);

  
  
  void set_sysinfo_backuptag_value(const ustring& backuptag) const {
      imported_backuptag_value = backuptag;
  }

  class section {  
  public:
      
      enum type {
          none,
          error,
          
          archive_info,
          workorder,
          backup,
          location,
          build,
          flagsettings,
          commandline,
          
          ddr_files_xml_gsan,
          ddr_files_xml_ddr,
          

     end_of_msection_enum            
      };

      
      inline section(const type sect) : sect(sect) {}

      
      inline static type first() { return none; }

      
      inline static type last() { return end_of_msection_enum; }

      
      const ustring image() const;

      
      type value() const {
          return sect;
      }

      
      bool operator==(const section& src) const {
          return this->sect == src.sect;
      }

      
      bool operator!=(const section& src) const {
          return this->sect != src.sect;
      }

      
      
      static const type value(const ustring& sectimage);

  private:

      
      static intassoc image_mapping;

      
      static bool image_mapping_initialized;

      const type sect;
  }; 

  
  
  exportstream_xml();

  
  
  exportstream_xml(const fileref& data);

  
  
  exportstream_xml(const ustring name);

  bool valid() const { return !mess.isnull() && mess->valid(); }  

  
  ~exportstream_xml();

  
  
  

  
  
  
  void add_section(section::type sect, xml_messagep sectinfop);

  
  xml_messagep to_xmlp() const;

  
  
  

  
  
  bool get_label(rhlLabel &rhllabel) const;

  
  
  bool get_status(int& status) const;

  
  
  bool get_totalsize(double& totalsize) const;

  
  
  bool get_roothashflags(roothashflags& rflags) const;

  
  
  pidtype get_pid() const;

  
  
  bool get_snapup_timestamp(ubigint64& timestamp) const;

  
  
  bool get_expires_time(ubigint64& timestamp) const;

  typedef enum {
      ddrfilesxml_from_gsan_then_ddr,
      ddrfilesxml_from_gsan,
      ddrfilesxml_from_ddr,
  } ddrfilesxml_search;

  
  xml_messagep get_xmlp(const ddrfilesxml_search from) const;

  
  ddrfiles_xmlp get_ddrfiles_xmlp(const ddrfilesxml_search from) const;

  
  
  
  emd_elementp get_containerid_emdp(const ddrfilesxml_search from, const location::tcontainerid containerid) ;

  
  
  

  
  const bool is_backup_supported() const;

  
  const bool is_backup_indio_or_greater() const;

  
  const bool is_backup_equal_or_newer_to(const tversion::release_ver rel_version) const;

 
 
 
 
 

  class attr {
  public:
      
      enum type {
          none,
          error,
          

          
          flags,
          pid,
          pidnum,
          newformat,
          ispresentbytes,
          percentnew,
          isencrypted,
          labelattr,
          labelattr_taghash,
          labelattr_aux1,
          labelattr_aux2,
          labelnum,
          created,
          created_prectime,
          totalbytes,
          expires,
          expires_prectime,
          retentiontype,
          partial,
          backuptype,
          backuptype_internal,
          ddrindex,
          backuptag,
          savesetid,
          appversion,
          appconsistent,
          tier,

     end_of_attr_enum  
      };
      
      inline attr(const type at) : at(at) {}

      
      inline static type first() { return none; }

      
      inline static type last() { return end_of_attr_enum; }

      
      const ustring image() const;

      
      bool operator==(const attr& src) const {
          return this->at == src.at;
      }

      
      bool operator!=(const attr& src) const {
          return this->at != src.at;
      }

      
      
      static const type value(const ustring& tyimage);
  private:
      
      static intassoc image_mapping;

      
      static bool image_mapping_initialized;

      const type at;
  }; 

private:
  
  const bool has_section(const section::type sect) const;

  
  const xml_messagep find_section(const section::type sect) const;

  
  
  const bool get_backup_version_and_ddrindex(ustring& version, int& ddrindex) const;

  
  static const ustring attr2ustr(const attr::type attrtype);

  
  mutable ustring imported_backuptag_value;

  xml_messagep mess;  
};






class exportstream_xmlp : public refcounter<exportstream_xml> {
public:
  exportstream_xmlp() : refcounter<exportstream_xml>() {}
  exportstream_xmlp(exportstream_xml* mess) : refcounter<exportstream_xml>(mess) {}
  SAFEPOOLALLOC(exportstream_xmlp);
};

#endif











#include "common.h"
#include "debug.h"
#include "backstate.h"
#include "connection.h"
#include "nbackroot.h"
#include "backstats.h"
#include "hash_cache.h"
#include "backtree.h"
#include "cycle.h"
#include "utar_flags_info.h"





#define chunktree_msg ((xflag[2]&256)!=0)
#define MAGIC 0x12345678

static int num_nodes;   

chunktree::node::node(workelem *info_, fileref& data_, hashcode &hash_, chunktype kind_, int origsize_, int depth_, cycle *parent_cycle, backtree *my_cycle_)
    : data(data_), hash(hash_), kind(kind_), info(info_), origsize( origsize_ ), depth( depth_ )
{
    assert(!parent_cycle->main->ADEChunkerEnabled());

    this->why = stats::noreason;
    this->sibling = NULL;
    this->child = NULL;
    this->node_sent = false;
    this->node_complete = false;
    this->magic = MAGIC;
    
    hash_cache *cache = NULL;
    mycycle = my_cycle_;
    
    
    if(info->usechunkcache || mycycle->flags.refcheck)
        cache = parent_cycle->main->state->hashes;
    num_nodes++;
    mycycle->setup( parent_cycle, this, parent_cycle->main->getstatsobj(context::backupstats), 
                                  info->fstats, cache );
    if( chunktree_msg ) DB->msg("chunktree::node creating %s mycycle=%p this=%p depth=%d kind=%s num_nodes=%d", *this->image(), mycycle, this, depth, *kind.image(), num_nodes );
}

chunktree::node::~node() {
  num_nodes--;
  if( chunktree_msg ) DB->msg("chunktree::node::~node delete this=%p, depth=%d, num_nodes=%d", this, depth, num_nodes );
  if( chunktree_msg ) this->print("chunktree::node::~node");
  assert( magic == MAGIC );
  if( magic != MAGIC ) {
      DB->msg( "chunktree::node::~node delete this=%p <BADMAGIC>", this );
      return;
  }

  if( chunktree_msg ) DB->msg("chunktree::node::~node deleting hash=%s mycycle=%p this=%p", *hash.partialimage(), mycycle, this );
  
  if (sibling != NULL) delete sibling;
  sibling = NULL;
  if (child != NULL) delete child;
  child = NULL;
  magic = 0x4321;
}

void chunktree::node::delete_subordinate_cycles( bool delete_cycle) {
  if( chunktree_msg ) DB->msg("chunktree::node::delete_subordinate_cycle hash=%s mycycle=%p this=%p delete=%d", *hash.partialimage(), mycycle, this, delete_cycle );
  if( sibling != NULL)
      sibling->delete_subordinate_cycles(true);
  if( child != NULL)
      child->delete_subordinate_cycles(true);
  if( delete_cycle ) {
      delete mycycle;
      mycycle = NULL;
  }
}



ustring chunktree::node::image() const {
    return ustring::sprintf("node %s %s", *kind.image(), *hash.partialimage());
}

int print_indent = 0;

void chunktree::node::print( const char *name ) {
    ustring leading;
    for( int i=0; i< print_indent; i++ )
        leading += " ";

    if( this == NULL ) {
        DB->msg( "%s%s->(nil)", *leading, name );
        return;
    }
    DB->msg( "%s%s->(node %p %s)", *leading, name, this, *hash.partialimage());
    print_indent++;
    sibling->print( "__sib" );
      child->print( "child" );
    print_indent--;
    
}

void chunktree::node::treestats(backstats *stats, stats::reason parentwhy, bool system_info) {
  assert( magic == MAGIC );
  if( chunktree_msg ) DB->msg("chunktree::node::treestats this=%p", this );
  if( chunktree_msg ) DB->msg("chunktree::node::treestats hash:%s why:%s parentwhy:%s stats:%p kind=%s", 
                                *hash.partialimage(), *stats::image(why), *stats::image(parentwhy), stats, *kind.image() );
  if (sibling != NULL) sibling->treestats(stats, parentwhy, system_info);
  if(why == stats::noreason)
      why = parentwhy;
  if (child != NULL) child->treestats(stats, why, system_info);

  assert(why != stats::noreason);
  if (stats) {
      if(origsize > data.size()) {
          
          stats->byteprogress(why, data.size(), info->fstats, kind, system_info);
          stats->byteprogress(stats::reduced, origsize-data.size(), filestatsref(), chunktype(0), system_info);
      } else {
          
          stats->byteprogress(why, origsize, info->fstats, kind, system_info);
      }
  }
}

msgerrors chunktree::node::send( bool ispresentonly, backstats *stats ) {
    assert( magic == MAGIC );
    if( chunktree_msg ) DB->msg("chunktree::node::send(stats=%p) this=%p mycycle=%p", stats, this, mycycle );
    if( chunktree_msg ) DB->msg("chunktree::node::send hash=%s node_complete=%d ispresentonly=%d", *hash.partialimage(), node_complete, ispresentonly);
    
    if( node_complete ) {
        DB->msg( "***Node already sent" );
        return MSG_ERR_NONE; 
    }

    if(ispresentonly)
        mycycle->ispresentonly();

    assert(!node_sent);
    node_sent = true;
    assert(!node_complete);

    if( chunktree_msg ) DB->msg("chunktree::node::send %s mycycle=%p", *this->image(), mycycle );
    mycycle->set_stats( stats );
    mycycle->todoEnqueue(TODO_CHUNK, mycycle);  
    if( chunktree_msg ) DB->msg("chunktree::node::send node sent" );
    node_sent = true;
    return MSG_ERR_NONE; 
}

bool chunktree::node::issimplecomposite() const
{
    if(!kind.is_anycomposit())
        return false;

    unsigned int count = 0;

    const node* sib = get_child();
    while(sib != NULL) {
        chunktype kind(sib->get_kind());
        if(kind == chunktype::atomic || kind == chunktype::extatomic || kind == chunktype::encrypted) {
            sib = sib->get_sibling();
            count++;
            continue;
        }

        return false;
    }

    return count > 0;
}

unsigned int chunktree::node::get_sibcount() const
{
    unsigned int count = 0;

    const node* sib = this;
    while(sib != NULL) {
        count++;
        sib = sib->get_sibling();
    }

    return count;
}

bool chunktree::node::shouldbesent() const
{
    if(why == stats::ispresent)
        return false;

    if(why == stats::hashcache)
        return false;

    if(hash == hashcode::empty)
        return false;

    if(hash == hashcode::zero)
        return false;

    return true;
}



void chunktree::clear() {
    this->top = NULL;
    this->last= NULL;
}

chunktree::chunktree() {
    if( chunktree_msg ) DB->msg("chunktree::chunktree this=%p", this );
    this->top = NULL;
    this->last= NULL;
}

chunktree::~chunktree() {
  if( chunktree_msg ) DB->msg( "chunktree::~chunktree this=%p", this );
  if( chunktree_msg ) DB->msg("chunktree::~chunktree deleting top=%p last=%p this=%p", top, last, this );
  if( top ) {
      if( chunktree_msg ) DB->msg( "chunktree::~chunktree delete top" );
      delete top;
      top = NULL;
  }
}

void chunktree::add(node * node, chunktree * nchild)
{
    if( chunktree_msg ) DB->msg("chunktree::node::add++");
    if( chunktree_msg ) this->print("chunktree::add before");
    if (top == NULL) {
        top = node;
        last= node;
    } else {
        last->set_sibling(node);
        last = last->get_sibling();
    }
    if (nchild != NULL) {
        last->set_child(nchild->top);
        nchild->top = NULL;
        nchild->last= NULL;
    }
    if( chunktree_msg ) this->print("chunktree::node::after");
    if( chunktree_msg ) DB->msg("chunktree::node::add--");
}

void chunktree::print( const char *name ) {
    top->print( name );
}

void chunktree::send(backstats *stats) {
  if (top == NULL) return;
  if( chunktree_msg ) DB->msg("chunktree::send(%p) - sending top=%p", stats, top );
  top->send(false, stats);
  if( chunktree_msg ) DB->msg("chunktree::send(%p) - sending (sent) top=%p", stats, top );
  cycle *parent_cycle = top->get_cycle()->parent;
  if( parent_cycle == NULL) {  
      assert(false); 
      
      
      
      delete top;
  }
  top = NULL;
  last = NULL;
  if( chunktree_msg ) DB->msg("chunktree::send()--- sending top=%p", top );
}











#include "common.h"
#include "debug.h"
#include "output.h"
#include "dump_layout.h"
#include "dumppipe.h"
#include "dumpcontext.h"
#include "ndmpcontrol.h"

#define dbg      ((xflag[2]&8192)!=0)

dumppipe::dumppipe(fileref& data_, dumpcontext* dumpctx_)
  : pipe_control(data_, TP_BSIZE),
    dumpctx(dumpctx_)
{
    assert(dumpctx);

    
    set_curroffset(dumpctx->streamoffset);
    if(dbg) DB->msg("dumppipe::init curroffset:%s", *get_curroffset().image());
}


bool dumppipe::fillheader(fileref& header, fileoffset& size_needed, fileoffset& altdatasize, fileoffset& stubdatasize,
                          const DIRELEM& de,
                          const ustring& path,
                          const filetype ftype,
                          const ustring& linkname,
                          const fileoffset startoff
) {
    if (!dumpctx) return false;
    if(dbg) DB->msg("dumppipe::fillheader %10d path:%s", de.inode_number(), *path);

    int inode = de.inode_number();

    
    if(startoff==fileoffset(0))
        dumpctx->control->sendinode(inode, de, get_curroffset());
    return dumpctx->do_file_header(header, size_needed, de, startoff);
}
















#ifndef BACKDUMPSTREAM_H
#define BACKDUMPSTREAM_H

#include "cycle.h"
#include "workelem.h"
#include "dumpstreamutils.h"
#include "MetadataStore.h"






class backdumpstream : public BackCycle 
{ 
public: 
    SAFEALLOC(backdumpstream);

    
    enum {
        phase_restore_prev_dir,     
        phase_retrieve_system_info, 
        phase_retrieve_dir_map,     
        phase_retrieve_acl_map,     
        phase_retrieve_type_map,    
        phase_update_dirmap,        
        phase_calc_initial_size,    
        phase_read_stream,          
        phase_process_dir,          
        phase_add_item_to_metastore,
        phase_make_system_info,     
        phase_write_directory,      
        phase_create_volume_dir,    
        phase_notify_parent         
    } m_phase;

    
    backdumpstream(BackCycle *parent, workelem *info);
    ~backdumpstream();

    void init();
    void childdone(cycle *child);

    void addItemToContainer(ustring& name, bool isrootdirectory);

    void printdirlist (const char* mytext);
    ustring phasetext();

    void handleSubdirectory(const ustring& name, bool isrootdirectory, cycle* child);
    void saveItemFromStream(const ustring& name, bool isrootdirectory, cycle* child);

    void beginFileInContainer (DIRELEMp& de);
    void endFileInContainer (cycle* child);
    void startDirInContainer();
    void endDirInContainer();
    void maintainDirOrder( const dumpstream::parser::path_action action, const ustring& name, const bool isrootdirectory);
    void sortSpecialDirectories (bool isdirdir);

    bool open_backup_metastore();
    bool open_metastore_directory_entry();
    bool add_directory_to_metastore(DIRELEMp obj_direlem);
    bool add_item_to_metastore(DIRELEMp obj_direlem);

protected:
    
    backdumpstream(BackCycle *parent, hashcode prevhash, workelem *info, dumpstream::parserp stream, MetadataIntf_sp parent_metadataIntfp_);

    hashcode               m_prevhash; 
    ustring                m_subdir;   
    workelem*              m_info;     
    dumpstream::parserp    m_stream;   
    name_to_direlemp_table m_children; 
    fileoffset             m_size;     
    fileref                m_buffer;   
    DIRELEMp               m_sysinfo;  
    std::vector<ustring>   m_items_in_dir; 
                                           
    unsigned int       m_current_dir_item; 
    fileoffset         m_diroffset;        
    DIRELEMp           m_saved_top;
    bool               m_begindir_sent;    
    BackCycle         *m_parent;           
    DIRELEMp           m_child_de;         

    
    bool               catalog_enabled;
    MetadataStore     *metadatastorep;
    MetadataIntf_sp    parent_metadataIntfp;
    MetadataIntf_sp    cur_metadataIntfp;
};


class dirmapupdatecycle : public cycle
{
public:
    SAFEALLOC(dirmapupdatecycle);

    enum phase {
        phase_get_child_direlems,
        phase_get_child_names,
        phase_get_child_streamslice,
        phase_update_dirmap_entry,
        phase_done
    };

    dirmapupdatecycle(cycle *parent, const location &baseloc, const location &loc,
                      ucontainer::basep container, dumpstream::parserp stream);

    void init();
    void childdone(cycle *child);
    void displayprogress();

private:
    name_to_direlemp_table      m_listing;       
    DIRELEMp                    m_de;            
    fileref                     m_buffer;        
    phase                       m_phase;         
    location                    m_baseloc;       
    location                    m_loc;           
    dumpstream::parserp         m_stream;        
    ucontainer::basep           m_container;     
    undoo::vector<ustring>      m_dirlist;       
    undoo::vector<ustring>      m_keylist;       
    int                         m_dirlistidx;    
    int                         m_keylistidx;    
    int                         m_dircount;      
    int                         m_processed;     
};

#endif

















#include "common.h"
#include "platform.h"
#include "debug.h"
#include "runstage.h"
#include "dumpcontext.h"
#include "boolvect.h"
#include "direlem.h"
#include "context.h"
#include "swap.h"
#include "ndmpcontrol.h"
#include "restdumpdir.h"
#include "direlem_netapp.h"







#define dbg      ((xflag[2]&8192)!=0)



#define dowfs    ((xflag[15]&2)==0)




#define STARTING_INODE_NUMBER 100




enum dumpkind {
    TS_TAPE  = 1,
    TS_INODE = 2,
    TS_BITS  = 3,
    TS_ADDR  = 4,
    TS_END   = 5,
    TS_CLRI  = 6,
    TS_EOM   = 7,
};


class dumpcontext::dumpheader {
public:
    swapuns   c_type;           
    swapuns   c_date;           
    swapuns   c_ddate;          
    swapuns   c_volume;         
    swapuns   c_tapea;          
    swapuns   c_inumber;        
    swapuns   c_magic;          
    swapuns   c_checksum;       
    swapuns16 di_mode;          
    swapuns16 di_nlink;         
    
    swapuns16 di_olduid;
    swapuns16 di_oldgid;
    swapuns64 di_size;          
    swapuns   di_atime;         
    swapuns   di_atimensec;     
    swapuns   di_mtime;         
    swapuns   di_mtimensec;     
    swapuns   di_ctime;         
    swapuns   di_ctimensec;     
    swapuns   di_db[12];        
    swapuns   di_ib[3];         
    swapuns   di_flags;         
    swapuns   di_blocks;        
    swapuns   di_gen;           
    swapuns   di_uid;           
    swapuns   di_gid;           
    swapuns   di_spare[2];      
    swapuns   c_count;          
    char      c_data[512];      
    char      c_label[16];      
    swapuns   c_level;
    char      c_filesys[64];
    char      c_dev[64];
    char      c_host[64];
    swapuns   c_flags;          
    swapuns   c_firstrec;       
    swapuns   c_ntrec;          
    swapuns   c_spare[31];      

    dumpheader() {
        memset(this, 0, sizeof(dumpheader));
    }

    swapuns& netapp_aclinode() {
        return c_spare[22];
    }
};

#define FT_IFMT         0170000  
#define FT_IFDIR	0040000  
#define FT_IFREG        0100000  


struct LARA_struct {
  char LARA_name[4];
  swapint LARA_inode;
};











class direntry {
public:
    swapuns       d_inode;
    swapuns16     d_reclen;
    swapuns16     d_namelen;  
};

dumpcontext::dumpcontext(context *main_, const fileref& stream_,
                         bool little_endian, const ustring& frompath_)
  :
    main(main_),
    stream(stream_),
    savedacls(4099),
    head(NULL),
    tailp(&head),
    frompath(frompath_),
    totaldirsize(0),
    missing(false),
    nextfake(2),     
    rootinode(0),
    nextseq(STARTING_INODE_NUMBER),
    linkseen(10000, false),  
    seqtab(10000, false),
    skipcount(0)
{
    assert(sizeof(dumpheader) == 1024);
    dumpnetapp = main->get_flags().dumpnetapp;
    ontap73acls = dumpnetapp && main->get_flags().ontap73acls && ((xflag[22] & 4194304) == 0);

    dumptime = TIME32(0);
    if(frompath_ != "")
        skipcount = 1;   
    swap_use_little_endian = little_endian;  

    zeroblock.initmem(4096);
    memset(zeroblock.start(), 0, zeroblock.size());

    dumpheader dh;
    dh.c_type = TS_TAPE;
    dh.c_count = 1;
    dh.c_filesys[0] = '/';  
    dh.c_flags = 1;
    do_header(dh);

    inodes.enter(2);

    seqtab.enter(2, 2);

    if(!dowfs)Out->msg(WARN, "<7221>Not restoring windows file summaries.");

    control = new ndmpcontrol(main->get_flags().ndmpcontrol);
    control->start(2);
}

void dumpcontext::do_end() {
    dumpheader dh;
    dh.c_type = TS_END;
    dh.c_count = 1;
    for(unsigned i = 0; i < dh.c_count; i++)
        dh.c_data[i] = 1;
    do_header(dh);
}

dumpcontext::~dumpcontext() {
    control->finish();
    delete control;
    do_end();

    dirlistelem *e = head;
    while(e != NULL) {
        dirlistelem *t = e;
        e = e->link;
        delete t;
    }
}

static ustring dirimage(fileref& data) {
    DIRELEM::diriterator dit(data);
    int count = 0;
    ustring res = "[";
    while(true) {
        DIRELEM de;
        if(! dit.next(de))
            break;
        if(count > 0)
            res += " ";
        res += de.name();
        if(++count > 3) {
            res += "...";
            break;
        }
    }
    res += "]";
    return res;
}

dumpcontext::dirlistelem *dumpcontext::add_directory(DIRELEM& direlem, fileref& data, dirlistelem *parent) { 
    int skipc = skipcount++;

    if(dbg)DB->msg("dumpcontext::add_directory direlem.path=%s direlem.size=%s "
                   "data.size=%d data=%s parent=%p, inode=%d, skipc=%d mode:%d",
                   *direlem.fullpath().image(), *direlem.file_size().image(), data.size(),
                   *dirimage(data), parent, direlem.inode_number(), skipc, direlem.unix_mode());

    totaldirsize += data.size();  

    if(direlem.unix_mode() == 0 && skipc == 0) { 
        DB->msg(DBTXT("dumpcontext::dirlistelem skipping '%s'"), *direlem.name());
        return NULL;
    }

    
    
    if (!missing || ontap73acls) {   
        DIRELEM::diriterator dit(data);
        DIRELEM de;
        while(dit.next(de)) {
            
            if(!missing && de.inode_number() == 0 && !de.is_internal()) {
                missing = true;  
                DB->msg(DBTXT("dumpcontext::add_directory inode number missing from '%s'"), *de.name());
                if (!ontap73acls)
                    break;           
            }
            if (ontap73acls) {
                
                
                
                
                
                
                
                
                
                int32_t aclinode;
                fileref acldata;
                dirrec_pack::netapp_acl nac(&de);
                if (nac.get(aclinode, acldata)  && !savedacls.defined(aclinode)) {
                    
                    fileref acl;
                    acl.initlist(acldata.size());
                    acl.append(acldata);
                    savedacls.enter(aclinode, acl);
                    aclinodes.enter(aclinode);
                    if (dbg) DB->msg("dumpcontext::add_acl: found ACL inode %d", aclinode);
                }
            }
        }
    }

    if (ontap73acls && !frompath.isempty() && (direlem.fullpath().numelems() < frompath.numelems() ||
                                               frompath != direlem.fullpath().slice(0, frompath.numelems()-1))) {
        
        DB->msg(DBTXT("dumpcontext::add_directory skipping '%s'"), *direlem.fullpath().image());
        return NULL;
    }

    
    
    
    
 
    if(parent == NULL && skipc > 0) {  
        
        DB->msg("dumpcontext::add_directory: Forcing inode=2, name=%s size=%s data.size=%d parent=%p, inode=%d, skipc=%d",
                *direlem.name(), *direlem.file_size().image(), data.size(), parent, direlem.inode_number(), skipc);
        direlem.set_inode_number(2);
        direlem.set_kind_unix_sp();
    }

    

    
    dirlistelem *e = new dirlistelem(direlem, data, parent);
    *tailp = e;
    tailp = &e->link;
    
    return e;
}

void dumpcontext::insert_target(const ustring& target) {
    DB->msg("dumpcontext::insert_target '%s'", *target);
    stringlist elems(target.split(DIRSEP, true, true));  
    int n = elems.size();
    head->direlem.set_name(elems[n-1]);
    head->direlem.set_inode_number(0);
    DIRELEM base(head->direlem);
    for(int i = n-2; i >= 0; i--) {
        fileref dirlist;
        dirlist.initlist();
        head->direlem.dolayout(dirlist, false, true, true);  
        DIRELEM de(base);               
        de.set_is_directory();
        de.set_name(elems[i]);
        de.set_hash(hashcode(dirlist));
        if(i == 0)
            de.set_inode_number(2);
        dirlistelem *n = new dirlistelem(de, dirlist, NULL);
        head->parent = n;
        n->link = head;
        head = n;
    }
    
    
    
    
    
    
}

fileref dumpcontext::zeros(int n) {
    fileref z;
    z.initzero(n);
    return z;
}

void dumpcontext::appendstream(const fileref& cdata) {
    fileref data = cdata;  
    if(data.iszero()) {
        assert(data.size() <= zeroblock.size());
        data = zeroblock.makeslice(0, data.size());
    }

    
    
    stream.setslice64(streamoffset, data);
    streamoffset += data.size64();
}

void dumpcontext::do_header(dumpheader& dh, bool addtostream, int spare_26 , bool inode3acl) {
    
    dh.c_date = dumptime;
    
    dh.c_volume = 1;
    
    dh.c_tapea = (int)(streamoffset.value() / 1024);

    
    dh.c_magic = inode3acl ? 60023 : 60012; 

    
    
    
    
    

    



    dh.c_spare[18]=6;
     dh.c_spare[20]=8;

    dh.c_spare[23]=1094929491;      
    dh.c_spare[24]=19541206;

    if (dowfs) {
        
        assert(spare_26<100);
        if(spare_26!=0) { dh.c_spare[26]=spare_26; }
    }





    
    dh.c_checksum = 0;
    
    int checksum = 0;
    swapint *p = (swapint *)&dh;
    for(int i = 0; i < 256; i++)
        checksum += p[i];
    
    dh.c_checksum = 84446 - checksum;

    
    if (addtostream) {
        fileref h;
        h.initmem(&dh, sizeof(dumpheader));  
        appendstream(h);
    }

    if (dbg) { DB->msg("dumpcontext::do_header c_spare "); for (int i = 0; i < 31; i++) if (dh.c_spare[i] != 0) DB->msg("   [%d]:%d", i, +dh.c_spare[i]); DB->msg("  done"); }
}

int dumpcontext::get_fake() {
    
    while(true) {
        int inode = nextfake++;
        
        if(inodes.inuse(inode))
            continue;
        
        
        newseq(inode);  
        
        return inode;
    }
}

void dumpcontext::gen_inodes() {
    DB->msg("dumpcontext::gen_inodes");
    
    dirlistelem *e = head;
    while(e != NULL) {
        if(e->parent == NULL) {
            
            if(e->direlem.inode_number() == 0)
                rootinode = get_fake();
        }
        
        DIRELEM::diriterator dit(e->data);
        while(true) {
            DIRELEM de;
            if(! dit.next(de))
                break;
            
            int inode = de.inode_number();
            if(inode == 0)
                inode = get_fake();
            
            
            e->fakeinodes.enter(de.name(), inode);
        }
        e = e->link;  
    }
}

void dumpcontext::newseq(int inode) {
    int seq = seqtab.lookup(inode);
    
    if(seq == 0) {
        seq = nextseq++;
        inodes.enter(seq);
        seqtab.enter(inode, seq);
        
        
    }
}

void dumpcontext::gen_seq() {
    
    
    dirlistelem *e = head;
    while(e != NULL) {
        int inode = get_inode(e->direlem, e->parent);
        newseq(inode);
        e = e->link;  
    }

    
    
    e = head;
    while(e != NULL) {
        
        DIRELEM::diriterator dit(e->data);
        while(true) {
            DIRELEM de;
            if(! dit.next(de))
                break;
            if(de.is_directory()) 
                continue;
            if(de.file_hash() == hashcode::zero)
                continue;
            
            int inode = get_inode(de, e);
            newseq(inode);
        }
        
        e = e->link;  
    }
}

void dumpcontext::do_bitmaps() {
    
    if(missing)
        gen_inodes();

    gen_seq();

    
    assert(inodes.pagesize() == 1024);
    int pagecount = (int)inodes.getpagecount();

    
    dumpheader dh;
    dh.c_type = TS_CLRI;
    dh.c_count = pagecount;
    do_header(dh);
    int i;  
    for(i = 0; i < pagecount; i++)
        appendstream(inodes.getpage(i));

    
    dh.c_type = TS_BITS;
    dh.c_inumber = 2;  
    do_header(dh);
    for(i = 0; i < pagecount; i++)
        appendstream(inodes.getpage(i));
}


void dumpcontext::setattrs(dumpheader& dh, const DIRELEM_netapp& de) {
    dh.di_blocks = 8;

    dh.di_mode = de.unix_mode();
    dh.di_uid = de.unix_uid();
    dh.di_gid = de.unix_gid();
    dh.di_olduid = de.unix_uid();
    dh.di_oldgid = de.unix_gid();

    
    epoch_t t = de.mtime();
    dh.di_atime = dumptime;
    dh.di_mtime = t;
    dh.di_ctime = t;

#if SYSTEM_UNIX
    if(S_ISBLK(dh.di_mode) || S_ISCHR(dh.di_mode))      
        dh.di_db[0] = de.unix_rdev();
#endif

    if(dumpnetapp) {
        int32_t aclinode=0;
        fileref acldata;
        if(de.get_netapp_acl(aclinode, acldata)) {
            aclinodes.enter(aclinode);
            dh.netapp_aclinode() = aclinode;

        
        
        } else if (de.get_acl_ref(aclinode)) {
            dh.netapp_aclinode() = aclinode;
        }
        if(dbg)DB->msg("dumpcontext::setattrs aclinode:%d dh.netapp_aclinode():%d",
                       aclinode, +dh.netapp_aclinode());
    }
}

int dumpcontext::get_inode(const DIRELEM& direlem, dirlistelem *parent) const {
    
    int inode = direlem.inode_number();
    if(inode != 0) {
        
        return inode;
    }
    
    if(parent == NULL) {
        
        return rootinode;
    }
    
    inode = parent->fakeinodes.lookup(direlem.name());
    if(inode == 0)
        Out->msg(INFO, "<6041>No inode for file %s", *direlem.name());
    

    return inode;
}

int dumpcontext::get_seq(const DIRELEM& direlem, dirlistelem *parent) const {
    int inode = get_inode(direlem, parent);
    int seq = seqtab.lookup(inode);
    if(seq==0) { DB->msg("dumpcontext::get_seq dir=%s, parent=%p, inode=%d, seq=%d", *direlem.fullpath().image(), parent, inode, seq); }
    assert(seq != 0);
    return seq;
}





class dumpcontext::dirheadlist {
public:
    dirheadlist() { head = NULL; tail = NULL; elemcnt = 0; }
    ~dirheadlist() {}

    void add(dumpheader& dh, fileref& f) {
        elem *p = new elem(dh, f);
        if (tail) tail->link = p; else head = p;
        tail = p;
        elemcnt++;
    }

    int elements() { return elemcnt; }

    bool isempty() { return (head == NULL); }

    bool get_front(dumpheader& dh, fileref& f) {
        if (head == NULL) return false;
        elem *e = head;
        dh = e->dh;
        f = e->f;
        head = e->link;
        delete e;
        elemcnt--;
        return true;
    }

    SAFEPOOLALLOC(dirheadlist);

private:
    class elem {
    public:
        elem() { link = NULL; }
        elem(dumpheader& dh_, fileref& f_) : dh(dh_), f(f_), link(NULL) { }
        dumpheader dh;
        fileref    f;
        elem       *link;
        SAFEPOOLALLOC(elem);
    };

    int elemcnt;
    elem *head;
    elem *tail;

    NOCOPY(dirheadlist);
};








class dumpcontext::direntry_list {
public:
    direntry_list(dumpcontext *dctx, int dirinode, DIRELEM &dir);

    void add(const char *name, int inodenum, bool align_512, int usesize, bool addhist);
    void flush();

    void set_has_lara() { has_lara = true; }
    bool ntstreams()    { return has_ntstreams; }

private:
    dumpcontext *dctx;
    int dirinode;               
    DIRELEM &dir;               

    
    fileref elems;              
    int nextedge;               
    int patchoffset;            
    swapuns16 patchvalue;       

    
    bool has_ntstreams;         
    bool has_lara;              
    int totaldirsize;           
    dirheadlist dhl;            

    void initialize();
    void add_dirblock(bool done);
};




dumpcontext::direntry_list::direntry_list(dumpcontext *dctx_, int dirinode_, DIRELEM &dir_)
  : dctx(dctx_),
    dirinode(dirinode_),
    dir(dir_),
    has_ntstreams(false),
    has_lara(false),
    totaldirsize(0)
{
    initialize();

    
    const int start = dir.name().contains("_ntstreams_");
    has_ntstreams = (start >= 0);
    if (has_ntstreams && dowfs) {
        ustring shortname = dir.name().substr(0, start);
        assert(!shortname.isempty());
        if(dbg)DB->msg("dumpcontext::direntry_list found _ntstreams_ on '%s', start:%d  name_to_inode.enter('%s', inode %d)", *dir.name(), start, *shortname, dirinode);
        dctx->name_to_inode.enter(shortname, dirinode);
    }
}


void dumpcontext::direntry_list::initialize() {
    elems.initlist(128*1024);                   
    nextedge = 512;                             
    patchoffset = 0;                            
    patchvalue = 0;
}



void dumpcontext::direntry_list::add_dirblock(bool done) {
    dumpheader dh;

    
    dh.c_type = dhl.isempty()?TS_INODE:TS_ADDR; 
    dh.c_inumber = dirinode;
    dh.di_nlink = 2;                            
    dctx->setattrs(dh, dir);
    if(dh.di_mode == 0)                         
        dh.di_mode = FT_IFDIR + 0777;

    if(dir.is_directory() && (dh.di_mode & FT_IFMT) != FT_IFDIR) {
        
        dh.di_mode = FT_IFDIR + 0777;
    }

    if (has_ntstreams && dowfs) {
        if(dbg)DB->msg(DBTXT("dumpcontext::add_dirblock tagging dir '%s' as has_ntstreams"), *dir.name());
        dh.c_spare[26]=8;
    }
    if (dh.c_type==TS_INODE && dir.device_number()!=0)
        dh.c_spare[26]=dir.device_number(); 

    if(has_lara && dowfs)                
        dh.c_flags = 4096;               

    if(patchoffset > 0)
        elems.setslice(patchoffset, sizeof(patchvalue), &patchvalue);
    
    if(nextedge % 1024 != 0)
        nextedge += 512;
    assert(nextedge % 1024 == 0);
    
    if(elems.size() < nextedge)
        elems.append(dumpcontext::zeros(nextedge - elems.size()));

    totaldirsize += nextedge;
    dh.di_size = totaldirsize;                                  
    dh.c_count = elems.size() / 1024;

    
    assert(dh.c_count <= sizeof(dh.c_data));
    assert(done || dh.c_count == sizeof(dh.c_data));            
    for(unsigned i = 0; i < dh.c_count; i++)
        dh.c_data[i] = 1;

    dhl.add(dh, elems);

    initialize();
}



void dumpcontext::direntry_list::flush() {
    if(elems.size() > 0) add_dirblock(true);            

    if (!dhl.isempty()) {
        
        if(dhl.elements()>1)
            Out->msg(INFO, "<6482>Handling huge directory: \"%s\", inode=%d, %d 512K blocks, %d bytes", *dir.fullpath().image(), dirinode, dhl.elements(), totaldirsize);

        dumpheader dh;
        fileref f;
        while(dhl.get_front(dh, f)) {
            dh.di_size = totaldirsize;                  
            dctx->do_header(dh);
            dctx->appendstream(f);
        }
    } else assert(totaldirsize == 0);                   
}



void dumpcontext::direntry_list::add(const char *name, int inodenum,
                                     bool align_512,
                                     int usesize, bool addhist
) {
    if (addhist && dctx->control) 
        dctx->control->senddirelem(dirinode, name, inodenum);

    
    if(dbg)DB->msg("direntry_list::add(%s, %d, %d, %d)", name, inodenum, align_512, usesize);
    int namelen = usesize;
    int extra = 4 - (namelen % 4);
    direntry e;
    e.d_inode = inodenum;
    e.d_reclen = (unsigned short)(sizeof(direntry) + namelen + extra);
    e.d_namelen = namelen;
    if((elems.size() + e.d_reclen > nextedge) || align_512) {
        
        
        assert(patchoffset != 0);
        elems.setslice(patchoffset, sizeof(patchvalue), &patchvalue);
        elems.append(dumpcontext::zeros(nextedge - elems.size()));
        nextedge += 512;
        assert(nextedge % 512 == 0);
    }

    
    patchoffset = elems.size() + 4;             
    patchvalue = nextedge - elems.size();

    
    elems.append(&e, sizeof(e));
    elems.append(name, namelen);
    elems.append(dumpcontext::zeros(extra));

    
    
    if (nextedge >= 512*1024) add_dirblock(false);
}









void dumpcontext::do_directories() {
    
    dirlistelem *e = head;
    while(e != NULL && uapp::staging().canRun()) {
        if(dbg)DB->msg("dumpcontext::do_directories **** %d %d ****\n", e->direlem.inode_number(), e->data.size());

        const int dirinode = get_seq(e->direlem, e->parent);
        assert(dirinode != 0);
        direntry_list de_list(this, dirinode, e->direlem);

        
        de_list.add(".", dirinode, false, 1, true);

        
        int parent = dirinode;
        if(e->parent != NULL)
            parent = get_seq(e->parent->direlem, e->parent->parent);
        de_list.add("..", parent, false, 2, true);

        DIRELEM::diriterator dit(e->data);
        while(uapp::staging().canRun()) {
            DIRELEM_netapp de;
            if(! dit.next(de) ) break;

            if(dbg)DB->msg(DBTXT("dumpcontext::do_directories name:%s"), *de.name());
            if(de.file_hash() == hashcode::zero) {
                DB->msg(DBTXT("dumpcontext::do_directories zero hashcode '%s'"), *de.name());
                continue;
            }
            int inode = get_seq(de, e);
            
            
            
            if (de_list.ntstreams()) {
              is_attr_file.enter(inode, dirinode);
              if(dbg)DB->msg(DBTXT("dumpcontext::do_directories is_attr_file.enter(%d, %d)"), inode, dirinode);
            }

            de_list.add(*de.name(), inode, false, de.name().bytelength(), !de.is_internal()); 

            
            ustring short_name;
            if (dowfs && de.get_8dot3_name(short_name))
                de_list.add(*short_name, 0, false, short_name.bytelength(), false);
        }

        if(dowfs) {
            
            de_list.add("/", 0, false, 1, false);
            de_list.add("/", 0, true,  1, false);

            
            DIRELEM::diriterator dit2(e->data);
            bool alignme = true;
            while(uapp::staging().canRun()) {
                DIRELEM_netapp de;
                if(! dit2.next(de) ) break;

                if(dbg)DB->msg(DBTXT("dumpcontext::do_directories looking for LARA inode:%d name:%s"), de.inode_number(), *de.name());
                int new_inode = get_seq(de, e);

                filereflist lara_list;
                if (!de.get_netapp_LARA(lara_list)) {
                  if(dbg)DB->msg("dumpcontext::do_directories no LARA for inode:%d name:%s", de.inode_number(), *de.name());
                  
                  continue;
                }

                de_list.set_has_lara();

                if (lara_list.size() <=0) continue;

                
                struct LARA_struct& ls = *(struct LARA_struct *)lara_list[0].start();
                if(dbg)DB->msg(DBTXT("dumpcontext::do_directories first string LARA_name:%s LARA_inode:%d size:%d"), ls.LARA_name, +ls.LARA_inode, lara_list[0].size());
                ls.LARA_inode = new_inode;

                for (unsigned int i=0; i<lara_list.size(); i++) {
                  de_list.add(lara_list[i].start(), 0, alignme, lara_list[i].size(), false);
                  alignme=false;
                }
            }
        }

        de_list.add("", 0, true, 0, false);

        de_list.flush();

        
        e = e->link;
    }
}

void dumpcontext::do_files() {

     
     
     main->restorecache_enable(main->get_flags().restorecachesize, false);

     cycle *empty_parent = new cycle(NULL, main);
     empty_parent->setautodelete(false);  
     restdumpdir* cy = new restdumpdir(empty_parent, this, head);
     cy->noop();

     bool error = main->loop();
     if (error) DB->msg(DBTXT("main loop returns error"));
     empty_parent->deleteself();  

     return;

























































































































}

void dumpcontext::check_netapp_acl(const DIRELEM_netapp& de, fileref *ref) {
    
    int32_t aclinode;
    fileref acldata;
    if(! de.get_netapp_acl(aclinode, acldata))
        return;
    

    int aclsize = acldata.size();
    
    
    
    int roundup = 1024;
    int partial = aclsize % roundup;
    int extra = partial == 0 ? 0 : roundup - partial;
    int totalsize = aclsize + extra;

    dumpheader dh;
    dh.c_type = TS_INODE;
    dh.c_inumber = aclinode;
    dh.c_count = totalsize / 1024;
    for(unsigned i = 0; i < dh.c_count; i++)
        dh.c_data[i] = 1;
    setattrs(dh, de);
    dh.netapp_aclinode() = 1;
    dh.di_size = aclsize;

    if (ref == 0) {
        do_header(dh);
        appendstream(acldata);
        appendstream(zeros(extra));
    } else {
        
        
        do_header(dh, false, 0, true);
        ref->append(&dh, sizeof dh);
        ref->append(acldata);
        ref->append(zeros(extra));
    }
}





void dumpcontext::do_netapp_inode3_acls()
{
    if (!ontap73acls)
        return;

    if (dbg) DB->msg("dumpcontext::do_netapp_inode3_acls: creating inode 3");
    
    fileref inode3;
    inode3.initlist(1024);
    for (int i = 0; i <= aclinodes.maximum(); i++) {
        fileref acl;
        if (!aclinodes.inuse(i) || !savedacls.lookup(i, acl))
            continue;
        DIRELEM_netapp de;
        de.add_netapp_acl(i, acl);
        check_netapp_acl(de, &inode3);
    }

    if (dbg) DB->msg("dumpcontext::do_netapp_inode3_acls: sending inode 3");
    
    DIRELEM de;
    de.set_inode_number(3);
    de.set_kind_unix_sp();
    de.set_file_size(inode3.size());
    
    
    fileoffset offset(0);
    for (fileoffset slice(0); offset < inode3.size(); offset += slice) {
        fileref header;
        do_file_header(header, slice, de, offset);
        streamoffset -= header.size();
        streamoffset -= slice;
        appendstream(header);
        appendstream(inode3.makeslice(offset.ivalue(), slice.ivalue()));
    }
    assert(offset == inode3.size());
}


void dumpcontext::do_netapp_acls() {
    if(! dumpnetapp)
        return;

    

    do_end();  

    
    int pagecount = (int)aclinodes.getpagecount();
    dumpheader dh;
    dh.c_type = TS_EOM;
    dh.c_count = pagecount;
    do_header(dh);
    for(int i = 0; i < pagecount; i++)
        appendstream(aclinodes.getpage(i));

    if (!ontap73acls) {
        
        dirlistelem *e = head;
        while(e != NULL && uapp::staging().canRun()) {
            
            
            DIRELEM::diriterator dit(e->data);
            while(true) {
                DIRELEM_netapp de;
                if(! dit.next(de))
                    break;
                check_netapp_acl(de);
            }
            
            e = e->link; 
        }
    } else {
        
        
        for (int i = 0; i <= aclinodes.maximum(); i++) {
            fileref acl;
            if (!aclinodes.inuse(i) || !savedacls.lookup(i, acl))
                continue;
            DIRELEM_netapp de;
            de.add_netapp_acl(i, acl);
            check_netapp_acl(de);
        }
    }
    
}


bool dumpcontext::do_file_header(fileref& header, fileoffset& size_needed,
                          const DIRELEM& de,
                          const fileoffset startoff
) {

    int inode = de.inode_number();
    if(dbg)DB->msg("dumpcontext::do_file_header %10d path:%s startoff:%s",
                   inode, *de.name(), *startoff.image());

    
    

    fileoffset filesize = de.file_size();

    if(filesize == fileoffset(0)) {
      assert(startoff==fileoffset(0));
      do_zero_length_file(de, header);
      return true;
    }

    fileoffset maxslice = fileoffset(512 * 1024);  
    
    fileoffset slicesize = filesize - startoff;
    
    if(slicesize == fileoffset(0))
        return true;
    
    if(slicesize > maxslice)
        slicesize = maxslice;
    if(dbg)DB->msg("dumpcontext::do_file_header filesize:%s, startoff:%s, slicesize:%s",
                   *filesize.image(), *startoff.image(), *slicesize.image());

    
    
    
    int roundup = 1024;
    int partial = (int)(slicesize.value() % roundup);
    int extra = partial == 0 ? 0 : roundup - partial;
    fileoffset totalsize = slicesize + extra;

    int nlinks = de.hard_links();

    dumpcontext::dumpheader dh;
    
    if(startoff == fileoffset(0)) {
        dh.c_type = TS_INODE;
    } else {
        dh.c_type = TS_ADDR;
    }

    
    dh.di_size = filesize.value();
    dh.di_nlink = nlinks;
    setattrs(dh, de);
    if((dh.di_mode & FT_IFMT) == 0)   
        dh.di_mode = dh.di_mode | FT_IFREG;

    
    dh.c_count = (int)(totalsize.value() / 1024);
    assert(dh.c_count <= sizeof(dh.c_data));  
    for(unsigned i = 0; i < dh.c_count; i++)
        dh.c_data[i] = 1;
    
    dh.c_inumber = inode;

    int c_spare_26=0;
    if(dowfs) {
        int acldir = name_to_inode.lookup(de.name());
        if (acldir) {
            if(dbg)DB->msg(DBTXT("dumpcontext::do_file_header found acldir name_to_inode.lookup(%s):%d"), *de.name(), acldir);
            dh.c_spare[17]=acldir;
            c_spare_26=2;
        }

        int acl_dir_inode = is_attr_file.lookup(de.inode_number());
        if (acl_dir_inode) {
            if(dbg)DB->msg(DBTXT("dumpcontext::do_file_header found 1 is_attr_file.lookup(%d):%d"), de.inode_number(), acl_dir_inode);
            c_spare_26=5;
        }
        if(dh.c_type==TS_ADDR) c_spare_26=0; 
        else if(de.device_number()>0) c_spare_26=de.device_number();
    }

    do_header(dh, false, c_spare_26);

    streamoffset += sizeof(dumpheader);  

    header.initmem(&dh, sizeof(dumpcontext::dumpheader));  
    size_needed = slicesize;
    streamoffset += totalsize;  
    if(dbg)DB->msg(DBTXT("dumpcontext::do_file_header returns %s (streamoffset:%s)"), *size_needed.image(), *streamoffset.image());
    return true;
}

void dumpcontext::do_zero_length_file(const DIRELEM& de, fileref& header) {
    if(dbg)DB->msg("dumpcontext::do_zero_length_file(%s)", *de.name());

    
    int inode = de.inode_number();
    int nlinks = de.hard_links();
    assert(de.file_size() == fileoffset(0));
    dumpcontext::dumpheader dh;
    dh.c_type = TS_INODE;
    dh.di_size = 0;
    dh.di_nlink = nlinks;
    setattrs(dh, de);
    if((dh.di_mode & FT_IFMT) == 0)   
        dh.di_mode = dh.di_mode | FT_IFREG;
    dh.c_count = 0;
    dh.c_inumber = inode;

    int acldir = name_to_inode.lookup(de.name());
    if (acldir && dowfs) {
      if(dbg)DB->msg("dumpcontext::do_zero_length_file found acldir name_to_inode.lookup(%s):%d", *de.name(), acldir);
      dh.c_spare[17]=acldir;
      dh.c_spare[26]=2;
    }

    int acl_dir_inode = is_attr_file.lookup(de.inode_number());
    if (acl_dir_inode && dowfs) {
      if(dbg)DB->msg(DBTXT("dumpcontext::do_zero_length_file found 2 is_attr_file.lookup(%d):%d"), de.inode_number(), acl_dir_inode);
      dh.c_spare[26]=4;
    }
    do_header(dh, false, de.device_number());
    main->addfilecount(context::restorestats, 1);
    header.initmem(&dh, sizeof(dumpcontext::dumpheader));  
}















































#include "common.h"
#include "debug.h"
#include "output.h"
#include "filenames.h"
#include "timer.h"
#include "backstream.h"
#include "backzfstardir.h"
#include "parsestream_base.h"
#include "backhidden.h"
#include "nbackdata.h"

#include "context.h"

#include "workelem.h"
#include "hashcode.h"
#include "filemem.h"

#include "utar_flags_info.h"
#include "runstage.h"
#include "restdirlist.h"
#include "utar_flags_enums.h"
#include "msgpack_c.h"
#include "ndmp_history.h"
#include "zfstar_history.h"
#include "dirrec_pack.h"
#include "filenames.h"
#include "pipe_control.h"
#include "utar_commands.h"

#include "ndmp_volume_entification.h"
#include "zfstarstream.h"
#include "backdirstreamslice.h"
#include "utar_ctl_sup.h"

#include <algorithm>





#define msg1  ((xflag[2]&2048)!=0)   
#define msg2  ((xflag[2]&4096)!=0)   

#define verbosealternative ((xflag[1]&16384)!=0) 








backzfstardir::backzfstardir(BackCycle* parent_, workelem* info_,
                             parsestream_base* parser_, int traverse_depth_,
                             inode_table& inodetab_,
                             int mount_point_numelems_,
                             zfstar_history* hist,
                             MetadataIntf_sp parent_metadataIntfp_)
    : backndmptardir_base(parent_, info_, parser_, traverse_depth_,
                          inodetab_, mount_point_numelems_, parent_metadataIntfp_),
                          histlist(NULL), 
                          histsrv(hist),
                          hdroffset(0),
                          dataoffset(0),
                          padoffset(0),
                          extattroffset(0)
{
    if(msg1) DB->msg("backzfstardir::backzfstardir (parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    inode_is_64_bits = true;

    
    if (traverse_depth == 0) {
        if (!flags.ndmp_history_pipe_name.isempty()) {
            
            assert(histsrv == 0);
            histsrv = new zfstar_history(parent->main, upath(flags.ndmp_history_pipe_name),
                                            upath(flags.save_ndmp_history));
            DB->msg("backzfstardir::backzfstardir() started zfstar_history");
            DB->msg("backzfstardir::backzfstardir() ndmp_history_pipe_name=%s, save_ndmp_history=%s",
                    *flags.ndmp_history_pipe_name, *flags.save_ndmp_history);
        }

        if (info->use_container) {
            
            determine_volume_offset();
        }
    }

    
    
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);

    
    
    if (info->use_container && info->direlemp->is_directory()) {
        
        
        
        add_directory_to_container();
    }

    
    
    
    
    if (catalog_enabled && info->direlemp->is_directory()) {
        
        
        if (!open_metastore_directory_entry()) {
            Out->Abort("Problem opening Metadata store entry for directory '%s'", *info->direlemp->fullpath().image());
            return;
        }
    }

    if (info->direlemp->is_directory()) {
        process_dir_data(info->direlemp);
    }
}

backzfstardir::~backzfstardir()
{
    if(msg1) DB->msg("backzfstardir::~backzfstardir "
                     "(parent:%p), (this:%p), (parser:%p) (traverse_depth:%d)",
                     parent, this, parser, traverse_depth);

    
    subtract_from_direlem_commitment(cycle_direlem_commitment);

    if (traverse_depth == 0 && histsrv != NULL) {
        
        delete histsrv;
    }
}







void backzfstardir::init()
{
    if (!flags.incremental && throttle_child_spawning()) {
        
        
        
        
        insert_self(info->direlemp);
        return;
    }

    static int count = 0;
    ++count;
    if(msg1 || (count%1000) == 0)
         DB->msg("backzfstardir::init cnt=%d (parent:%p) (this:%p), depth=%d info->direlemp:%s",
                 count, parent, this, traverse_depth, *info->direlemp->fullpath().image());

    if (phase != phase_init) {
        
        

        if (info->use_container && !save_obj_direlem->is_directory()) {
            
            
            

            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->endfile(save_obj_direlem.getimpl(), 0)) != ucontainer::pce__success) {
                Out->Abort("backzfstardir::init: Problem calling endfile for %s (%s)",
                        *save_obj_direlem->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            } else if (flags.incremental) {
                location loc(save_obj_direlem->get_location());

                
                
                
                
                
                
                if (cur_synthlist_coversize == 0) {
                    cur_synthlist_offset = loc.get_abs_offset_in_container();
                    if (msg2) DB->msg("backzfstardir::init: Reset cur_synthlist_offset to abs_offset_in_container (offset:%"LL"d)",
                                      cur_synthlist_offset.value());
                }

                
                
                
                
                if ((save_obj_direlem->hard_links() > 1) && !save_obj_direlem->is_tar_hardlink()) {
                    
                    
                    add_files_to_synth_list(&cur_synthlist);
                    
                    

                    
                    cur_synthlist.add_hardlink_data((ubigint64)save_obj_direlem->inode_number64());
                    assert ((cur_synthlist_coversize == 0) && (cur_synthlist_checksum == 0));  
                }

                
                
                
                
                
                cur_synthlist_coversize += loc.get_coverage_size();
                cur_synthlist_checksum ^= loc.get_checksum().value;  
                if (msg2) DB->msg("backzfstardir::init: cur_synthlist (offset:%"LL"d coversize:%"LL"d checksum:%u)",
                                  cur_synthlist_offset.value(), cur_synthlist_coversize.value(), cur_synthlist_checksum);
            }
        }
    }

    if (!get_next_header(save_obj_direlem, save_altdata, save_stubdata)) {
        
        
        

        
        
        
        
        if (info->use_container && (inodetab.current_container_location.get_containerid() == 0)) {
            save_location_template(info->direlemp->get_location(), false );
        }

        if (info->use_container && info->direlemp->is_directory() && !reserved_hiddendir) {
            
            
            

            if (flags.incremental) {
                
                add_files_to_synth_list(&cur_synthlist);
                
                
            }

            
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                Out->Abort("backzfstardir::init: Problem calling enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }

            if (msg2) DB->msg("DDR: backzfstardir::init DIR LOCATION %s is %s",
                           *info->direlemp->fullpath().image(), *info->direlemp->get_location().image());

            if (flags.incremental) {
                
                
                
                
                
                
                
                
                
                
                if (!dir_header_added) {
                    
                    add_dir_header_to_synth_list(&cur_synthlist);
                    
                    
                }

                
                inode_table::data_block synth_item;
                
                location loc(info->direlemp->get_location());
                
                
                synth_item.block_begin = (ubigint64)(loc.get_abs_offset_in_container() + loc.get_coverage_size() - loc.get_footer_size()).value();
                synth_item.block_size = (bigint64)loc.get_footer_size().value();
                synth_item.block_checksum = loc.get_checksum().footer_value;
                cur_synthlist.add_item(synth_item);
                if (msg2) DB->msg("backzfstardir::init Added entry (footer for '%s') to cur_synthlist (block_begin:%"LL"d block_size:%"LL"d) list size:%"LL"d",
                                  *info->direlemp->name(), synth_item.block_begin, synth_item.block_size, (ubigint64)cur_synthlist.list_size());
            }
        }  
        return;
    }

    set_phase(phase_read_data);
    process_direlem(save_obj_direlem, save_altdata, save_stubdata);

    
    
    todoEnqueueInsert(TODO_DIR, this, -traverse_depth);
}




bool backzfstardir::get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata)
{
    
    altdata  = fileref::empty;
    stubdata = fileref::empty;

    bool pushed_entry = parser->has_pushed_entry();
    bool get_entry_ret = parser->getentry(obj_direlem, altdata, stubdata);

    
    
    if (!get_entry_ret && !max_changed_date_msg_sent) {
        send_max_changed_date();
    }

    if (!get_entry_ret || obj_direlem.isnull()) {
        DB->msg("backzfstardir::get_next_header encountered end of stream inc?%d phase:%d empty_stream:%d, direlem.isnull():%d",
                flags.incremental, phase, parser->is_empty_stream(), obj_direlem.isnull());

        if (flags.incremental && phase == phase_init) {
            
            if (parser->is_empty_stream()) {
                const upath parent_path("");
                DB->msg("backzfstardir::get_next_header empty stream reading previous backup path for parent '%s'", *parent_path.image());
                
                location prev_loc(inodetab.base_container_location);
                prev_loc.set_abs_offset_in_container(0);

                
                
                
                
                
                
                
                prev_loc.set_containerid(0);
                prev_loc.set_enclosing_container(NULL);  

                cycle *child = new restdirlist(this, main->prev_backup.getRootLocation(), parent_path, prev_loc, prevlist);
                child->noop();
                nforked++;
                forked_prev_restore = true;
            }
        }

        set_phase(phase_wait_for_history); 
        childdone(NULL);

        if ((NULL != histsrv) && (traverse_depth == 0))
            
            
            histsrv->data_stream_done(); 

        return false;
    }

    if (!set_new_direlem_path(obj_direlem, pushed_entry)) return false;

    const upath curpath(info->direlemp->fullpath());
    const int cur_path_elems(curpath.numelems()); 
    const upath newpath(obj_direlem->fullpath());
    const int new_path_elems(newpath.numelems());    

    if(msg2)
        DB->msg("backzfstardir::get_next_header cur_path_elems:%d(%s)[0]='%s' "
                "new_path_elems:%d(%s)[0]='%s' curroffset:%s",
                cur_path_elems, *curpath.image(), *curpath.get(0),
                new_path_elems, *newpath.image(), *newpath.get(0),
                *parser->get_headeroffset().image());

    if (new_path_elems <= cur_path_elems) {
        
        
        if (msg2)DB->msg("backzfstardir::get_next_header exiting2 because path is in parent (%d <= %d) '%s'",
                         new_path_elems, cur_path_elems, *obj_direlem->fullpath().image());

        parser->push_entry(obj_direlem, altdata, stubdata);    
        
        set_phase(phase_wait_for_history); 
        childdone(NULL);
        return false;
    }

    
    
    
    
    
    if (new_path_elems > cur_path_elems+1) {
        
        
        
        
        if (msg1)
        {
            DB->msg("backzfstardir::get_next_header big step '%s' vs '%s' new_path_elems:%d cur_path_elems+1:%d",
                        *curpath.image(), *newpath.image(), new_path_elems, cur_path_elems+1);
        }

        assert(obj_direlem->is_directory()); 

        
        
        parser->push_entry(obj_direlem, altdata, stubdata);    
        

        
        altdata = fileref::empty;
        assert(stubdata.isnull());

        
        obj_direlem->set_security(fileref::empty);

        
        obj_direlem->set_fullpath(newpath.slice(0, cur_path_elems));
        obj_direlem->set_name(obj_direlem->fullpath().stripdir());
        obj_direlem->set_is_root();  
        if (msg1)DB->msg("backzfstardir::get_next_header big step new path '%s' name '%s'",
                         *obj_direlem->fullpath().image(), *obj_direlem->name());
    }

    if (msg2)DB->msg("backzfstardir::get_next_header returns obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                     *obj_direlem->fullpath().image(), *obj_direlem->file_size().image(), *altdata.size64().image(),
                     *stubdata.size64().image());

    return true;
}

void backzfstardir::process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata) {

    if (verbosealternative)
        DB->msg("%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                *obj_direlem->name(), obj_direlem->file_size().dvalue());
    else
        Out->msg(VERBOSE, "%s%s  (%.0f bytes)", *ustring(' ', traverse_depth*2),
                 *obj_direlem->name(), obj_direlem->file_size().dvalue());

    fileoffset datasize(obj_direlem->file_size());
    if(msg2)
        DB->msg("backzfstardir::process_direlem obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                *stubdata.size64().image());

    fileoffset patchoffset = 1;  

    
    
    if (flags.incremental) {
        bool added = curlist.split_enter_if_undef(obj_direlem->inode_number64(), obj_direlem->name(), obj_direlem);
        if (!added) {
            Out->msg(ERR, "While processing %s (inode %lu) found a second entry with inode '%lu' and name '%s'",
                     *info->direlemp->fullpath().image(), info->direlemp->inode_number64(),
                     obj_direlem->inode_number64(), *obj_direlem->name());
        }
    }

    
    ordered_curlist.push_back(obj_direlem);

    if(msg2)
        DB->msg("backzfstardir::process_direlem: Added to ordered_curlist('%s', '%s')",
                *obj_direlem->name(), *obj_direlem->fullpath().image());

    
    
    if (info->use_container && !dir_header_added && flags.incremental && info->direlemp->is_directory()) {
        
        
        
        add_dir_header_to_synth_list(&cur_synthlist);
        
        
    }

    
    
    if (info->use_container && !obj_direlem->is_directory()) {
        
        

        ucontainer::errortype errcode;

        if ((errcode = info->container->beginfile(obj_direlem.getimpl(), datasize, 1 )) != ucontainer::pce__success) {
            Out->Abort("backzfstardir::process_direlem: Problem calling beginfile for %s (%s)",
                    *obj_direlem->fullpath().image(), *ucontainer::error_description(errcode));
            return;
        } else {
            if (msg2) DB->msg("DDR: backzfstardir::process_direlem: abs_offset_in_container: %"LL"d beginfile for file %s",
                              obj_direlem->get_location().get_abs_offset_in_container().value(),
                              *obj_direlem->fullpath().image());
        }
    }

    if(obj_direlem->is_directory()) {
        
        child_dir_count++;
        
        

        
        
        if (info->use_container && flags.incremental) {
            
            add_files_to_synth_list(&cur_synthlist);
            
            

            
            if (msg2) DB->msg("backzfstardir::process_direlem: Adding directory '%s' to cur_synthlist within '%s'",
                              *obj_direlem->name(), *info->direlemp->name());
            cur_synthlist.add_dir((ubigint64)obj_direlem->inode_number64());
        }

        
        
        if (msg2) DB->msg("backzfstardir::process_direlem subdir for %s", *obj_direlem->fullpath().image());
        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        backzfstardir *subdir = new backzfstardir(this, w, parser, traverse_depth+1,
                                                  inodetab, mount_point_numelems, histsrv,
                                                  my_metadataIntfp);
        subdir->noop();
        nforked++;

    } else if (obj_direlem->is_symlink() && datasize == 0) {
        
        
        fileref link = parser->get_symlink_data();
        assert(!link.isnull());
        datasize = link.size();
        obj_direlem->set_file_size(datasize);

        if (msg2)DB->msg("Handling inline symlink, size=%d", datasize.ivalue());
        workelem *w = new workelem( info, link );
        cycle *linkchild = new nbackdata(this, w, patchoffset, false , 0, info->use_container );
        linkchild->noop();
        nforked++;

    } else { 
        
        obj_direlem->set_stdin();       

        workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem);
        if (obj_direlem->is_tar_hardlink()) {
            if (msg2)
                DB->msg("backzfstardir::process_direlem this:%p obj_direlem:%s is_tar_hardlink:1",
                        this, *obj_direlem->fullpath().image());
            
            
            
            
            
            w->hold_data = true;
        }

        nbackdata *cycle_chunk = new nbackdata( this, w, patchoffset, false, parser, info->use_container );
        cycle_chunk->noop();
        nforked++;
        size += datasize;
    }

    
    main->set_cur_filename(obj_direlem->fullpath(), obj_direlem->is_directory());

    if(msg2)DB->msg("backzfstardir::process_direlem DONE obj_direlem1:%s file_size=%s altdata:%s stubdata:%s",
                    *obj_direlem->fullpath().image(), *datasize.image(), *altdata.size64().image(),
                    *stubdata.size64().image());
}


void backzfstardir::process_dir_data(DIRELEMp obj_direlem)
{
    zfstarstream::parser *zfs_parser = dynamic_cast<zfstarstream::parser*>(parser);

    workelem *w = new workelem(info, obj_direlem->fullpath(), obj_direlem, filestatsref());
    cycle *child = new backdirstreamslice(this, w, obj_direlem, zfs_parser, info->use_container);
    child->noop();
    nforked++;
}


void backzfstardir::childdone(cycle* child)
{
    if(msg1) DB->msg("backzfstardir::childdone parent:%p this:%p child:%p nforked=%d ncollected=%d",
                     parent, this, child, nforked, ncollected);

    if (child) {
        ncollected++;

        switch (phase) {
        case phase_init:
            return;

        case phase_read_data:
        case phase_wait_for_history:
            
            
        case phase_wait_for_children:
            
            
        case phase_forksdone:
            
            
            
            if (child == data_hasher_child) {
                
                main->safesetactivelimit(TODO_MAX, "return from prevlist", true);
                break; 
            }
            
        case phase_do_hidden: {
            
            
            
            
            
            backzfstardir *dc_dir = dynamic_cast<backzfstardir *>(child);
            if (dc_dir != NULL) {
                
                

                
                child_dir_count--;
                
                

                DIRELEMp de(dc_dir->getInfo()->direlemp);
                if (info->use_container) {
                    
                    
                    ubigint64 child_inode(de->inode_number64());

                    
                    
                    childlist.add_child(child_inode);
                    if (msg2) DB->msg("backzfstardir::childdone: Added inode %"LL"d to child_dir_list. List size=%"LL"d",
                                      child_inode, (ubigint64)childlist.list_size());

                    if (flags.incremental) {
                        
                        
                        merged_coverage_size += dc_dir->merged_coverage_size;
                        if (msg2) DB->msg("backzfstardir::childdone  Updated merged_coverage_size for %s to:%"LL"d (added %"LL"d from child dir)",
                                          *info->direlemp->name(), (bigint64)merged_coverage_size.value(), (bigint64)dc_dir->merged_coverage_size.value());

                        
                        
                        merged_checksum ^= dc_dir->merged_checksum;
                        if (msg2) DB->msg("backzfstardir::childdone  Updated merged_checksum for %s to:%u (included %u from previous backup)",
                                          *info->direlemp->name(), merged_checksum, dc_dir->merged_checksum);
                    }
                } else {
                    
                }

                
                
                if (catalog_enabled) {
                    MetadataIntf_sp metadatap = dc_dir->my_metadataIntfp;
                    direlemp2metadatap.insert(std::make_pair(de.getimpl(), metadatap));
                    if (msg2) DB->msg("backemctardir7::childdone: Added child dir '%s' to metadata map (de.getimpl=%p, metadatap=%p, map_size=%d)",
                                      *de->name(), de.getimpl(), metadatap.get(), (int)direlemp2metadatap.size());
                }
            }

            
            
            nbackdata *dc_file = dynamic_cast<nbackdata *>(child);
            if (dc_file && dc_file->get_depkind() == none) {
                DIRELEMp de(dc_file->getInfo()->direlemp);
                remember_hardlinked_info(de);
            }
            break;
        }
        case phase_done: {
            commit_directory_metadata();
            notifyparent();
            
            
            return;
        }
        default:
            assert(false);
        }
    }

    if(msg1) DB->msg("backzfstardir::childdone this:%p phase:%d forked_prev_restore:%d nforked=%d ncollected=%d",
                     this, phase, forked_prev_restore, nforked, ncollected);

    if ((phase == phase_wait_for_history) || (phase == phase_wait_for_children)) {
        process_wait_phases(histlist ? static_cast<const int> (histlist->size()) : 0);
    } 

    if ((phase == phase_forksdone) && forked_prev_restore && (ncollected == nforked)) {
        if (flags.incremental) {
            
            
            
            process_forksdone_phase_part1(&cur_synthlist, &prev_synthlist);
        }

        
        
        
        
        if (catalog_enabled) {
            
            
            
            if (!add_children_to_metastore()) {
                Out->Abort("Problem adding children to the Metadata store for directory '%s'", *info->direlemp->fullpath().image());
                return;
            }
        }

        
        
        
        
        
        process_forksdone_phase_part2(child, &cur_synthlist, &prev_synthlist);
    } 

    
    if ((phase == phase_do_hidden) && (ncollected == nforked)) {
        process_do_hidden_phase();
    }
}







void backzfstardir::remember_hardlinked_info(DIRELEMp &de)
{
    if (msg2)
        DB->msg("backzfstardir::remember_hardlinked_info for %s", *info->direlemp->fullpath().image());

    if (de->is_directory() || (de->hard_links()<2) || de->is_tar_hardlink()) {
        if (msg2) DB->msg("backzfstardir::remember_hardlinked_info ignoring dir:%d nlink:%u hl:%d inode:%lu %s",
                          de->is_directory(), de->hard_links(), de->is_tar_hardlink(), de->inode_number64(), *de->fullpath().image());
        return;
    }

    
    
    if (msg2)
        DB->msg("backzfstardir::remember_hardlinked_info inode:%lu nlink:%d %s",
                de->inode_number64(), de->hard_links(), *de->fullpath().image());

    
    
    
    
    const MetadataId metadataid(de->file_hash());
    get_end_offsets(de);
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false,
                           de->get_location().get_abs_offset_in_container().value(), 0, 0, 0,
                           hdroffset, dataoffset, padoffset, extattroffset);

        
        childlist.add_child(de->inode_number64());
        if (msg2) DB->msg("backzfstardir::remember_hardlinked_info: Added inode %"LL"d to child_dir_list. List size=%"LL"d",
                          de->inode_number64(), (ubigint64)childlist.list_size());
        
        
    } else {
        
        inodetab.add_entry(de->inode_number64(), metadataid, emctar_file_hash_size(*de), true, false, 0, 0, 0, 0,
                           hdroffset, dataoffset, padoffset, extattroffset);
    }
}









void backzfstardir::request_prevlist()
{
    forked_prev_restore = true; 

    if (!flags.incremental)
        return;

    if (flags.noinodetable)
        return;

    ndmp_inode64_t de_inode = info->direlemp->inode_number64();
    MetadataId metadataid;
    fileoffset size;
    bool wasdir = false;
    ubigint64 dir_offset;
    upath path("");

    if (!inodetab.find_entry(de_inode, metadataid, size, wasdir, dir_offset)) {
        if (msg2)
            DB->msg("backzfstardir::request_prevlist for '%s' no entry in inode_table for inode:%"LL"u",
                    *info->direlemp->fullpath().image(), de_inode);

        upath topdirpath = upath(info->direlemp->fullpath().image(), info->direlemp->fullpath().kind(), true);

        if (topdirpath.image() == flags.ndmp_prefix) {
            
            
            
            wasdir = true;
            metadataid = main->prev_backup.getRootLocation().getMetadataId();
            if (msg2) DB->msg("backemctardir7::request_prevlist: Retrieved MetadataId '%s' for previous backup", *metadataid.partialimage());
            dir_offset = 0;
            path = topdirpath;
        } else {
            if (msg1)
                DB->msg("backzfstardir::request_prevlist for '%s' inodetab.find_entry(%"LL"u) returned false",
                              *info->direlemp->fullpath().image(), de_inode);
            return;
        }
    }

    if (!wasdir) {
        if (msg1) DB->msg("backzfstardir::request_prevlist entry in inode_table for inode:%"LL"u was not a directory", de_inode);
        return;
    }

    if(msg1)
        DB->msg("backzfstardir::request_prevlist for '%s' starting restdirlist using MetadataId:%s diroffset:%"LL"u path:%s",
                *info->direlemp->fullpath().image(), *metadataid.partialimage(), dir_offset, *path.image());

    
    location prev_loc(inodetab.base_container_location);
    prev_loc.set_abs_offset_in_container(dir_offset);

    
    
    
    
    
    
    
    if (reserved_hiddendir) {
        prev_loc.set_containerid(0);
        prev_loc.set_enclosing_container(NULL);  
    }

    const location dirloc(main->prev_backup.getMedialoc(), metadataid);
    cycle *child = new restdirlist(this, dirloc, path, prev_loc, prevlist);
    child->noop();
    nforked++;
    forked_prev_restore = true;
}




void backzfstardir::response(message& outargs)
{
    if(msg2)
        DB->msg("backzfstardir::response (parent:%p) (this:%p)", parent, this);
    ncollected++;
    msgpack_c::getndmphistlist64 thl(outargs);
    bool existed;
    ubigint64 histlistptr;
    thl.res(UNPACK, existed, histlistptr);
    if (msg2) DB->msg("backzfstardir::response unpacked result: existed:%d histlistptr:%p",
                      existed, (void*)histlistptr);

    if (existed) {
        
        histlist = (histvector_t *)histlistptr;
        foundhistory = true;
        if (msg2) {
            DB->msg("backzfstardir::response DEBUG DUMP histlist:%p with %"Z"u entries",
                    histlist, histlist->size());
            for (histvector_t::const_iterator i = histlist->begin(); i!=histlist->end(); i++) {
                DB->msg("    name:'%s' inode:%lu", *((*i).key_string), (*i).key_number);
            }
        }
    } else {
        histlist = NULL;
        foundhistory = false;
        DB->msg("backzfstardir::response unable to find history for inode '%s'", *tostr(info->direlemp->inode_number64()));
    }
    childdone(NULL);  
}



bool backzfstardir::merge_lists()
{
    if (msg1) {
        DB->msg("backzfstardir::merge_lists directory %s (inode %s), prevlist.size():%u curlist.size():%u histlist.size():%"Z"u",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()),
                prevlist.size(), curlist.size(), (foundhistory ? histlist->size() : 0));
    }

    
    
    removesnapviewvolumes(flags.ndmp_prefix);

    if (parser->is_empty_stream()) {
        copy_previous_backup(&prev_synthlist, &childlist);
        return true;
    }

    
    if (!foundhistory) return false;

    
    if (msg2) {
        DB->msg("backzfstardir::merge_lists for directory %s inode:%s",
                *info->direlemp->fullpath().image(), *tostr(info->direlemp->inode_number64()));
        debug_print_direlemp_list(curlist, "curlist", msg2);
        debug_print_direlemp_list(prevlist, "prevlist", msg2);
    }

    
    
    
    histvector_t::const_iterator hi;
    for (hi = histlist->begin(); hi != histlist->end(); hi++) {
        csustring name((*hi).key_string);
        uint64_t inum((*hi).key_number);

        
        
        
        if ((name == ".") || (name == ".."))
            continue;

        if (msg2) DB->msg("backzfstardir::merge_lists processing histlist item '%s' -> %"LL"u",
                          *name, inum);

        DIRELEMp curDE;
        DIRELEMp prevDE;

        if (curlist.lookup(*hi, curDE)) {
            
            assert(name.equal(curDE->name()));
            update_stats_counts(curDE);
        } else if (prevlist.lookup(*hi, prevDE)) {
            
            assert(name.equal(prevDE->name()));
            main->getstatsobj(context::backupstats)->mergeprogress(prevDE);

            
            
            if (info->use_container) {
                
                
                
                add_to_prev_synth_list(prevDE, &prev_synthlist, &childlist);
            }

            
            ordered_prevlist.push_back(prevDE);

        } else {
            
            Out->msg(ERR, "<9982>While processing %s (inode %"LL"u), NDMP file history messages "
                     "indicate the presence of a directory entry (inode:%"LL"u name:%s) that "
                     "doesn't appear in the data stream or in our previous backup of this directory.",
                     *info->direlemp->fullpath().image(), (ndmp_inode64_t)info->direlemp->inode_number64(),
                     inum, *name);
            continue;
        }
    }

    delete histlist;
    histlist = NULL;

    return true;
}


void backzfstardir::request_history()
{
    
    
    if (!histsrv) return; 

    assert(phase == phase_wait_for_history);

    
    if (historyrequests++) {
        DB->warn("backzfstardir::request_history %p request count %d, not requesting again!", this, historyrequests);
        return;
    }

    message m;
    msgpack_c::getndmphistlist64 thl(m);
    assert(info->direlemp->inode_number64() != 0);
    ndmp_inode64_t inode_arg = info->direlemp->inode_number64();
    thl.arg(PACK, inode_arg);
    nforked++;
    if(msg1)
        DB->msg("backzfstardir::request_history_new requesting history (GETNDMPZFSHISTLIST) for inode:'%s'(%s) nforked:%d ncollected:%d phase:%d forked_prev_restore:%d",
                *tostr(info->direlemp->inode_number64()), *info->direlemp->fullpath().image(), nforked, ncollected, phase, forked_prev_restore);
    histsrv->send(this, m);
}

void backzfstardir::finish_top_level_directory(cycle *child)
{
    
    
    
    
    if (info->use_container && info->direlemp->is_directory() && reserved_hiddendir) {
        if (!flags.incremental) {
            
            
            
            ucontainer::errortype errcode;
            if ((errcode = info->container->enddir(info->direlemp.getimpl())) != ucontainer::pce__success) {
                Out->Abort("Problem creating container enddir for %s (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                return;
            }
        } else {
            
            
            
            
            

            
            
            
            
            
            fileoffset system_info_dir_size;
            DIRELEMp tmpde(curlist.split_lookup(0, UNDOO_DIRECTORY_NAME));
            if (tmpde.isnull()) {
                Out->msg(ERR,"Could not find .system_info in curlist.");
            } else {
                
                system_info_dir_size = tmpde->get_location().get_coverage_size();
                if (msg2) DB->msg("backzfstardir::finish_top_level_directory  Coverage size for .system_info directory is %"LL"d",
                                  (ubigint64)system_info_dir_size.value());
            }

            
            
            ubigint64 inode_number = 0;
            ubigint64 dir_header_size = 0;
            if (msg2) DB->msg("backzfstardir::finish_top_level_directory    Synth footer from current container (Offset:%"LL"d  Size:%"LL"d  Checksum:%u)",
                              top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum);
            synth_block(top_level_footer.block_begin, top_level_footer.block_size, top_level_footer.block_checksum, inode_number, dir_header_size, false );

            
            
            
            
            
            location loc(info->direlemp->get_location());
            loc.set_coverage_size(loc.get_coverage_size() + (merged_coverage_size + system_info_dir_size));
            info->direlemp->set_location(loc);
            if (msg2) DB->msg("backzfstardir::finish_top_level_directory  Coverage size for %s increased by (%"LL"d+%"LL"d) (now %"LL"d)",
                              *info->direlemp->name(), (ubigint64)merged_coverage_size.value(),
                               (ubigint64)system_info_dir_size.value(),(bigint64)loc.get_coverage_size().value());
        }
    }

    
    
    
    
    
    if (copy_entire_previous_backup) {
        
        
        assert(!info->direlemp->is_directory());  
        assert(cur_synthlist.list_size() == 0);

        
        
        synth_volume_data(child, &cur_synthlist, &prev_synthlist);
    }

    if (info && info->use_container && !info->container.isnull()) {
        bool write_ddrfile = parser->is_empty_stream();
        main->finalizeucontainer(info->container, write_ddrfile);
    }
}

void backzfstardir::commit_directory_metadata()
{
    assert(ncollected == nforked);
    
    
    info->direlemp->set_hash(hash);

    
    
    
    
    check_dirlisting_limit(flags);
    static const fileoffset dirsizelimit(flags.dirlisting_limit);
    if ((dirsizelimit > 0) && (consumed_size > dirsizelimit)) {
        double avgsize = (dirlistcount > 0) ? (consumed_size.dvalue() / double(dirlistcount)) : 0;
        Out->msg(INFO, "<10675>Directory data consumes %s bytes for %"Z"d entries, average storage used per directory entry is %lf bytes",
                 *consumed_size.image(), dirlistcount, avgsize);
        Out->msg(INFO, "<10676>Please reduce the size of this directory to allow future incremental backups.  See Avamar NDMP documentation for further details.");
    }

    
    const ubigint64 de_inode(info->direlemp->inode_number64());
    
    
    
    
    const MetadataId metadataid(hash);
    
    
    
    get_end_offsets(info->direlemp);
    if (inodetab.use_inode_tree) {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory(),
                           (info->direlemp->get_location().get_abs_offset_in_container() + info->direlemp->get_location().get_header_size()).value(),
                           &childlist, &cur_synthlist, &prev_synthlist, hdroffset, dataoffset, padoffset, extattroffset);
    } else {
        
        inodetab.add_entry(de_inode, metadataid, info->direlemp->file_size(), true, info->direlemp->is_directory(), 0, 0, 0, 0,
                           hdroffset, dataoffset, padoffset, extattroffset);
    }

    
    
    
    if (!info->direlemp->is_dirrec_present(KIND_EXTRA_DIR_SIZES) && info->direlemp->is_directory()) {
        if (msg1) DB->msg("backzfstardir::commit_directory_metadata  Creating EXTRA_DIR_SIZES dirrec for empty directory '%s'", *info->direlemp->name());
        info->direlemp->increment_dirsizes(0, 0, 0);
    }

    
    
    
    if (info->use_container && flags.incremental && info->direlemp->is_directory()) {
        location loc(info->direlemp->get_location());
        loc.set_checksum_value(loc.get_checksum().value ^ merged_checksum);
        info->direlemp->set_location(loc);
        if (msg2) DB->msg("backzfstardir::commit_directory_metadata  Checksum for %s modified to %u (included %u from previous backup)",
                          *info->direlemp->name(), loc.get_checksum().value, merged_checksum);
    }
}

void backzfstardir::get_end_offsets(DIRELEMp& de)
{
    dirrec_pack::regions drr(de.getimpl());
    data_regions::endoffsets_t eoff;
    if (!drr.get(eoff)) return;
    hdroffset = dataoffset = padoffset = extattroffset = 0;
    for (data_regions::endoffsets_t::iterator itr = eoff.begin(); itr != eoff.end(); itr++) {
        if (itr->first == data_regions::header) hdroffset = itr->second.value();
        else if (itr->first == data_regions::primarydata) dataoffset = itr->second.value();
        else if (itr->first == data_regions::padding) padoffset = itr->second.value();
        else if (itr->first == data_regions::ads) extattroffset = itr->second.value();
    }
}


#include "common.h"
#include "debug.h"
#include "restelem.h"
#include "streamtransformbackupread.h"
#include "streamtransform.h"
#include "restorestreamstate.h"
#include "data_regions.h"

#define disable_data_regions_primarydata_restore ((xflag[22]&134217728) != 0)


restelem::restelem(const upath& path_, DIRELEM& direlem_,
                   const filestatsref& fstats_ ,
                   bool checkrange_ ,
                   const volinfo vinfo_ ,
                   const fileoffset startbyte_ , const fileoffset endbyte_ )
 : path(path_), direlem(direlem_), fstats(fstats_),
   vinfo(vinfo_),
   startbyte(startbyte_), endbyte(endbyte_),
   restdircycle(NULL), ppipe_control(0), dpninx(dpn0), m_prss(NULL),
   checkrange(checkrange_), isroot(false), rawmode(false), ignoreStats(false), isprefetching(false), ischangeblockappend(false),
   m_bSpecialZipProcessingEngaged(false),
   m_bSpecialCelerraProcessingEngaged(false)
{ }

restelem::restelem(const ustring& matchpath_, const upath& path_, DIRELEM& direlem_,
                   const filestatsref& fstats_ ,
                   bool checkrange_ ,
                   const volinfo vinfo_ ,
                   const fileoffset startbyte_ , const fileoffset endbyte_ )
  : matchpath(matchpath_), path(path_), direlem(direlem_), fstats(fstats_),
    vinfo(vinfo_),
    startbyte(startbyte_), endbyte(endbyte_),
    restdircycle(NULL), ppipe_control(0), dpninx(dpn0), m_prss(NULL),
    checkrange(checkrange_), isroot(false), rawmode(false), ignoreStats(false), isprefetching(false), ischangeblockappend(false),
    m_bSpecialZipProcessingEngaged(false),
    m_bSpecialCelerraProcessingEngaged(false)
{ }


restelem::restelem(const upath& path_, DIRELEM& direlem_,
                   const filestatsref& fstats_, fileref& data_, const ucontainer::basep containerp_)
 : path(path_), direlem(direlem_), fstats(fstats_), data(data_), 
   restdircycle(NULL), container(containerp_), ppipe_control(0), dpninx(dpn0), m_prss(NULL),
   checkrange(false), isroot(false), rawmode(false), ignoreStats(false), isprefetching(false), ischangeblockappend(false),
   m_bSpecialZipProcessingEngaged(false),
   m_bSpecialCelerraProcessingEngaged(false)
{ }


restelem::restelem(fileref& data_)
 : data(data_),
   restdircycle(NULL), ppipe_control(0), dpninx(dpn0), m_prss(NULL),
   checkrange(false), isroot(false), rawmode(false), ignoreStats(false), isprefetching(false), ischangeblockappend(false),
   m_bSpecialZipProcessingEngaged(false),
   m_bSpecialCelerraProcessingEngaged(false)
{ }

restelem::restelem()
 : restdircycle(NULL), ppipe_control(0), dpninx(dpn0), m_prss(NULL),
   checkrange(false), isroot(false), rawmode(false), ignoreStats(false), isprefetching(false), ischangeblockappend(false),
   m_bSpecialZipProcessingEngaged(false),
   m_bSpecialCelerraProcessingEngaged(false)
{ } 


restelem::restelem( const restelem &rhs )
{
   matchpath = rhs.matchpath;
   path = rhs.path;
   direlem = rhs.direlem;
   fstats = rhs.fstats;
   data = rhs.data;

   vinfo = rhs.vinfo;
   startbyte = rhs.startbyte;
   endbyte = rhs.endbyte;

   restdircycle = rhs.restdircycle;
   container = rhs.container;
   ppipe_control = rhs.ppipe_control;
   dpninx = rhs.dpninx;
   m_prss = rhs.m_prss;

   checkrange = rhs.checkrange;
   isroot = rhs.isroot;
   rawmode = rhs.rawmode;
   ignoreStats = rhs.ignoreStats;
   isprefetching = rhs.isprefetching;
   ischangeblockappend = rhs.ischangeblockappend;

   m_bSpecialZipProcessingEngaged = rhs.m_bSpecialZipProcessingEngaged; 
   m_bSpecialCelerraProcessingEngaged = rhs.m_bSpecialCelerraProcessingEngaged; 
}


restelem::~restelem()
{
    if( m_bSpecialZipProcessingEngaged ) {
      
      
      
      
      
    }
}

bool restelem::enableSpecialZipProcessing(const bool shrinkofficexml)
{
    
    ustring usExtension = direlem.file_name_extension();
    if(shrinkofficexml && direlem.useBackupOps() && StreamtransformZip::isExtensionSpecialZip( usExtension.tostr() ) ) {
        m_bSpecialZipProcessingEngaged = true;
        Out->msg(INFO, "Office XML ZIP Detected %s", direlem.fullpath().image().tostr() );
        m_prss = new RestoreStreamState(direlem.useBackupOps() ? rst_ntfs : rst_none);
    }
    return m_bSpecialZipProcessingEngaged;
}

bool restelem::enableSpecialCelerraProcessing(const fileref& compressordata)
{
    m_bSpecialCelerraProcessingEngaged = true;
    if (m_prss != NULL) {
        DB->warn("restelem::enableSpecialCelerraProcessing should not have m_prss set when called");
        delete m_prss;
    }
    m_prss = new RestoreStreamState(rst_emctar_dedup, compressordata);
    return true;
}

ustring restelem::specialCelerraImage() const
{
    if (m_bSpecialCelerraProcessingEngaged) {
        return ustring::sprintf("enabled m_prss %p and st image %s", m_prss, (m_prss != NULL) ? *m_prss->stImage() : "null");
    }

    return ustring::sprintf("disabled m_prss %p", m_prss);
}


void restelem::exportdata(const fileoffset foOffset, fileref& frWriteThis)
{
    bool transform = ( m_bSpecialZipProcessingEngaged && (NULL != m_prss) ) 
        || (m_bSpecialCelerraProcessingEngaged && (NULL != m_prss));

    if(transform) {
        
        
        
        bool bSegmentReady = m_prss->queueStreamSegment(foOffset, frWriteThis);

        while( bSegmentReady ) { 
            fileoffset fo = m_prss->getBytesRetrieved();
            fileref fr = m_prss->retrieveStreamSegment(bSegmentReady);

            if( fr.size64() > 0 ) {
                fr.makecontiguous();
#if SYSTEM_WINDOWS
         
#elif SYSTEM_UNIX_LINUX
         
#endif
                data.setslice64(fo, fr, true);
            }
        }
    } else { 
        data.setslice64(foOffset, frWriteThis, true);
    }
}


bool restelem::querySecondPassRequired(void)
{
    bool bRetVal = false;
    if( m_bSpecialZipProcessingEngaged && (NULL != m_prss) ) {
        bRetVal = m_prss->signalEndOfPass();
        if( !bRetVal ) {
            delete m_prss; 
            m_prss = NULL;
        }
    }
    return bRetVal;
}

bool restelem::prep_restore_of_slice(const hashcode& h, const fileoffset &start, const fileoffset &end)
{
    
    

    direlem.set_hash(h);
    startbyte = start;
    endbyte = end;
    
    fileoffset range(endbyte - startbyte);
    checkrange = ( (startbyte>0) || (range>0) );
    if (range > 0)
        endbyte -= 1;
    direlem.set_file_size(range);
    return true;
}

bool restelem::init_data_regions_primarydata()
{
    if (disable_data_regions_primarydata_restore)
        return false;

    
    dirrec_pack::regions drp(&direlem);
    data_regions::endoffsets_t endoffsets;
    if (!drp.get(endoffsets))
        return false;

    bool found = data_regions::findrange(endoffsets, 
                                         data_regions::primarydata,
                                         true,
                                         startbyte,
                                         endbyte);
    fileoffset startads, endads;
    bool foundads = data_regions::findrange(endoffsets, data_regions::ads, true, startads, endads);

    if (!found) {
        DB->warn("restelem::init_data_regions_primary found KIND_REGIONS (%s) with no primarydata section for '%s'",
                 *data_regions::image_endoffsets(endoffsets),
                 *direlem.fullpath().image());
        return false;
    }

    if (foundads) {
        
        
        if (endads + 1 == startbyte) startbyte = startads;
        if (endads == startbyte)     startbyte = startads;
    }
    fileoffset range(endbyte - startbyte);
    
    
    

    checkrange = ( (startbyte > 0) || (range > 0) );
    if (range > 0) {
        
        
        
        endbyte -= 1;
    }
    
    if (direlem.file_size() > (endbyte - startbyte)) {
        
        
        direlem.set_file_size(range);
    }
    return true;
}

bool
restelem::is_celerra_streamslice_restore(const DIRELEM& direlem, const pidtype &backup_pid, const pidtype &running_pid)
{
    

    
    
    bool has_dr = direlem.is_stream_slice();

    bool ret = ( (backup_pid.number() == (pidtype::os_celerra + pidtype::ndmp)) &&
                 (running_pid.number() == (pidtype::os_celerra + pidtype::ndmp)) &&
                 has_dr );

    
    

    return ret;
}

ustring restelem::image() const
{
    return ustring::sprintf("matchpath:'%s' path:'%s' data.isnull():%d vinfo:%s startbyte:%s endbyte:%s restdircycle:%p checkrange:%d isroot:%d rawmode:%d ignorestats:%d isprefetching:%d ischangeblockappend:%d zip:%d specialcelerra:%d",
                            *matchpath, *path.image(), data.isnull(), *vinfo.image(), 
                            *startbyte.image(), *endbyte.image(), restdircycle, 
                            checkrange, isroot, rawmode, ignoreStats, isprefetching, ischangeblockappend,
                            m_bSpecialZipProcessingEngaged, m_bSpecialCelerraProcessingEngaged);
}
#include "direlem_netapp.h"
#include "dirrec.h"
#include "direlemimpl.h"
#include "debug.h"
#include "dirrec_pack.h"

#define dbg ((xflag[2]&8192)!=0)

void DIRELEM_netapp::add_netapp_acl(int aclinode, const fileref& acldata) {
    dirrec_pack::netapp_acl nac(this);
    nac.set(aclinode, acldata);
}

bool DIRELEM_netapp::get_netapp_acl(int32_t& aclinode, fileref& acldata) const {
    dirrec_pack::netapp_acl nac(this);
    return nac.get(aclinode, acldata);
}

void DIRELEM_netapp::reset_netapp_LARA(const int namelen) {
    dirrec_pack::netapp_LARA dr(this);
    dr.reset(namelen);
    if(dbg)DB->msg("DIRELEM_netapp::reset_netapp_LARA(%d)", namelen);
}

void DIRELEM_netapp::add_netapp_LARA(const int namelen, const fileref ldata) {
    dirrec_pack::netapp_LARA dr(this);
    dr.append(namelen, ldata);
    if(dbg)DB->msg("DIRELEM_netapp::add_netapp_LARA(%d, %s)", namelen, ldata.start());
}

bool DIRELEM_netapp::get_netapp_LARA(filereflist& ldata)  {
    dirrec_pack::netapp_LARA dr(this);
    return dr.get(ldata);
}

#if !defined(RESTISILONSSLICEFILE_H_INCLUDED)
#define RESTISILONSSLICEFILE_H_INCLUDED












#include "common.h"
#include "cycle.h"
#include "layout.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "fileoffset.h"
#include "utar_flags_info.h"
#include "hashcode.h"
#include "ade_restore.h"
#include "isilontarpipe.h"
#include "isilontarstream.h"
#include "restdataproducer.h"



class restisilonsslicefile : public bicycle, nsAdeLib::ADERestore {
public:
    restisilonsslicefile(bicycle* parent, const hashcode& hash,
                         DIRELEM& direlem, cycle* starter = NULL,
                         ucontainer::basep  rest_container = NULL);

    virtual void init();
    
    virtual void handleData(fileoffset foOffset, fileref& restoreData);
    virtual void childdone(cycle* child);
    virtual ~restisilonsslicefile();

    SAFEPOOLALLOC(restisilonsslicefile);

protected:
    restelem info;

private:
    bool process_header_buffer(const fileref& buf, DIRELEMp& realde,
                               const MetadataId &metadataid, isilontarstream::parser& p);

    cycle* restore_section(data_regions::section_t sectiontype,
                           data_regions::endoffsets_t& endoff,
                           DIRELEM& de,
                           bool fromend, fileref& outslice,
                           ustring& errmsg);

    void process_regular_file();
    void process_link_to_reg();
    void process_reg_or_link_to_link();
    void update_sparse_file_attributes();
    void update_link_to_reg_attributes();
    void output_header_to_stream(isilontarstream::parser& p);
    void init_real_location_data();

    bool decrementfilecount;

    
    int phase;

    
    
    isilontarpipe* ppipe_control;

    
    
    data_regions::endoffsets_t eoff;
    data_regions::endoffsets_t realeoff;
    DIRELEMp realde;
    DIRELEMp tmpde;
    fileref realbuf;
    fileref tmprealbuf;
    fileref tmpcurbuf;
    fileoffset realsize;
    fileoffset tmpsz;
    MetadataId real_metadataid;
    hashcode realh;
    bool isregularfile;
    bool islnk;
    bool isfirst;
    ustring errmsg;
    isilontarstream::parser* parser_real;
    isilontarstream::parser* parser_current;
    ubigint64 dir_offset;
    location real_loc;
    location cur_loc;
    bool use_container;
    bool setactivelimit;

    
    const bool catalog_enabled;
};

#endif





















#include "common.h"
#include "debug.h"
#include "backatom.h"
#include "todoelem.h"
#include "context.h"
#include "chunktype.h"
#include "compelem.h"
#include "msgpack_c.h"
#include "utar_flags_info.h"

int backatom_msg = 0;

backatom::backatom(BackCycle *parent, hashcode hash, const fileref& data, bool dolookup) 
  : BackCycle(parent, ((workelem*)NULL) )
{
    this->hash = hash;
    this->data = data;
    this->dolookup = dolookup;
    todoEnqueue(TODO_CHUNK, this);
}

void backatom::init() {
    if(flags.degenerate) {
        notifyparent();
        return;
    }
    inlookup = true;
    if(dolookup) {
        message inargs;
        msgpack_c::hashispresent hip(inargs);
        hip.arg(PACK, hash);
        
        inargs.body().kind = chunktype::atomic.ckind();
        sendRemoteCall(this, inargs);
    } else {
        message null;
        response(null);
    }
}

void backatom::response(message& outargs) {
    message inargs;

    if( backatom_msg ) DB->msg("backatom::response inlookup=%d hash=%s", inlookup, *hash.partialimage());
    if(inlookup) {
        
        if(! outargs.isnull() && outargs.isgoodresponse() && !flags.ignoreispresent ) {  
            if( backatom_msg ) DB->msg("backatom::response lookup suceeded, returning");
            main->addfilebytes(context::backupstats, data.size());    
            main->getstatsobj(context::backupstats)->byteprogress(stats::ispresent, data.size(), filestatsref(), chunktype::atomic, main->handling_system_info());
            notifyparent();
        } else {
            if( backatom_msg ) DB->msg("backatom::response lookup failed, enter %s", *hash.partialimage());
            msgpack_c::addhashdata  addhashdata_message(inargs);
            chunktype kind = chunktype::atomic;
            addhashdata_message.arg(PACK, hash, kind, data);
            inlookup = false;
            sendRemoteCall(this, inargs);
        }
    } else {
        if( backatom_msg ) DB->msg("add_hash_data succeeded, %s", *hash.partialimage());
        
         if(!outargs.isgoodresponse() && 
           (outargs.responsecode() == MSG_ERR_UNNECESSARY) ) {
            DB->msg( "enter unnecessary %s", *outargs.ximage());
        } else if( outargs.isgoodresponse()) {
            if( backatom_msg ) DB->msg("good add_hash_data succeeded, %s", *hash.partialimage());
        } else {
            DB->error( "backatom::response bad response %s hash=%s kind=%d", 
                       *outargs.ximage(), *hash.partialimage(), outargs.body().kind);
        }

        assert(outargs.responsecode() != MSG_ERR_ENTER_FAILED);  
        main->addfilebytes(context::backupstats, data.size());        
        main->getstatsobj(context::backupstats)->byteprogress(stats::sent, data.size(), filestatsref(), chunktype::atomic, main->handling_system_info());
        notifyparent();
    }
}

backatom::~backatom() {
}

#if !defined(SYNCCALLMULT_H_INCLUDED)
#define SYNCCALLMULT_H_INCLUDED












#include "ade/interfaceade_flags.h"

class msgvect;
class context;


class synccallmult {
public:
    
    synccallmult(context& main_, dpns dpninx_ = dpn0) : main(main_), dpninx(dpninx_) {}

    
    void call(msgvect& inargs, msgvect& outargs);

    SAFEALLOC(synccallmult);

private:
    context &main;
    const dpns dpninx;
};

#endif
#include "common.h"
#include "output.h"
#include "exception.h"
#include "fileddr.h"
#include "ddr_interface.h"


#if DDRSUPPORTED





fileddr::fileddr(const DDR_HANDLE handle_, const ustring& containerlsu_, const ustring& containerpath_, const ustring& containername_)
    : fsize(0), tail(0), debugMsgsOn((xflag[25]&8) != 0), 
      m_containerlsu(containerlsu_), m_containername(containername_), m_containertype("CAT"),
      isclosed(true), result(EXIT_OK), m_containerhandle(0), m_checksumtype(1),
      m_containerpath(containerpath_), m_handle(handle_), m_fileddrtype(UNKNOWN)
{
    
}

fileddr::~fileddr()
{
    
}








fileddrread::fileddrread(const DDR_HANDLE handle_,
                         const ustring &lsu_,
                         const ustring &clientid_,
                         const ubigint64 backupid_,
                         const unsigned int streamindex)
    : fileddr(handle_ , lsu_, clientid_, ""),
      backupid(backupid_),
      m_clientid(clientid_),
      m_backup_handle(handle_),
      m_container_index(streamindex),
      m_wsh(0)
{
    ddp_uint64_t flags = 0; 
    ustring avClientID = m_clientid; 

    try
    {
        m_r = new ddrfs_reader(handle_, flags);

        if (!m_r.isnull())
        {
            unsigned int error = 0;

            if ((backupid_ != 0) && (streamindex <= 0xFFFF0000))
            {
                
                ustring backupid = tostr((ubigint64)backupid_,16).upper();

                
                ustring prevBackupDir = ustring("/") + ustring(DDR_CUR_DIR) + ustring("/") + avClientID; 

                Out->msg(INFO, "Opening DD stored file system container %s/%s for restore operation, Data Domain system provides ddr_files.xml.",
                    *prevBackupDir, *backupid );

                
                m_r->openContainer(backupid, prevBackupDir, m_container_index,   error); 
            }
            else
            {
                
                m_r->openContainer(lsu_, avClientID ,  error);
                Out->msg(INFO, "Opened DD stored file system container '%s/%s' for restore operation, Avamar server provides ddr_files.xml.",
                    *lsu_, *avClientID );
            }
        }
        else
        {
        }
    }
    catch(ddrfs_readerexception& e)
    {
        
        
        
        
        
        
        
        Out->msg((e.ErrorCode() == (dd_errno_t)AVAMAR_ERR_NOT_FOUND) ? WARN : ERR,
                 "%s",
                 *e.Description());

        this->result = EXIT_MISC;
    }

    m_fileddrtype = READ_RESTORE;
}



fileddrread::fileddrread(const DDR_HANDLE handle_,
                         const ustring &lsu_,
                         const ustring &clientid_,
                         const ubigint64 backupid_,
                         const unsigned int streamindex,
                         const ddrfiles_xmlp ddrfilesxmlp_)
    : fileddr(handle_ , lsu_, clientid_, ""),
      m_ddrfilesxmlp(ddrfilesxmlp_),
      backupid(backupid_),
      m_clientid(clientid_),
      m_backup_handle(handle_),
      m_container_index(streamindex),
      m_wsh(0)
{
    ddp_uint64_t flags = 0; 
    ustring avClientID = m_clientid; 

    try
    {
        m_r = new ddrfs_reader(handle_, flags);

        if (!m_r.isnull())
        {
            if ((backupid_ != 0) && (streamindex <= 0xFFFF0000))
            {
                
                ustring backupid = tostr((ubigint64)backupid_,16).upper();

                
                ustring prevBackupDir = ustring("/") + ustring(DDR_CUR_DIR) + ustring("/") + avClientID; 

                Out->msg(INFO, "<18076>Opening DD stored file system container %d in %s/%s for restore operation, using pre-fetched ddr_files.xml.",
                    m_container_index, *prevBackupDir, *backupid );

                
                m_r->openContainer(backupid, prevBackupDir, m_container_index, m_ddrfilesxmlp,  m_backup_handle); 
            }else{
                
                m_r->openContainer(lsu_, avClientID ,  m_backup_handle);
            }
        } else {

        }
    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "DDR read exception: %s", e.Description().tostr());
        result = EXIT_MISC;
    }

    m_fileddrtype = READ_RESTORE;
}


fileddrread::fileddrread(const DDR_HANDLE handle_,
                         const fileref& frwrite,
                         const ustring &clientid_,
                         const ubigint64 backupid_,
                         const unsigned int streamindex,
                         const ddrfiles_xmlp ddrfilesxmlp_)
    : fileddr(handle_, "", clientid_, ""),
      m_ddrfilesxmlp(ddrfilesxmlp_),
      backupid(backupid_),
      m_clientid(clientid_),
      m_backup_handle(handle_),
      m_container_index(streamindex),
      m_wsh(0)
{
    ddp_uint64_t flags = 0; 
    ustring avClientID = m_clientid;

    try
    {
        
        
        fileddrwrite *frw = dynamic_cast<fileddrwrite*>(frwrite.base());

        
        ustring backup_id = tostr((ubigint64)backupid_,16).upper();

        
        ustring prevBackupDir = ustring("/") + ustring(DDR_CUR_DIR) + ustring("/") + avClientID;

        
        ddrfiles_xmlp ddr_files_xml(m_ddrfilesxmlp);

        if( ddr_files_xml.isnull()){ 
                
                
                
            ddrfs_backupp b = new ddrfs_backup(m_handle, flags);
            b->get_ddr_files(prevBackupDir, backup_id, ddr_files_xml);
        }

        
        
        frw->associate(prevBackupDir, backup_id, ddr_files_xml, this->m_backup_handle);

        
        m_frw = frwrite;

    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "%s", *e.Description());
        result = EXIT_MISC;
    }

    m_fileddrtype = READ_BACKUP;
}


fileddrread::fileddrread(const DDR_HANDLE handle_,
                         const fileref& frwrite,
                         const ustring &lsu_,
                         const ustring &absName_)
    : fileddr(handle_, lsu_, "", ""),
      m_clientid(absName_),
      m_backup_handle(handle_),
      m_wsh(0)  
{
    backupid = 0;
    m_container_index = 0;

    try
    {
        
        
        fileddrwrite *frw = dynamic_cast<fileddrwrite*>(frwrite.base());

        if(frw == NULL) throw ddrfs_readerexception ("frwrite.base() is not type fileddrwrite", __FILE__, __LINE__);

        
        backupid = frw->get_temp_backupID();
        
        m_container_index = frw->get_temp_streamID();

        ustring backup_id = tostr((ubigint64)backupid,16).upper();

        
        
        frw->associate(lsu_, absName_, backup_id, this->m_backup_handle);

        
        m_frw = frwrite;
    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "%s", *e.Description());
        result = EXIT_MISC;
    }

    m_fileddrtype = READ_BACKUP;
}

fileddrread::~fileddrread()
{
    

    
    if (m_fileddrtype == READ_BACKUP)
    {
        
        fileddrwrite *frw = dynamic_cast<fileddrwrite*>(m_frw.base());
        if (frw != NULL)
        {
            frw->disassociate(m_backup_handle);
        }
    }
}


int fileddrread::startchecksum(fileoffset& begin_offset)
{
    m_r->beginMarker(begin_offset);
    return EXIT_OK;
}

int fileddrread::endchecksum(  fileoffset& begin_offset,
                                       fileoffset& length,
                                       uint32_t* checksum)
{
    m_r->endMarker(begin_offset, length, checksum);
    return EXIT_OK;
}

int fileddrread::readfilenext(const size_t len, void* buf)
{
    if ((len > 0x7FFFFFFF) || (len <= 0)) return 0;

    int bytesRead(0);
    int maxBytesToRead((int)len);
    try
    {
        bytesRead = m_r->readNextSlice(maxBytesToRead, buf);
    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "%s", *e.Description());
        result = EXIT_MISC; 
        return 0;
    }

    if(debugMsgsOn)
        DB->msg("fileddrread::readfilenext buffer size requested: %d returning buffer size: %i", maxBytesToRead, bytesRead);

    return bytesRead;
}








void fileddrread::getslice64(fileoffset offset, int size, void *res) const
{
    try
    {
        m_r->readNextSlice(offset, size, res);
    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "%s", *e.Description());

        
        throw e;
    }
}

fileoffset fileddrread::seek(const fileoffset offset, int whence)
{
    try
    {
    if (m_r->setOffset(offset, whence) == 0)
    {
        return (m_r->getOffset() );
    }
    else
    {
        
        return (m_r->getOffset() );
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    }
    catch(ddrfs_readerexception& e)
    {
        Out->msg(ERR, "%s", *e.Description());
    }

    return offset;
}


fileref fileddrread::makeslice64( fileoffset offset,  fileoffset length,  tchecksum::tchecksumval* checksum)
{
    fileref slice;
    
    ddr_interface::initddrslice(slice,
                                this,               
                                m_backup_handle,    
                                m_container_index,  
                                offset,             
                                length,             
                                checksum);          
    return slice;
}


fileref fileddrread::makeslice64( fileoffset offset,  fileoffset length)
{
    fileref slice;
    
    ddr_interface::initddrslice(slice,
                                this,               
                                m_backup_handle,    
                                m_container_index,  
                                offset,             
                                length,             
                                NULL);              
                                                    
    return slice;
}

fileoffset fileddrread::offset() const
{
    return (m_r != NULL) ? m_r->getOffset() : 0;
}

fileoffset fileddrread::offset64() const
{
    return (m_r != NULL) ? m_r->getOffset() : 0;
}



fileddrwrite::fileddrwrite( const DDR_HANDLE handle_,  const ustring& containerlsu_,  const ustring& containerpath_,  const ustring& containername_)
    : fileddr(handle_, containerlsu_, containerpath_, containername_), m_wsh(0)
{
    bid_count = 0xF0000000;
    sid_count = 0xF0000000;
    m_filecount = 0;
    isclosed = false;

    
    m_fileddrtype = WRITE_BACKUP;

    if (m_containerlsu.isempty())
    {
        DB->msg("fileddrwrite::fileddrwrite: delaying creation of container '%s' until first use", *m_containername);
    }
    else
    {
        DB->msg("fileddrwrite::fileddrwrite: delaying creation of container '%s/%s' until first use", *m_containerlsu, *m_containername);
    }
}

void fileddrwrite::close()
{
    if (isclosed) {
        DB->msg("fileddrwrite::close called but we are already closed");
        return;
    }

    if (m_b != NULL)
        m_b->closeContainer();
    isclosed = true;
    return;
}

fileddrwrite::~fileddrwrite()
{
    close();
}

unsigned int fileddrwrite::get_temp_backupID()
{
    return (++bid_count);
}

unsigned int fileddrwrite::get_temp_streamID()
{
    return (++sid_count);
}


int fileddrwrite::startchecksum(fileoffset& begin_offset)
{
    assert(!isclosed);
    result = EXIT_OK;

    if (m_b == NULL && !create_ddrfs_backup())
        return EXIT_MISC;
    try
    {
        m_b->beginMarker(begin_offset);

        ustring s;

        if (debugMsgsOn)
           DB->msg( "File marker: beginning offset %s",
                     *tostr(begin_offset.value()));
    }
    catch(ddrfs_backupexception& e)
    {
        result = EXIT_MISC;
        Out->msg(ERR, "%s", *e.Description());
    }

    return result;
}

int fileddrwrite::endchecksum(  fileoffset& begin_offset,
                                fileoffset& length,
                                uint32_t* checksum)
{
    assert(!isclosed);
    result = EXIT_OK;

    if (m_b == NULL && !create_ddrfs_backup())
        return EXIT_MISC;
    try
    {
        m_b->endMarker(begin_offset, length, checksum);

        ustring s;

        if (debugMsgsOn)
           DB->msg( "File marker: beginning offset %s end offset %s length %s",
                     *tostr(begin_offset.value()),
                     *tostr(length.value() + begin_offset.value()),
 		             *tostr(length.value()));
    }
    catch(ddrfs_backupexception& e)
    {
        result = EXIT_MISC;
        Out->msg(ERR, "%s", *e.Description());
    }

    return result;
}

bool fileddrwrite::ddrstats(   const filebase::ddrfilestats kind,
                              ubigint64& stat,
                               const filebase::ddrstats_priority priority )
{
    try
    {
        if (!isclosed && m_b != NULL)
            return m_b->ddrstats(kind, stat, priority);
    }
    catch (...)
    {
    }

    return false;
}

void fileddrwrite::append( const fileref& data)
{
    assert(!isclosed);
    result = EXIT_OK;

    if (m_b == NULL && !create_ddrfs_backup())
    {
        result = EXIT_MISC;
        return;
    }
    try
    {
        fileddrslice* ddrslice = dynamic_cast<fileddrslice*>(data.base());

        if (ddrslice != NULL) { 
            fileddrread* ddrread = dynamic_cast<fileddrread*>(ddrslice->get_parent().base());

            if ((ddrread == NULL) || (ddrread->get_parent().base() != this)) {
                throw fileddr_exception("Invalid use of a slice. The slice does not belong to this write object.", __FILE__, __LINE__);
            }

            uint32_t slice_checksum = 0;
            bool isChecksumValid = false;

            isChecksumValid = ddrslice->get_slice_checksum( &slice_checksum );

            
            
            
            
            
            
            
            

            
            m_b->synthesizeToContainer( ddrslice->get_backup_handle(),      
                                        ddrslice->get_container_handle(),   
                                        ddrslice->get_slice_offset(),       
                                        ddrslice->get_slice_length(),
                                        isChecksumValid ? &slice_checksum : NULL, 
                                        m_append_starting_offset);          
            ddrslice->set_newoffset(m_append_starting_offset);
            m_currentoffset += ddrslice->get_slice_length();

        }
        else{ 
            
            
            m_b->sendDataToContainer( data );
            m_currentoffset += data.size64();
        }
    }
    catch (const fileddr_exception &e)
    {
        result = EXIT_MISC;
        Out->msg(ERR, "%s", *e.Description());

        throw e;
    }
    catch(ddrfs_backupexception& e)
    {
        result = EXIT_MISC;
        Out->msg(ERR, "%s", *e.Description());

        
        throw e;
    }
    
    
}

void fileddrwrite::associate( const ustring &prevBackupDir,
                              const ustring &backupid_,
                              const ddrfiles_xmlp &ddrfiles_ ,
                              unsigned int& backup_handle)
{
    if (m_b == NULL && !create_ddrfs_backup())
        return;
    m_b->associate( prevBackupDir, backupid_, ddrfiles_, backup_handle );
}

void fileddrwrite::associate( const ustring &lsu,
                              const ustring &absName,
                              const ustring &backupid_,
                              unsigned int& backup_handle)
{
    if (m_b == NULL && !create_ddrfs_backup())
        return;
    m_b->associate( lsu, absName, backupid_, backup_handle );
}

void fileddrwrite::disassociate(unsigned int backup_handle)
{
    if (m_b == NULL && !create_ddrfs_backup())
        return;
    m_b->closePreviousBackup(backup_handle);
}








bool fileddrwrite::create_ddrfs_backup()
{
    assert(m_b == NULL);
    try
    {
        
        const ddp_uint64_t flags = DDR_OVERWRITE_EXISTING_FILE;
        m_b = new ddrfs_backup(m_handle, flags);

        
        
        
        
        const ustring streamName(m_containerpath + ustring("/") + m_containername);

        
        m_b->createContainer(*m_containerlsu, *streamName, m_checksumtype);

        if (m_containerlsu.isempty())
        {
            DB->msg("fileddrwrite::create_ddrfs_backup: created container stream '%s'", *streamName);
        }
        else
        {
            DB->msg("fileddrwrite::create_ddrfs_backup: created container stream '%s/%s'", *m_containerlsu, *streamName);
        }

        
    }
    catch(ddrfs_backupexception& e)
    {
        result = EXIT_MISC;
        Out->msg(ERR, "%s", *e.Description());
    }

    if(result != EXIT_OK){
        if (m_containerlsu.isempty())
        {
            Out->msg(FATAL,"Could not create fileddr container %s for write, result: %d", *m_containername, result);
        }
        else
        {
            Out->msg(FATAL,"Could not create fileddr container %s/%s for write, result: %d", *m_containerlsu, *m_containername, result);
        }
        return false;
    }
    return true;
}

bool fileddrwrite::trace( uint16_t trace_type,
                          uint16_t payload_type,
                          const fileref& payload)
{
    try
    {
        if (!isclosed)
            return m_b->trace(trace_type, payload_type, (const void*)payload.start(), (size_t)payload.size());
    }
    catch (...)
    {
    }

    return false;
}

fileoffset fileddrwrite::offset() const
{
    return (m_b != NULL) ? m_b->getOffset() : 0;
}

fileoffset fileddrwrite::offset64() const
{
    return (m_b != NULL) ? m_b->getOffset() : 0;
}







fileddr_exception::fileddr_exception(dd_errno_t errCode, const char* file, int line)
          :
          _errCode(errCode),
          _file(file),
          _line(line)
{
    ustring msg(DDR_GetErrorString((DDR_HANDLE)errCode));

    if(!msg.isempty())
    {
        _desc = msg;
    }
}

fileddr_exception::fileddr_exception(dd_errno_t errCode, const char* description, const char* file, int line)
          :
          _errCode(errCode),
          _file(file),
          _line(line)
{
    ustring msg(DDR_GetErrorString((DDR_HANDLE)errCode));

    if(!msg.isempty())
    {
        _desc = msg;
        _desc+= " ";
        _desc+= description;
    }
}

fileddr_exception::fileddr_exception(const char* description, const char* file, int line)
          :
         _errCode(DD_ERR_ERROR_NOT_SET),
         _desc(description),
         _file(file),
         _line(line)
{
}

ustring fileddr_exception::Description() const
{
    return _desc;
}

dd_errno_t fileddr_exception::ErrorCode() const
{
    return _errCode;
}

ustring fileddr_exception::File() const
{
    return _file;
}

int fileddr_exception::Line() const
{
    return _line;
}

#endif

#if !defined(BACKVIEWTOP_H_INCLUDED)
#define BACKVIEWTOP_H_INCLUDED





























#include "common.h"
#include "tassoc.h"
#include "ustring.h"
#include "cycle.h"
#include "dumpdirelem.h"
#include "upath.h"
#include "vector.h"
#include "roothashlist.h"

#include "nbackdir_manual.h"
#include "snapview_xml.h"

class context;
class utar_commands;
class restdirelem;


class backviewtop : public BackCycle {
public:
    SAFEALLOC(backviewtop);

    backviewtop(BackCycle* parent, ustring filename_or_xml, fileoffset offset);
    virtual ~backviewtop();

    virtual void init();
    virtual void childdone(cycle *child);
private:
    cycle *child;
};



class backviewbase : public BackCycle {
public:
  
  struct pathentry {
      upath   fullname;  
      ustring saveas;    
      bool    internal;  
      bool    isdir;     
      SAFEPOOLALLOC(pathentry);
  };

  
  class pathentrylist : public undoo::vector<pathentry> {
  public:
      pathentrylist() : undoo::vector<pathentry>() {}
      SAFEPOOLALLOC(pathentrylist);
  };

protected:
  SAFEALLOC(backviewbase);

  backviewbase(BackCycle* parent, ustring filename_or_xml, fileoffset offset);
  ~backviewbase();

  virtual void init() = 0;
  virtual void childdone(cycle *child) = 0;

  virtual void response(message& outargs);  
  virtual void notifyparent();              

  
  
  
  bool setup();

  
  bool sort_valid_entries(snapview_xml& sv_xml);

  
  bool read_input(ustring input);
  bool read_and_quick_parse_file(ustring filename); 
  bool enter_path(xml_messagep mess);

  
  class viewtable : public tassoc<ustring, pathentrylist*> {
  public:
      viewtable(int n = 32)
        : tassoc<ustring, pathentrylist*>(n, false)  
      {}

      virtual bool keyeq(const ustring& a, const ustring& b) const {
          return a.equal(b);
      }
      SAFEPOOLALLOC(viewtable);

      ustring image();
      static ustring makekey(ustring clientname, int labelnum);
      static ustring getacnt(ustring key);
      static int     getlabelnum(ustring key);
  };

  
  ustring filename_or_xml;

  
  ustring saveacnt;  
  int expires;       
  ustring server;    
  ustring savelabel; 
  bool allowmixedbackups; 

  DIRELEM hiddendir;
  int files_included;  

  viewtable table; 
  undoo::vector<ustring> keylist;
};






class backview_plugin_merge : public backviewbase {
public:
    SAFEALLOC(backview_plugin_merge);

    backview_plugin_merge(BackCycle* parent, ustring filename_or_xml, fileoffset offset);
    ~backview_plugin_merge();

    virtual void init();
    virtual void childdone(cycle *child);

private:
    BackupRootInfoList* rhlistp;  
    ustring rhaccount;      
    nbackdir_manual* top_cycle; 

    
    bool prepare_container(const std::set<int> &ddrindices);

    
    bool get_roothashlistrec(const ustring acntname, const int labelnum, BackupRootInfo& backup_record, ustring& clientid);

    bool wrapup_merge(); 

    
    
    class nbackdirtable : public tassoc<ustring, nbackdir_manual*> {
    public:
        nbackdirtable(int n = 32)
          : tassoc<ustring, nbackdir_manual*>(n, false)  
        {}
        virtual bool keyeq(const ustring& a, const ustring& b) const {
            return a.equal(b);
        }
        SAFEPOOLALLOC(nbackdirtable);
        
    };
    nbackdirtable nbackdir_cycle_table;

    
    
    
    
    class restpaths : public bicycle {
    public:
        SAFEALLOC(restpaths);

        restpaths(BackCycle* parent,
                  const roothashlistrec backup_record, const pathentrylist& pathlist,
                  const ustring acntname,
                  const ustring clientid,
                  nbackdirtable& nbackdir_cycle_table,
                  int& _nsynth_reqs,
                  int& _nsynth_done);
        virtual ~restpaths();

        virtual void init();
        virtual void childdone(cycle *child);

    private:
        const roothashlistrec backup_record;  
        const pathentrylist& pathlist;
        const ustring acntname;
        const ustring clientid; 
        nbackdirtable& nbackdir_cycle_table;
        const int labelnum;
        size_t index;	
        location loc;	
        DIRELEM parentde; 

	int casesense;	
		
		
		
		
		
		
		
		
		
		
		
		
        int& nsynth_reqs;   
        int& nsynth_done;   

        bool enter_in_table(const restdirelem* child);
        void* find_parent_cycle(upath dirpath, const direlemp_list_type& direlems, int level,
                                const bool internal, const bool ADE_is_on);
    };

    enum phases {phase_init=0, phase_spawn_children=1, phase_forksdone=2, phase_backup_table};
    phases phase;
    bool set_phase(phases newphase);

protected:
    int nsynth_reqs;        
    int nsynth_done;        
};








class backview_global_merge : public backviewbase {
public:
    SAFEALLOC(backview_global_merge);

    backview_global_merge(BackCycle* parent, ustring filename_or_xml, fileoffset offset);

    virtual void init();
    virtual void childdone(cycle *child);

private:
    bool done;
    fileref listing;

    bool do_next_snapup();  
};

#endif
#if !defined(ZFSTARPIPE_H_INCLUDED)
#define ZFSTARPIPE_H_INCLUDED












#include "pipe_control.h"
#include "fileref.h"
#include "direlem.h"
#include "ustring.h"
#include "userid.h"
#include "paxndmp.h"

class zfstarpipe : public pipe_control {
public:
    
    zfstarpipe(fileref& data_, int zeroblockcount = 4096);

    bool addfile(const DIRELEM& elem,
                 const ustring& path,
                 fileref& dataslice,
                 fileref& altdataslice,
                 fileref& stubdataslice,
                 fileref& gsanextentsdata,
                 const filetype ftype = REGTYPE,
                 const ustring& linkname = "",
                 const fileoffset startoff = fileoffset(0));
    bool addobj(const filetype otype, const ustring& path, const DIRELEM& elem,
                const fileoffset datasize, fileref& dataslice);
    void set_data_slice(const fileref& hdrslice, const ustring& desc);
    void init_data_slice(fileref& dataslice, const fileoffset& size, const ustring& desc);
    void padd_end(fileoffset& size_of_stream);
    const hashcode get_dirslice_hash() const;

    SAFEALLOC(zfstarpipe);

protected:
    
    
    
    bool fillheader(fileref& header, fileoffset& filesize,
                    fileoffset& altdatasize, fileoffset& stubdatasize,
                    const DIRELEM& elem,  const ustring& path,
                    const filetype ftype, const ustring& linkname,
                    const fileoffset startoff);

    hashcode m_slicehash;
};

#endif

#if !defined(BACKRAND_H_INCLUDED)
#define BACKRAND_H_INCLUDED











               
#include "cycle.h"


class backrand : public BackCycle {
public:
    backrand(BackCycle *parent);
    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~backrand();
    SAFEALLOC(backrand);
    
    
    
    
};

#endif

#if !defined(NBACKFILE_H_INCLUDED)
#define NBACKFILE_H_INCLUDED















#include "hashcode.h"
class cycle;
#include "upath.h"
#include "file.h"

class fileref;
class DIRELEM;
class workelem;
class context;

class nbackfile : public BackCycle {
public:
    

    nbackfile(BackCycle *parent, workelem *info, const fileoffset offset, cycle * starter=NULL, int fd=-1, 
              const fileref& symlink_target_path_ref_ = fileref::empty);
    
    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);

    
    virtual void notifyparent();

    virtual ~nbackfile();

    static void print_listing(context *main, workelem *info, bool backed_up_data, bool showhash, const hashcode& hash);

    SAFEPOOLALLOC(nbackfile);
private:
    void set_phase(int phasenum); 

    void advance_progress_bytes_and_finish_cycle(DIRELEMp dep);

    void advance_progress_bytes_ads_and_finish_cycle(fileoffset& size);

    bool synthfile(DIRELEMp dep); 

    void backupfile();

    bool get_ads_size(DIRELEMp dep, fileoffset& size);

    ustring phase_image(int);     

    const bool flag_ddgsan2dd;    

    bool need_raw_container;      
    location::tcontainerid raw_containerid;

    int phase;                    
    bool started_thread;          

    upath path;
    fileoffset stat_file_size;      
    bigint64 myfileord; 

    fileref f;

    
    unsigned int synth_cache_atime;
    location     synth_loc;

    int file_desc;
    file file_obj;

    
    
    
    
    fileref symlink_target_path_ref;

    void HandleReparsePoint();

    
    int ProcessReparsePointBeforeFileOpen();

    
    bool NeedsReparsePointDirrec(const Reparse_Type repType) const;

    
    fileoffset GetExpectedProcessedSize(void);

    void set_hardlink_hash( const hashcode &hash, bool isatomic, const DIRELEM &dir );
    bool already_done_via_hardlink( hashcode &hash, const DIRELEM &dir );
    bool nbacklink   (workelem * info, hashcode& hash);


    bool check_cache(DIRELEMp direlem);  

    
    bool container_cachehit(DIRELEMp direlem, location loc, unsigned int cache_atime);

    
    bool is_raw_container_cachehit(DIRELEMp direlem, location loc, unsigned int cache_atime);

    
    bool should_create_new_thread(const todo_kind kind) const;

    
    void recycle(todo_kind kind);
};

#endif
#if !defined(FILENAME_CACHE_H_INCLUDED)
#define FILENAME_CACHE_H_INCLUDED


















#include "hashcode.h"
#include "mutex.h"
#include "filenames.h"
#include "univ.h"
#include "ade/cache.h"
#include "direlem.h"
#include "location_checker.h"

class upath;
class context;



class filename_cache
{
public:
    SAFEALLOC(filename_cache);

    filename_cache(context *main, const ustring name, bool is_paging_cache, int autoflushrate, bool include_atime);

    
    virtual bool iserror() { return !is_valid_cache; }
    virtual bool isshareerror() { return working_cache->isshareerror(); }
    virtual bool checkversion(bool oktoclear, bool& need_to_repair_cache) { return working_cache->checkversion(oktoclear, need_to_repair_cache); }
    void set_root_tag( hashcode root, int count, int date, int ddr_index = -1, ubigint64 backupid = 0) {
       working_cache->set_root_tag(root, count, date, ddr_index, backupid);
    }
    void validate(bool repaircache) { filename_callback_methods_type validate_methods(working_cache_format); working_cache->validate(repaircache, &validate_methods); }
    void close_cache() { scope s(update_mtex); working_cache->close_cache(); }
    void suppress_update() { working_cache->suppress_update(); }
    void set_incomplete() { working_cache->set_incomplete(); }
    bool have_previous_backup() const { return working_cache->have_previous_backup(); }
    int get_items_entered() { return working_cache->get_elements_entered(); }
    ubigint64 get_cache_size() const { scope s(update_mtex); return working_cache->get_cache_size(); }
    void define_stream(int streamnum) { scope s(update_mtex); working_cache->define_stream(streamnum); }
    void release_stream(int streamnum) { scope s(update_mtex); working_cache->release_stream(streamnum); }

    
    enum cache_format_t { CFT_BASE, CFT_ATIME, CFT_LOCATION };

    
    

    
      void put_file_info( const upath& fullpath,                
                          unsigned int mtime,                   
                          unsigned int size,                    
                          unsigned char attr,                   
                          unsigned char kind,                   
                          unsigned int extflags,                
                          int streamnum,                        
                          const hashcode& hashed_content,       
                          const bool isatom,                    
                          unsigned int atime );                 

    
      void put_file_info(const upath& fullpath,
                         const unsigned int size,               
                         const DIRELEMp de,                     
                                                                
                         const bool isatom,
                         const unsigned int atime,
                         const unsigned int extflags_or,        
                         int streamnum
      );

      
    
    
    
    
    
    
    
      bool get_file_info( const upath& fullpath,                
                          const unsigned int mtime,             
                          const unsigned int size,              
                          const unsigned char attr,             
                          const unsigned char kind,             
                          const unsigned int extflags,          
                          int streamnum,                        
                          hashcode& hashed_content,             

                          int &tagword,                         
                          bool& isatom,                         
                          unsigned int& atime,                  

                          location &loc,                        
                                                                
                          const bool update_tag                 
                          );                          

      
      bool tag_file_info( const upath& fullpath,                
                          const unsigned int mtime,             
                          const unsigned int size,              
                          const unsigned char attr,             
                          const unsigned char kind,             
                          const unsigned int extflags,          
                          int streamnum                         
                          );

      
      void put_chunk_info( const hashcode &src_hash,            
                           const hashcode &dst_hash,            
                           const unsigned int extflags,         
                           const int streamnum,                 
                           const bool isatom,                   
                           const unsigned int atime,            
                           location const &loc,                 
                           const fileoffset& filesize,          
                           const upath& fullpath = upath()      
                           );

      
      bool get_chunk_info( const hashcode &src_hash,            
                           int streamnum,                       
                           const fileoffset& filesize,          
                           hashcode& dst_hash,                  
                           int &tagword,                        
                           bool& isatom,                        
                           unsigned int& atime,                 
                           location& loc,                       
                           const bool update_tag                
      ) {
            return working_cache->lookup_result_miss() != metadata_lookup(src_hash, upath(), streamnum, filesize, dst_hash, tagword, isatom, atime, loc, update_tag);
      }

      
      
      void choose_root_tag(bool checkcache, bool assume_root_hashes_are_valid, bool readheader = true, dpns dpninx = dpn0);

      
      
      
      bool copy_forward(int stream_num, const location& old_location, const location& new_location, const hashcode& base_hash, int* file_count, int* dir_count);

      virtual ~filename_cache();
private:
    
    
    class filename_cache_element;

    
    int get_element_version() const;

    
    cache::lookup_result metadata_lookup( const hashcode &src_hash, 
                         const upath path,                    
                         int streamnum,                       
                         const fileoffset& filesize,          
                         hashcode& dst_hash,                  
                         int &tagword,                        
                         bool& isatom,                        
                         unsigned int& atime,                 
                         location& loc,                      
                         const bool update_tag);

    
    
    bool ignore_this_file(const upath& path) const;

    
    bool tag_chunk_info( const hashcode &src_hash,            
                         int streamnum,                       
                         const fileoffset& filesize);         

    context *main;
    bool is_valid_cache;
    int autoflushrate;
    mtex   update_mtex;                     

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    bool get_secondary_element_hash(const filename_cache_element& primary_element, hashcode* secondary_hash);
    cache::lookup_result filename_element_lookup(const hashcode& hash, int streamnum, filename_cache_element* found_element, hashcode* found_filehash, int* found_index, ubigint64* backup_id);
    bool filename_element_set(const filename_cache_element& source_element, const hashcode& filehash, int target_index, int streamnum, const fileoffset& file_size);

    
    
    
    class filename_callback_methods_type : public cache::callback_methods_type
    {
    public:
        filename_callback_methods_type(cache_format_t cache_format) : m_cache_format(cache_format), m_container_id(0), m_cf_file_count(0), m_cf_dir_count(0) {}
        virtual ~filename_callback_methods_type() {}
        SAFEPOOLALLOC(filename_callback_methods_type);
        NOCOPY(filename_callback_methods_type);

    public:
        
        
        
        virtual hashcode get_server_verify_hash(const cache::cache_element_type& element);

        
        
        virtual bool validate(const cache::cache_element_type& element);
        virtual void validate_summary();

        
        
        
        void set_copy_forward(const location& old_location, const location& new_location, const hashcode& base_hash);
        virtual bool apply_copy_forward(const cache::cache_element_type& element, cache::cache_element_type* modified_element);
        void get_copy_forward_counts(int* file_count, int* dir_count);

    private:
        const cache_format_t    m_cache_format;     

        
        location_checker        m_checkinfo;        

        
        fileoffset              m_region_start;     
        fileoffset              m_region_end;       
        fileoffset              m_offset_diff;      
        location::tcontainerid  m_container_id;     
        hashcode                m_base_hash;        
        int                     m_cf_file_count;    
        int                     m_cf_dir_count;     
    };

    
    const cache_format_t working_cache_format;
    cache* const working_cache;

    
    bool repl_use_secondary;        

    
    
    filename_cache* ro_cache;
    cache_format_t ro_cache_format;
    bool need_to_migrate(const ustring& old_filename, int* element_size);
};

#endif














#include "common.h"
#include "restroot2backupdir.h"
#include "restdir.h"
#include "restdirlist.h"
#include "restdata.h"
#include "restfileusingextents.h"
#include "filenames.h"
#include "avpaxpipe.h"
#include "cdsf_container.h"
#include "filemap.h"
#include "filerefx.h"

#include "context.h"

#define CONTAINER_1_ID           1
#define SYSTEM_INFO_CONTAINER_ID (CONTAINER_1_ID + 1)
#define NEXT_CONTAINER_ID        (SYSTEM_INFO_CONTAINER_ID + 1)


restroot2backupdir::restroot2backupdir(const BackupRootInfo& _backuprootinfo, const location& _metadataLocation, context& main_,
                                       const resource_identifier& ri_, const mediadesc& mediad_, const ustring& backupdirname,
                                       const DIRELEM *de , const location& parentdataloc )
  : multivolumeroot(&main_, *main_.getTodoQueue(), false ),
    bicycle(NULL, &main_),
    backuprootinfo(_backuprootinfo),
    backup_resource_identifier(ri_),
    mediad(mediad_),
    basepath(mediad.getdirpath() / backup_resource_identifier.backup_resource_path().parentdir().image() / backupdirname),
    metadataloc(_metadataLocation),
    phase(phase_construction),
    system_info_pipe_control(0),
    backup_pipe_control(0),
    containers(),
    next_container_id(NEXT_CONTAINER_ID)
{
    setasroot(this);

    
    flags.internal       = true;
    flags.restoresystem  = true;
    flags.restorehidden  = true;
    flags.notemporary    = false;
    flags.restorerootdir = true;
    flags.restoreshortnames = true;
    flags.restorewfp     = true;
    flags.archive_unfiltered_data = true;
    flags.dtoexportstream = true;
    
    xflag[22] |= 67108864;

    const pidtype pid_of_backup(backuprootinfo.getPluginType());
    
    if(pid_of_backup.kind() == pidtype::vcbimage ||
       pid_of_backup.kind() == pidtype::vcsvapp  ||
       pid_of_backup.kind() == pidtype::vmwappimage) {
        if(!flags.isexplicit("outofstream-patterns")) {
            flags.outofstream_patterns.push_back("*flat.vmdk");
        }
    }

    
    if(!mediad.createdirectories(upath(basepath))) {
        Out->msg(FATAL, "Creation of backup directory '%s' failed", *basepath);
        childdone(0);
        return;
    }

    cycle * child = new restdirlist(this, backuprootinfo.getRootLocation(), upath(), parentdataloc, top_level_list);
    child->noop();
    nforked++;
    phase = phase_retrieving_top_level_list;
}


void restroot2backupdir::init() {}


void restroot2backupdir::childdone(cycle *child)
{
    if(child) {
        ncollected++;

        switch(phase) {
        case phase_retrieving_top_level_list:
            
            
            
            if(!containers.startXmlBackupFileList()) {
                Out->msg(FATAL, "Unable to create containers list");
            }

            
            generate_backup_info_and_system_info_container(top_level_list);
            phase = phase_restoring_system_info;
            break;

        case phase_restoring_system_info:
            
            close_and_delete_pipe_control_object(system_info_pipe_control);

            
            top_level_list_names = top_level_list.keys();

            
            names_iterator = top_level_list_names.begin();

            
        case phase_restoring_backup_contents:
            if(!restore_backup_contents(names_iterator, top_level_list)) {
                
                outofstream_objlist = backup_pipe_control->retrieve_all_content_out_of_stream();

                
                close_and_delete_pipe_control_object(backup_pipe_control);

                
                for(direlemp_list_type::const_iterator it = outofstream_objlist.begin(); it != outofstream_objlist.end(); ++it) {
                    const DIRELEMp dep(*it);

                    
                    upath basefilepath;
                    const hashcode extentshash(retrieve_file_extents_hash(dep, basefilepath));

                    
                    const ustring filepath(basepath / dep->fullpath().image().replace(DIRSEP, "_"));

                    fileref transport;
                    if(initmediafileref(transport, filepath, true, basefilepath.image())) {
                        restelem re(dep->fullpath(), *dep, filestatsref(), transport);
                        cycle* child = new restfileusingextents(this, *dep, re, extentshash);
                        if(child) {
                            child->noop();
                            nforked++;

                            
                            add_container(next_container_id++, location::tformat::raw, filepath.stripdir(), dep->fullpath(), true);
                        }
                    }
                }
                phase = phase_restoring_outofstream_files;
            } else {
                phase = phase_restoring_backup_contents;
            }
            break;

        case phase_restoring_outofstream_files:
            break;

        default:
            assert("restroot2backupdir entered invalid phase" == 0);
            break;
        }
    }

    if(nforked == ncollected) {
        
        {
            const ustring filepath(basepath / CONTAINERSFILES_FILENAME);

            fileref transport;
            if(initmediafileref(transport, filepath)) {
                transport.append(containers.fimage());
            }
        }

        todoEnqueue(TODO_DONE);
        notifyparent();
    }
}

restroot2backupdir::~restroot2backupdir()
{
    close_and_delete_pipe_control_object(system_info_pipe_control);
    close_and_delete_pipe_control_object(backup_pipe_control);
}


void restroot2backupdir::close_and_delete_pipe_control_object(avpaxpipe*& pcpref)
{
    if(avpaxpipe* pcp = pcpref) {
        pcpref = 0;

        
        fileoffset size_of_stream;
        pcp->padd_end(size_of_stream);

        
        delete pcp;
    }
}


avpaxpipe* restroot2backupdir::init_avpaxpipe_control(const ustring& containername) const
{
    avpaxpipe* ret(0);

    const ustring containerfilepath(basepath / containername);

    fileref transport;
    if(initmediafilerefpipe(transport, containerfilepath)) {
        
        
        ret = new avpaxpipe(transport, flags.streamformat_out, ustring(),
                            (ucontainer::base::flags_generate_stream |
                             ucontainer::base::flags_nondir_is_file | ucontainer::base::flags_generate_flatten_direlem_on_descend |
                             (flags.archive_unfiltered_data ? ucontainer::base::flags_archive_unfiltered_data : 0) |
                             ucontainer::base::flags_objnames_only),
                            -1, ustring(), 0, fileref(),
                            flags.restorebuffermb
                            );
    }

    if(ret && flags.archive_unfiltered_data) {
        ret->set_archive_unfiltered_data();
    }

    if(!ret) {
        Out->msg(FATAL, "Unable to create %s format container %s",
                 *utar_flags_info::streamformat_image(flags.streamformat_out), *containerfilepath);
    }

    return ret;
}


void restroot2backupdir::generate_backup_info_and_system_info_container(const name_to_direlemp_table& top_level_list)
{
    
    {
        const xml_messagep infoxmlp = cycle::main->gather_existing_backup_info_xml(backuprootinfo.getRootLocation(), &backuprootinfo);
        if(!infoxmlp.isnull()) {
            const ustring filepath(basepath / EXPORTSTREAM_METADATA_FILENAME);
            fileref datafile;
            if(initmediafileref(datafile, filepath)) {
                datafile.append(infoxmlp->fimage());
            }
        }
    }

    
    const DIRELEMp dep(top_level_list.lookup(UNDOO_DIRECTORY_NAME));
    if(!dep.isnull() && dep->is_internal()) {
        const baselocation_sp mdloc(dep->get_metadataLocation());
        const location        loc  (dep->get_location());

        const upath fullpath(dep->fullpath());
        if((system_info_pipe_control = restroot2backupdir::init_avpaxpipe_control(SYSTEM_INFO_CONTAINER_FILENAME))) {
            restelem info(fullpath.image(), fullpath, *dep, filestatsref(), false);
            info.container = 0;
            info.ppipe_control = system_info_pipe_control;

            cycle* newchild = new restdir(this, dep->get_location(), info, NULL, NULL, false);
            newchild->noop();
            nforked++;

            
            add_container(SYSTEM_INFO_CONTAINER_ID, location::tformat::cdsf, SYSTEM_INFO_CONTAINER_FILENAME, fullpath, false);
        }
    }
}



bool restroot2backupdir::restore_backup_contents(undoo::vector<ustring>::const_iterator& names_iterator,
                                                 const name_to_direlemp_table& direlem_table)
{
    while(names_iterator != top_level_list_names.end()) {
        const ustring name(*names_iterator);

        if(!direlem_table.defined(name)) {
            Out->msg(ERR, "Processing error: Cannot find table entry for direlem for '%s'", *name);
        } else {
            DIRELEMp dep(direlem_table.lookup(name));

            
            if(name != UNDOO_DIRECTORY_NAME || !dep->is_internal()) {
                
                if(!backup_pipe_control) {
                    if((backup_pipe_control = restroot2backupdir::init_avpaxpipe_control(CDSF_CONTAINER_1_FILENAME))) {
                        for(int i = 0; i < flags.outofstream_patterns.size(); i++) {
                            backup_pipe_control->match_content_out_of_stream(flags.outofstream_patterns[i]);
                        }
                    } else {
                        throw EXC_CANCEL;
                    }

                    
                    add_container(CONTAINER_1_ID, location::tformat::cdsf, CDSF_CONTAINER_1_FILENAME, upath(), false);
                }

                
                
                cycle::main->set_location_info(ustring("restroot2backupdir"), location(), *dep);

                
                

                restelem info(dep->fullpath().image(), dep->fullpath(), *dep, filestatsref(), false);
                info.container = 0;
                info.ppipe_control = backup_pipe_control;

                cycle* newchild = new restdir(this, dep->get_location(), info, NULL, NULL, false);
                newchild->noop();
                nforked++;

                names_iterator++;

                DB->msg("restroot2backupdir::restore_backup_contents(): processing backup container %s => nforked %d",
                        *dep->name(), nforked);

                return true;
            }
        }

        names_iterator++;
    }

    return false;
}






bool restroot2backupdir::check_resource_on_media(const upath& backup_resource_path, const upath& backup_object_path, upath& container_path) const
{
    bool ret(false);

    if(mediad.subdirectory_exists(backup_resource_path)) {
        
        const upath basepath(upath(mediad.getdirpath()) / backup_resource_path);
        const upath filepath(basepath / CONTAINERSFILES_FILENAME);

        
        fileref datafile;
        ddrfiles_xml previous_backup_containers;
        if(initmediafileref(datafile, filepath.image(), false) && previous_backup_containers.loadXmlBackupFileList(datafile)) {
            bool whole_container(false);
            const emd_elementp emdp(previous_backup_containers.queryEmd(backup_object_path, false, whole_container));

            
            if(!emdp.isnull() && whole_container && emdp->streamType == location_types::tformat::raw) {
                container_path = basepath / emdp->DDRFileName;
                ret = true;
            }
        }
    }

    return ret;
}




hashcode restroot2backupdir::retrieve_file_extents_hash(const DIRELEMp dep, upath& path) const
{
    hashcode ret(hashcode::zero);

    path = upath();
    if(!dep.isnull()) {
        
        int hashoffset(-1);

        
        if(dep->is_dirrec_present(KIND_CHANGEBLOCK)) {
            const dirrec_pack::changeblock changeblock_dirrec(dep.getimpl());
            fileref resourceidentifier_data;
            if(changeblock_dirrec.get(resourceidentifier_data, hashoffset)) {
                DB->msg("restroot2backupupdir::retrieve_file_extents_hash found change block extents dephash index %d",
                        hashoffset);

                const resource_identifier ri(resourceidentifier_data);
                if(ri.valid()) {
                    const upath objpath(ri.object_path());

                    DB->msg("restroot2backupupdir::retrieve_file_extents_hash resource identifer %s", *ri.image());

                    upath tmppath;
                    if(check_resource_on_media(ri.backup_resource_path(), objpath, tmppath)) {
                        path = tmppath;
                        Out->msg(INFO, "Using previous backup resource for replication of %s", *objpath.image());
                    } else {
                        
                        hashoffset = -1;
                    }
                } else {
                    Out->msg(WARN, "Invalid resource identifier for object %s", *dep->fullpath().image());
                    
                    hashoffset = -1;
                }
            } else {
                DB->msg("restroot2backupupdir::retrieve_file_extents_hash %s has no change block information", *dep->fullpath().image());
            }
        }

        
        if(hashoffset < 0 && dep->is_dirrec_present(KIND_DATA_EXTENTS)) {
            dirrec_pack::data_extents data_extents_dirrec(dep.getimpl());
            if(data_extents_dirrec.get(hashoffset)) {
                DB->msg("restroot2backupupdir::retrieve_file_extents_hash found existence extents dephash index %d",
                        hashoffset);
                Out->msg(INFO, "Using data existence extents for replication of %s", *dep->fullpath().image());
            }
        }

        
        if(hashoffset >= 0) {
            hashvect hashes;
            dep->getdephashes(hashes);
            if(static_cast<size_t>(hashoffset) < hashes.size()) {
                ret = hashes[hashoffset+1];
            }
        }
    }

    DB->msg("restroot2backupupdir::retrieve_file_extents_hash returning hash %s for object %s",
            *ret.partialimage(), *dep->fullpath().image());

    return ret;
}


void restroot2backupdir::add_container(const location::tcontainerid containerid,
                                       const location::tformat::type containerformat,
                                       const ustring& containerpath,
                                       const upath& objectpath,
                                       const bool content_only)
{
    
    if(!containers.createXmlEmdElementForBackupFile(containerid, containerformat,
                                                    objectpath.parentdir().image(), objectpath.stripdir(),
                                                    objectpath.image(), containerpath, content_only) ||
       !containers.addXmlEmdElementForBackupFile(containerid)) {
        Out->msg(FATAL, "Unable to add container entry for %s", *containerpath);
    }
}



bool restroot2backupdir::initmediafileref(fileref& fr, const ustring& filepath, bool writeobject , const ustring& basefilepath ) const
{
    
    mediadesc tmpmediad(mediad);

    
    tmpmediad.setpath(filepath);
    if(!basefilepath.isempty()) {
        tmpmediad.setbase(basefilepath);
    }

    
    const bool ret(tmpmediad.init_fileref(fr, writeobject));
    if(!ret) {
        Out->msg(ERR, "Error initializing output container for %s", *filepath);
    }

    return ret;
}




bool restroot2backupdir::initmediafilerefpipe(fileref& fr, const ustring& filepath, const ustring& basefilepath ) const
{
    bool ret(false);

    
    fileref intermediate_fr;
    if((ret = initmediafileref(intermediate_fr, filepath, true, basefilepath))) {
        fileref tmpfr;

        filerefx::initfilerefpipe(tmpfr, intermediate_fr);
        if((ret = !tmpfr.iserror())) {
            fr = tmpfr;
        } else {
            Out->msg(ERR, "Error initializing pipe to output container for %s", *filepath);
        }
    }

    return ret;
}


#if !defined(RESTDIRLISTPRODUCER_H_INCLUDED)
#define RESTDIRLISTPRODUCER_H_INCLUDED











#include "cycle.h"
#include "common.h"
#include "restdataproducer.h"



class restdirlistproducer : public bicycle, restdataproducer::consumer
{
public:
    SAFEALLOC(restdirlistproducer);

    
    class consumer {
    public:
        consumer() {}
        virtual ~consumer() {}

        
        virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer * const producer) = 0;
    };

    restdirlistproducer(cycle* parent, consumer *callback_, const location& _metadataloc, const location &parent_loc_, const ustring& msgid_ = "unknown", const dpns dpninx=dpn0);

    
    
    
    
    
    
    virtual void rdpconsume(const fileref& buf, const fileoffset& listingoffset, restdataproducer * const producer);

    virtual ~restdirlistproducer();

    virtual void init();
    virtual void childdone(cycle *child);

    
    
    void terminate();

private:
    NOCOPY(restdirlistproducer);

    restdataproducer *childrdp;
    bool inorder;
    const bool have_parent_loc;   
    const location parent_loc;
    consumer *callback;
    bool terminated;
    const ustring msgid;
    const location metadataloc;
    dpns dpninx;
    GetChildrenState_sp catalog_state;

    void process_direlem_list(direlemp_list_type_sp& delist);
    void process_direlem(DIRELEMp de);

    
    
    DEFINE_STL_MAP_TYPE(location::tcontainerid, fileoffset) running_coverage_size;

    void launch();
    ubigint64 get_direlem_inode_number(DIRELEMp de);

};


#endif


#if !defined(BACKAVPAXSTREAM_H_INCLUDED)
#define BACKAVPAXSTREAM_H_INCLUDED












#include "fileref.h"
#include "scalar.h"
#include "cycle.h"
#include "direlem.h"
#include "fileoffset.h"
#include "dataextents.h"
#include "paxrec.h"
#include "ade_backup.h"
#include "statistic.h"
#include "backdataconsumer.h"
#include "shared_ptr.h"
#include "mediadesc.h"

class cycle;
class workelem;             
class utar_flags_info;
class upath;
class filemem;
class parsestream_base;
class inode_table;

class exportstream_xmlp;

class backavpaxstream : public BackCycle,
                      nsAdeLib::ADEBackup,        
                      backdataconsumer::producer  
{

public:
  SAFEALLOC(backavpaxstream);

  enum {
      flag_none                    = 0x0000,
      flag_should_output_listing   = 0x0001,
      flag_delete_parser           = 0x0002,
      flag_is_system_info_contents = 0x0004,
      flag_use_cycles_location     = 0x0008,

      
      flag_subcycle_mask           = flag_is_system_info_contents | flag_use_cycles_location,
  };

  
  
  
  
  backavpaxstream(BackCycle* parent_, context* main, workelem *info_,
                  parsestream_base *parser, int traverse_depth,
                  exportstream_xmlp& infop, direlemp_list_type_sp delist_sp, unsigned objflags_);

  virtual ~backavpaxstream();

  virtual void init();
  virtual void childdone(cycle *child);

  
  virtual fileref nextdatablock(bool& suppress_requeue);

protected:
  
  const ustring m_objname;

  
  const bool m_isdir;

  
  const int traverse_depth;

  
  
  const unsigned objflags;

  
  paxrec m_paxrecs;

  
  parsestream_base *parser;

  
  ubigint64 get_headflags(const paxrec& paxrecs) const;

  
  bool check_headflag(const ubigint64 flag, const paxrec& paxrecs) const;

  
  fileref build_listing(fileoffset& totalsize, const bool flags_inode) const;

  
  
  
  

  
  
  
  const direlemp_list_type_sp m_delist_sp;

  
  bool listing_output;

  
  
  bool found_object;

private:
  NOCOPY(backavpaxstream);

  
  
  
  bool found_backupexport_metainfo;

  
  
  exportstream_xmlp& exportstream_infop;
};

#endif
















#ifndef BACKUPBOOSTDIR_H
#define BACKUPBOOSTDIR_H














#include "common.h"
#include "cycle.h"
#include "backhidden.h"
#include "tassoc.h"
#include "backupboostutils.h"
#include "backdataconsumer.h"
#include "restdirlistproducer.h"
#include "fileref.h"
#include "backupboost_interface.h"

namespace backupboost
{
class backupboostdir : public BackCycle,
                       public restdirlistproducer::consumer,
                       public backdataconsumer::producer
{
public:
    SAFEPOOLALLOC(backupboostdir);

    
    
    
    
    
    
    
    
    backupboostdir(BackCycle *parent, cycle *root_,
                   workelem *info, int traverse_depth_, ubigint64 session_id_,
                   backupboost::backupboost_interface::lfs_handle token_,
                   inode_table &inode_tab_, hardlink_path_table &hardlink_path_tab_,
                   backupboost::path2event_table &bbeventlist_, utar_flags_info *vol_flags_,
                   BackupRootInfo &prev_backup_);

    virtual ~backupboostdir();
    virtual void init();
    virtual void childdone(cycle *child);

    virtual void rdlpconsume(const direlemp_list_type_sp &direlems, restdirlistproducer *const producer);
    virtual fileref nextdatablock(bool &suppress_requeue);

private:
    NOCOPY(backupboostdir);
    void backupboost_begin_full();
    void backupboost_end_full();
    void set_sysinfo_data();
    void set_work_results();
    void set_session_time_entry();
    void do_sysinfo_hidden();

    enum phases {
        phase_init              = 0,  
        phase_read_events       = 1,  
        phase_wait_for_prevlist = 2,  
        phase_merge             = 3,  
        phase_get_listing       = 4,  
        phase_sys_info          = 5,  
        phase_write_listing     = 6,  
        phase_done              = 7   
    };

    void set_phase(int new_phase);

    ustring phase_image(int phasenum)
    {
        switch(phasenum) {
        case phase_init:              return "phase_init"; break;
        case phase_read_events:       return "phase_read_events"; break;
        case phase_wait_for_prevlist: return "phase_wait_for_prevlist"; break;
        case phase_merge:             return "phase_merge"; break;
        case phase_get_listing:       return "phase_get_listing"; break;
        case phase_sys_info:          return "phase_sys_info"; break;
        case phase_write_listing:     return "phase_write_listing"; break;
        case phase_done:              return "phase_done"; break;
        default:                      return "unknown"; break;
        };
    }

    
    void determine_volume_offset();
    void add_directory_to_container();

    
    
    
    bool get_next_direlem(DIRELEMp &obj_direlem);
    
    void process_direlem(DIRELEMp  obj_direlem);
    
    bool populate_direlem(const bbevent &event_info, const ubigint64 &event_inode,
                          const upath &event_path, DIRELEMp& obj_direlem);
    
    
    bool skip_event(const bbevent &event_info);
    
    
    
    void insert_self(DIRELEMp obj_direlem);

    
    void request_prevlist();

    
    void merge_prevlist();

    
    
    
    
    
    void synth_block(const ubigint64 &block_begin,
                     const bigint64 &block_size,
                     const tchecksum::tchecksumval &block_checksum,
                     const ubigint64 &inode_number = (ubigint64)0,
                     const ubigint64 &dir_header_size = (ubigint64)0);

    
    
    void synth_file_block();

    ustring dir_path;
    cycle *root;

    
    
    inode_table &inodetab;

    
    
    
    
    hardlink_path_table &hardlink_path_tab;

    
    
    
    backupboost::path2event_table &bbeventlist;

    
    
    utar_flags_info *vol_flags;

    
    BackupRootInfo &prev_backup;

    
    bool thread_started;

    
    DIRELEMp sysinfo_de;

    
    
    
    
    direlemp_list_type cur_direlem_list;

    
    int cur_list_index;
    int prev_list_index;

    
    
    ubigint64 session_id;

    
    static ubigint64 session_time;

    
    
    backupboost::backupboost_interface::lfs_handle token;

    
    bool incremental;

    
    bool top_level;

    
    
    int traverse_depth;

    
    
    
    
    
    bool new_directory;

    
    int current_phase;

    
    
    ustring mount_point_path;

    
    DIRELEMp save_obj_direlem;

    
    
    direlemp_list_type prev_direlem_list;

    
    
    
    std::set<ubigint64> remove_list;

    inode_table::child_dir_list childlist;  
                                            

    
    
    
    
    
    
    
    
    
    fileoffset synthblock_offset;
    fileoffset synthblock_coversize;
    tchecksum::tchecksumval synthblock_checksum;

    int file_desc;

    fileref symlink_target_path_ref;
};
}

#endif 
#if !defined(RESTORE_PREFETCHMANAGER_H_INCLUDED)
#define RESTORE_PREFETCHMANAGER_H_INCLUDED












#include "mutex.h"
#include "dpnobject.h"

struct tprefetchblock;
class tprefetchwork;
class hashcode;
class fileoffset;

class restore_prefetchmanager {
public:
    SAFEALLOC(restore_prefetchmanager);
    restore_prefetchmanager() {}
    virtual ~restore_prefetchmanager() {}

    
    
    virtual bool advance() = 0;

    virtual void hint(const dpnobj *obj) = 0;

    
    virtual bool fill(tprefetchblock &b) = 0;

    
    virtual bool reset(const tprefetchwork &work) = 0; 

    

    virtual bool isdone() const = 0;

 protected:
    
    virtual bool advancefile() = 0;
};


class depthfirst_prefetchmanager : public restore_prefetchmanager {
public:
    depthfirst_prefetchmanager(const fileoffset &ringblocksize_);
    virtual ~depthfirst_prefetchmanager();

    
    virtual bool advance();

    virtual void hint(const dpnobj *obj);

    virtual bool fill(tprefetchblock &b);

    virtual bool reset(const tprefetchwork &work); 

    

    virtual bool isdone() const { return done; }

protected:
    virtual bool advancefile();

    std::vector<dpnobj::iterator *> directorystack;

    bool hasdir;
    bool hasfile;

    
    dpnobj::iterator *currentdir;

    
    hashcode h;

    
    fileoffset start, end, max;

    fileoffset ringblocksize;
    bool done;

    
};


#endif 
#include "common.h"
#include "debug.h"
#include "workelem.h"
#include "output.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "backdirmerge.h"
#include "restdirlist.h"
#include "nbackroot.h"
#include "backhidden.h"
#include "timer.h"
#include "utar_commands.h"
#include "sortdirwalk.h"        
#include "filenames.h"          
#include "ddr_interface.h"      


#define MAXLISTINGBYTES (128*1024)

#define bdm_msg ((xflag[30]&2048)!=0)

backdirmerge::backdirmerge(BackCycle* parent,   
                           workelem* info_,      
                           DIRELEMp& prevdp_,
                           DIRELEMp& currdp_,
                           int traverse_depth_)
    : BackCycle(parent, info_),
    prevdp(prevdp_),
    currdp(currdp_),
    phase(phase_start),
    traverse_depth(traverse_depth_),
    previndex(0),
    currindex(0),
    curindex(0),
    ddrSysInfo(NULL)
{
    assert(!(prevdp.isnull() || currdp.isnull()));
    
    
    
    
    
    
    
    
    final_stage = flags.backupstate == utar_flags_enums::backstate_final;
    if (final_stage)
        assert(prevdp->file_hash() == currdp->file_hash());
    else assert(prevdp->file_hash() != currdp->file_hash());

    curr_loc = currdp->get_location();

    
    merging_roots = prevdp->is_root() && currdp->is_root();
    if (merging_roots)
        if (bdm_msg) DB->msg("backdirmerge::backdirmerge merging roots");

    if (final_stage && !merging_roots) {
        Out->Abort("Merging for the final stage not at the root!");
        return;
    }

    info->direlemp = new DIRELEM(*currdp);      
    
    
    
    
    merge_to_ddr = info->use_container && !info->container.isnull();

    
    
    if(merging_roots && merge_to_ddr) {
        
        fileref cur_ddrfilesxml_data;

        
        
        const exitcodes_t resultOK(main->getAdeMgr()->get_ddrfilesdata(cur_ddrfilesxml_data, true));

        if(resultOK == EXIT_OK && !cur_ddrfilesxml_data.isnull() && cur_ddrfilesxml_data.size64() > 0) {
            
            ddrfiles_xmlp xmlp(new ddrfiles_xml());
            xmlp->loadXmlBackupFileList(cur_ddrfilesxml_data);

            
            
            curr_loc = main->fill_in_location_clientid_and_backupid(curr_loc);

            
            curr_loc.set_backupid(location::tbackupid::partial_cur_backupid);

            
            ddr_interface::set_ddr_files(curr_loc.get_clientid(), curr_loc.get_backupid(), xmlp);
        } else {
            Out->msg(ERR, "Unable to retrieve the ddr_files.xml information for the new data in the partial backup");
        }
    }
    if (final_stage) {
        if (flags.ddrenabled) {     
            
            
            
            utar_flags_info fakeflags;
            fakeflags.path = flags.path;
            fakeflags.label = flags.label;
            fakeflags.labelnum = flags.labelnum;
            fakeflags.incpartials = true;

            
            hfs_info_struct& hfsinfo = main->getAdeMgr()->getHfsInfo(dpn0);
            blkpath dpnacnt(flags.path);
            blktraj new_blktraj(dpnacnt);
            hfsinfo.blk = new_blktraj;

            utar_flags_info dstflags;  
            utar_commands uc(fakeflags, hfsinfo, dstflags);

            
            ddrSysInfo = new DataDomainSysInfo;
            ddrSysInfo->fileName = DATADOMAINFILES_FILENAME;   
            const BackupRootInfo backupInfo(location::media::gsan, prevdp->file_hash());        
            if (!uc.get_ddrfiles_xml(backupInfo, ddrSysInfo->fileName, ddrSysInfo->ddrfilesData) ||
                ddrSysInfo->fileName.isempty() || ddrSysInfo->ddrfilesData.isnull())
            {
                Out->Abort("Unable to get ddr_files.xml data from DDR for backup %d, time %"LL"d '%s' %d",
                    flags.labelnum, flags.snapuptime,
                    *ddrSysInfo->fileName, ddrSysInfo->ddrfilesData.isnull());
                return;
            }
            if (bdm_msg) DB->msg("backdirmerge::backdirmerge: got '%s'", *ddrSysInfo->fileName);
        }
        
    } else if (merge_to_ddr) {        
        
        main->getAdeMgr()->getStagingPath(staging_path);
        if (merging_roots) {
            info->container = main->initnextucontainer(info->direlemp, false);
            if (info->container.isnull()) { 
                Out->Abort("Unable to create new container for partial merge");
                return;
            }
            
            if(info->container->set_ddr_staging_path(staging_path) != ucontainer::pce__success) {
                DB->msg("backdirmerge::backdirmerge: Unable to set container staging path : '%s'", *staging_path);
            }

            
            location myloc(info->direlemp->get_location());
            myloc.set_containerid(info->container->containerid);
            info->direlemp->set_location(myloc);
            if (bdm_msg) DB->msg("backdirmerge::backdirmerge: New root location: '%s'", *info->direlemp->get_location().image());
        }
    }

    todoEnqueueInsert(TODO_DIR, this, -traverse_depth); 
}


void dump_listing(const direlemp_list_type& list)
{
    for (unsigned i = 0; i < list.size(); i++) {
        DB->msg("backdirmerge::dump_listing: [%d] '%s'", i, *list[i]->name());
    }
}

void backdirmerge::init()
{
    if (bdm_msg) DB->msg("backdirmerge::init this %p phase %d, merging roots %d final %d ddrSysInfo %p", this, phase, merging_roots, final_stage, ddrSysInfo);
    if (!uapp::staging().canRun()) {
        if (nforked == ncollected)      
            notifyparent();
        return;
    }
    switch (phase) {
        case phase_start:
        {
            if (bdm_msg) DB->msg("backdirmerge::init phase %d: merging '%s' and '%s'", phase, *prevdp->name(), *currdp->name());
            if (bdm_msg) {
                DB->msg("backdirmerge::init prev loc '%s'", *prevdp->get_location().image());
                DB->msg("backdirmerge::init curr loc '%s'", *curr_loc.image());
                DB->msg("backdirmerge::init  new loc '%s'", *info->direlemp->get_location().image());
            }

            
            if (flags.isexplicit("case_sensitive"))
                casesensitive = flags.case_sensitive;
            else
                casesensitive = ! ((prevdp->get_kind() && prevdp->ignorecase()) || (currdp->get_kind() && currdp->ignorecase()));

            
            
            if (!final_stage && !merging_roots && merge_to_ddr) {
                ucontainer::errortype errcode(info->container->begindir(info->direlemp.getimpl()));
                if (errcode != ucontainer::pce__success) {
                    Out->Abort("Directory header staging for '%s' failed (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                    notifyparent();
                    return;
                }
                if (bdm_msg) DB->msg("backdirmerge::init       ucontainer %d after begindir    loc:%s", info->container->containerid, *info->direlemp->get_location().image());
                errcode = info->container->begindircontent(info->direlemp.getimpl());
                if (errcode != ucontainer::pce__success) {
                    Out->Abort("Directory header content staging for '%s' failed (%s)",
                        *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                    notifyparent();
                    return;
                }
                if (bdm_msg) DB->msg("backdirmerge::init       ucontainer %d after begindircontent:%s", info->container->containerid, *info->direlemp->get_location().image());
            }

            
            if (bdm_msg) DB->msg("backdirmerge::init - getting restdirlist from prev %s tree, location '%s'",
                *prevdp->file_hash().partialimage(), *prevdp->get_location().image());
            
            const location prevLoc(location::media::gsan, prevdp->file_hash());
            restdirlist* prevchild = new restdirlist(this, prevLoc, upath(), prevdp->get_location(), prevlisting);
            prevchild->noop();  
            nforked ++;

            
            if (!final_stage) {
                
                if (bdm_msg) DB->msg("backdirmerge::init - getting restdirlist from curr %s tree, location '%s'",
                    *currdp->file_hash().partialimage(), *curr_loc.image());
                
                const location currLoc(location::media::gsan, currdp->file_hash());
                restdirlist* currchild = new restdirlist(this, currLoc, upath(), curr_loc, currlisting);
                currchild->noop();
                nforked++;
            }
            phase = phase_restlistings;
            break;
        }

        case phase_hiddendir:
            
            
            
            if (merging_roots) {
                if (!final_stage && merge_to_ddr) {
                    ADEMgrX* adeMgr = main->getAdeMgr();
                    if (!adeMgr) {
                        Out->Abort("Unable to get ADE Manager to clear temporary ddr_files.xml");
                        notifyparent();
                        return;
                    }
                    if (!adeMgr->deleteDDRStagingFile(DATADOMAINFILES_FILENAME)) {
                        Out->Abort("Unable to delete temporary ddr_files.xml");
                        notifyparent();
                        return;
                    }
                    main->finalizeucontainer(info->container, false);  
                    nbackroot *nbr = dynamic_cast<nbackroot *>(parent);
                    assert(nbr);
                    nbr->set_ucontainer_finalized();

                    
                    
                    const ddrfiles_xmlp curr_xmlp(ddr_interface::get_ddr_files(0, curr_loc.get_clientid(), curr_loc.get_backupid()));
                    
                    if(!curr_xmlp.isnull()) {
                        emd_elementp emdp;
                        if(!curr_xmlp.isnull() && curr_xmlp->get_XmlEMD_count() > 0 && curr_xmlp->first_XmlEmd(emdp)) {
                            do {
                                
                                if (!adeMgr->deleteDDRStagingFile(emdp->DDRFileName)) {
                                    Out->Abort("Unable to delete temporary staging container '%s' for partial merge", *emdp->DDRFileName);
                                    notifyparent();
                                    return;
                                }
                                
                                if (!adeMgr->deleteDDRStagingFile(emdp->DDRFileName + DATADOMAINFILES_TRACEEXT)) {
                                    Out->Abort("Unable to delete temporary staging container '%s' for partial merge", *(emdp->DDRFileName + DATADOMAINFILES_TRACEEXT));
                                    notifyparent();
                                    return;
                                }
                            } while(curr_xmlp->next_XmlEmd(emdp));
                        }
                    }

                    
                    
                    if (flags.incremental && (flags.streamformat_in == utar_flags_enums::streamformat_emctar ||
                                              flags.streamformat_in == utar_flags_enums::streamformat_isilon ||
                                              flags.streamformat_in == utar_flags_enums::streamformat_zfs)) {
                        if (!adeMgr->deleteDDRStagingFile(TEMP_CONTAINER_FILENAME)) {
                            Out->Abort("Unable to delete temporary staging container '%s' for partial merge", TEMP_CONTAINER_FILENAME);
                            notifyparent();
                            return;
                        }
                        const ustring tracefilename((ustring)TEMP_CONTAINER_FILENAME + DATADOMAINFILES_TRACEEXT);
                        if (!adeMgr->deleteDDRStagingFile(tracefilename)) {
                            Out->Abort("Unable to delete temporary staging container '%s' for partial merge", *tracefilename);
                            notifyparent();
                            return;
                        }
                    }
                }
                if (!flags.nohiddendir) {
                    DIRELEMp de = new DIRELEM;
                    de->zero();  
                    epoch_t now((epoch_t)timer::now());
                    de->initialize(hashcode::zero, now, now, now, fileoffset(0), ATTR_DIRECTORY|ATTR_INTERNAL, UNDOO_DIRECTORY_NAME);
                    de->set_fullpath(upath(UNDOO_DIRECTORY_NAME));
                    de->set_unix_attributes(0666, 0, 0);
                    workelem *w = new workelem(info, de->fullpath(), de, filestatsref());
                    w->use_container = false;
                    
                    
                    if (bdm_msg) DB->msg("backdirmerge::init: calling backhidden with ddrSysInfo %p", ddrSysInfo);
                    backhidden *hidden = new backhidden(this, w, 0, 0, false, true, ddrSysInfo);
                    hidden->noop();
                    nforked++;
                    break;
                }
            }
            
            
            
            
            phase = phase_finishmerge;   

        case phase_finishmerge:
        {
            if (bdm_msg) dump_listing(newlisting);
            cycle *child = new backdataconsumer(this, info, this, true);
            child->noop();
            nforked++;
            if (bdm_msg) DB->msg("backdirmerge::init: started backdataconsumer child nforked %d ncollected %d", nforked, ncollected);
            break;
        }

        default:
            
            DB->msg("backdirmerge::init - unexpected phase %d!", phase);
            assert(false);
    }
}

void backdirmerge::response(message& outargs)
{
}


void dump_rdlisting(const name_to_direlemp_table& list)
{
    undoo::vector<ustring> names = list.keys();
    for (unsigned i = 0; i < names.size(); i++) {
        DB->msg("backdirmerge::dump_rdlisting: [%d] '%s'", i, *names[i]);
    }
}

void backdirmerge::childdone(cycle* child)
{
    if (child) ncollected++;

    if (!uapp::staging().canRun()) {
        if (nforked == ncollected)      
            notifyparent();
        return;
    }
    if (bdm_msg) DB->msg("backdirmerge::childdone this %p, phase %d, nforked %d, ncollected %d",
        this, phase, nforked, ncollected);
    if (nforked > ncollected) return; 
    assert(nforked == ncollected); 

    switch (phase) {
        case phase_restlistings:
            
            
            
            
            
            
            
            phase = phase_mergelistings;
            if (bdm_msg) DB->msg("backdirmerge::childdone: advancing to phase %d", phase);
            mergesome();
            break;

        case phase_mergelistings:
        case phase_hiddendir:   
        {
            assert(child != NULL);
            
            
            if (child == NULL) {
                Out->Abort("Directory merge failed.");
                notifyparent();
                return;
            }
            BackCycle* bc_child(dynamic_cast<BackCycle*>(child));
            assert(bc_child != NULL);
            newlisting.push_back(bc_child->getInfo()->direlemp);
            if (phase == phase_mergelistings) {
                
                mergesome();
                return;
            }
            
            phase = phase_finishmerge;
            init();
            break;
        }

        case phase_finishmerge:
            if (bdm_msg) DB->msg("backdirmerge::childdone phase %d: nforked %d, ncollected %d", phase, nforked, ncollected);
            
            info->resulthash = hash;
            info->direlemp->set_hash(info->resulthash);
            if (!merging_roots && merge_to_ddr) {
                ucontainer::errortype errcode(info->container->enddir(info->direlemp.getimpl()));
                if (errcode != ucontainer::pce__success) {
                    Out->Abort("Directory staging error at end of '%s' (%s)",
                             *info->direlemp->fullpath().image(), *ucontainer::error_description(errcode));
                    notifyparent();
                    return;
                }
                if (bdm_msg) DB->msg("backdirmerge::childdone  ucontainer %d after enddir      loc:%s", info->container->containerid, *info->direlemp->get_location().image());
            }

            if (ddrSysInfo != NULL) {
                delete ddrSysInfo;
                ddrSysInfo = NULL;
            }
            notifyparent();
            
            break;

        default:
            
            assert(false);
    }
}


void backdirmerge::appendde(DIRELEMp de, bool is_curr)
{
    if (de.isnull()) {
        assert(!de.isnull());
        Out->msg(ERR, "Attempt to merge null direlem");
        return;
    }
    ustring myname(de->name());
    if (bdm_msg)
        DB->msg("backdirmerge::appendde(%s (%s), %p, %d) this %p", *myname, *de->fullpath().image(), de.getimpl(), is_curr, this);
    
    
    if (myname.equal(UNDOO_DIRECTORY_NAME)) {
        prectime temp(prectime::now());
        myname = myname + "." + temp.hexstr();
        if (bdm_msg) DB->msg("backdirmerge::appendde: changed name to '%s'", *myname);
        de->set_name(myname);
        de->set_fullpath(upath(myname));
    }
    
    if (!final_stage && merge_to_ddr && de->get_location().getMedia() > location::media::gsan) {
        if (bdm_msg) {
            DB->msg("backdirmerge::appendde: synthing from '%s'", *de->get_location().image());
            
            
        }

        
        const ucontainer::errortype errcode(info->container->synthobj(de.getimpl()));
        if (errcode != ucontainer::pce__success) {
            Out->Abort("Error synthesizing %s (%s)",
                     *de->fullpath().image(), *ucontainer::error_description(errcode));
            notifyparent();
            return;
        }
    }
    newlisting.push_back(de);
}







void backdirmerge::mergesome()
{
    if (!uapp::staging().canRun()) {
        notifyparent();
        return;
    }

    
    
    

    
    undoo::vector<ustring> prevnames = prevlisting.keys();
    if (bdm_msg) DB->msg("backdirmerge::mergesome prev list index %u size %u", previndex, prevlisting.size());
    undoo::vector<ustring> currnames = currlisting.keys();
    if (bdm_msg) DB->msg("backdirmerge::mergesome curr list index %u size %u", currindex, currlisting.size());
    
    
    
    
    
    
    
    
        std::sort(prevnames.begin(), prevnames.end());
        std::sort(currnames.begin(), currnames.end());
    

    DIRELEMp prevde = NULL, currde = NULL;
    ustring prevname, currname;
    
    
    
    
    
    
    
    for(;;) {
        if (!uapp::staging().canRun()) {
            notifyparent();
            return;
        }
        
        

        if (bdm_msg) DB->msg("backdirmerge::mergesome: this %p in loop prev %u isnull %c curr %u isnull %c",
            this, previndex, prevde.isnull()?'T':'F', currindex, currde.isnull()?'T':'F');

        if (prevname.isempty() && previndex < prevlisting.size()) {
            prevname = prevnames[previndex++];
            prevde = prevlisting.lookup(prevname);
        }
        if (currname.isempty() && currindex < currlisting.size()) {
            currname = currnames[currindex++];
            currde = currlisting.lookup(currname);
        }

        if (bdm_msg) {
            DB->msg("backdirmerge::mergesome: checking prev '%s' [%p] loc '%s'",
                *prevname, prevde.getimpl(), prevde.isnull()?"":*prevde->get_location().image());
            DB->msg("backdirmerge::mergesome:   versus curr '%s' [%p] loc '%s'",
                *currname, currde.getimpl(), currde.isnull()?"":*currde->get_location().image());
        }

        if (prevname.isempty() && currname.isempty()) {
            
            
            if (bdm_msg) DB->msg("backdirmerge::mergesome: both names are empty - terminating the loop");
            break;
        }
        if (prevname.isempty()) {       
            if (bdm_msg) DB->msg("backdirmerge::mergesome: appending curr '%s' (prev empty)", *currname);
            appendde(currde, true);
            currname = "";
        } else if (currname.isempty()) {
            if (bdm_msg) DB->msg("backdirmerge::mergesome: appending prev '%s' (curr empty)", *prevname);
            appendde(prevde, false);
            prevname = "";
        } else if (namelessthan(prevname, currname)) { 
            if (bdm_msg) DB->msg("backdirmerge::mergesome: appending prev '%s' before '%s'", *prevname, *currname);
            appendde(prevde, false);
            prevname = "";
        } else if (namelessthan(currname, prevname)) {
            if (bdm_msg) DB->msg("backdirmerge::mergesome: appending curr '%s' before '%s'", *currname, *prevname);
            appendde(currde, true);
            currname = "";
        } else if (nameequals(prevname, currname)) {
            if (prevde->is_directory() && currde->is_directory()) {
                if (bdm_msg) DB->msg("backdirmerge::mergesome: directory collision '%s'", *prevname);
                workelem *w = new workelem(info, currde);
                backdirmerge *child = new backdirmerge(this, w, prevde, currde, traverse_depth++);
                child->noop();
                nforked++;
                prevname = currname = "";
            } else if (flags.partial_overwrite) {
                if (bdm_msg) DB->msg("backdirmerge::mergesome: file name collision on '%s' - overwriting", *prevname);
                appendde(currde, true);
                prevname = currname = "";
                continue;   
            } else {
                Out->Abort("Cumulative backup path name collision on '%s'", *prevname); 
                notifyparent();
            }
            if (bdm_msg) DB->msg("backdirmerge::mergesome: loop collision return %d with prev %u/%u, curr %u/%u", phase, previndex, prevlisting.size(), currindex, currlisting.size());
            return;
        } else {        
            Out->Abort("Cumulative backup path compare failure: '%s' vs. '%s'", *prevname, *currname);
            notifyparent();
            return;
        }
    }

    if (bdm_msg) DB->msg("backdirmerge::mergesome: loop terminated %d with prev %u/%u, curr %u/%u",
        phase, previndex, prevlisting.size(), currindex, currlisting.size());
    phase = phase_hiddendir;
    init();
}




fileref backdirmerge::nextdatablock(bool& suppress_requeue)
{
    if (bdm_msg) DB->msg("backdirmerge::nextdatablock this %p, cur %u/%"LL"u", this, curindex, newlisting.size());

    fileref res;
    suppress_requeue = false;   

    if (curindex >= newlisting.size()) return res;    

    res.initlist(DEFAULTDIRSIZE * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    
    
    while (curindex < newlisting.size()) {
        DIRELEMp curde = newlisting[curindex++];

        if (curde != NULL) {    
            main->layout_direlem(*curde, res, true, main->isnewdir() , flags.inode);
            curde = NULL;     
        }

        
        if (res.size() > MAXLISTINGBYTES) {
            DB->msg("backdirmerge::nextdatablock breaking due to %d byte limit", MAXLISTINGBYTES);
            break;
        }
    }

    if (bdm_msg) DB->msg("backdirmerge::nextdatablock returning %s (remaining=%"LL"u)", *res.desc(), newlisting.size());
    return res;
}

backdirmerge::~backdirmerge()
{
    if (ddrSysInfo != NULL)
        delete ddrSysInfo;
}


#if !defined(RESTDIR_H_INCLUDED)
#define RESTDIR_H_INCLUDED












#include "cycle.h"
#include "layout.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "dumpcontext.h"
#include "vector.h"
#include "ustring.h"
#include "ade_restore.h"

class restdirpart;
class restdata;


class restdir : public cycle, nsAdeLib::ADERestore {
public:
    restdir(cycle           *parent,
            const location& _metadataLocation,
            const restelem& restinfo,
            cycle           *starter ,
            dumpcontext::dirlistelem *dumpparent ,
            bool            excluded,
            int             traverse_depth=0,
            bool            waspreexisting = true);
    virtual void init();
#if !NOADECHUNKER
    virtual void handleListing(cycle* provider, const restelem& restinfo);
#endif
    virtual void childdone(cycle *child);
    virtual ~restdir();

    SAFEPOOLALLOC(restdir);
private:
    friend class restdirpart;
    friend class restdata;
    friend class Regulator;

#if !NOADECHUNKER
    ADERestore::ListingProvider     listingProvider;
#endif
    restelem info;
    const location metadataLocation;
    restelem altdatainfo;
    restdata* altdatachild;
    restelem securityinfo;
    restdata* securitychild;

    
    
    int restore_pipe_altdata(fileref &altdataslice);
    bool restore_pipe_sslice_altdata(fileref &altdataslice);
    int restore_pipe_stubdata(fileref& altdataslice);
    bool spawn_sslice_header_restore();
    void spawn_zfs_sslice_restore();
    bool process_sslice_header();
    void process_zfs_dir_sslice();

    bool restorealtdatastream(DIRELEM* direlemp);
    bool writealtdatastream(const upath path, fileref data);
    bool restoresecurity(DIRELEM* direlemp);

    
    
    bool dephashes_restored;

  
    dumpcontext::dirlistelem *dumpparent;
    int traverse_depth; 
    fileoffset altstreamsize;  
    bool preexisting; 
    bool threadStarter;   
    bool threadShutdown;    
    undoo::vector<DIRELEM> hardlink_direlems;
    undoo::vector<ustring> hardlink_linknames;

    
    
    
    
    
    
    fileref altdataslice;

    recursive_mutex restdirlock; 


    
    
    
    
    
    class Regulator {
    private:
        context*      main;
        const int     maxFilesOpen;     
        int           myMaxOpen[2];     
        int           myIsOpen[2];      
    public:
        Regulator(context *main, int maxFilesOpen_);
        bool okToProcessMore();
        void addChild(cycle* child);
        void removeChild(cycle* child);
    }; 

    Regulator *regulator;

    
    int phase;
    fileref sslicebuf;
    hashcode orighash;
};

#endif




























#include "common.h"
#include "debug.h"
#include "collator.h"
#include "chunker.h"
#include "hashcode.h"
#include "chunktype.h"
#include "fileref.h"

#define chgblkmsg      ((xflag[19]&4096)!=0)

class collator::collelem {
public:
    int pos;
    hashcode hash;
    chunktype kind;
    fileref data;
    int origsize;
    collelem* link;
    SAFEPOOLALLOC(collelem);
};

static int nextid;

collator::collator(chunker *chunk) {
    this->chunk = chunk;
    id = ++nextid;
    maxpos = 0;
    curpos = 0;
    wasatomic = false;
    list = NULL;
}

int collator::nextpos() {
    return maxpos++;
}

void collator::insert(collelem *e) {
    collelem **pp = &list;
    while(1) {
        collelem *p = *pp;
        if(p == NULL)
            break;     
        if(p->pos > e->pos)
            break;     
        pp = &p->link; 
    }

    e->link = *pp;
    *pp = e;
}

void collator::append(hashcode& hash, chunktype& kind, fileref& data, int origsize, int pos) { 
    
    if(pos == curpos) {
        chunk->append_process(NULL, hash, kind, data, origsize);
        curpos++;
        while(list != NULL) {
            if(list->pos != curpos)
                break;
            curpos++;
            if(list->pos == maxpos)
                resulthash = chunk->flush_tree(NULL, wasatomic);
            else
                chunk->append_process(NULL, list->hash, list->kind, list->data, list->origsize);
            collelem *e = list;
            list = list->link;
            delete e;
        }
    } else {
        collelem *e = new collelem;
        e->hash = hash;
        e->kind = kind;
        e->data = data;
        e->origsize = origsize;
        e->pos = pos;
        insert(e);
    }
}

void collator::flush() {
    
    if(curpos == maxpos) {
        resulthash = chunk->flush_tree(NULL, wasatomic);
        curpos++;
    } else {
        collelem *e = new collelem;
        e->pos = maxpos;
        insert(e);
    }
}

void collator::result(hashcode& hash, bool& isatomic) {
    
    assert(curpos == maxpos+1);
    assert(list == NULL);
    hash = resulthash;
    isatomic = wasatomic;
}

void collator::set_chunk( chunker *chunk_ )
{
    if( chunk == NULL ) {
        if( chgblkmsg ) DB->msg( "CHGBLK collator::set_chunk previous=NULL" );
    } else {
        if( chgblkmsg ) DB->msg( "CHGBLK collator::set_chunk previous=%p name=%s", chunk, chunk->get_chunker_name() );
    }
    chunk = chunk_;
}


#if !defined(RESTFILE_H_INCLUDED)
#define RESTFILE_H_INCLUDED












#include "cycle.h"
#include "layout.h"
#include "ustring.h"
#include "direlem.h"
#include "restelem.h"
#include "fileoffset.h"
#include "utar_flags_info.h"
#include "volinfo.h"
#include "hashcode.h"
#include "ade_restore.h"
#include "ucontainer_base.h"



#define BCD_PATH "C:\\Boot\\BCD"
#define WINDOWS_LICENSE_EXTENSION ".C7483456-A289-439d-8115-601632D005A0"
class restfile : public bicycle, nsAdeLib::ADERestore {
public:
    
    enum {
        opt_none     = 0x0000,
        opt_nofilter = 0x0001,
        opt_dephash  = 0x0002,
    };

    restfile(bicycle *       parent,
             const hashcode& hash,
             DIRELEM&        direlem,
             ucontainer::basep container,
             cycle *         starter = NULL,
             const volinfo   vinfo = volinfo(),
             fileoffset      startoff=fileoffset(0),
             fileoffset      endoff=fileoffset(0),
             const unsigned  opts = unsigned(opt_none)
    );
    virtual void init();
    
    virtual void handleData(fileoffset foOffset, fileref& restoreData);
    virtual void childdone(cycle *child);
    virtual ~restfile();
    
    static bool should_restore(restelem &info, const utar_flags_info& flags,
                               bool &bExists, bool &bExistsAsFile, bool &bExistsAsSymlink);

    void set_info_pipe_control(pipe_control* _ppipe_control) {
        info.ppipe_control = _ppipe_control;
    };

    void set_original_file_size(const fileoffset& size) { original_file_size = size; }

    bool process_emctar_hardlinks(bool &checknormalhardlink);
    void process_emctar_lnk_to_reg(const hashcode &h, const fileoffset &sz);
    void process_emctar_lnk_to_lnk(const ustring &realfullpath);
    void process_emctar_reg_to_lnk(const ustring &realfullpath);

    SAFEPOOLALLOC(restfile);

protected:
    friend class smallfile_prefetcher;
    restelem info;

private:
    bool delonerror;
    bool m_bRenamed;
    bool m_bSecurityLost;
    bool decrementfilecount;
    bool threadStarter;         
    bool threadShutdown;        

    bool checkold();
    bool exists();

    int phase; 

    void rename_windows_file();

    
    
    bool isemctardedup(const DIRELEM& de, hashcode& cdhash, fileoffset& cdsize) const;

    
    
    bool handle_emctardedup_childdone() const;

    
    
    fileref compressordata;

    
    
    
    int restore_pipe_altdata(fileref& altdataslice);

    
    
    
    int restore_pipe_stubdata(fileref& altdataslice);

    
    
    hashcode getextentshash(const DIRELEM& de) const;

    
    
    unsigned get_archive_filetype() const;

    
    
    const unsigned opts;

    
    
    
    fileoffset original_file_size;

    hashcode    m_hcOriginalRoot;

    
    fileref gsan_extentsdata;

    ustring fname;

    
    bool size_reported;

};




class smallfile_prefetcher : public cycle {
public:
    
    smallfile_prefetcher(restfile *rf, context *main);
    void init();
    void childdone(cycle *child);

    
    
    static void getstats(fileoffset &totalbytes, fileoffset &runningbytes);
};

#endif



#if !defined(BACKAVPAXOBJ_H_INCLUDED)
#define BACKAVPAXOBJ_H_INCLUDED












#include "backavpaxstream.h"
#include "exportstream_xml.h"

class backavpaxobj : public backavpaxstream
{
public:
  SAFEALLOC(backavpaxobj);

  
  
  
  
  backavpaxobj(BackCycle* parent_, context* main, workelem *info_,
               parsestream_base *parser_, int traverse_depth,
               const fileref paxrecs_fr, const exportstream_xmlp _metainfop = 0,
               const unsigned objflags = flag_none);

  virtual ~backavpaxobj();

  virtual void init();
  virtual void childdone(cycle *child);

  
  virtual fileref nextdatablock(bool& suppress_requeue);

private:
  NOCOPY(backavpaxobj);

  
  backavpaxobj();

  const location::tcontainerid getde_containerid_from_metainfo(const ddrfiles_xmlp ddrfilesxmlp, const DIRELEM de) const;

  
  
  
  bool process_outofstream_content_file(const DIRELEMp& dep);

  
  
  
  void create_data_cycle(const bool use_raw_container, workelem* wep, parsestream_base *parser = NULL);

  typedef enum {
      bpo_nul,           
      bpo_enqueued,      
      bpo_objdata,       
      bpo_dirdata,       
      bpo_exportstream_metafile, 
      bpo_metadata,      
      bpo_dirlist,       
  } phase;

  
  bool had_metadata;

  
  bool is_root_direlem;

  
  const bool is_system_info;

  
  const bool is_backup_indio_or_greater;

  
  bool is_ddrfiles_xml;

  
  bool is_backuptag_object;

  
  
  bool already_output_exportstream_metadata;

  
  bool synthesized_file;

  
  
  
  location::tcontainerid synthesized_containerid;
  fileoffset synthesized_size;

  
  paxrec last_paxrecs;

  
  phase curphase;

  
  
  
  

  
  hashcode m_basehash;

  
  tassoc<ustring, hashcode> dephashes;

  
  exportstream_xmlp metainfop;
};

#endif







































#include "common.h"
#include "debug.h"

#include "acntmngr.h"
#include "agenttest.h"
#include "build.h"
#include "client.h"
#include "client_agent.h"
#include "client_commands.h"
#include "datetime.h"
#include "exitcodes.h"
#include "runstage.h"
#include "filebase.h"
#include "filenames.h"
#include "fileref.h"
#include "mutex.h"
#include "nbackmain.h"
#include "ade_mgrx.h"
#include "homebase.h"
#include "output.h"
#include "synccall.h"
#include "timer.h"
#include "uflags.h"
#include "utar_commands.h"
#include "dto/dto_utar_commands.h"
#include <math.h> 
#include "pwdcrypt.h"
#include "upath.h"
#include "platerror.h"
#include "netsys.h"
#include "mctypes.h"
#include "utar_ctl_sup.h"
#include "dto/utar_dto_sup.h"
#include "ctl_table.h"
#include "ctl_message.h"
#include "ctl_message_header.h"
#include "adhoc_man.h"
#include "ctl_callhome.h"
#include "subscript.h"
#include "utar_flags_enums.h"
#include "signposts_base.h"
#include "include.h"
#include "ctl_translate.h"
#include "cli_man.h"
#if !defined(AVOID_NETWORKER_INTERFACE)
    #include "legato_interface/xdrctl_connection.h"
#endif

#include "uwrapper.h"
#include "ui18n.h"
#include "memman.h"
#include "securesessionticket.h"

#if SYSTEM_WINDOWS
  #include "passwdsimulator.h"
  #include "ntsecurity.h"
  #include "volumeinfo.h"

  #include "mapix.h"
  #include "mapiwalk.h"
  #include "mapistream.h"
  #include "mapibase.h"
  #include "oldvc6\include\dapi.h"
  #include "wss_sis_manager.h"
  #include "wservice.h"
#endif

#ifdef INTEL_SHA1
#include "lowhash.h"
#endif
#include "cryptofuncs.h"

#define sis_feature_enabled ((xflag[22]&262144)==0)
#define multistreamingddr_disabled ((xflag[13]&16777216)!=0)


static const char* AVMETA_MACHNAME  = ".avamar_metadata";
static const char* AVMETA_BACKUPTAG = ".avamar-account-metadata";




#define WATCHDOG_CANCEL_SECS (10*60)

client::client(int argc, char **argv)
  : uapp_staged(argc, argv)
{
  istar  = false; 
  app_exitonfault = true;
  mycontext   = NULL;  
  mytable     = NULL;
  callhome    = NULL;
  #if 0
     DB->info("No error");                
     DB->error("Internal server error");  
  #endif
}

client::~client()
{
#if SYSTEM_WINDOWS
    fflush(stdout);

    
    
    
    
    passwdsimulator::static_cleanup();

    ntsecurity::static_cleanup();
    VolumeInfo::static_cleanup();

    if(wss_sis_manager::sis_manager != NULL)
        delete ( wss_sis_manager::sis_manager );

#endif

    
    DB->msg("client::~client");
    delete ( mycontext );
    if (mytable != NULL)
        delete mytable;
    if (callhome != NULL)
        delete callhome;
}

void client::CreateContext( void )
{
  uapp::initialize( istar ? AVTAR_EXENAME : CLIENT_EXENAME, buildinfo::client_version );

  mycontext  = new context(flags);
}










exitcodes_t client::ExecuteCommand (
  const ustring& command,    
  const cidtype  clientid,
  ctl_messagep   requestp,    
  ctl_queuep     responseq    
)
{
    DB->msg("client::ExecuteCommand command=%s, cid:%s", *command, *clientid.image());
    assert(mycontext != NULL);
    

    exitcodes_t status = EXIT_OK;

    if(!uapp::staging().canRun()) {
        DB->msg("client::ExecuteCommand cannot run");
        return uapp::staging().getExitCode();
    }

    
    
    
    
    
    if (istar && flags.replicate) {
        
        
        
        dstflags.parse(argc, argv, "");
        DB->msg("Checking if avtar should add destination (%d) flags (%p)", flags.destination_data, &dstflags);
        if(flags.destination_data == client_config_flags::gsan_to_ddr) {
            mycontext->add_dstflags(&dstflags);
            if(flags.streamformat_out != utar_flags_enums::streamformat_cdsf)
                flags.streamformat_out = utar_flags_enums::streamformat_cdsf;
        } else if(flags.destination_data == client_config_flags::ddr_to_gsan)
            dstflags.ddrindex = 0; 
        
        
        
        
        flags.encrypt = dstflags.encrypt;
        flags.encrypt_strength = dstflags.encrypt_strength;
        
        
        
        bool engaged = dstflags.degenerate? mycontext->engageADE() : mycontext->engageADE(&dstflags);
        if(!engaged) { 
            Out->msg(FATAL, "<10776>Failed to initiate session with servers for replication.");
            return EXIT_CONNECT;
        }
    }
    else {
        if(!mycontext->engageADE()) { 
            if(uapp::staging().isExitCancel())      
                return uapp::staging().getExitCode();
	        Out->msg(FATAL, "<5308>Failed to initiate session with server");
            return EXIT_CONNECT;
        }
    }

    if( !mycontext->init(clientid) ) {
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }

    ADEMgrX* adeMgr = mycontext->getAdeMgr();
    if(adeMgr == NULL) {  
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }
    hfs_info_struct&   hfs_info = adeMgr->getHfsInfo(dpn0);
    if(!hfs_info.isAvailable) {
        Out->msg(FATAL, "<10777>Failed to initiate session with server:dpn0");
        return EXIT_CONNECT;
    }

    const tversion tver = adeMgr->getServerVersion(dpn0);
    const ustring version = tver.isvalid()?ustring::sprintf(" [%s]", *tver.image()):"";
    Out->msg(INFO, "<5550>Successfully logged into Avamar Server%s", *version);

    if (istar) {

        if(flags.replicate) {
            
            flags.clientid = hfs_info.clientidhash.image();  
            mycontext->setclientid(cidtype(flags.clientid));
            dstflags.workorderid = flags.workorderid;   
        } else {
            
            if(widtype(flags.workorderid) == widtype::nah) {
                mycontext->setclientid(cidtype(hfs_info.clientidhash.image()));
            }
        }

        
        
        try {
            
            undoo::auto_ptr<utar_commands> utar_cmdp;

            
            utar_cmdp = flags.dtostream.isempty() ?
                new utar_commands(flags, hfs_info, dstflags, requestp, responseq) :
                new dto_utar_commands(flags, hfs_info, dstflags, requestp, responseq);

            
            status = utar_cmdp.get() ? utar_cmdp->do_command() : EXIT_MISC;

        } catch(connerror& ce) {
            Out->msg(FATAL, "<7413>Aborting due to connection error (%d, %s)", ce, *ADEMgr::image(ce));
            status = EXIT_CONNECT;
        }

        
        userid::static_cleanup();
        groupid::static_cleanup();
    }
    
    
    
    
    
#if RAWCLIENT
    else {
        DB->msg("rawclient client::ExecuteCommand with flags.args: %s", *flags.args.image());
        ustring subcommand = (flags.args.size() > 0 ? flags.args[0] : "");

        if      (subcommand == "pipe")       status = client_commands::do_pipe(hfs_info, flags, mycontext);       
        else if (subcommand == "user")       status = client_commands::do_user(hfs_info, flags);                  
        else if (subcommand == "cycletest")  status = client_commands::do_cycletest(hfs_info, flags, mycontext);  
        else {
            Out->msg(FATAL, "bad rawclient subcommand '%s', valid commands are: pipe, user, cycletest", *subcommand );
            status = EXIT_BAD_FLAGS;
        }
    }
#else
    else {
        DB->error( DBTXT("bad command %s\n"), *command );
        status = EXIT_BAD_FLAGS;
    }
#endif 

#if SYSTEM_WINDOWS
    
    if (flags.hberestoresystem == "prepare" || flags.hberestoresystem == "finalize") {
        
        if (flags.hbesystemprofilepath.isempty()) {
            
            if (flags.hberestoresystem == "prepare")
                Out->msg(ERR, "<8466>System prepare failed. The profile has not been restored successfully.");
            else
                Out->msg(ERR, "<10778>System finalize failed. The profile has not been restored successfully.");
        } else if (!execute_hbe(flags)) {
            
            if (flags.hberestoresystem == "prepare")
                Out->msg(ERR, "<8467>System prepare failed. HBE enountered problems during execution.");
            else
                Out->msg(ERR, "<10779>System finalize failed. HBE enountered problems during execution.");
        }
    }
#endif

    
    if (signposts_base* spp = mycontext->signposts_p) {
        spp->work_done(status);
        spp->report_done(status);
    }

    DB->msg("client::ExecuteCommand disengaging ADE");
    mycontext->disengageADE();

    DB->msg("client::ExecuteCommand returns %u", status);
    return status;
}

#if SYSTEM_WINDOWS

int client::do_wfp_test() {
    if(!flags.args.isempty()) {
        
        int i;
        for (i=0; i<flags.args.size(); i++) {
            ustring result(ntsecurity::IsProtectedFile((upath)flags.args[i])?"Protected":"Not Protected");
            Out->msg(STD, "%s = %s", *flags.args[i], *result);
        }
    } else {
        
        if (win_os_version_info::is_server_2008_or_newer() || win_os_version_info::is_windows_Vista_or_newer()) {
            Out->msg(ERR, "<10780>List not available on Windows Vista, Server 2008, or later.");
			return 1;
        }
        stringlist files(ntsecurity::GetProtectedFiles());
        int i;
        for (i=0; i<files.size(); i++)
            Out->msg(STD, "%5d: %s", i+1, *files[i]);
    }
    return 0;
}
#else
int client::do_wfp_test() {
    Out->msg(ERR, "<6167>Windows File Protection only available on Windows");
    return 1;
}
#endif

bool client::read_workorder(ustring filename, agent_messagep& mess) {
    fileref wo;
    wo.initdisk(filename);
    if (wo.iserror()) {
        Out->msg(ERR, "<5279>Unable to open workorder file '%s'", *filename);
        return false;
    }
    DB->msg(DBTXT("read_workorder: successfully opened %s"), *filename);
    ustring mess_str;
    wo.getdata(mess_str);
    DB->msg(DBTXT("read_workorder: read from %s\n--------------\n%s\n---------------"), *filename, *mess_str);
    mess = agent_messagep(new agent_message(mess_str, true));
    { 
        ctl_messagep ctl_tmp(ctl_translate::to_ctl_message(mess));
        if(ctl_tmp.isdefined()) {
            ctl_tmp->hide_passwords();
            agent_messagep am_tmp(ctl_translate::to_agent_message(ctl_tmp));
            if(am_tmp.isdefined()) {
                if(DB->workorder.isnull())
                    DB->workorder.initlist(); 
                DB->workorder.append(am_tmp->fimage()); 
            }else
                DB->msg("client::read_workorder failed to translate ctl_message to agent_message");
        }else
            DB->msg("client::read_workorder failed to translate agent message to ctl_message");
    }
    return true;
}


int client::workorder_parse(agent_messagep mess, utar_flags_info& uflags)
{
    
    if (mess->defined("work")) {
       if (mess->getstring("work") == "backup")
           uflags.create = true;
       else if (mess->getstring("work") == "restore")
           uflags.extract = true;   
    }

    if (mess->defined("wid")) uflags.workorderid = mess->getstring("wid");
    if (mess->defined("pid")) uflags.pluginid = pidtype(mess->get_pid());

    const int thispidnum = pidtype::my_os + pidtype::filesystem;  

    ctl_messagep ctl_mess;
    ctl_mess = ctl_translate::to_ctl_message(mess);
    if (ctl_mess.isnull()) {
        Out->msg(ERR, "<6785>unable to translate message");
        return 1;
    }
    const workorder mywork(ctl_mess);
    stringlist saveargs(uflags.args);

    mywork.parse(thispidnum, uflags.args, uflags.excludelist, uflags.includelist, uflags);
    

    if (uflags.pluginid.kind() != pidtype::db2) {
        
        if (!uflags.makeview) {
            
            
            uflags.arg = uflags.args.size() > 0 ? uflags.args[0] : "";
        } else { 
            
            const ustring vimage(mywork.get_snapview());
            if (!vimage.isempty()) {
                DB->msg("client::workorder_parse() Found targets snapview xml");
                DB->msg("client::workorder_parse() Snapview xml '%s'", vimage.tostr());
                uflags.arg = vimage;
            } else {
                uflags.arg = "";  
                Out->msg(ERR, "No view targets in snapview xml.");
                uapp::staging().startTermination(EXIT_TARGETLIST, "No view targets in snapview xml");
                return 1;
            }
        }
    } else {
        
        
        uflags.args = saveargs;
    }

    DB->msg("client::workorder_parse uflags.hfsaddr:%s", *uflags.hfsaddr);

    
    
    
    ustring sessionticket;
    if (((xflag[31]&128) == 0)) {
        if (mess->defined(secure_st_connection)) {
            sessionticket = mess->getstring(secure_st_connection);
        }
    }
    if (sessionticket.isempty() && mess->defined(TICKET))
        sessionticket = mess->getstring(TICKET);
    if (!sessionticket.isempty())
        uflags.sessionticket = sessionticket;

    Out->msg(INFO, "<5900>Workorder received:\n%s", *ctl_mess->simage());  

    return 0;
}

bool client::check_for_workorder() {

    DB->msg(DBTXT("client::check_for_workorder begin"));

    flags.parse(argc, argv, "workorder");
    if (flags.workorderfile.isempty()) {
        DB->msg("client::check_for_workorder no workorder file");
        return true;  
    }

    DB->msg("client::check_for_workorder workorder found");
    agent_messagep mess;
    if (!read_workorder(flags.workorderfile, mess))
        return false;
    DB->msg("client::check_for_workorder back from workorder read %s", *flags.workorderfile);
    DB->msg("client::check_for_workorder --------------\n%s\nclient::check_for_workorder ---------------", *mess->simage());

    workorder_parse(mess, flags);
    DB->msg("client::check_for_workorder workorder DONE");
    return true;
}

void client::check_pluginid() {
    
    if(flags.pluginid == pidtype::none) {
        if (istar) {
            if(flags.mapi) {
                flags.pluginid = pidtype("exch-msg", pidtype::my_os + pidtype::exchange_msg); 
            } else if(flags.streamformat_in == utar_flags_enums::streamformat_dump) {
                flags.pluginid = pidtype("ndmp", pidtype::my_os + pidtype::ndmp);
            } else {
                
                flags.pluginid = pidtype(pidtype::image(pidtype::my_os),
                                         pidtype::my_os + pidtype::filesystem);
            }
        } else {
            flags.pluginid = pidtype(build().appname() + "-" + build().platform(), 0);
        }
    }

    
    if (!flags.pluginname.isempty()) flags.pluginid = pidtype(flags.pluginname, flags.pluginid.number());
    if (flags.pluginnum != 0)        flags.pluginid = pidtype(flags.pluginid.name(), flags.pluginnum);

    DB->msg("client::check_pluginid flags.pluginid:%s", *flags.pluginid.imagex());
}



exitcodes_t client::prepForMetadata(const cidtype client_id)
{
    
    

    
    flags.backuptype = tbackuptype::metadata.rawvalue();
    if (!flags.isexplicit("backuptag"))
        flags.backuptag = AVMETA_BACKUPTAG;

    
    
    

    
    
    flags.nocache = true;

    
    if (flags.create) {
        
        if (!flags.from_stdin)
            Out->msg(ERR, "The --account-metadata flag for creation requires --from-stdin to be specified.");

        
        flags.check_stdin_path = false;

        
        

        
        if (!flags.isexplicit("expires"))
            flags.expires = 0;
    } else if (flags.extract) {
        
        if (!flags.to_stdout)
            Out->msg(ERR, "The --account-metadata flag for extraction requires --to-stdout to be specified.");
    }

    
    
    
    
    
    
    
    

    if (!mycontext->engageADE()) {
        Out->msg(FATAL, "Unable to start ADE.");
        return EXIT_CONNECT;
    }
    if( !mycontext->init(client_id) ) {
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }
    ADEMgrX* adeMgr = mycontext->getAdeMgr();
    if(adeMgr == NULL) {  
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }
    hfs_info_struct&   hfs_info = adeMgr->getHfsInfo(dpn0);
    if(!hfs_info.isAvailable) {
        Out->msg(FATAL, "<10777>Failed to initiate session with server:dpn0");
        return EXIT_CONNECT;
    }

    
    

    acntmngr acct_mgr(hfs_info.sync);
    const blktraj block_parent(hfs_info.blk);
    const authid auth_user(hfs_info.auth);

    
    
    
    
    

    roothashlist roothashes;
    msgerrors error = acct_mgr.getBackups(roothashes, block_parent, auth_user, 1);

    if (error != MSG_ERR_NONE) {
        if (error == MSG_ERR_INVALID_PARAMETERS) {
            

            if (flags.create) {
                
                
                

                const authuserTx new_user; 
                msgerrors create_error = acct_mgr.createBlk(block_parent, auth_user, AVMETA_MACHNAME, BLK_TYPE_MACHINE, new_user, "metadata backup");
                if ((create_error != MSG_ERR_DUPLICATE) && (create_error != MSG_ERR_NONE)) {
                    DB->msg("client::RunEx: createBlk failed, error %s", *message::err_image(create_error));
                    Out->msg(FATAL, "Failed to create domain account, unable to continue the metadata backup.");
                    return EXIT_MISC;
                }
                DB->msg("client::RunEx: createBlk successful, result code %s", *message::err_image(create_error));
            }

            
            

            flags.path = flags.path / AVMETA_MACHNAME;
            DB->msg("client::runEx: new account path is %s", *flags.path);

        } else {
            DB->msg("client::RunEx: getBackups failed, error %s", *message::err_image(error));
            Out->msg(FATAL, "Failed to retrieve a backup root hash, unable to continue.");
            return EXIT_MISC;
        }
    }

    
    
    

    DB->msg("client::RunEx: disengaging ADE after metadata checks");
    mycontext->disengageADE();

    return EXIT_OK;
}


void client::handle_wrapup(const int exitcode, const backstats* stats)
{
    assert(mycontext != NULL);
    
    
    if (!flags.fakeprogress || ((xflag[10]&2097152)!=0)) {
        
        
        xml_messagep errorsummary(mycontext->get_errorsummary_xml(exitcode)); 
        xml_messagep wrapup_summary(stats->xml(mycontext->getAdeMgr(), flags.makeview));      
        double bytes_protected = 0.0;
        if (flags.bytes_protected <= 0.0){
            bytes_protected = wrapup_summary->getdouble("totalfilebytes");
        } else{
            bytes_protected = flags.bytes_protected;
        }
        wrapup_summary->enter("totalprotectedbytes",    +bytes_protected);     
        wrapup_summary->children.push_back(mycontext->sessinfo[dpn0].get_message());
        wrapup_summary->children.push_back(errorsummary);                     

        if (!mycontext->client_ctl_statep.isnull()) {
            Out->msg(INFO, "<8468>Sending wrapup message to parent");
            ctl_messagep wrap(new ctl_message(ctl_message::type::status_wrapup_summary));
            ubigint64 backuptime(0);
            ubigint64 original_backuptime(0);
            if (!mycontext->workctx.isnull()) {
                backuptime = +mycontext->workctx->atime;
                original_backuptime = mycontext->workctx->original_backup_time;
             
         
             
            }
            wrap->set_res_status_wrapup_summary(ctl_key, cidtype(flags.clientid),
                                                flags.pluginid,
                                                widtype(flags.workorderid),
                                                datetime(),
                                                datetime(),
                                                "", exitcode,
                                                wrapup_summary,
                                                &backuptime,
                                                original_backuptime != 0 ? &original_backuptime : NULL);

            ctl_queue::rettype success(mycontext->client_ctl_statep->enq_send(wrap));
            if (success !=  ctl_queue::enqueued_ret)
                DB->msg("client::RunEx unable to queue wrapup %s", *ctl_queue::rettype_image(success));
            else DB->msg("client::RunEx queued (%s) message %s", *ctl_queue::rettype_image(success), *wrap->simage());

            
            
            
            
            
            
            
            
            
            
            
            
            

            
            
            
            
        } else if((widtype(flags.workorderid) != widtype::nah) && !(flags.pluginid == pidtype::none)) {

            Out->msg(INFO, "<6644>Writing wrapup to alg file for agent to read");
            
            
            ustring algfilepath(flags.vardir /
                                widtype(flags.workorderid).to_filename(flags.pluginid) + ALGEXT);

            output OutLog("workorderlog");

            OutLog.disable_stdout();
            OutLog.enable_logfile(algfilepath, false, false, true);

            
            OutLog.msg(STD, "%s", *wrapup_summary->simage(" ", false));             

            
            OutLog.msg(STD, "%s", *errorsummary->simage(" ", false));               

            OutLog.disable_logfile(true);

        } else if(flags.create || flags.extract) {
            Out->msg(INFO, "<6645>Not sending wrapup anywhere.");
        }
    } else {
        Out->msg(INFO, "<8469>Progress avtar, no wrapup.");
    }
}

void client::validate_stream_flags()
{
    
    
    
    
    

    
    
    


    if (flags.create) {
        
        if (flags.streamformat_tmp != utar_flags_enums::streamformat_none) {
            if (flags.streamformat_in == utar_flags_enums::streamformat_none) {
                
                flags.streamformat_in = flags.streamformat_tmp;

            } else if (flags.streamformat_in != flags.streamformat_tmp) {
                Out->msg(ERR, "It is an error to specify conflicting --streamformat (%s) and --streamformat-in (%s) during backup",
                         *utar_flags_info::streamformat_image(flags.streamformat_tmp), *utar_flags_info::streamformat_image(flags.streamformat_in));
            }
        }

        
        if (!flags.stream_tmp.isempty()) {
            if (flags.media_in.isempty()) {
                
                flags.media_in = flags.stream_tmp;

            } else if (!flags.media_in.equal(flags.stream_tmp)) {
                Out->msg(ERR, "It is an error to specify conflicting --stream and --stream-in during backup.");
            }
        }

        
        if (flags.streamformat_out == utar_flags_enums::streamformat_none && flags.ddrenabled) {
            flags.streamformat_out = utar_flags_enums::streamformat_cdsf;
        }

    } else if (flags.extract) {
        
        if (flags.streamformat_tmp != utar_flags_enums::streamformat_none) {
            if (flags.streamformat_out == utar_flags_enums::streamformat_none) {
                
                flags.streamformat_out = flags.streamformat_tmp;

            } else if (flags.streamformat_out != flags.streamformat_tmp) {
                Out->msg(ERR, "It is an error to specify conflicting --streamformat (%s) and --streamformat-out (%s) during restore",
                         *utar_flags_info::streamformat_image(flags.streamformat_tmp), *utar_flags_info::streamformat_image(flags.streamformat_in));
            }
        }

        if (!flags.stream_tmp.isempty()) {
            if (flags.media_out.isempty()) {
                
                flags.media_out = flags.stream_tmp;

            } else if (!flags.media_out.equal(flags.stream_tmp)) {
                Out->msg(ERR, "It is an error to specify conflicting --stream and --stream-out during restore.");
            }
        }

    } else {
        DB->msg("client::validate_stream_flags not create or extract");
    }
    DB->msg("client::validate_stream_flags media-in:%s streamformat-in:%s streamformat-out:%s media-out:%s",
            *flags.media_in, *utar_flags_info::streamformat_image(flags.streamformat_in),
            *utar_flags_info::streamformat_image(flags.streamformat_out), *flags.media_out);
}












exitcodes_t client::RunEx( int iSpecialFlag )  
{
    toolnames tool;
    if (!istar)
        tool = tool_client;
    else
        tool = tool_avtar;

    
    int guru = 0;
    uflags::readenv_x(guru, "HFSGURU");
    if (istar && !guru) {
         flags.show_helplevel = UFLAGS_HELP_SHOWSTD; 
    } else {
         flags.show_helplevel = UFLAGS_HELP_SHOWALL;
    }

    
    flags.set_defaults();                
    DB->messages_on = false;
    DB->setexitonfatal(false);          
    DB->setexitoninternal(false);       
    
    if (!istar) {
        flags.verbose = true;
        if(iSpecialFlag == 0)
            Out->setVerbosity(VERBOSE);
    } else
        Out->setVerbosity(STD);

    
    flags.exit_on_error = false;

    flags.parse(argc, argv, "debug");        

    
    
    
    
    
    
    
    
    
    
    

    flags.parse(argc, argv, "mapi");         
    if (flags.mapi)
    {
        flags.collapse_multi_dirseps = false;
    }

    flags.read_config(tool, argc, argv);

    if (!check_for_workorder()) {
        Out->msg(FATAL, "<5280>Unable to process workorder");
        return EXIT_MISC;
    }

    

    if (!istar) { 
        flags.parsefile("undooflags");
        if(iSpecialFlag == 0)
            DB->messages_on = true;
    }

    flags.parse(argc, argv, "history");         
    flags.raw_arguments = flags.history;

    
    flags.parse(argc, argv);

    DB->set_trackerrorcount(true, flags.max_identical_msgs);

#ifdef INTEL_SHA1
    if (flags.opensslsha1)
        lowhash::set_openssl();
    DB->msg("Using %s implementation of SHA1", *lowhash::image());
#endif

#if SYSTEM_WINDOWS
    
    if (!win_os_version_info::is_windows_Vista_or_newer() && (xflag[31]&4)==0) {
        Out->msg(FATAL, "This version of Avtar does not support this specific version of Windows OS.");
        return EXIT_MISC;
    }

    if (flags.extract && 
        (flags.openfilerestoreoption != utar_flags_enums::openrestore_never) &&
        (flags.existingfileoverwriteoption == utar_flags_enums::existowrite_never)) {
        Out->msg(WARN, "<7533>The open-file-restore-option setting will not be effective without also setting existing-file-overwrite-option");
    }
#endif

    
    
    threadbase::defaultstacksize = flags.threadstacksize * 1024;

    
    if (flags.errorcount) return EXIT_BAD_FLAGS;
    flags.exit_on_error = true;

    
    if (!flags.logfilename.isempty() && !flags.logfilename.equal(Out->get_logfilename())) {
        Out->enable_logfile(flags.logfilename, true, false);
        Out->msg(INFO, "<5241>Logging to %s", *flags.logfilename);
    }

    
    if (flags.rotatelogsize > 0 && flags.rotatelogcount > 1) {
        Out->setup_rotation(flags.rotatelogsize, flags.rotatelogcount);
    }

    DB->msg("CID flags.clientid:%s", *flags.clientid);
    ustring hfsid;
    if (flags.clientid.isempty() || flags.clientid == "0") {
        if (flags.read_clientid(hfsid)) 
            DB->msg("read cid %s\n", *flags.clientid);
        else {
            DB->msg("UNABLE to read cid\n");
            flags.clientid = netsys::getcurrhostname();
        }
        if (flags.clientid.isempty()) flags.clientid="unknown-cid";
    }

    check_pluginid();

    
    

  

    if (flags.ping) { 
        return client_commands::pingtest(flags) == 0 ? EXIT_OK : EXIT_MISC;
    }

    if (flags.acntver < 2) {
        Out->msg(FATAL, "<5075>Old accounting no longer supported");
        return EXIT_AUTH_FAIL;
    }

    if (!flags.fakeprogress) {  
        
        
        if (!flags.run_at_start.isempty())
            client::check_script_allowed(flags.run_at_start, flags.to_stdout, flags.create, flags.extract, "run-at-start");

        if (!flags.run_at_end.isempty())
            client::check_script_allowed(flags.run_at_end, flags.to_stdout, flags.create, flags.extract, "run-at-end");

        if (!flags.run_after_freeze.isempty())
            client::check_script_allowed(flags.run_after_freeze, flags.to_stdout, flags.create, flags.extract, "run-on-freeze");
    }

#if SYSTEM_WINDOWS
    if (flags.debug)
        DB->redirect(flags.sysdir/DEBUG_OUTPUT_FILENAME);
#endif

    
    if (flags.version) {
        Out->setVerbosity(STD);
        if (flags.format == "xml") {
            xml_messagep ver(build().xmlmess());
            if (!flags.versionoverride.isempty()) ver->enter("appversion", flags.versionoverride);
            Out->XmlMsg(STD, "%s\n", *ver->simage());
        } else
            Out->msg(STD, "%s\n", *build().info());
        
        exit(0);
    }

    const ustring encpasswordflag("encodepassword");
    if (flags.isexplicit(encpasswordflag)) {
        if (flags.encodepassword.isempty()) {
            if (!acntmngr::getPassword(stdin, stdout, "Password: ", flags.encodepassword)) {
                DB->msg("client::RunEx --%s no password read from stdin", encpasswordflag.tostr());
            }
        }
        if (flags.encodepassword != "") {
            char result[256] = {0};
            
            
            
            
            int res = encodepassword(*flags.encodepassword, result, sizeof(result), flags.portable_encoding);
            if (res == 0) {
                uwrapper::uprintf("%s\n", result);

                
                
                

                exit(0);
            }
            uwrapper::uprintf(DBTXT("ERROR: Encode error=%d\n"), res);
            exit(1);
        } else {
            Out->msg(ERR, "The --%s flag requires a non-zero length argument", encpasswordflag.tostr());
            return EXIT_BAD_FLAGS;
        }
    }

    if (flags.testwinprotection) {
        exit(do_wfp_test());
    }

#if TEST_EXCLUDES
    
    test_excludes();
    exit(0);
#endif

    flags.logcommand();

    if (!flags.progresslog.isempty() && !mycontext->open_progresslog())
        Out->msg(ERR, "<7832>Client: Failed to open %s for progress log.", *flags.progresslog);

    
    Out->msg(INFO, "<5551>Command Line: %s %s", *flags.progname, *flags.parsed_flags);
    
    if ((xflag[1]&262144) != 0) {
        encodings::debug_dump();
    }

    
    if (flags.isexplicit("allsnapups") && flags.allsnapups && flags.labelnum > 0) {
        Out->msg(ERR, "The flags --allsnapups=true and --labelnumber cannot be used together.");
        return EXIT_BAD_FLAGS;
    }

    
    if(!flags.create && flags.forcewo)
    {
        Out->msg(ERR, "The flag --forcewo only can be used with flag --create.");
        return EXIT_ABORT;
    }

    if (flags.replicate) {
        dstflags.set_defaults();
        dstflags.read_config(tool_avtar, argc, argv);
        
        
        
        dstflags.setindex(1);
        if ((flags.destination_data == client_config_flags::gsan_to_ddr) && (flags.rechunk != tristateflag::st_enable))
            flags.rechunk = tristateflag::st_enable;
    }

    {   
        const datetime nowx;
        const buildinfo build(Out->get_toolname(), buildinfo::client_version);
        const ustring tz(datetime::TzDst.av_tzname);
        Out->msg(INFO, "<7977>Starting at %s %s [%s %s %s %s-%s]", *nowx.image(), *tz, *build.appname(), *build.date(), *build.version(), *build.platform(), *build.processor());
    }

    
    mycontext->start_watchdog(WATCHDOG_CANCEL_SECS);

#if SYSTEM_WINDOWS
    MAPISESSION client_mapisession;

    
    
    

    if (flags.mapi)
    {
        if (!client_mapisession.init(flags.mapiprofile, flags.mapipassword, flags.mapiserver, flags.mapimailbox, flags.mapipst ))
        {
            
            
            
            
            
            Out->msg(ERR, "<5510>Unable to login to MAPI, remaining open for avagent connections");
            mapisessionp = NULL;

        } else {
            mapisessionp = &client_mapisession; 
        }
    }
#endif

  

    if (istar && flags.pluginport) {
        
        
        
        
        flags.read_tool_config_only(tool);
        
    }

#if !defined(AVOID_NETWORKER_INTERFACE)
    
    
    if (flags.xdrctl && flags.ctlinterface.isempty()) {
        flags.ctlinterface = XDRCTL_CONNECTION_INTERFACE_KEY;
    }
#endif

    DB->msg("checking ctlinterface:'%s'", *flags.ctlinterface);
    if (!flags.ctlinterface.isempty()) {

        DB->msg("client trying to run in ctl_mode int:%s port:%d", *flags.ctlinterface, flags.ctlcallport);
        

        
        
        IPADDR ipaddr;
        if (flags.ctlcallip.isempty()) {
            ipaddr = IPADDR(IPADDR::localhost.getaddr(), flags.ctlcallport);
        } else {
            ipaddr = IPADDR(flags.ctlcallip, flags.ctlcallport);
        }

        if (!run_in_ctl_mode(ipaddr, flags, dstflags)) {
            if (mycontext->tomato) {
                DB->msg(DBTXT("client::runex calling terminate on main sup, exiting runex in the middle"));
                mycontext->tomato->terminate();
            }
            return uapp::staging().getExitCode();   
        }

        if (!uapp::staging().canRun()) {
            DB->msg("client::runex cannot run");
            return uapp::staging().getExitCode();
        }

        
        
        
        
        
        if (flags.encrypt=="proprietary" && flags.encrypt_strength=="cleartext") flags.encrypt_strength=DEFAULT_ENCRYPT_STRENGTH;

        
        
        
        
        flags.read_tool_config_only(tool);
    }
    
    else if(flags.forcewo)  {

        DB->msg("client trying to run in adhoc_mode");
        IPADDR ipaddr;
        if (flags.ctlcallip.isempty()) {
            ipaddr = IPADDR(IPADDR::localhost.getaddr(), flags.ctlcallport);
        } else {
            ipaddr = IPADDR(flags.ctlcallip, flags.ctlcallport);
        }

        if (!run_in_adhoc_mode(ipaddr, flags)) {
            if (mycontext->tomato) {
                DB->msg(DBTXT("client::runex calling terminate on main sup, exiting runex in the middle"));
                mycontext->tomato->terminate();
            }
            return uapp::staging().getExitCode();
        }

        flags.read_tool_config_only(tool);

    }

    
    
    if (!flags.dtoaddr.isempty() && !flags.fakeprogress) {
        
        

        const pidtype pid(pidtype::image(pidtype::dto_import), pidtype::dto_import);
        const widtype wid(ustring::sprintf("process-id-%s", *tostr(proccntl::get_current_process_id())));
        const IPADDR dtoip(flags.dtoaddr, flags.dtoport);

        ctl_statep statep = new ctl_state(cidtype(flags.clientid), pid, wid, ustring());  

        
        dto_ctl_conn = new ctl_connection(*mytable, statep, dtoip, true);

        
        if (!dto_ctl_conn.isnull()) {
            
            
            dto_ctl_conn->disable_usessl();

            fileref empty;
            if (dto_ctl_conn->handshake(empty, wid.image(), ctl_message_header::version_2)) {
                DB->msg("DTO connection created");

                
                if ((mycontext->dto_supp = new utar_dto_sup(*mytable, statep, flags, mycontext))) {
                    DB->msg("client: starting up utar_dto_sup");
                    mycontext->dto_supp->start();
                    DB->msg("client: waiting on utar_dto_sup");
                    const bool xcontinue = mycontext->dto_supp->should_i_do_something();
                    DB->msg("client: utar_dto_sup after wait xcontinue:%d", xcontinue);
                } else {
                    return EXIT_MISC;
                }
            } else {
                Out->msg(FATAL, "Unable to connect to Avamar Extended Retention daemon. Please ensure that the daemon is running and listening on port %d", flags.dtoport);
                return EXIT_MISC;
            }
        }

        
        
        
        
        
        
        flags.read_tool_config_only(tool);
    }

    if (!flags.fakeprogress) {
        validate_stream_flags();

          
        if (((flags.streamformat_out == utar_flags_enums::streamformat_tar) ||
             (flags.streamformat_out==utar_flags_enums::streamformat_dump)) &&
            flags.media_out.isempty()) flags.to_stdout = true;   

        if (flags.streamformat_in==utar_flags_enums::streamformat_dump || flags.streamformat_out==utar_flags_enums::streamformat_dump)
            flags.internal=true; 
    }

    
    if (flags.randchunk && !flags.isexplicit("nocache")) flags.nocache = true;  

    
    
    
    
    
    if (flags.pluginid.kind() == pidtype::backupboost) flags.nocache = true;

    
    if ((flags.degenerate || (flags.degenerate_mode != 0) || flags.dtoexportstream) && !flags.isexplicit("maxpending")) flags.maxpending = 100;

    
    
    if (flags.parallel) {
        const pidtype::pid_kind pkind = flags.pluginid.kind();
        if (pkind != pidtype::filesystem && pkind != pidtype::avexvss && pkind != pidtype::mossvss && pkind != pidtype::hypervvss && pkind != pidtype::backupboost) {
            Out->msg(INFO, "IGNORING --parallel flag because it's not supported by this plug-in");
            flags.parallel = false;
            flags.maxstreams = 1;
        }
    }

    flags.check_maxstreams();

    
    
    
    if ((flags.maxstreams != 1) && (flags.pluginid.kind() != pidtype::backupboost)) {
        if (SYSTEM_WINDOWS && flags.args.isempty()) {
            
            
            
            
            
            DB->msg("Parallel Pool tuning -- Full System backup");
        }
        else if (flags.args.size() <= 1) {
            flags.parallel = false;         
            flags.maxstreams = 1;           
        }
        else {  
            
            if(flags.maxstreams > flags.args.size()) { 
                flags.maxstreams = flags.args.size();
            }
        }
        flags.maxparallelfiles *= flags.maxstreams; 
    }
    assert(flags.maxparallelfiles > 0);

    
    
    
    
    

    if (flags.ddrenabled && !flags.nocache && flags.filecache_enabled) {
        if (!flags.paging_cache) {
            Out->msg(INFO, 2, "When using the filename cache for a DDR backend, the paging cache is enabled by default and can't be disabled.");
            flags.paging_cache = true;
        }
    }

    

    if (flags.isexplicit("cache-page-size") ||
        flags.isexplicit("cache-champion-ratio") ||
        flags.isexplicit("cache-musthave-threshold") ||
        flags.isexplicit("cache-champion-reserved") ||
        flags.isexplicit("cache-max-pages-resident")) {

        Out->msg(WARN, "Do not specify the paging cache tuning flags. These flags are for development use only and using them will negatively impact your ability to use the paging cache.");
    }

    if (flags.ddrenabled && (flags.streamformat_in != utar_flags_enums::streamformat_none || flags.streamformat_out != utar_flags_enums::streamformat_none)) {
        
        if (!flags.isexplicit("blocksize")) {
            
            flags.blocksize = 256 * 1024;
            Out->msg(INFO, 2, "client: setting write blocksize to %s for file system backup to DD system",
                     *byteunits((double)flags.blocksize, 4, 5));
        }

        if (!flags.isexplicit("ddr-threshold")) {
            flags.ddrthreshold = 0;
            Out->msg(INFO, 2, "client: setting ddr-threshold to zero for file system backup to DD system");
            
        }

        
        
        
        if (flags.parallel || flags.maxstreams > 1) {
            if (!multistreamingddr_disabled) {
                Out->msg(INFO, "client: allowing parallel mode for file system backup to DD system, with flags.parallel=%d and flags.maxstreams=%d",
                         flags.parallel, flags.maxstreams);
            } else {
                flags.parallel = false;
                flags.maxstreams = 1;
                Out->msg(INFO, "client: disabled parallel mode for file system backup to DD system");
            }
        }
    }

    const int parallelFileMultiplier = 20;
    
    
    
    
    if (flags.maxopenfiles == 0) flags.maxopenfiles = flags.maxparallelfiles * parallelFileMultiplier;
    if (flags.maxopendirs == 0)  flags.maxopendirs  = flags.maxparallelfiles * parallelFileMultiplier;

    if (flags.showlog) {
        flags.extract = true;                                   
        flags.to_stdout = true;                                 
        flags.verbose = false;                                  
        flags.internal = true;                                  
        if (!flags.isexplicit("quiet")) {
            flags.quiet = true;                                 
            Out->enable(INFO, 0);
        }
        if (flags.arg.isempty()) {                               
            flags.arg = ustring(UNDOO_DIRECTORY_NAME) / ustring(LOG_FILENAME);
        
        } else if (!flags.ndmp_prefix.isnull()) {
            
            
            
            
            
            flags.arg = ustring(flags.ndmp_prefix / UNDOO_DIRECTORY_NAME / flags.arg);
            DB->msg("client::RunEx Setting log path to:'%s'", *flags.arg);
        } else {
            flags.arg = ustring(UNDOO_DIRECTORY_NAME) / flags.arg; 
        }                                                       
        flags.args.clear();
        flags.args.push_back(flags.arg);
    }

    if ((flags.from_stdin || flags.to_stdout ) && flags.args.size() > 1 && flags.ignore_workorder_section.contains("targets")) {
        Out->msg( INFO, "<7218>Truncating arg list for stream %s", *flags.args.image() );
        ustring tmp = flags.args.back();
        flags.args.clear();
        flags.args.push_back( tmp );
        Out->msg( INFO, "<7219>New arg list %s", *flags.args.image() );
    }

    if (flags.fakeprogress) {
        Out->msg(INFO, "<6640>Running in progress mode");
        DB->msg("client::RunEx: fakeprogress %d, create %d", flags.fakeprogress, flags.create);
        flags.nocache = true;                
        flags.nouserinfo = true;             
    }

    if (flags.debug_messages) Out->enable(STATS);       

    if (flags.forceaddr) flags.singleconn = true;

    if (flags.to_stdout && flags.verbose) {
        Out->msg(FATAL, "<5074>Cannot use --verbose with --to-stdout.   To restore data to stdout remove the --verbose option.");
        exit(1);
    }
    const ustring stdout_desc(uwrapper::mk_fileno_streamdesc(STDOUT_FILENO));
    if (flags.media_out.equal(stdout_desc) && (flags.verbose != 0)) {
        Out->msg(WARN, "<10786>Cannot use --verbose with --stream=&1, remove the verbose option flag to stop this error");
        exit(1);
    }

    if (flags.net_throttle) Out->msg(INFO, "<6586>Network bandwidth throttling is enabled, limiting to approx.  %.3f Mbps (%s/sec)", flags.net_throttle, *byteunits((flags.net_throttle*1000000.0)/8.0));
    if (flags.cpu_throttle) Out->msg(INFO, "<6587>CPU throttling is enabled, limiting CPU usage to approx. %d%%", flags.cpu_throttle);

    if (flags.singleconn || flags.nearest) {
        
        flags.alldc = false;
        flags.allnode = false;
    }

    if (flags.statistics && ! flags.quiet)
        Out->enable(STATS, flags.statistics);

    
    filebase::blocksize = flags.blocksize;

    
    
    
    
    if (flags.backupstate == utar_flags_enums::backstate_begin)
        flags.nohiddendir = true;
    
    if (flags.hiddensnapup && (flags.backupstate != utar_flags_enums::backstate_onetime)) {
        Out->msg(INFO, "Can't specify hidden backup flag in a partial backup - resetting to false");
        flags.hiddensnapup = false;
    }

    if (flags.validate && flags.randchunk==0) flags.extract = true;
        

    
    if (!(tool == tool_avtar && ((flags.create && !flags.dtoexportstream) || flags.replicate)))
        flags.nowrapupcancel = true;
    uapp::staging().skipWrapup(flags.nowrapupcancel);

    if (flags.rebuildcache) {
        flags.extract = false;  
        flags.validate = false; 
        flags.list = true;
    }

    if (flags.repaircache || flags.checkcache) {
        flags.extract = false;  
        flags.validate = false; 
        flags.create = true;
    }

    
    
    if (flags.labelnum_delta != 0 && !flags.isexplicit("internal")) {
        flags.internal = true;
    }

    const bool isexplicit_backupboost_config(flags.isexplicit("backupboost-config"));
    const bool isexplicit_backupboost_unconfig(flags.isexplicit("backupboost-unconfig"));
    const bool isbackupboost(flags.backupboostlist || isexplicit_backupboost_config || isexplicit_backupboost_unconfig);

    
    int cnt = flags.create + flags.extract + flags.list + flags.archives + flags.history + flags.delbackup + flags.browsefs + flags.fakeprogress;
    if (!isbackupboost && !flags.bbjournalmaint && istar && cnt != 1) {
        
        
        
        
        if (flags.fakeprogress) {
            DB->msg("client::RunEx progress avtar allowing conflicting flags cnt=%d", cnt);
        } else if (flags.mapi && flags.pluginport) {
            
            
            
            
            
            
            return EXIT_OK;
        } else {
            if (cnt<1)
            {
              Out->msg(FATAL, "<5078>Missing action option.   You must specify one of --create (-c), --extract (-x), --list (-t), --backups, --validate, --showlog or --delete.");
            } else {
              Out->msg(FATAL, "<7833>You may not specify more than one of --create (-c), --extract (-x), --list (-t), --backups, --validate, --showlog or --delete.");
            }
            return EXIT_BAD_FLAGS;
        }
    }

    
    if (flags.create && flags.vardir.isempty() && !flags.nocache) {
        Out->msg(FATAL, "<5209>Unspecified cache directory, set with --cachedir=");
        return EXIT_BAD_FLAGS;
    }


#if SYSTEM_WINDOWS
    if (flags.create && !flags.nocache) {
        ustring strLockname("UTAR_LOCK");

        if (!flags.vardir.isempty()) {
            upath strLockpath(upath(flags.vardir).to_absolute());
            if(!flags.cacheprefix.isempty()) {
                strLockpath.push_back(flags.cacheprefix);
            }
            strLockpath.push_back(strLockname);
            strLockname = strLockpath.image("|");
        }

        if (HANDLE hWinLock = CreateMutex(NULL,FALSE, *uwstring(encodings::utf8, strLockname))) {
            CloseHandle(hWinLock);
        } else {
            const unsigned long ulError = GetLastError();

            if( ulError == ERROR_ALREADY_EXISTS ||
                ulError == ERROR_ACCESS_DENIED) { 

                Out->msg(FATAL, "<5239>Cannot run multiple backups with the same VARDIR and cache-prefix at the same time.  Consider changing VARDIR or using --cache-prefix option.");
                return EXIT_LOCKED;
            }

            if (ulError) {
                platerror pe(platerror::use_given, ulError);
                Out->msg(ERR, "<6641>Could not create %s mutex (error: %s)", *strLockname, *pe.description());
            }
        }
    }
#endif

    
    
    
#if SYSTEM_WINDOWS
    VolumeInfo::setExcludeVols(flags.excl_vols);
#endif

    
    ReparsePoints::SetReparseOptions(flags.reparse_restore_option, flags.reparse_limit, flags.dereference, flags.single_device, flags.preserve_hardlinks, flags.create);

    if (flags.makeview) {
        
        if (flags.adechunker) {
            Out->msg(ERR, "ADE Chunker (--adechunker) can't be used with makeview (--makeview)");
            return EXIT_BAD_FLAGS;
        }

        flags.validate=true;           
        
        flags.nocache=true;            
      
      
        if (!flags.makeview_nosubsysteminfos) flags.internal = true;  
        
        flags.incpartials = true;
    }

    
    if (flags.backupstate == utar_flags_enums::backstate_partial ||
        flags.backupstate == utar_flags_enums::backstate_final)
        flags.incpartials = true;

    if (flags.nouserinfo) {
       Out->msg(INFO, 2, "<5697>Suppressing external name service queries for uids and gids");
       userid::instance()->do_external_lookup(false);
       groupid::instance()->do_external_lookup(false);
    }

    
    if (flags.replicate && !flags.isexplicit("retention-type"))
        flags.retentiontype = tretentiontype::alltypes();

    
    tretentiontype rtype(flags.retentiontype);
    if (!rtype.get_errors().isempty()) {
        Out->msg(ERR, "%s", *rtype.get_errors());
        return EXIT_BAD_FLAGS;
    }

    tbackuptype btype(flags.backuptype);
    if (!btype.get_errors().isempty()) {
        Out->msg(ERR, "%s", *btype.get_errors());
        return EXIT_BAD_FLAGS;
    }

    
    pluginidlist testlist;
    if (!flags.parse_pluginid_flags(testlist)) {
        Out->msg(ERR, "<8711>Invalid plugin ID list.");
        return EXIT_BAD_FLAGS;
    }

    
    if (flags.dtoexportstream) {
        

        
        if (flags.args.size() > 0) {
            Out->msg(FATAL, "<12556>No targets are allowed for a backup export");
            return EXIT_BAD_FLAGS;
        }

        
        if (flags.extract) {
            if (flags.streamformat_out!=utar_flags_enums::streamformat_avpax && flags.streamformat_out!=utar_flags_enums::streamformat_cdsf) {
                Out->msg(FATAL, "<12557>Stream format out must be set to avpax or cdsf for backup export processing");
                return EXIT_BAD_FLAGS;
            }

            
            flags.internal       = true;
            flags.restoresystem  = true;
            flags.restorehidden  = true;
            flags.notemporary    = false;
            flags.restorerootdir = true;
            flags.restoreshortnames = true;
            flags.restorewfp     = true;
            flags.archive_unfiltered_data = true;
            
            xflag[22] |= 67108864;
        } else if(flags.create) {
            if (flags.streamformat_in!=utar_flags_enums::streamformat_avpax && flags.streamformat_in!=utar_flags_enums::streamformat_cdsf) {
                Out->msg(FATAL, "Stream format in must be set to avpax or cdsf for backup import processing");
                return EXIT_BAD_FLAGS;
            }
        } else {
            Out->msg(FATAL, "<12558>For backup export processing, need to specify either -x, extract (export), or -c, create backup (import)");
            return EXIT_BAD_FLAGS;
        }
    }


    
    
    cidtype clientid(flags.clientid);
    DB->msg("client flags.clientid:%s, clientid:%s", *flags.clientid, *clientid.image());
    if (flags.sessionticket.isnull() &&
        flags.workorderfile.isnull() &&
        !flags.degenerate &&
        !flags.browsefs &&
        !flags.backupboostlist &&
        !isexplicit_backupboost_config &&
        !isexplicit_backupboost_unconfig &&
        !flags.bbjournalmaint &&
        !(xflag[12]&65535))
    {
        
        
        if (flags.hfsaddr.isempty() && flags.catalog_address.isempty()) {
            Out->msg(FATAL, "<5086>No server address specified.  Reinstall software or add --server option to specify IP or DNS address of the server.");
            return EXIT_BAD_FLAGS;
        }
        if (istar || (2 == flags.acntver)) {
          if (flags.au.isnull() && flags.id.isnull() && flags.catalog_user.isempty()) {
                Out->msg(FATAL, "<5087>User authentication error.  Login user name not specified.   Use --id=<name> option to specify server user name.");
                return EXIT_AUTH_FAIL;
          
          } else if (flags.ap.isnull() && flags.catalog_password.isempty() &&
                     !acntmngr::getPassword(stdin, stdout, "Password: ", flags.ap)) {
                Out->msg(FATAL, "<5089>User authentication error logging into the server.   Specify login password with the --password option.");
                return EXIT_AUTH_FAIL;
          }
        }
        setbuf(stdout, NULL);
        DB->msg("GSAN IP address is %s:%d", *flags.hfsaddr, flags.hfsport);
        DB->msg("Catalog IP Address is %s", *flags.catalog_address);
        
    }

    DB->msg("client::RunEx: flags.sessionid:%s clientid:%s", *tostr(flags.sessionid), *clientid.image());
 
    
    if (flags.create && !flags.verify_required_acnt_flags())
    {
        Out->msg(ERR, "Unable to determine account path, check --id and --path options");
        return EXIT_BAD_FLAGS;
    }

    
    
    
    

    if (flags.account_metadata) {
        exitcodes_t excode = prepForMetadata(clientid);
        if (excode != EXIT_OK)
            return excode;
    }

  
  
  
  
  
  
    if (0 != iSpecialFlag)
      {
      return(EXIT_OK); 
      }
    

    if (istar)
        setmemman_filename(*(flags.vardir / "memman.out"));

    
    
    
    
    exitcodes_t exitcode = main_control(clientid);
    
    
    

    backstats *stats = mycontext->getstatsobj(mycontext->get_dpn_statstype(dpn0));

    double elapsed = timer::elapsed();
    const double tbytes = stats->get_filebytes_prog();  
    const double abytes = stats->get_filebytes(backstats::sent);

    int compbypassed;
    double comptime, compsize, uncompsize;
    stats->get_compress(comptime, compsize, uncompsize, compbypassed);
    if (compsize != 0) {
        double compress = (uncompsize - compsize) / uncompsize;
        DB->msg("compression limit = %d%%, level = %d", flags.cpercent, flags.clevel);
        DB->msg("compression reduced %.0f of %.0f bytes = %.0f%%, %.3f secs, bypassed %d files", uncompsize-compsize, uncompsize, compress * 100, comptime, compbypassed);
        Out->msg(STATS, "<6142>reduced %s of %s bytes = %.0f%% savings, bypassed %s files",
                 *commas(uncompsize-compsize), *commas(uncompsize), compress * 100, *commas(compbypassed));
    }

    DB->msg("total time = %6.1f seconds", elapsed);
    DB->msg("total bytes/second = %.0f", tbytes / elapsed);
    DB->msg("atomic bytes/second = %.0f", abytes / elapsed);

    Out->msg(STATS, "<6144>total time = %s seconds", *commas(elapsed, 1));
    Out->msg(STATS, "<6146>total bytes/second = %s", *commas(tbytes / elapsed));
    Out->msg(STATS, "<6147>atomic bytes/second = %s", *commas(abytes / elapsed));

    double prefetchtime = stats->get_prefetchtime();
    if(prefetchtime != 0) {
        double adjusted = elapsed - prefetchtime;
        Out->msg(STATS, "<6148>after prefetch total bytes/second = %.0f", tbytes / adjusted);
    }

    
    Out->report_write_errors();

    int warnings, errors, fatals;
    Out->get_total_counts(warnings, errors, fatals); 

    if (Out->is_enabled(INFO)) {
        
        ustring errsummary(DB->error_counts_image());
        if (!errsummary.isempty()) {
            Out->msg(INFO, "<6149>Error summary: %d error%s: %s", errors, errors != 1 ? "s" : "", *errsummary);
        }
    }

    
    
    int openfile_errors = (DB->number_of_errors(5328) + DB->number_of_errors(5139));

    
    if (exitcode == EXIT_OK && fatals > 0) exitcode = EXIT_MISC;   
    if (exitcode == EXIT_OK && errors > 0) {
        exitcode = EXIT_OK_WITH_ERRORS;
        if (errors == openfile_errors && (xflag[10]&1)==0) exitcode = EXIT_OK_WITH_OPENFILES;   
    }

    
    
    
    
    
    assoc add2env;
    add2env.enter("AVAMAR_EXITCODE", (int)exitcode);
    subscript::old_runat(flags, add2env,
                         flags.run_at_end, flags.run_at_end_clauses,
                         flags.run_at_end_exit,
                         istar ? AVTAR_EXENAME : CLIENT_EXENAME);

    
    handle_wrapup(exitcode, stats);

    
    
    {
        const ustring path(flags.sessionticket);

        if (flags.delete_sessionticket && !path.isempty() && !(path.byteindex(0) == '<' && path.contains(TICKET) == 1)) {

            uwrapper::uunlink(path);  
        }
    }



        char errmsg[128] = "";
        if (errors)   snprintf(&errmsg[strlen(errmsg)], sizeof(errmsg)-strlen(errmsg), "%d error%s, ",
                               errors, errors==1?"":"s");
        if (warnings) snprintf(&errmsg[strlen(errmsg)], sizeof(errmsg)-strlen(errmsg), "%d warning%s, ",
                               warnings, warnings==1?"":"s");
        ustring status(ExitCode::isOkayCode(exitcode)?"completed":"failed");
        
        
        Out->msg(INFO, "<5314>Command %s (%sexit code %d: %s)",
                        *status, errmsg, ExitCode::translateCodeToMC(exitcode), *ExitCode::getExitDescription(exitcode));
        avamardebug::msg(*ustring::sprintf(DBTXT("Command %s (%sexit code %d: %s)"),
                        *status, errmsg, ExitCode::translateCodeToMC(exitcode), *ExitCode::getExitDescription(exitcode)));


        
        
        

    DB->msg("client::runex returns %d", exitcode);

    return exitcode;
}

int client::run()
{
  exitcodes_t iResult = RunEx( 0 );  

  if(mycontext->dto_supp) {
      
      mycontext->dto_supp->terminate();
  }

  
  if(mycontext->tomato) {
      DB->msg(DBTXT("client::runex calling terminate on main sup"));
      mycontext->tomato->terminate();
  }

  return( iResult );
}











void client::check_script_allowed(stringlist &s, bool is_stdout, bool is_create, bool is_extract, const ustring &script)
{
    
    if(!is_extract && !is_create) {
        Out->msg(WARN, "<12559>Script (%s) execution was suppressed.  Scripts are only run during a create or extract operation.", *script);
        s.clear();
        return;
    }

    
    if(is_extract && is_stdout){
        Out->msg(WARN, "<12560>Script (%s) execution was suppressed due to output being sent to stdout.", *script);
        s.clear();
        return;
    }

}


extern char *main_application_name;




bool client::run_in_ctl_mode(const IPADDR connect_to, utar_flags_info& flags, utar_flags_info& dstflags) {

  DB->msg("client.run_in_ctl_mode(%s) ctlcallport:%d ctlinterface:%s xdrctl:%d", *connect_to.image(), flags.ctlcallport, *flags.ctlinterface, flags.xdrctl);

  
  
  cryptofuncs::fipslibinitverbose(); 
  if (sock::libinit("tls", flags.sysdir, flags.encrypt_strength, true ) != EXIT_OK) {
    Out->msg(FATAL, "Unable to initialize socket library for CTL.");
    return false;
  }

  

  mainq = new ctl_queue("mainq");

  widtype wid("");  
  pidtype pid(AVTAR_EXENAME, pidtype::my_os+pidtype::filesystem);
  if(mycontext)
      mycontext->client_ctl_statep = new ctl_state(cidtype(flags.clientid), pid, wid, 0, 0, mainq);  
  else {
    Out->msg(FATAL, "<6646>client::run_in_ctl_mode No context defined, unable to run in ctl mode");
    return false;
  }

  ctl_key = flags.ctlinterface;


  mytable = new ctl_table;

  
  mycontext->tomato = new utar_ctl_sup(*mytable, mycontext->client_ctl_statep, flags, mycontext, &dstflags);
  mytable->set_sup(mycontext->tomato);

  

  if(flags.xdrctl) {
      
#if !defined(AVOID_NETWORKER_INTERFACE)
      ctl_conn = new xdrctl_connection(mycontext, flags, *mytable, mycontext->client_ctl_statep, connect_to);
#else
      Out->msg(ERR, "<7537>xdrctl connection is not supported on this platform");
#endif
  } else {
      ctl_conn = new ctl_connection(*mytable, mycontext->client_ctl_statep, connect_to);
  }
  fileref empty;
  if(ctl_conn.isnull()) {
      Out->msg(FATAL, "<6647>Unable to create connection to %s", *connect_to.image());
      uapp::staging().startTermination(EXIT_CONNECT, "can't create connection (initial)");
      return false;
  }

  ctl_connection::set_max_ctl_connect_attempts(flags.max_ctl_connect_attempts);
  ctl_connection::set_ctl_reconnect_interval(flags.ctl_reconnect_interval);

  if (!ctl_conn->handshake(empty, ctl_key)) {
      Out->msg(FATAL, "<5221>Unable to connect to %s", *connect_to.image());
      uapp::staging().startTermination(EXIT_CONNECT, "can't connect (handshake)");
      return false;
  }
  Out->msg(INFO, "<6767>Successfully connected to %s", *connect_to.image());

  DB->msg(DBTXT("client.run_in_ctl_mode starting up sup"));
  mycontext->tomato->start();
  DB->msg(DBTXT("client.run_in_ctl_mode after start, before wait"));
  const bool xcontinue = mycontext->tomato->should_i_do_something();
  DB->msg(DBTXT("client.run_in_ctl_mode after wait xcontinue:%d"), xcontinue);

  return xcontinue;
}



exitcodes_t client::main_control(const cidtype& clientid)
{
    exitcodes_t ret_exitcode = EXIT_OK;

#if SYSTEM_WINDOWS
    
    
    
    
    
    if (flags.mapi) {
        if(!mapisessionp) {
            ret_exitcode = EXIT_AUTH_FAIL;
        }
    }
#endif

    if(ret_exitcode == EXIT_OK) {
        
        do {
            ctl_messagep requested_commandp;       
            ctl_queuep   response_queuep;          

            if(mycontext->tomato && !mycontext->tomato->perform_command_queuep.isnull()) {
                Out->msg(INFO, "<6649>Waiting on perform_command_queue dequeue");

                if(mycontext->tomato->perform_command_queuep->dequeue(requested_commandp,
                                                                      response_queuep,
                                                                      60) != ctl_queue::dequeued_ret) {
                    
                    break;
                }
                Out->msg(DEBUG, DBTXT("client::main_control() Received request!"));
            }

            
            const bool is_backup = ((0 == argc) ||
                                    (0 == strcmp(argv[0], "nbackup")) ||
                                    (flags.create) ||
                                    ((argc > 1) && (0 == strcmp(argv[1], "nbackup"))));

            
            if(is_backup && flags.incremental) {
                mycontext->incflags.set_defaults();
                mycontext->incflags.read_config(tool_avtar, argc, argv, false);  
                mycontext->incflags.setindex(1);
                
                mycontext->incflags.parse(argc, argv, "");
                Out->msg(INFO, "<5905>Incremental flags: %s", *mycontext->incflags.parsed_flags);
            }

            
            for(int i=0; i<(int)(sizeof(xflag)/sizeof(int)); i++) {
                if(xflag[i]) DB->msg(DBTXT("Debug: xflag[%d] = %d (0x%x)"), i, xflag[i], xflag[i]);
            }

            

            
            
            
            
            
            assoc add2env;
            subscript::old_runat(flags, add2env,
                                 flags.run_at_start, flags.run_at_start_clauses,
                                 flags.run_at_start_exit,
                                 istar ? AVTAR_EXENAME : CLIENT_EXENAME);

            if(flags.browsefs) {
                DB->msg(DBTXT("Browse path(arg) = %s"), *flags.arg);
                ret_exitcode = utar_commands::do_browse(flags);
                return ret_exitcode;
            }

            const bool isexplicit_backupboost_config(flags.isexplicit("backupboost-config"));
            const bool isexplicit_backupboost_unconfig(flags.isexplicit("backupboost-unconfig"));

            if(flags.backupboostlist || isexplicit_backupboost_config || isexplicit_backupboost_unconfig)
            {
                DB->msg("Backboost operation requested");

                if (pidtype::my_os != pidtype::os_linux) {
                    Out->msg(ERR, "BackupBoost operations are only supported on Linux");
                    return EXIT_MISC;
                }

                
                flags.pluginid = pidtype(flags.pluginid.name(), (pidtype::my_os + pidtype::backupboost));

                bool badflags(isexplicit_backupboost_config && isexplicit_backupboost_unconfig);
                badflags = badflags || (flags.backupboostlist && (isexplicit_backupboost_config || isexplicit_backupboost_unconfig));
                if (badflags) {
                    Out->msg(ERR, "Can only specify one of the following flags: --%s, --%s or --%s",
                                  "backupboost-list", "backupboost-config=", "backupboost-unconfig="); 
                    return EXIT_MISC;
                }

                if (isexplicit_backupboost_config && flags.backupboostconfig.isempty()) {
                    Out->msg(ERR, "Flag --backupboost-config= must have a list of one or more mount points");
                    return EXIT_MISC;
                }

                if (isexplicit_backupboost_unconfig && flags.backupboostunconfig.isempty()) {
                    Out->msg(ERR, "Flag --backupboost-unconfig= must have a list of one or more mount points");
                    return EXIT_MISC;
                }

                ret_exitcode = utar_commands::do_backupboost_browse(flags);
                return ret_exitcode;
            }

            if (flags.bbjournalmaint) {
                if (!flags.isexplicit("bbjournalmaintdate") || flags.bbjournalmaintdate.isempty()) {
                    Out->msg(ERR, "Must specify a valid date for --bbjournalmaintdate when performing BackupBoost journal maintenance.");
                    return EXIT_BAD_FLAGS;
                }
                return utar_commands::do_backupboost_journal_cleanup(flags, mycontext);
            }

#if SYSTEM_WINDOWS
            
            
            if(sis_feature_enabled && !flags.makeview && ((flags.extract && !flags.to_stdout ) || (is_backup && !flags.from_stdin))) {
                
                if(win_os_version_info::is_os_64bit()) {
                    OSVERSIONINFOEX osverstr;
                    ZeroMemory(&osverstr, sizeof(OSVERSIONINFOEX));
                    osverstr.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                    GetVersionEx((OSVERSIONINFO *)&osverstr);
                    DB->msg(DBTXT("OS Version (Major, Minor, SP Major, SP Minor): %x, %x, %x, %x"),
                                                                osverstr.dwMajorVersion,
                                                                osverstr.dwMinorVersion,
                                                                osverstr.wServicePackMajor,
                                                                osverstr.wServicePackMinor);
                    
                    if((osverstr.dwMajorVersion == 6) && (osverstr.dwMinorVersion == 0) ||
                        (osverstr.dwMajorVersion == 6) && (osverstr.dwMinorVersion == 1)) {

                        unsigned long retval(~0);
                        retval = wservice::query_named_service(SIS_SERVICE);
                        if ((retval & APPLICATION_ERROR_MASK) == APPLICATION_ERROR_MASK) {
                            Out->msg(INFO, "<10792>Single Instance Store Groveler Service installed - initializing WSS SIS Manager.");
                            wss_sis_manager::sis_manager = new wss_sis_manager(is_backup, flags.vardir);
                        }
                        else {
                            Out->msg(INFO, "<10793>Single Instance Store Groveler Service NOT installed - WSS SIS Manager will not be started.");
                        }
                    }
                    else if (win_os_version_info::is_server_2012_or_newer()) {
                        
                        
                        
                        Out->msg(INFO, "Restore target is Win2012 - initializing WSS SIS Manager.");
                        wss_sis_manager::sis_manager = new wss_sis_manager(is_backup, flags.vardir);
                    }
                }
            }
#endif

            
            
            
            if (flags.fakeprogress && flags.replicate) {
                dstflags.parse(argc, argv, "");
                flags.encrypt = dstflags.encrypt;
                flags.encrypt_strength = dstflags.encrypt_strength;
                const bool engaged = dstflags.degenerate? mycontext->engageADE() : mycontext->engageADE(&dstflags);
                if (!engaged) {
                    Out->msg(INFO, "Failed to initiate session with destination server '%s' for parent replication job status.", *dstflags.hfsaddr);
                    flags.replicate = false;
                }
            }

            
            if (is_backup) {
                uapp::catchinterrupt(); 
                nbackmain nbm(mycontext, flags, dstflags);
                nbm.setBuildVersion(build().version());
                ret_exitcode = nbm.doBackup();
            } else if(strcmp(argv[0], "timetest"   )==0 || (xflag[12]&65535)) { client_commands::timetest(flags);   
            } else if(strcmp(argv[0], "extentstest")==0 || (xflag[12]&524288)) { client_commands::testdataextents(flags.count);
            } else if(strcmp(argv[0], "controltest")==0) { client_commands::controltest(flags);
            } else if(strcmp(argv[0], "testpipe"   )==0) { client_commands::testpipe(flags);
            } else if(strcmp(argv[0], "agent"      )==0) { client_commands::testagent();
            } else if(strcmp(argv[0], "agentserver")==0) { client_commands::testagentserver(flags);
            } else {
                if (flags.extract) uapp::catchinterrupt(); 

                
                ret_exitcode = ExecuteCommand( argv[0], clientid, requested_commandp, response_queuep );

                mycontext->getstatsobj(context::restorestats)->dump();
            }

            
        } while(mycontext->tomato && !mycontext->tomato->perform_command_queuep.isnull());
    }

    return ret_exitcode;
}


bool client::run_in_adhoc_mode(const IPADDR connect_to, utar_flags_info& flags) {

    DB->msg("client.run_in_adhoc_mode(%s) ctlcallport:%d ctlinterface:%s", *connect_to.image(), flags.ctlcallport, *flags.ctlinterface);

    
    
    cryptofuncs::fipslibinitverbose();
    if (sock::libinit("tls", flags.sysdir, flags.encrypt_strength, true ) != EXIT_OK) {
        Out->msg(FATAL, "Unable to initialize socket library for CTL.");
        return false;
    }

    
    
    mainq = new ctl_queue("mainq");

    pidtype pid(AVTAR_EXENAME, pidtype::my_os+pidtype::filesystem);
    widtype wid = widtype::createMcNahWid();

    if(mycontext)  {
        mycontext->client_ctl_statep = new ctl_state(cidtype(flags.clientid), pid, wid, 0, 0, mainq);  
    }
    else {
        Out->msg(FATAL, "<6646>client::run_in_adhoc_mode No context defined, unable to run in ctl mode");
        return false;
    }

    ctl_key = ctl_message::getkey(pid, wid);
    mytable = new ctl_table;

    
    mycontext->tomato = new utar_ctl_sup(*mytable, mycontext->client_ctl_statep, flags, mycontext, &dstflags);
    mytable->set_sup(mycontext->tomato);

    
    DB->msg(DBTXT("client.run_in_ctl_mode starting up sup"));
    mycontext->tomato->start();

    ctl_messagep request_ctl_msg;
    callhome = new ctl_callhome(*mytable, mycontext->client_ctl_statep, connect_to, ctl_key, false);
    cli_man climan(&flags, uapp::tool_avtar, pidtype::filesystem, pidtype::my_os, mytable, callhome,
        mycontext->client_ctl_statep, mycontext->tomato, connect_to,wid);
    flags.operation_type = "backup";
    const int ret = climan.run();
    DB->msg("client.run_in_ctl_mode starting up sup %d", ret);
    if (ret == EXIT_BAD_FLAGS || ret == EXIT_MISC) {
        return false;
    }
    return mycontext->tomato->should_i_do_something();
}












#include "common.h"
#include "filestats.h"
#include "debug.h"
#include "output.h"
#include "utar_flags_info.h"
#include "timer.h"

filestats::filestats(const utar_flags_info& flags_, const upath& _path, double _size)
  : flags(flags_)
{
   f_path = _path;
   f_size = _size;
   stime = -1.0;        
   etime = 0.0;
}

void filestats::start() {
   
   if (flags.filestats > 0 && f_size.value() >= flags.filestatmin*0.1)
       stime = timer::elapsed();
}

void filestats::fupdate(reason why, double size, chunktype kind, bool system_info) {
    update(why, size, kind, system_info);
    if (kind.is_dir()) return;

    switch (why) {
        case excluded:
        case skipped:
        case filecache:
        case ddpresent:
        case ddsent:
          break;

        case hashcache:
        case ispresent:
        case sent:
          if (kind.is_anyatomic()) {
              ++f_atomcount;
          } else if (kind.is_anycomposit()) {
              ++f_compcount;
          } else assert(false);
          break;

        default:         assert(false);
    }
}

filestats::~filestats() {
    

    if (flags.filestats > 0) {
        
        
        
        
        
        
        double score = filebytes[stats::sent].value()*20.0 + 
                       filebytes[stats::ispresent].value()*5.0 +
                       filebytes[stats::hashcache].value();

        
        
        if (score >= (double)flags.filestatmin && stime > -1) {
            
            

            double etime = timer::elapsed();
            const ustring filename(xml_message::validvalue(f_path.image()));        
            DB->filelog(score, flags.filestats,
                        "<file score=\"%.0f\" name=\"%s\" size=\"%.0f\" fcache=\"%.0f\" hcache=\"%.0f\" ispresent=\"%.0f\" atomsent=\"%.0f\" compsent=\"%.0f\" atomcount=\"%.0f\" start=\"%.2f\" elapsed=\"%.2f\" />\n",
                 score, *filename, f_size.value(),
                 filebytes[stats::filecache].value(),
                 filebytes[stats::hashcache].value(),
                 filebytes[stats::ispresent].value(),
                 filebytes[stats::sent].value(),
                 compbytes[stats::sent].value(),
                 f_atomcount.value(),
                 stime,
                 etime-stime
            );
        }
    }
}
#if !defined(EXTENTSONLYTARPIPE_H_INCLUDED)
#define EXTENTSONLYTARPIPE_H_INCLUDED












#include "common.h"
#include "tarpipe.h"

class context;
class paxrec;
class extent;
class dataextents;



class extentsonlytarpipe : public tarpipe {
public:
  SAFEALLOC(extentsonlytarpipe);

  
  
 extentsonlytarpipe(const fileref& extentsdata_)
     : tarpipe(fileref(), 0, 0, ustring(), utar_flags_enums::streamformat_none, 0)
  {
      tarpipe::extents = dataextents(extentsdata_, false);
  };

  virtual ~extentsonlytarpipe() {};

private:
    NOCOPY(extentsonlytarpipe);
};

#endif
#include "common.h"
#include "dumpdirelem.h"
#include "direlem.h"
#include "dump_layout.h"
#include "direlemimpl.h"

#define clear_subnodes      ((xflag[13]&32)==0)  

void dumpDIRELEM::initialize(const s_spcl& header, unsigned char attributes) 
{
    const dinode& inode = header.c_dinode;
    int mode = inode.di_mode;

    zero(true);     

    kind = KIND_UNIX_SP;
    base_mtime = inode.di_mtime;
    base_attr  = ATTR_EXTENDED;

    impl->unixsp.st_ino = header.c_inumber;
    impl->unixsp.st_nlink = inode.di_nlink;

    impl->unixreg.st_uid = inode.oldids[0];
    impl->unixreg.st_gid = inode.oldids[1];
    impl->unixreg.st_mode = mode;
    impl->unixreg.eff_st_mode = mode;

    
    
    impl->unixsp.st_dev = +header.c_spare[26];
 DB->msg("dumpDIRELEM::initialize 26:%d st_dev:%d", +header.c_spare[26], +impl->unixsp.st_dev);

    









    unsigned short ft_mode((unsigned short)inode.di_mode & FT_IFMT);
    switch (ft_mode) {
    case FT_IFDIR: set_is_directory();  break;
    case FT_IFLNK: set_is_symlink(); break;
    case FT_IFBLK: impl->unixsp.st_rdev = inode.di_db[0]; break;
    case FT_IFREG:  break;
    default: DB->msg("dumpdirelem::initialize unknown mode %d", ft_mode);
    }

    

    
    
    
    
    
    
    if (clear_subnodes && subnodes) subnodes->clear();  
}



int dumpDIRELEM::c_spare_26() const {
    return device_number();  
}





















#include "common.h"
#include "debug.h"
#include "message.h"  
#include "mctypes.h"
#include "priqueue.h"
#include "nbackroot.h"
#include "workelem.h"
#include "workcontext.h"
#include "sock.h"
#include "layout.h"
#include "dirwalk.h"
#include "backstats.h"
#include "filename_cache.h"
#include "hash_cache.h"
#include "resource.h"
#include "runstage.h"
#include "acntmngr.h"

#include "reparse_points.h"

#if SYSTEM_WINDOWS
    #include "mapiwalk.h"

    #include "ntsecurity.h"
    #include "uwstring.h"
    #include "winpriv.h"
    #include "volumeinfo.h"
    #include "upath_win.h"
    #include "wmi.h"
#else
    #include "processlock.h"
#endif

#include "file_system_info.h"
#include "winversion.h"
#include "client.h"
#include "backstate.h"
#include "build.h"
#include "filenames.h"
#include "output.h"
#include "client_config_flags.h"
#include "hostinfo.h"
#include "cycle.h"
#include "utar_commands.h"
#include "utar_flags_info.h"
#include "utar_flags_enums.h"
#include "signposts_base.h"

#include "nbackfile.h"

#if SYSTEM_UNIX
#  include <sys/time.h>
#  include <sys/resource.h>
#endif

#include "dirstats.h"

#include "userid.h"

#include <strstream>
#if SYSTEM_WINDOWS
   #include <string>
#endif


#include "freezevol.h"
#include "timer.h"

#include "subscript.h"
#include "mtfread.h"
#include "utar_ctl_sup.h"
#include "netsys.h"
#include "uwrapper.h"
#include "tretentiontype.h"
#include "homebase.h"
#include "include.h"
#include "ndmp_volume_entification.h"
#include "backupboost_interface.h"


#include "ade_mgrx.h"
#include "sessionprofile.h"
#include "nbackmain.h"


#include "prectime.h"

#define dbg_msgs ((xflag[2]&32)!=0)        



#define DONT_LOOK_FOR_REPARSE_POINTS ((xflag[31]&33554432)!=0)



nbackmain::nbackmain(context *ctxt_, utar_flags_info& flags_, utar_flags_info& dstflags_) :
    flags(flags_),
    dstflags(dstflags_),
    ctxt(ctxt_),
    buildVersion("--not set--"),
    root("--not set--")
{
}



nbackmain::~nbackmain()
{
}






exitcodes_t nbackmain::doBackup()
{
    DIRELEM rootdirelem;

#if SYSTEM_WINDOWS
    
    
    
    winpriv wp(winpriv::EPrivTypeBackup);
    winpriv wp2(winpriv::EPrivTypeSecurity);
    if( !wp.is_enabled() ) {
        hostinfo host;
        Out->msg(WARN, "<6023>Current user (%s) could not enable SE_BACKUP_NAME privilege.  Some file contents cannot be backed up", *host.osuser());
    }
    if( !wp2.is_enabled() ) {
        hostinfo host;
        Out->msg(WARN, "<6970>Current user (%s) could not enable SE_SECURITY_NAME privilege.  All ACLs cannot be backed up", *host.osuser());
    } else {
        
        if(!flags.isexplicit("permissions")) flags.permissions = true;
    }
#endif

    
    
    
    
    exitcodes_t result = initBackup(rootdirelem);
    
    
    
    
    
    if(result == EXIT_OK) {  
        result = runBackup(*ctxt->state, rootdirelem);
    }
    else {
        Out->msg(ERR, "<8939>Errors occurred preparing for backup (exitcode=%u).   No backup will be created.", result);
    }
    if(ctxt->state != NULL) { 
        delete ctxt->state;
        ctxt->state = NULL;
    }
    return result;
}



#if SYSTEM_UNIX



bool nbackmain::wakeup_automounts(backstate& state) {
    DB->msg("wakeup_automounts");
    bool retval(true);
    stringlist target(state.targets.includelist());
    for (int i=0; i<target.size(); i++) {
        const upath path(target[i]);
        ELEMID dirid(path);
        DB->msg("wakeup_automounts: dirwalk:%s", *target[i]);

        dirwalk dir(dirid, false, false, false, NULL, NULL);
        if (!dir.geterror().isempty()) {
            
            
            
            if (!DIRELEM::queryexists(path)) {
                
                
                const output::severitycode errcode((xflag[18]&256)==0?ERR:WARN);
                Out->msg(errcode, LOCTXT("Specified path \"%s\" does not exist; ignored"), *target[i]);
                retval=false;
                continue;
            }
        }
        DIRELEM subdir;
        while (dir.getnext(subdir)) {
            
            
        }
    }
    return retval;
}

bool nbackmain::enter_default_mount_rules(backstate& state, ustring root, dirstats& dstats) {

    wakeup_automounts(state); 

    DB->msg("nbackmain::enter_default_mount_rules fs_force:%s  fs_ignore:%s", *flags.fs_force.image(','), *flags.fs_ignore.image(','));

    state.fsinfo.enter_rules(flags.force_nfs, flags.single_device, flags.fs_force, flags.fs_ignore);

    
    state.fsinfo.load_system_mount_descriptions(flags.force_nfs,
                                                flags.force_nfs | flags.unknown_devices_ok,
                                                dstats.numfiles, dstats.numbytes, &state.targets);

    
    DB->msg("mount type of root path %s", *root);
#if SYSTEM_UNIX_HPUX_ITANIUM
    
    ustring starting_file_system_type = "local";
#else
    ustring starting_file_system_type = state.fsinfo.path_to_fs_type(root);
#endif

    DB->msg("mount type of root path %s == %s", *root, *starting_file_system_type);
    if (starting_file_system_type == "lofs") {
        if (!flags.force_nfs) {
            Out->msg(FATAL, "--force option is required for loopback filesystems.");
            return false;
        }
        
        Out->msg(WARN, "<7879>Backing up \"%s\" partition \"%s\" may result in an incomplete backup.", *starting_file_system_type, *root);
    }

    Out->msg(INFO, 3, "<5718>Setting mount type '%s' to default_backup because it is root", *starting_file_system_type);
    state.fsinfo.set_mount_status( *starting_file_system_type, file_system_info::DEFAULT_BACKUP);

    
    state.fsinfo.record_mount_decision(root, starting_file_system_type, "starting_point");
    return true;
}
#endif







int nbackmain::processSystemstate(ustring sysstate) {
    Out->msg(INFO, 2, "<6203>Processing System State file \"%s\"", *sysstate);

    bool do_zero = (xflag[10]&4) == 0;      
    int  verbose = (xflag[10]&24)>>3;       

    mtfsettings mtfinfo;
    mtfinfo.tapeBlockSize = 1024;           
    mtfinfo.zero = do_zero;                 
    mtfinfo.list = !do_zero;                
    mtfinfo.verbose = verbose;
    mtfinfo.debug = (verbose > 2);

    mtfread mtfrd(&mtfinfo);

    if (!mtfrd.openfile(*sysstate)) {
        Out->msg(ERR, "<6191>Could not open System State file \"%s\"", *sysstate);
        return -1;
    }

    if (!mtfrd.openMedia()) {
        Out->msg(ERR, "<7880>Could not open System State Media \"%s\"", *sysstate);
        return -2;
    }

    if (!mtfrd.processMedia()) {
        Out->msg(ERR, "<7881>Problem processing System State \"%s\"", *sysstate);
        return -3;
    }
    
    Out->msg(INFO, 2, "<6204>Processing System State complete");
    return 0;
}

int nbackmain::backupSystemstate() {


    int res = -1000;            

#if SYSTEM_WINDOWS
    if (win_os_version_info::is_server_2008_or_newer()) {
        Out->msg(WARN, "<8027>Backupsystem option is ignored on Server2008, Windows 7 and later; use the VSS plugin to perform System State backup");
    } else if ( win_os_version_info::is_windows_Vista_or_newer()) {
        Out->msg(WARN, "<8028>System State backup is not implemented on Windows Vista; backupsystem option ignored");
    } else if ( win_os_version_info::is_windows_XP_home()) {
        Out->msg(WARN, "System State backup is not implemented on Windows XP Home; backupsystem option ignored");
    } else if ( win_os_version_info::is_windows_2000_or_newer() ) {       
        const bool do_windows_dir((xflag[15]&32)!=0);                           
        const bool do_system32_dir(!do_windows_dir && (xflag[15]&16)==0);       

        TCHAR buf[MAX_PATH];
        ustring root = "C:\\windows\\system32";
        ustring windowsdir, junk;
        const unsigned int bufclen(sizeof(buf) / sizeof(*buf));
        if(GetSystemDirectory(buf, bufclen) <= bufclen) root = ustring(encodings::filesystem, buf);
        root.split(windowsdir, junk, true);                                     

        
        ustring sysstate(ustring("\"") + flags.systemstatefile + ustring("\""));

        
        ustring sysvol;
        ustring value;
        if ((xflag[10]&32)==0 &&        
            ntsecurity::registry_lookup("HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters", "sysvol", value)) {
            
            DB->msg("Registry SYSVOL entry is \"%s\"", *value);
            ustring sysvolpath;
            ustring sysvolsubdir;
            value.split(sysvolpath, sysvolsubdir, true, DIRSEP);
            if (sysvolsubdir == "sysvol") sysvol = sysvolpath;
            Out->msg(INFO, "<6224>Including Active Directory database (%s) in System State backup", *sysvol);
        }

        arglist args;
        args.exename(root / ustring("ntbackup.exe"));                                   
        args.preformated("backup");                                                     
        args.preformated("systemstate");                                                
        
        
        
        if(!sysvol.isempty()) args.param(sysvol, true);                                
        if(do_system32_dir) args.param(root,true);                                     
        if(do_windows_dir && !windowsdir.isempty()) args.param(windowsdir,true);       
        
        args.preformated("/f");                                                         
        args.preformated(sysstate);                                                     
        
        args.preformated("/j");                                                         
        args.preformated("avamar");                                                     

        res = 0;
        if ((xflag[10]&2)==0) {          
            
            
            assoc add2env;
            res = subscript::run_command_nopipes(args, add2env,
                                                false ,
                                                flags.systemstate_timeout,  
                                                "system-state-backup",
                                                ustring::sprintf("Writing System State to %s",
                                                *sysstate));
            if(res != 0) {
                Out->msg(ERR, "<8535>System State backup process failed!");
                return(res);
            }
        }

        if (flags.process_sysstate)  {
            
            
            
            
            
            
            DIRELEM tempFile(upath(flags.systemstatefile)); 
            const double fileSize = tempFile.file_size().dvalue();
            
            
            
            
            if(fileSize < 1024*1024) { 
                Out->msg(ERR, "<8536>Skipping post-processing on '%s' because of bad file size of %0.1fKB", flags.systemstatefile.tostr(), fileSize);
                res = -10;
            }
            else {      
                res = processSystemstate(flags.systemstatefile);
            }
        }

    } else {
        Out->msg(WARN, "<6425>System State backup supported only on Windows-2000 and later");
    }
#else
    Out->msg(WARN, "<6082>Backup System State option only applies to Windows, ignored.");
    if (((xflag[10]&2)!=0) && flags.process_sysstate)           
        res = processSystemstate(flags.systemstatefile);
#endif
    return res;
}




exitcodes_t nbackmain::cache_setup(bool load_local_hashcache, context *ctxt, utar_flags_info& flags, backstate &state )
{
    if( ! flags.nocache && ! flags.vardir.isempty() ) {
        Out->msg(INFO, "<5586>Loading cache files from %s", *flags.vardir);
        DB->msg("flags.vardir = %s", *flags.vardir);

        
        if(uwrapper::umkdir(flags.vardir,0777) != 0)
            DB->msg("Unable to create directory '%s'", *flags.vardir);

        if( !flags.mergedir.isempty()) {
            
            
            Out->msg(ERR, "<10943>Cache merge option is not supported");
        } else if (flags.filecache_enabled) {    
            if(flags.morphfactor >= 0 && flags.cacheprefix.isempty()) {
                Out->msg(FATAL, "A --cacheprefix is required when morphing and filecache is enabled");
                return EXIT_BAD_FLAGS;
            }

            state.fcache = new filename_cache(ctxt, cache::makecachename(flags.vardir, flags.cacheprefix, "", FILENAME_CACHE_FILENAME),
                                              flags.paging_cache, flags.filecacheflushrate, flags.detect_acl_changes || flags.cacheitmsize);
            if(state.fcache->iserror()) {
                if(state.fcache->isshareerror())
                    Out->msg(FATAL, "<5345>Cannot run multiple backups with the same filename cache name at the same time.  Consider changing VARDIR or using --cache-prefix option.");
                else
                    Out->msg(FATAL, "<5223>Unable to open filename cache in directory \"%s\".   Possibly invalid path or missing read/write privileges.", *flags.vardir);
                delete state.fcache;
                state.fcache = 0;
                return EXIT_LOCKED;
            }
        } else {
            Out->msg(INFO, "<5769>Filecache is disabled.");
        }
        

        
        
        if (flags.hashcache_enabled) {
            if(load_local_hashcache) {  
                state.hashes = new hash_cache(ctxt, cache::makecachename(flags.vardir, flags.cacheprefix, "", HASH_CACHE_FILENAME));
                if(state.hashes->iserror()) {
                    if(state.hashes->isshareerror())
                        Out->msg(FATAL, "<5224>Cannot run multiple backups with the same hash cache name at the same time.  Consider changing VARDIR or using --cache-prefix option.");
                    else
                        Out->msg(FATAL, "<5225>Unable to open hash cache in directory '%s'", *flags.vardir);
                    delete state.hashes;
                    state.hashes = 0;
                    return EXIT_LOCKED;
                }
            }
#if USEADE
            else {
                
                
                
                
                ctxt->getAdeMgr()->setupHashCache();
            }
#else
            assert(false);
#endif
            
        } else {
            Out->msg(INFO, "<5770>Hashcache is disabled.");
        }
    } else {
        Out->msg(INFO, "<5771>Client side cache files are turned off");
    }

    bool need_to_repair_cache = false;
    if(state.fcache) {
        if(! state.fcache->checkversion(flags.oktoclear, need_to_repair_cache)) {
            DB->msg("deleting state.fcache and return");
            delete state.fcache;
            state.fcache = 0;
            if(!flags.oktoclear)
                return EXIT_LOCKED;
        }
    }
    if(!ctxt->ADEChunkerEnabled() && state.hashes) {
        bool tmp = false;
        if(! state.hashes->checkversion(flags.oktoclear, tmp)) {
            DB->msg("deleting state.hashes");
            delete state.hashes;
            state.hashes = 0;
            if(!flags.oktoclear)
                return EXIT_LOCKED;
        }
    }

    if( state.fcache ) {
        state.fcache->choose_root_tag(flags.checkcache|flags.repaircache,  flags.degenerate );
        if ((flags.checkcache || flags.repaircache) && uapp::staging().canRun())
            state.fcache->validate(flags.repaircache);
        if( need_to_repair_cache )
            state.fcache->validate( need_to_repair_cache );
    }

    if(!ctxt->ADEChunkerEnabled() && state.hashes ) {
        state.hashes->choose_root_tag(flags.checkcache|flags.repaircache,  flags.degenerate );
        if ((flags.checkcache || flags.repaircache) && uapp::staging().canRun())
            state.hashes->validate(flags.repaircache);
    }

    if( ! flags.nocache && ! flags.vardir.isempty() )
        Out->msg(INFO, "<6426>Done loading cache files");

    return EXIT_OK;
}




void nbackmain::cache_write(context *ctxt, utar_flags_info& flags, backstate &state, ubigint64 explicit_backupid, int explicit_ddr_index)
{
    if(flags.cachereadonly) {
        Out->msg(INFO, "Cache read-only mode: Writes suppressed");
        return;
    }

    context *main = ctxt;
    backstats *stats = ctxt->getstatsobj(context::backupstats);
    if( state.fcache || (state.hashes && uapp::staging().canRun()) ) {
        
        
        
        
        const exitcodes_t excode = uapp::staging().getExitCode();
        const bool updatecache = uapp::staging().canRun() || (excode == EXIT_CANCELED) || (excode == EXIT_KILLED) || (excode == EXIT_MCSCANCEL);
        if( updatecache && !flags.checkcache && (state.fcache || state.hashes)) {
            Out->msg(INFO, "<5587>Updating cache files in %s", *flags.vardir);
            int count = (int)stats->get_filecount();
            if( state.fcache ) {
                if(flags.ddrenabled || (flags.ddgsan2dd.bytelength() > 0)) { 
                    if (main->workctx.isdefined()) {
                        DB->msg("nbackmain::cache_write: set root tag from working context with DDR enabled");
                        state.fcache->set_root_tag( main->final_resulthash, count, TIME32(0), flags.ddrindex, main->workctx->atime );
                    } else {
                        DB->msg("nbackmain::cache_write: set root tag for explicit DDR information with DDR enabled");
                        state.fcache->set_root_tag( main->final_resulthash, count, TIME32(0), explicit_ddr_index, explicit_backupid );
                    }
                } else if (explicit_ddr_index > 0) {
                    DB->msg("nbackmain::cache_write: set root tag for explicit DDR information without DDR explicitly enabled");
                    state.fcache->set_root_tag( main->final_resulthash, count, TIME32(0), explicit_ddr_index, explicit_backupid );
                } else {
                    DB->msg("nbackmain::cache_write: set root tag without DDR information");
                    state.fcache->set_root_tag( main->final_resulthash, count, TIME32(0) );
                }

                state.fcache->close_cache();
                delete state.fcache;
                state.fcache = NULL;
            }

            
            if( state.hashes ) {
                
                
                state.hashes->set_root_tag( main->final_resulthash, count, TIME32(0) );
                state.hashes->close_cache();
                delete state.hashes;
                state.hashes = NULL;
            }
        }
    }

#if USEADE
    
    if (uapp::staging().canRun() && !flags.checkcache) {
        if (ctxt->ADEChunkerEnabled()) {
            ADEMgrX* adeMgr = ctxt->getAdeMgr();
            assert(adeMgr != NULL);
            if(adeMgr != NULL) {    
                const int count = (int)ctxt->getstatsobj(context::backupstats)->get_filecount();
                adeMgr->sealHashCache(count, ctxt->final_resulthash);
            }
        }
    }
#endif
}





bool nbackmain::stats_data_only(DIRELEM rootdirelem, context* main) {
    DB->msg("nbackmain stats_data_only");

    bool begin(false);
    bool qterminated(false);
    while (!qterminated && uapp::staging().canRun()) {
      if ((main == NULL) || (main->tomato == NULL) || main->tomato->progressq.isnull()) {
          Out->msg(ERR, "<6751>no progressq - unable to get progress, exiting");
          if (main != NULL)
            DB->msg("nbackmain::stats_data_only no progressq tomato:%d", main->tomato==NULL);
          return false;
      }
      ctl_messagep mess;
      ctl_queuep conn;
      ctl_queue::rettype ans(main->tomato->progressq->dequeue(mess, conn, 30));

      if (ans == ctl_queue::dequeued_ret) {
        if (mess.isnull())
            continue;
        if (mess->gettype() != ctl_message::type::workorder_status && mess->gettype() != ctl_message::type::status_wrapup_summary) {
          DB->msg("nbackmain::stats_data_only strange message:\n%s", *mess->simage());
          continue;
        }

        xml_messagep sessionprogress, dstsessionprogress;
        bool wrapup_sent;
        if(!mess->get_res_workorder_status(sessionprogress, wrapup_sent)) {
          DB->msg("nbackmain::stats_data_only unable to unpack workorder_status");
          continue;
        }
        if (flags.replicate && !flags.avoid_progress_dst_messages) dstsessionprogress = sessionprogress->clone();
        ustring kind("PROGRESS");
        if (!begin) {
            kind = "BEGIN";
            sessionprogress->children.push_back(uapp::getapp()->build().xmlmess());
            if (flags.replicate && !dstsessionprogress.isnull()) dstsessionprogress->children.push_back(uapp::getapp()->build().xmlmess());
            if ((xflag[29]&2097152) == 0) {
                xml_messagep tmp = main->sessinfo[dpn0].get_message();
                if (!flags.widimage.isempty()) tmp->enter("workorderid", flags.widimage);
                sessionprogress->children.push_back(tmp);

                if (flags.replicate) { 
                    xml_messagep dsttmp = main->sessinfo[dpn1].get_message();
                    if (!flags.widimage.isempty()) dsttmp->enter("workorderid", flags.widimage);
                    if(!dstsessionprogress.isnull()) dstsessionprogress->children.push_back(dsttmp);
                }
            }
            begin = true;
        }
        else if (wrapup_sent) {
            kind = "END";
            if ((xflag[29]&2097152) == 0) {
                if (flags.replicate && !dstsessionprogress.isnull()) {
                    xml_messagep dstsessionchild(dstsessionprogress->getchild("session"));
                    if(!dstsessionchild.isnull()) {
                        dstsessionchild->enter("type", "repldst"); 
                    }
                    if(!most_recent_sessionprogress.isnull()) {
                        dstsessionprogress->children.push_back(most_recent_sessionprogress);
                    }
                }
                if(!most_recent_sessionprogress.isnull()) {
                    sessionprogress->children.push_back(most_recent_sessionprogress);
                }
            }
        }
        else most_recent_sessionprogress = sessionprogress;

        DB->msg("nbackmain::stats_data_only kind:%s mess:\n%s", *kind, *sessionprogress->simage());
        DB->servlog(kind, sessionprogress, NULL, false, wrapup_sent);
        if (flags.replicate && !dstsessionprogress.isnull()) DB->dstservlog(kind, dstsessionprogress, NULL, false, wrapup_sent);

      } else if (ans == ctl_queue::terminated_ret) {
          DB->msg("nbackmain::stats_data_only terminated");
          break;
      } else if (ans == ctl_queue::timeout_ret) {
          DB->msg("nbackmain::stats_data_only timedout");
      } else  {
          DB->msg("nbackmain::stats_data_only dequeue result:%s", *ctl_queue::rettype_image(ans));
      }
    }
    return true;
}

















static ustring get_bmc_cacheprefix(const ustring tag, const int mode) {
    DB->msg("get_bmc_cacheprefix: tag=\"%s\", mode=%d", *tag, mode);

    
    
    int i, cnt=5;
    for (i=tag.bytelength()-1; i>=0 && cnt>0; i--) if (tag.byteindex(i)=='-') cnt--;

    
    if(i < 0) return "";

    ustring objectname = tag.substr(0, i+1);

    
    if (mode == utar_flags_enums::bmc_oracle) {
        char *sid = getenv("ORACLE_SID");
        if (sid && *sid) {
            DB->msg("get_bmc_cacheprefix: $ORACLE_SID=\"%s\"", sid);
            objectname += '#';      
            objectname += sid;
        } else {
            Out->msg(WARN, "<7554>No $ORACLE_SID value is defined for BMC Oracle database backup");
        }
    }

    
    const hashcode h(*objectname, objectname.bytelength());

    
    const ustring hash = h.image();
    DB->msg("get_bmc_cacheprefix: objectname=\"%s\" yields hash=\"%s\"", *objectname, *hash);
    return hash.substr(0, 20);          
}

#if SYSTEM_WINDOWS






#define MSFT_KB_DEDUPCHUNKSTORE ("KB3019276")
bool check_windows_optimized_update() {
    bool retValue = false;
    if(win_os_version_info::is_server_2016_or_newer()){
        retValue = true;
    }else{
        DB->msg("nbackmain::check_windows_optimized_update() - Trying to Find '%s' on Windows Server 2012", MSFT_KB_DEDUPCHUNKSTORE);

        stringlist all_updates;
        
        if(WMI::get_installed_updates(all_updates)) {
        if(all_updates.contains(MSFT_KB_DEDUPCHUNKSTORE)) { 
            retValue = true;
            }
        }

        if (retValue)
            DB->msg("nbackmain::check_windows_optimized_update() - Found Expected KB");
        else
            DB->msg("nbackmain::check_windows_optimized_update() - Did Not Find Expected KB");
    }
    return retValue;
}
#endif

#if SYSTEM_WINDOWS
static int debug_me = 0;
#endif



exitcodes_t nbackmain::initBackup(DIRELEM& rootdirelem)
{

    ctxt->state = NULL;     
    static const char *thrstate = "";
    DB->setthrstate(thrstate);

    DB->msg("nbackmain::initBackup()- sizeof(DIRELEM)=%"Z"u (%d), sizeof(cycle)=%"Z"u, sizeof(nbackfile)=%"Z"u",
             sizeof(DIRELEM), DIRELEM_DOLAYOUT_AVERAGE_SIZE, sizeof(cycle), sizeof(nbackfile));

    
    
    
    
    
    
    
    bool valid_dedup_arg = false;
#if SYSTEM_WINDOWS
    if(!include::inspect_args(flags.args, valid_dedup_arg, flags.windowsOptimizedBackup)) {
#else
    
    
    
    
    if (flags.pluginid.kind() == pidtype::backupboost) {

        using namespace backupboost;

        backupboost_interface bb_int;
        backupboost_interface::lfs_handle lfshandle;

        if (!bb_int.initialize()) {
            Out->msg(ERR, "Failed to load BackupBoost shared library");
            return EXIT_MISC;
        }

        DB->msg("nbackmain::initBackup() Successfully loaded BackupBoost shared library");

        int lfserror(LFS_SUCCESS);
        backupboost_interface::version_info kernel_ver;
        backupboost_interface::version_info lib_ver;
        backupboost_interface::version_info api_ver;

        lfserror = bb_int.get_version_info(kernel_ver, lib_ver, api_ver);
        if (lfserror != LFS_SUCCESS) {
            
            
            
            
            Out->msg(INFO, "Unable to retrieve BackupBoost version information");

        } else {
            Out->msg(INFO, "BackupBoost Version Information:\n"
                     "  Kernel Module:\n"
                     "     major = %s\n"
                     "     minor = %s\n"
                     "     patch = %s\n"
                     "     build = %s\n"
                     "  Library Binary = %s.%s.%s-%s\n"
                     "  Library API    = %s.%s.%s-%s",
                     *kernel_ver.v_major, *kernel_ver.v_minor, *tostr(kernel_ver.v_patch), *tostr(kernel_ver.v_build),
                     *lib_ver.v_major, *lib_ver.v_minor, *tostr(lib_ver.v_patch), *tostr(lib_ver.v_build),
                     *api_ver.v_major, *api_ver.v_minor, *tostr(api_ver.v_patch), *tostr(api_ver.v_build));
        }

        
        
        lfserror = bb_int.init_library(bb_int.lib_version(), lfshandle);

        if (lfserror != LFS_SUCCESS) {
            DB->msg("Initialize BackupBoost library for list mounts failed with '%s' (return code: %d)",
                    *bb_int.err_code_to_desc(lfserror), lfserror);
            return EXIT_TARGETLIST;
        }

        DB->msg("nbackmain::initBackup() Successfully initialized BackupBoost library for list mounts");

        if (flags.args.isempty() ||
            ((flags.args.size() == 1) && flags.args[0].equal("/"))) {
            
            flags.args.clear();

            unsigned int mountCount(0);

            
            lfserror = LFS_MORE_MOUNT_POINT;

            while ((lfserror == LFS_MORE_MOUNT_POINT) && (++mountCount <= maximumMountCount)) {
                ustring mountPoint;
                int mountPointIsConfigured(0); 
                int mountPointIsSupported(0); 
                lfserror = bb_int.list_mounts(lfshandle, mountPoint, mountPointIsConfigured, mountPointIsSupported);

                
                
                
                if (lfserror == LFS_MORE_MOUNT_POINT) {
                    if (mountPointIsSupported) {
                        
                        if (mountPointIsConfigured) {
                            flags.args.push_back(mountPoint);
                            DB->msg("nbackmain::initBackup() add configured mount point of %s to targetlist",
                                    *mountPoint);
                        } else {
                            
                            
                            Out->msg(ERR, "Mount point of %s is un-configured. BackupBoost backup fails "
                                          "with top level if there is an un-configured mount point. "
                                          "Configure all the mount points then do top level backup, "
                                          "or backup with selecting configured mount points only",
                                          *mountPoint);
                            return EXIT_TARGETLIST;
                        }
                    } else {
                        Out->msg(INFO, "Path %s is not a supported BackupBoost mount, skipping from backup.", *mountPoint);
                    }
                } else if (lfserror != LFS_NO_MORE_MOUNT_POINT) {
                    Out->msg(ERR, "BackupBoost list mount points failed with '%s' (return code: %d)",
                                  *bb_int.err_code_to_desc(lfserror), lfserror);
                }
            } 

            if (flags.args.isempty()) {
                Out->msg(ERR, "Failed to get any BackupBoost configured mount points");
                return EXIT_TARGETLIST;
            }

            if (mountCount > maximumMountCount) {
                Out->msg(WARN, "BackupBoost number of mount points of %d reached maximum allowed count of %d",
                               mountCount, maximumMountCount);

            }
        } else {
            
            
            for(int i=0; i<flags.args.size(); i++) {
                backupboost_interface::mount_status m_status;
                lfserror = bb_int.current_status(flags.args[i], m_status);

                if (lfserror != LFS_SUCCESS) {
                    Out->msg(ERR, "BackupBoost unable to retrieve current status for mount point of %s with '%s' (return code: %d)",
                                  *flags.args[i], *bb_int.err_code_to_desc(lfserror), lfserror);
                    return EXIT_TARGETLIST;
                } else if (!m_status.is_configured){
                    Out->msg(ERR, "Mount point of %s is un-configured. BackupBoost backup fails "
                                  "the whole backup if there is an un-configured mount point in the list. "
                                  "Either de-select, or configure the mount points that were "
                                  "selected but not configured",
                                  *flags.args[i]);
                    return EXIT_TARGETLIST;
                } else {
                    DB->msg("Mount point of %s, is_configured: %d, is_tracked: %d, is_mounted: %d, session_id: %"LL"u, journal_prefix: %s\n",
                            *flags.args[i],
                            m_status.is_configured,
                            m_status.is_tracked,
                            m_status.is_mounted,
                            m_status.session_id,
                            *m_status.journal_prefix);
                }
            }
        }

        
        
        
        flags.parallel = true;
        if (flags.maxstreams > flags.args.size()) {
            flags.maxstreams = flags.args.size();
        }
        flags.maxparallelfiles *= flags.maxstreams;
        DB->msg("nbackmain::initBackup() for BackupBoost flags.parallel=%d, "
                "flags.maxstreams=%d, flags.maxparallelfiles=%d",
                flags.parallel, flags.maxstreams, flags.maxparallelfiles);
    }

    if(!include::inspect_args(flags.args, valid_dedup_arg)) {
#endif
        Out->msg(FATAL, "<8029>Backup arguments (%s) invalid, aborting", *flags.args.image());
        return EXIT_TARGETLIST;
    }

#if SYSTEM_WINDOWS
    
    
    
    
    
    
    
    
    
    if (valid_dedup_arg && !check_windows_optimized_update()) {
        Out->msg(ERR, "Unable to find 'required' installed update (KB3019276) from MSFT to fix the DeDup Chunk Store Corruption Issue. Please download and install KB3019276 from https://support.microsoft.com/en-us/kb/3019276.\nUnable to perform optimized backup due to missing update (KB3019276), switching to non-optimized backup.");
        flags.windowsOptimizedBackup = false;
    }

    if (flags.windowsOptimizedBackup) {
        Out->msg(WARN, "Default performance is already optimal. It's recommended not select Windows Optimized Backup option.\nPlease perform at least one L0 backup when changing this flag.\n(Refresh the cache file by renaming the *.dat files under Avamar's vardir directory.)");
    }

#endif

    
    if (flags.expires != 0 && prectime::evalExpiration(flags.expires) == prectime(0))  
        return EXIT_BAD_FLAGS;

#if SYSTEM_WINDOWS
    
    if (flags.args.size() > 0) {
        stringlist targets(flags.args);
        VolumeInfo::filter_list_by_volume_label(ustring(AVAMAR_VIRTUAL_DISK_LABEL), targets);
        if (targets.isempty()) { 
            Out->msg(FATAL, "<8029>Backup arguments (%s) invalid, aborting", *flags.args.image());
            return EXIT_TARGETLIST;
        }
    }

    
    ctxt->character_encodings.set_encodings(flags.encodings);

    
    ustring encoding_description;
    if(ctxt->character_encodings.description(encoding_description)) {
        Out->msg(INFO, "<5946>File system character encoding is %s.", *encoding_description);
    } else {
        const encodings fs_encoding(encodings::filesystem);

        
        if(win_os_version_info::is_windows_2000_or_newer() || !win_os_version_info::is_windows_NT_or_newer()) {

            Out->msg(WARN, "<5987>File system character encoding %d not supported on this client.",
                     fs_encoding.value());
        } else {
            
            Out->msg(INFO, "<6427>File system character encoding is %d - NT 4 allowance.", fs_encoding.value());
        }
    }

    
    upath::setReparseCacheEnabled(true);

#endif

    
    if (flags.cacheprefix.isempty() && flags.bmc_mode > 0) {
        if (!flags.backuptag.isempty()) {
            flags.cacheprefix = get_bmc_cacheprefix(flags.backuptag, flags.bmc_mode);
            if (flags.cacheprefix.isempty()) {
                Out->msg(ERR, "<7555>Malformed --backuptag (%s) for BMC mode %d", *flags.backuptag, flags.bmc_mode);
            } else {
                Out->msg(INFO, "<7556>BMC cache prefix for this database is \"%s\"", *flags.cacheprefix);
            }
        } else {
            Out->msg(ERR, "<7557>A --backuptag must be specified when using the --bmc option; --bmc option ignored");
        }
    }

#if !SYSTEM_WINDOWS
    
    Out->msg(INFO, "<5946>File system character encoding is %s.", *encodings(encodings::filesystem).value());

    
    const ustring lockname((flags.cacheprefix.isempty() ? ustring("") :
                            (flags.cacheprefix + "_")) +
                           uapp::image(uapp::tool_avtar));
    const ustring lockfile(flags.vardir / lockname + LOCK_EXT);
    processlock processlockobject(lockfile);

    if (!flags.nocache && !flags.cachereadonly) {
        if(!processlockobject.checkandobtainlock()) {
            if( flags.mergedir.isempty()) {
                Out->msg(FATAL, "<5345>Cannot run multiple avtars at the same time");
                Out->msg(FATAL, "<7005>Running avtar process lock file detected (%s)", *lockfile);
            } else {
                Out->msg(INFO, "<7174>(Cache Merge)Cannot run multiple avtars at the same time");
                Out->msg(INFO, "<7175>(Cache Merge)Running avtar process lock file detected (%s)", *lockfile);
            }
            return EXIT_LOCKED;
        }
    }
#endif

    
    
    

    DIRELEM::ignoreacls       = flags.ignoreacls;
    DIRELEM::ignorerwxmapping = flags.ignorerwxmapping;

  
    hostinfo host;
    ustring currhostname(netsys::getcurrhostname());
    datetime starttime;

    ustring multicore;
    if (flags.parallel) multicore = " multicore";
    
    Out->msg(INFO, "<8940>Starting back up at %"AVDATE"s %s as \"%s\" on \"%s\" (%d CPUs%s) [%s]",
             *starttime.image(), *datetime::TzDst.av_tzname, *host.osuser(), *currhostname, host.numprocessors(), *multicore, *buildVersion);

    DB->showmessages = flags.debug;  

  
    if (!flags.directory.isempty()) {
        DB->msg("changing directory to %s", *flags.directory);
        Out->msg(INFO, "<5145>Changing to directory \"%s\".", *flags.directory);
        if (uwrapper::uchdir(flags.directory) != 0) {
          Out->msg(FATAL, "<5215>Unable to change to directory \"%s\".", *flags.directory);
          return EXIT_LOCAL_PERMISSIONS;
        }
    }

    stringlist cmdargs(flags.args);
#if SYSTEM_WINDOWS
    
    if ( flags.backupsystem_ignore_version_check )
    {
        
        
        if ( !flags.backupsystem )
        {
            Out->msg(ERR, "Incompatible parameters found: Version checking override (backupsystem-ignore-version-check flag) can only be set when \"Back up System State (Windows Server 2003 only)\" (backupsystem flag) has also been selected.");
            return EXIT_BAD_FLAGS;
        }
    }

    
    if (win_os_version_info::is_server_2008_or_newer() || win_os_version_info::is_windows_Vista_or_newer() || win_os_version_info::is_windows_XP_home()) {

        
        if ( flags.backupsystem_ignore_version_check )
        {
            flags.backupsystem = false;
            Out->msg(INFO, "Flag backupsystem-ignore-version-check is true.  Skipping Windows version checking at user's request.");
        }

        if (flags.backupsystem) {
            flags.backupsystem = false;
            if(win_os_version_info::is_windows_XP_home()) {
                Out->msg(ERR, "The backupsystem=true option is invalid on Windows XP Home.  Ignoring the option.");
            }
            else {
                Out->msg(ERR, "<10945>The backupsystem=true option is invalid on Windows 2008, Windows 7 and later.  Use the Windows VSS Plug-in with \"Create Disaster Recovery Backup\" enabled to perform System State backup");
                return EXIT_BAD_FLAGS;
            }
        }
    }

    if (flags.backupsystem) {
        
        if (flags.systemstatefile.isempty()) flags.systemstatefile = flags.vardir / "SystemState.bkf";
        
        if ((xflag[18]&512)==0 && !cmdargs.isempty()) cmdargs.push_back(flags.systemstatefile);       

        
        
        int res = backupSystemstate();
        if(res == 0) {
            Out->msg(INFO, "<6196>Windows System State backup successful");
        } else if (res != -1000) {
            Out->msg(ERR, "<6197>Windows System State backup failed (code %d)", res);
            flags.backupsystem = false;        
        }
    }

    
    if (flags.hbeprotectsystem == "enabled") {
        
        
        if (flags.hbesystemprofilepath.isempty()) {
            flags.hbesystemprofilepath = flags.vardir / HBE_DEFAULT_PROFILE_FILENAME;
        }

        upath profile_path(flags.hbesystemprofilepath);
        upath profile_parent(profile_path.parentdir());
        
        
        
        
        
        
        profile_parent.set_end_dirsep(true);

        if (DIRELEM::querydirectoryexists(profile_parent)) {
            
            if (execute_hbe(flags) && write_profile_path_to_file(flags)) {
                
                
                flags.commentfiles.push_back(ustring("HBE_profile_path=") + (flags.vardir / ustring(HBE_PROFILE_PATH_FILENAME)));
                
                if (!cmdargs.isempty()) {
                    cmdargs.push_back(flags.hbesystemprofilepath);
                }
            } else {
                
                flags.hbeprotectsystem = "disabled";
            }
        } else {
            
            Out->msg(ERR, "<8537>The path where the HBE system profile should be saved does not exist. System profile backup disabled.");
            flags.hbeprotectsystem = "disabled";
        }
    } else if (flags.hbeprotectsystem == "disabled") {
        if (is_hbe_installed(flags)) {
            Out->msg(WARN, "<10946>HomeBase Embedded is installed but the Server Recovery Option was not enabled - system state backup will not be performed.");
        }
    } else {
        
        Out->msg(ERR, "<8538>Unknown --protect-system option. System profile backup disabled.");
        flags.hbeprotectsystem = "disabled";
    }

    
    
    
    
    
    if (!flags.makeview) {
        DB->msg( "Building mount points list for all volumes on the system" );
        VolumeInfo::build_win_mount_points_maps();

        
        
        
        
        ReparsePoints::build_win_reparse_point_maps();
        file_system_info::dump_reparse_maps();

        if (!flags.exclude_csv) { 
            DB->msg( "Creating mount points mapping for CSV volumes" );
            VolumeInfo::set_csv_mount_points_mapping();
        }
    }
#endif  

    
    
    DB->msg("nbackmain: warn_on_missing_target flag set to: %s",
      flags.warn_on_missing_target?"true":"false");
    ctxt->state = new backstate(cmdargs,
                      (xflag[18]&256)==0 && !(flags.mapi || flags.from_stdin || flags.streamformat_in || flags.fakeprogress),
                      flags.parallel_type,
                      flags.warn_on_missing_target,
                      &flags.pathmap,
                      flags.fakeprogress);
    backstate& state = *ctxt->state;

    if(!state.is_valid()) {
        DB->msg("nbackmain: No valid targets exist, exiting");
        return EXIT_TARGETLIST;
    }

    
    if(flags.parallel) {
        bool isexplict_max_streams = flags.isexplicit("max-streams");
        bool isexplict_parallel_type = flags.isexplicit("parallel-type");
        if(!isexplict_max_streams) {
            hostinfo host;
            if(host.numprocessors() >= 2)
                flags.maxstreams = host.numprocessors() / 2;            
            if((flags.parallel_type == utar_flags_enums::parallel_by_volume) && (state.targets.incs_num_volumes() > flags.maxstreams))
                flags.maxstreams = state.targets.incs_num_volumes();    
            if(state.targets.includelist().size() <= 1) {
                flags.parallel = false;    
                flags.maxstreams = 1;      
                if((!isexplict_parallel_type) && (flags.parallel_type == utar_flags_enums::parallel_by_volume))
                    flags.parallel_type = utar_flags_enums::parallel_by_target;    
            }
        }
        if((flags.maxstreams == 1) && (!isexplict_parallel_type))
            flags.parallel_type = utar_flags_enums::parallel_by_target;    

        Out->msg(INFO, "<10947>Backup sets %d streams", flags.maxstreams);
    }
    else {    
        flags.maxstreams = 1;    
        flags.parallel_type = utar_flags_enums::parallel_by_target;    
    }





    if(flags.ddrenabled && flags.ddrindex>0 && !flags.adechunker) {
        if(true) { 
            
            DB->msg("Disabling ADE Chunker because this is a FILE SYSTEM DDR backup using ddr-filesystem");
            flags.adechunker = false;
        }
        else{
        DB->msg("Enabling ADE Chunker because this is a DDR backup");
        flags.adechunker = true;
        }
    }




    assert(flags.maxparallelfiles > 0);

    if (flags.mapi) state.snaptype = MAPI;
    if (flags.online_system_state) state.snaptype = VSS;
    if ((flags.streamformat_in == utar_flags_enums::streamformat_dump) || flags.makeview) {
        state.snaptype = DUMP; flags.filecache_enabled = false;
        if (!flags.makeview_nosubsysteminfos) flags.internal = true;  

    } else if(flags.streamformat_in) {
        state.snaptype = STREAM;
        
        if(!flags.xdrctl) {
            flags.filecache_enabled = false;
        }
        if(flags.cachepaxstream) {
            flags.filecache_enabled = true; 
        }                                   
    }
    DB->msg("snaptype:%d, permissions=%d, ignoreacls=%d, ignorerwxmappng=%d", state.snaptype, flags.permissions, DIRELEM::ignoreacls, DIRELEM::ignorerwxmapping);




#if SYSTEM_WINDOWS
    if (flags.mapi) {
        if( flags.freezemethod != utar_flags_enums::freezemethod_none )
            Out->msg(INFO, "<6752>Flag --mapi specified, disabling volume freeze");
        flags.freezemethod = utar_flags_enums::freezemethod_none;
    }

    if (flags.from_stdin) {
        if( flags.freezemethod != utar_flags_enums::freezemethod_none )
            Out->msg(INFO, "<6753>Flag --from-stdin specified, disabling volume freeze");
        flags.freezemethod = utar_flags_enums::freezemethod_none;
    }

    if (flags.repaircache || flags.checkcache) {
        if( flags.freezemethod != utar_flags_enums::freezemethod_none )
            Out->msg(INFO, "<6754>Flag --repaircache specified, disabling volume freeze");
        flags.freezemethod = utar_flags_enums::freezemethod_none;
    }

    if(flags.detect_acl_changes) {
        if (!ntsecurity::isLastAccessTimeEnabled()) {
            Out->msg(ERR, "<7882>Cannot perform ACL change detection (--detect-acl-changes) because Last Access Time is not enabled on NTFS");
        }
    }

#endif

    if (flags.mapi && (flags.streamformat_in == utar_flags_enums::streamformat_dump)) {  
        Out->msg(FATAL, "<5729>Incompatible backup types.");
        return EXIT_BAD_FLAGS;
    }

    state.sessionid = flags.sessionid;


    if (state.snaptype != DUMP && !flags.from_stdin && !flags.fakeprogress) {  
        
        Out->msg(INFO, "<5730>Entering include/exclude rules.");
        exitcodes_t status(state.enter_targets_exclude_include_lists(flags, flags.ignoredefaultexcludes));
        if (status != 0) {
            DB->msg("Combination of specified paths, exclude rules and include rules yields no valid paths");
            return status;
        }
    } else {
        Out->msg(INFO, "<5731>Not using include/exclude list");
    }

    nbackmain::root = state.targets.root;

    
    
    
    const ustring temp_root = root.chop(' ');
    if (temp_root.isempty()) root = temp_root;

    DB->msg("nbackmain::nbackmain root is '%s'", *root);

    
    bool all_drives = false;
    if (!flags.streaming_an_archive()) {
        if (root.isempty()) {
            if (flags.backupstate == utar_flags_enums::backstate_begin) 
                flags.backupstate = utar_flags_enums::backstate_begin_empty;
            if (flags.backupstate == utar_flags_enums::backstate_begin_empty ||
                flags.backupstate == utar_flags_enums::backstate_final)
            {
                
                flags.ddrenabled = false;
                flags.ddrindex = -1;
                
                if (flags.streamformat_out == utar_flags_enums::streamformat_cdsf)
                    flags.streamformat_out = utar_flags_enums::streamformat_none;
            }

            
            root = "/";
            all_drives = true;
        }
    }

    if (state.snaptype == DUMP || state.snaptype == STREAM) {
        
    } else if(!flags.from_stdin || flags.check_stdin_path) {
        upath root_path(root);
        DB->msg("nbackmain root_path:'%s' size:%d", *root_path.image(), root_path.numelems());
        rootdirelem.initialize(root_path, flags.mapi, flags.dereference);
    } else {
        rootdirelem.set_name(root);     
        
    }

    if(flags.from_stdin) {
        rootdirelem.set_stdin();

#if SYSTEM_WINDOWS
    
    
    
    
    
    
    
    
    










        
        rootdirelem.set_attr( 0 );
#endif
        if (state.snaptype==DUMP || state.snaptype==STREAM) {
            if (flags.args.size() > 1) {
                Out->msg(ERR, "<6993>Cannot specify a file/directory name with a stream format (args=\"%s\")", *flags.args.image());
                return EXIT_BAD_FLAGS;
            }





        } else { 
            if (root.isempty()) {
                Out->msg(ERR, "<6755>A file name must be specified when using the --from-stdin flag");
                return EXIT_BAD_FLAGS;
            }

            if (flags.args.size() > 1) {
                Out->msg(ERR, "<6756>Only one file name can be specified when using the --from-stdin flag (args=\"%s\")", *flags.args.image());
                return EXIT_BAD_FLAGS;
            }

            if (rootdirelem.is_directory()) {  
                Out->msg(ERR, "<6757>You must specify a file, not a directory, when using the --from-stdin flag");
                return EXIT_BAD_FLAGS;
            }
        }
    }

    
    if (!flags.fakeprogress && (flags.randchunk == 0)) {
        rootdirelem.set_is_root();
#if SYSTEM_WINDOWS
        if (all_drives)
            rootdirelem.set_is_root_directory();
#endif
        if(rootdirelem.has_error()) {
            Out->msg(FATAL, "<7559>Unable to open \"%s\" for back-up.", *root);
            return EXIT_LOCAL_PERMISSIONS;
        }
        if (!rootdirelem.is_directory() && !rootdirelem.is_stdin())
           Out->msg(INFO, "<5150>Backing up a single file \"%s\"", *root);
    }

    if (flags.maxchunksize < flags.minchunksize || flags.threshold < flags.minchunksize || flags.threshold > flags.maxchunksize) {
        Out->msg(ERR, "<5446>Invalid chunker options: minchunksize=%d <= threshold=%d <= maxchunksize=%d", flags.minchunksize, flags.threshold, flags.maxchunksize);
        return EXIT_BAD_FLAGS;
    }

  
    if((xflag[5]&1024)==0) {    
        DB->localstats.initlist();
        DB->localstats.append(ustring::sprintf(DBTXT("STARTING BACKUP %s\n"), *starttime.imageTZ()));
        ctxt->dolocalstats = true;
    }

    return EXIT_OK;
}

bool nbackmain::raw_format_supported_for_backup(const utar_flags_info& flags, const bool only_if_by_default) const
{
    
    
    
    if(only_if_by_default) {
        if((flags.pluginid.kind() == pidtype::ostackimage) ||
           (flags.pluginid.kind() == pidtype::hypervvss)) {
            return false;
        }
    }

    return ((flags.pluginid.kind() == pidtype::ostackimage) ||
            (flags.pluginid.kind() == pidtype::vcbimage) ||
            (flags.pluginid.kind() == pidtype::hypervvss) ||
            (flags.pluginid.kind() == pidtype::cpbackup) ||
            (flags.pluginid.kind() == pidtype::ostackimage) ||
            flags.nemoresurrect);
}

#define upath_reparse_point_optimizations_enabled ((xflag[31]&512)==0)



exitcodes_t nbackmain::runBackup(backstate &state, DIRELEM& rootdirelem)
{
  
    exitcodes_t exitcode = EXIT_OK;
    backstats *stats = ctxt->getstatsobj(context::backupstats);
    context *main = ctxt;
    workcontextref workctx(new workcontext(main));

#if SYSTEM_WINDOWS



#endif

    try {

  
    dirstats dstats;

    
    if (state.snaptype == FILESYSTEM && !flags.from_stdin
        && !rootdirelem.is_fifo()  
        && !flags.fakeprogress
    ) {
        
        
        DB->msg("examining mount points and computing backup size");
#if SYSTEM_UNIX
            if (!enter_default_mount_rules(state, root, dstats)) {
                 return EXIT_MOUNTTABLE;
            }
#elif SYSTEM_WINDOWS

            
            
            
            
            
            
            if (state.targets.includelistsize() > 1 && (state.targets.getNumRemoteDrives() > 0) && (!flags.force_nfs)) {
                Out->msg(ERR, "Use --force flag to backup multiple remote targets");
            }

            
            file_system_info::set_network_drives_ok(flags.force_nfs);

            
            file_system_info::set_dvd_drive_ok(!(flags.args.isempty())); 

            DB->msg( "Getting Disk Information" );
            bigint64 diskused = winInfo::getlocaldiskusage();
            DB->msg("Getting Disk Information = %I64u", diskused );
            
            dstats.numbytes = (double)diskused;
#endif

        
        DB->msg("numfiles = %d, numbytes = %.0f", +dstats.numfiles, double(dstats.numbytes));
        if (stats) stats->estimated_totalbytes_to_process = double(dstats.numbytes);
    }


    if (!uapp::staging().canRun()) {
        
        if (uapp::staging().isExitCancel()) {
            Out->msg(INFO, "<7560>Canceled");
            return uapp::staging().getExitCode();
        }
        if (uapp::staging().isExitAbort()) {
            Out->msg(FATAL, "<5383>INTERRUPTED");
            return uapp::staging().getExitCode();
        }
    }

    const ustring currhostname(netsys::getcurrhostname());
    DB->msg("nbackmain host = %s, root = %s, numdirs = %d, numfiles = %d, numbytes = %.0f\n",
            *currhostname, *root, +dstats.numdirs, +dstats.numfiles,
            +dstats.numbytes);
    DB->msg("nbackmain   Account Version: %d", flags.acntver);

    bool nothreads = false;
    if(flags.numthreads == -1) {
        nothreads = true;
        flags.numthreads = 1;
        flags.numconns = 1;
    }

    nothreads = true;
    flags.numthreads = 1;
    flags.numconns = 1;

    int numthreads = flags.numthreads;
    cidtype clientid(flags.clientid);

    

    
    
    
    if (flags.cid.hasCID(cidtype::kind_targetcid)) {
        clientid = flags.cid;
        DB->msg("nbackmain() -- clientid = %s, targetcid = %s", *clientid.getCIDFrom(cidtype::kind_cid), *clientid.getCIDFrom(cidtype::kind_targetcid));
    }
    if(!ctxt->engageADE() ) { 
        if (flags.encrypt == "proprietary")
        {
            Out->msg(FATAL, "<8941>Fatal server connection problem, aborting initialization. Verify correct server address and login credentials and that your server supports un-encrypted network connections.");
        }
        else
        {
            Out->msg(FATAL, "<8941>Fatal server connection problem, aborting initialization. Verify correct server address and login credentials.");
        }
        return EXIT_CONNECT;
    }
    else if( !ctxt->init(clientid) ) {
        Out->msg(FATAL, "<8942>Failed to initialize Backup Manager");
        return EXIT_CONNECT;
    }

    
    
    
    

    
    

    
    if(ctxt->getAdeMgr() == 0) {
        
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }

    const hfs_info_struct& hfs_info = ctxt->getAdeMgr()->getHfsInfo(dpn0);

    if(!hfs_info.isAvailable && hfs_info.metaStore == NULL) {
        Out->msg(FATAL, "<5308>Failed to initiate session with server");
        return EXIT_CONNECT;
    }

    
    send_secondary_session_ticket(main);

    DB->msg("hfs_info.clientid %s", *hfs_info.clientid.image());

    if(main->signposts_p) main->signposts_p->after_login(EXIT_OK);

    if (hfs_info.isAvailable) {
        const tversion tver = main->getserverversion(dpn0);
        const ustring version = tver.isvalid()?ustring::sprintf(" [%s]", *tver.image()):"";
        if (flags.compress)
            Out->msg(INFO, "<5550>Successfully logged into Avamar Server%s (Compression enabled)", *version);
        else
            Out->msg(INFO, "<5550>Successfully logged into Avamar Server%s", *version);
    }

    
    if (hfs_info.metaStore != NULL) {
        Out->msg(INFO, "Successfully logged into Catalog Server");
    }

    
    if(widtype(flags.workorderid) == widtype::nah) {
        main->setclientid(cidtype(hfs_info.clientidhash.image()));
    }

    state.sessionid = flags.sessionid; 

    if (hfs_info.sync != NULL)
        hfs_info.sync->log(flags.commandline());

    const ustring ipaddr = flags.hfsaddr;

    int numconns = 1;

    ustring server_info = ipaddr;
    if( ipaddr == "127.0.0.1") server_info = "Localhost";

    if (flags.args.size() > 1)
        Out->msg(INFO, "<7511>Back up paths are %s", *state.targets.includelist().image(' ', dbg_msgs ? (size_t)-1 : 50));

    if(flags.degenerate) {
        Out->msg(INFO, "<5151>Scanning \"%s\"", *root);
    } else if (rootdirelem.is_stdin()) {  
        Out->msg(INFO, "<7562>Back up of stdin on server \"%s\" for %s",
                 *server_info, hfs_info.blk.path.tostr());
    } else if(!flags.checkcache) {
        Out->msg(INFO, "<7563>Back up of \"%s\" on server \"%s\" for %s",
                 *root, *server_info, hfs_info.blk.path.tostr());
    }

    
    

    
    
    
    if(flags.create && flags.ddrenabled && (!flags.fakeprogress)) {
        if(!flags.isexplicit("streamformat-out") && !ctxt->getAdeMgr()->isSynthesisSupported()) {
            if(raw_format_supported_for_backup(flags, true)) {
                DB->msg("nbackmain::runBackup: setting streamformat-out to raw because DD doesn't support synthesis");
                flags.streamformat_out = utar_flags_enums::streamformat_raw;
            } else {
                Out->msg(ERR, "Synthesis is not supported on the output DD");
                return EXIT_BAD_FLAGS;
            }
        }

        
        
        if (flags.streamformat_out == utar_flags_enums::streamformat_cdsf && !ctxt->getAdeMgr()->isSynthesisSupported()) {
            Out->msg(ERR, "Streamformat %s to DDR requires a DDR capable of synthesis operations.", *utar_flags_info::streamformat_image(flags.streamformat_out));
            return EXIT_BAD_FLAGS;
        }

        
        
        
        if((flags.streamformat_out == utar_flags_enums::streamformat_raw) && !raw_format_supported_for_backup(flags, false)) {
            Out->msg(ERR, "Streamformat %s is only supported for nemo and the vcbimage/cpbackup plugins.", *utar_flags_info::streamformat_image(flags.streamformat_out));
            return EXIT_BAD_FLAGS;
        }

        Out->msg(INFO, "Writing %s stream format to DDR", *utar_flags_info::streamformat_image(flags.streamformat_out));

        #define skipchecksums ((xflag[29]&16384)!=0)
        if (skipchecksums) Out->msg(INFO, "During backup to Data Domain, checksums are DISABLED");
        else Out->msg(INFO, "During backup to Data Domain, checksums are ENABLED");

    }

    
    if(flags.adechunker || !flags.degenerate) {

        
        
        
        
        DB->msg("nbackmain::runBackup: Original root string for session message is \"%s\"", root.tostr());
        ustring correct_root;
        
        if  (((flags.streamformat_in == utar_flags_enums::streamformat_dump) || (flags.streamformat_in == utar_flags_enums::streamformat_emctar)) && (root.first() != '/')) {
            
            correct_root = ndmp_unentify_volume(root);
            DB->msg("nbackmain::runBackup: Unentified root string for session message is \"%s\"", correct_root.tostr());
        }
        else {
            correct_root = root;
        }
        if(!main->startsession(main->sessinfo[dpn0], dpn0, AVTAR_EXENAME, correct_root, flags, clientid, widtype(flags.workorderid), &dstats, true, "avtarbackup", flags.label))
            return EXIT_MISC;
    }
    exitcodes_t cache_result = cache_setup(!flags.adechunker, ctxt, flags, state);

    
    if(main->signposts_p) main->signposts_p->caches_setup(cache_result);

    if( cache_result != EXIT_OK )
        return cache_result;

    
    
    

    
    

    if (flags.clientid.isempty())
       clientid=cidtype(hfs_info.blk.path.hash().image());   
    else
       clientid=cidtype(flags.clientid);

    if (!flags.workorderid.isempty() && (widtype(flags.workorderid) != widtype::nah) && flags.label.isempty()) {
        
        DB->msg("setting label from %s to %s", *flags.label, *flags.workorderid);
        flags.label = flags.workorderid;
    }

    intassoc timerstates;
    timerstates.enter("file", FILESTATE);
    timerstates.enter("serv", SERVSTATE);
    timerstates.enter("wait", WAITSTATE);
    timerstates.enter("ispresent", ISPRESENTSTATE);
    timerstates.enter("adddata",   ADDDATASTATE);
    timerstates.enter("addblock",  ADDBLOCKSTATE);

    
    timer ***calltimes = NULL;

    
    if ((flags.streamformat_in == utar_flags_enums::streamformat_dump) && !flags.isexplicit("status")) flags.statusrate = 5*60;

    if(flags.compress)
        flags.setcompressdefaults();

    
    if(main->get_encmode() != fileref::encmode_none && flags.compress == fileref::compmode_zlib) {
        Out->msg(FATAL, "<7366>Invalid options: ZLIB compression cannot be used with data-at-rest encryption");
        return EXIT_BAD_FLAGS;
    }

    DB->msg("Chunker settings: compress=%d, clevel=%d, cpercent=%d, threshold=%d, minchunksize=%d", flags.compress, flags.clevel, flags.cpercent, flags.threshold, flags.minchunksize);

    if (flags.fakeprogress) {
        if (flags.replicate) {
            
            const dpns dstdpn = dpn1;
            main->sessinfo[dstdpn].addsrchost(flags.hfsaddr);
            dstflags.pluginid = pidtype("Replicate", pidtype::my_os + pidtype::replicator);
            if(!main->startsession(main->sessinfo[dstdpn], dstdpn, "repldst", "", dstflags, cidtype(flags.clientid), widtype(flags.workorderid), NULL, true, "repldst")) {
                Out->msg(INFO, "Unable to start a session with the destination server for parent replication jobs progress messages");
                flags.replicate = false;
            }
        }
        bool success(stats_data_only(rootdirelem, main));
        if (success) return EXIT_OK;
        return EXIT_MISC;
    }

    
    
    freezevol freezevolume_object(flags);

    
    

    bool hasReparsePoints = true;
    bool hasRemoteReparsePoints = true;
    if(flags.freezemethod != utar_flags_enums::freezemethod_none && !flags.makeview) {
#if SYSTEM_WINDOWS
        if((xflag[6] & 2097152) == 0) {   
            
            
            flags.freezeexcludedevice.push_back("\\Device\\PGPdisks\\*");
        }
#endif
       
       freezevolume_object.freeze_volumes(hasReparsePoints, hasRemoteReparsePoints);
    }

#if SYSTEM_WINDOWS
    
    
    
    if(!flags.pathmap.isempty()) {
        upath_win::set_volume_mappings(flags.pathmap);
    }

    if (upath_reparse_point_optimizations_enabled) {
        
        
        upath::SetNeedToCheckForCrossVolReparsePoints(DONT_LOOK_FOR_REPARSE_POINTS ? false : hasRemoteReparsePoints);

        
        
        upath_win::SetNeedToCheckForReparsePoints(DONT_LOOK_FOR_REPARSE_POINTS ? false : hasReparsePoints);
    }
#endif

    
    
    
    
    
    assoc add2env;
    subscript::old_runat(flags, add2env,
                         flags.run_after_freeze,
                         flags.run_after_freeze_clauses,
                         flags.run_after_freeze_exit,
                         AVTAR_EXENAME);

    
    if(flags.incremental && !flags.isexplicit("depth")) flags.depth = 0;

    state.hfs_send_depth = flags.depth;
    state.numthreads = numthreads;

    
    main->state = &state;
    main->workctx = workctx;

    
    
    
    if(main->getdpnmaxmessage(dpn0) < ACTIVESTRIPELIST){
        flags.consolidate = false;
        DB->msg("nbackmain::runBackup the backup server is older than Eureka, consolidate is disabled.");
    }

    
    
    
    if(flags.randchunk > 0) {
        int seed = flags.randseed;
        if(seed == 0) {
            if(flags.validate) {
                Out->msg(ERR, "<5076>RANDCHUNK: No --randseed=<seed> specified for randchunk validate");
                return EXIT_BAD_FLAGS;
            }
            double now = timer::now();  
            seed = int((bigint64(~currhostname)*1000000 + bigint64((now-1100000000)*1000)) & 0x7FFFFFFF);
        }
        Out->msg(INFO, "<5077>RANDCHUNK mode: Setting random seed to %d", seed);
        if(flags.validate) Out->msg(INFO, "<7234>RANDCHUNK VALIDATE");
        if (flags.args.size() > 0)      
            Out->msg(WARN, "<7172>All backup paths are ignored in RANDCHUNK mode: %s", *flags.args.image());
        srand(seed);
    }
    else { 
        unsigned int seed = proccntl::get_current_process_id();
        srand(seed);
    }

    if (flags.morphfactor >= 0) {
        fileref d;
        d.initmem(65536*4);             
        if (flags.morphfactor < 256) {                          
            memset(d.start(), flags.morphfactor, d.size());
            Out->msg(INFO, "<0000>Morphing data with 0x%02x", flags.morphfactor);
        } else {                                                
            const char morph0 = flags.morphfactor & 255;        
            const char morph1 = (flags.morphfactor>>8) & 255;   
            char *p = d.start();
            for(int i=0; i<d.size()/2; i++) {
                *p++ = morph0;                                  
                *p++ = morph1;
            }
            Out->msg(INFO, "<0000>Morphing data with 0x%04x", flags.morphfactor&0xffff);        
        }
        main->morphdata = d;
    }

    
    
    
    

    if (flags.account_metadata) {
        main->remove_old_metadata(hfs_info, hashcode::zero);  
    }

    if(!flags.checkcache && !flags.repaircache && flags.mergedir.isempty()) {

    tryagain:
        
        try {
        
            
            
            
            if(!flags.backup_prefix.isempty()) {
                
                
                
                if (root.first() != DIRSEP) {
                    
                    flags.backup_prefix = flags.backup_prefix.chop(DIRSEP) + DIRSEPSTR;
                    
                }
                root = flags.backup_prefix.concat(root, DIRSEP);
            }

            upath workelemroot(root);
            DIRELEMp rootdirelemp(new DIRELEM(rootdirelem));

            workelem *w = new workelem(NULL, *(new upath(root)), rootdirelemp, filestatsref()); 

            
            
            
            
            
            
            
            
            
            
            
            
            
            if (!flags.no_toplevel_container && !flags.makeview && !flags.regenerate_inode2hash &&
                flags.backupstate != utar_flags_enums::backstate_begin_empty &&
                flags.backupstate != utar_flags_enums::backstate_final &&
                
                
                !flags.backupboost_convert)
            {
                if (flags.streamformat_out != utar_flags_enums::streamformat_none)
                    w->container = main->initnextucontainer(rootdirelemp, false);
            } else
                DB->msg("nbackmain is not calling context::initnextucontainer here, because this is a makeview backup");

            w->use_container = (w->container != NULL);

            DB->msg("nbackmain created workelem:%p for our nbackroot:%p child, use_container:%d container:%p",
                    w, this, w->use_container, w->container.getimpl());

            
            nbackroot *child = new nbackroot( main, *main->getTodoQueue(), w);
            main->add(TODO_DIR, child, false);
            child->noop();

            
            if(main->signposts_p) main->signposts_p->cycles_started();

            
            
            
            
            
            
            
            
            
            
            
            if (flags.pluginid.kind() == pidtype::backupboost) {
                main->set_backupboost_threaded_backup();
                main->loop(false, child);
            } else {
                
                main->loop();
            }

        } catch(connerror& e) {
            Out->msg(INFO, "<5726>Aborting backup due to error (%d:%s)", e, *ADEMgr::image(e));
            if (e != EXC_CANCEL) throw e;
            uapp::staging().startTermination(EXIT_CANCELED, "aborting backup due to error");

            
        } catch(const startupddr_exception &x) {
            if(flags.ddrenabled) {
                Out->msg(ERR, "<10949>DDR was enabled, but not started, unable to continue.");
                return EXIT_CONNECT;
            }
            Out->msg(INFO, "<10950>Starting up ddr connection to ddr#%d", x.get_ddrindex());
            flags.ddrenabled = true;
            flags.ddrindex = x.get_ddrindex();
            if (main->ADEChunkerEnabled()
                || !main->enableADEChunker(main->getAdeMgr()->getHfsInfo(dpn0))) 
            {
                Out->msg(ERR, "<10951>Could not restart ADE for DDR#%d backup", x.get_ddrindex());
                return EXIT_AUTH_FAIL;  
            }

            
            if (flags.adechunker || !flags.degenerate) {
                if(!main->startsession(main->sessinfo[dpn0], dpn0, AVTAR_EXENAME, root, flags, clientid, widtype(flags.workorderid), &dstats, true, "avtarbackup", flags.label))
                    return EXIT_MISC;
            }

            Out->msg(INFO, "<10952>Finished logging into the DDR, proceeding with backup");
            goto tryagain;
        }

        if (!uapp::staging().canRun()) DB->servlog("INTERRUPTED", "%s", "terminated");

        
        if(main->signposts_p) main->signposts_p->work_done(uapp::staging().getExitCode());

        ustring ds1("(none)");
        if(workctx->atime) {
           datetime atime_nice(+workctx->atime);
           ds1 = atime_nice.image();    
           DB->msg("Snapup Time = %s", *tostr(workctx->atime));
           if (flags.backupstate != utar_flags_enums::backstate_onetime) {
               ustring partialmode;
               switch (flags.backupstate) {
                   
                   case utar_flags_enums::backstate_begin_empty:        
                   case utar_flags_enums::backstate_begin:   partialmode = "Initial Partial"; break;
                   case utar_flags_enums::backstate_partial: partialmode = "Intermediate";  break;
                   case utar_flags_enums::backstate_onetime: partialmode = "One-time";      break;
                   case utar_flags_enums::backstate_final:   partialmode = "Final";         break;
               }
               Out->msg(INFO, "<6758>Backup Time = %s for %s Backup", *tostr(workctx->atime), *partialmode);
           }
        }

        if (!uapp::staging().canRun(RSTAGE_WRAPUP)) {
            
            Out->msg(FATAL, "<5155>Backup aborted due to earlier errors.  No backup created on the server.");
        } else {
           state.excludes.print_members(false);     
           state.includes.print_members(false);     

           const ustring dircnt = stats->get_dircount()==0 ? "" : ustring::sprintf("%s %s, ", *commas(stats->get_dircount()), DIRECTORY_NOUN);
           const double new_percent = stats->get_filebytes_sent() > stats->get_filebytes_prog() ? 100.0 : (stats->get_filebytes_sent()*100.0 / (stats->get_filebytes_prog()+0.1));
           if(uapp::staging().isExitCancel()) {
               if (state.fcache != NULL)
                   state.fcache->set_incomplete();
               Out->msg(INFO, "<5157>PARTIAL Backup #%d timestamp %s, %s files, %s%s (%s files, %s, %.2f%% new)",
                         +workctx->idnum,
                         *ds1,
                         *commas(stats->get_filecount()),
                         *dircnt,
                         *byteunits(stats->get_filebytes_prog()),        
                         *commas(stats->get_modifiedfilecount()),
                         *byteunits(stats->get_filebytes_sent()),
                         new_percent                                     
                       );
           } else if (flags.makeview) {
               
               Out->msg(INFO, "<5156>Backup #%d timestamp %s",
                         +workctx->idnum,
                         *ds1
                       );
           } else {
               
               Out->msg(INFO, "<5156>Backup #%d timestamp %s, %s files, %s%s (%s files, %s, %.2f%% new)",
                         +workctx->idnum,
                         *ds1,
                         *commas(stats->get_filecount()),
                         *dircnt,
                         *byteunits(stats->get_filebytes_prog()),        
                         *commas(stats->get_modifiedfilecount()),
                         *byteunits(stats->get_filebytes_sent()),
                         new_percent                                     
                       );
           }

            
            
            if(!flags.from_stdin && !flags.compress && stats->get_filebytes_prog() < stats->get_filebytes_primary())
                DB->msg("Byte count internal inconsistency: %.0f total < %.0f primary bytes",
                         stats->get_filebytes_prog(), stats->get_filebytes_primary());

            if(workctx->snapupoption != RHL_UPDATE_BEGIN && workctx->snapupoption != RHL_UPDATE_PARTIAL) {
                ustring msg(DBTXT("No label"));
                if(!flags.label.isempty())
                   msg = ustring::sprintf(DBTXT("Label \"%s\""), *flags.label);

                ustring expiretime, expiresmsg;
                if( (workctx->etime) && (flags.degenerate_mode == 0) ) {
                   DB->msg("backup expire prectime=%"LL"u", +workctx->etime);
                   const datetime dt(+workctx->etime);
                   avdate etime(+workctx->etime);
                   expiretime = etime.toString();
                   expiresmsg += ustring::sprintf(LOCTXT(", scheduled to expire after %s (%s)"), *expiretime, *dt.imageTZ(true));
                } else {
                   expiresmsg += ustring::sprintf(LOCTXT(", no scheduled expiration"));
                }
                
                
                if(flags.hiddensnapup) DB->msg("hidden backup etime:%s", *expiretime);
                else msg += expiresmsg;

                tretentiontype rtype(flags.retentiontype);
                if(!rtype.isnone()) 
                   msg += ustring::sprintf(", %s backup", *rtype.image());

                tbackuptype btype(flags.backuptype);
                if(btype != tbackuptype::unknown)
                    msg += ustring::sprintf(", backup type: %s", *btype.image());

                Out->msg(INFO, "<7539>%s", *msg);       
            }

            double elapsed_secs(timer::elapsed()+0.001); 
            Out->msg(INFO, "<6083>Backed-up %s in %3.2f minutes: %s/hour (%s files/hour)",
                     *byteunits(stats->get_filebytes_prog()),
                     elapsed_secs/60,
                     *byteunits(((stats->get_filebytes_prog()/elapsed_secs)*3600),2),
                     *commas((stats->get_filecount()/elapsed_secs)*3600));

            main->sessinfo[dpn0].addlabel(flags.label, +workctx->idnum);

        }
    } 

    if (!main) Out->msg(ERR, "<5310>ack - no main");
    else if (!uapp::staging().canRun()) {
        exitcode = uapp::staging().getExitCode();
        

        avamardebug::exitcode = exitcode;
    }

    if(ADEMgrX* adeMgr = ctxt->getAdeMgr()) {
        adeMgr = ctxt->getAdeMgr();
        assert(adeMgr);
        adeMgr->turnOffProgressInfo();
        DB->servlog("STATS", stats->xml(adeMgr), main->get_errorsummary_xml());  
    }

#if SYSTEM_WINDOWS
   if( ntsecurity::get_serverlog_cnt() > 0 ) {
        DB->servlog("ACLDENYCNT", DBTXT("Total non applied ACLS=%d"),  ntsecurity::get_serverlog_cnt());
    }
#endif

    if (flags.debug_messages) Out->enable(STATS);       

    
    if(!flags.adechunker && xflag[1]&1024) stats->call_stats();

    
    freezevolume_object.unfreeze_volumes();

    double latency;
    if( +stats->numcalls == 0)
        latency = 0;
    else
        latency = +stats->totalwait / +stats->numcalls;



    stats->dump();












    if(flags.adechunker) {      
        if(ADEMgrX* adeMgr = ctxt->getAdeMgr()) {
            assert(adeMgr != NULL);
            stats->atom_stats(adeMgr);
        }
    }
    else {                      
        
        if (! flags.ddrenabled) 
            stats->atom_stats();
    }

    if(! nothreads) {
        int con(0);
        timer grand_total(NULL,false);
        for(con = 0; con < numconns; con++) {
            for(int thr = 0; thr < numthreads; thr++) {
                grand_total.addtime( *calltimes[con][thr] );
            }
        }

        DB->msg( "%s", *grand_total.report("HFS Totals Calls"));

        for(con = 0; con < numconns; con++) {
            for(int thr = 0; thr < numthreads; thr++) {
                ustring res = calltimes[con][thr]->report("HFS calls");
                if(res.bytelength() > 0)
                    DB->msg("%s\n", *res);
                delete calltimes[con][thr];
            }
            delete calltimes[con];
        }
    }
    DB->filereport();
    if(calltimes)
        delete[] calltimes;

    cache_write(ctxt, flags, state, 0, 0);

    } catch(connerror& e) {
        DB->msg("nbackmain connection exception %d %s", e, *ADEMgr::image(e));
        if (main != NULL && +main->rebuilds_in_process > 0) {
            Out->msg(ERR, "<5395>Unrecoverable error occurred during connection rebuild");
        }
        avamardebug::exitcode = exitcode = EXIT_CONNECT;
        if (main != NULL && !uapp::staging().canRun()) avamardebug::exitcode=exitcode = uapp::staging().getExitCode(); 
        switch(e) {
           case EXC_CANCEL:   Out->msg(FATAL, "<5396>User Interrupt, aborting");
                              if (exitcode==EXIT_CONNECT) avamardebug::exitcode=exitcode=EXIT_CANCELED;
                              break;
           case EXC_TIMEOUT:  Out->msg(FATAL, "<5397>Server timeout: Communication failure with server, aborting.  Correct network connectivity issues, verify access to the server and retry.");
                              avamardebug::exitcode=exitcode=EXIT_MISC;
                              break;
           case EXC_CONNLOST: Out->msg(FATAL, "<5398>Connection failure with server, aborting.  Correct network connectivity issues, verify access to the server and retry.");
                              avamardebug::exitcode=exitcode=EXIT_MISC;
                              break;
           case EXC_HFSERROR: Out->msg(FATAL, "<5399>Internal error, aborting");
                              avamardebug::exitcode=exitcode=EXIT_CRASHED;
                              break;
           case EXC_PRIV_FAIL:Out->msg(FATAL, "<5416>User not authorized to perform requested operation");
                              avamardebug::exitcode=exitcode=EXIT_MISC;
                              break;
           default:           Out->msg(FATAL, "<5400>Internal connection error %s, aborting", *ADEMgr::image(e));
        }
    } catch(uexception& x) {
        SAFECATCH(x);
        Out->msg(FATAL, "<5351>MAIN: Unhandled internal exception %s", *x.image());
        avamardebug::exitcode = exitcode = EXIT_MISC;
    } catch(std::exception& x) {
        Out->msg(FATAL, "<5352>MAIN: Unhandled standard exception %s", x.what());
        avamardebug::exitcode = exitcode = EXIT_MISC;
    } catch(win_sexception& x) {
        
        x.sexception_backtrace("nbackmain", FATAL);

        
        avamardebug::exitcode = exitcode = EXIT_MISC;
    } catch(...) {
        Out->msg(FATAL, "<5353>MAIN: Unhandled unknown exception");
        avamardebug::exitcode = exitcode = EXIT_MISC;
    }

    
    
    
    
    if (!ExitCode::isOkayWithExceptions(exitcode) && !ExitCode::isCancelCode(exitcode))
        uapp::staging().startTermination(exitcode, "error reported in nbackmain");

    if(ADEMgrX* adeMgr = ctxt->getAdeMgr()) {
        SessionProfile* sessionProfile = adeMgr->getSessionProfile();
        if(sessionProfile != NULL) {
            if (uapp::staging().isExitOkay() || uapp::staging().isExitOkayWithExceptions() || uapp::staging().isExitCancel()) { 
                
                sessionProfile->finishSession(uapp::staging().getExitCode(), workctx->idnum, main->sessinfo, workctx->atime);
            }
        }
    }
    
    datetime finish;
    Out->msg(INFO, "<7883>Finished at %"AVDATE"s %s, Elapsed time: %s",
                   *finish.image(), *datetime::TzDst.av_tzname,  *timer::elapsedstring(timer::elapsed()));

    DB->sender = NULL;

    
    userid::static_cleanup();
    groupid::static_cleanup();

    
    if(main->signposts_p) main->signposts_p->report_done(uapp::staging().getExitCode());

    DB->msg("nbackmain::runBackup: disengaging ADE");
    ctxt->disengageADE();

    return exitcode;
}

void nbackmain::send_secondary_session_ticket(context* main)
{
    DB->msg("nbackmain::send_secondary_session_ticket fakeprogress=%d", flags.fakeprogress);

    if(!flags.fakeprogress) return;

    if (!main->client_ctl_statep.isnull()) {
        ctl_messagep secondary_session_ticket(new ctl_message(ctl_message::type::secondary_session_ticket));
        if (!secondary_session_ticket.isnull()) {
            secondary_session_ticket->set_res_secondary_session_ticket(flags.ctlinterface, cidtype(flags.clientid), flags.pluginid, widtype(flags.workorderid));
            const ctl_queue::rettype res(ctxt->client_ctl_statep->enq_send(secondary_session_ticket));
            DB->msg("nbackmain::send_secondary_session_ticket doing ctl enqueque %d", res);
            if (res!=ctl_queue::enqueued_ret) {
                DB->msg("nbackmain::send_secondary_session_ticket unable to enqueue secondary_session_ticket message");
            }
        }
        else
            DB->msg("nbackmain::send_secondary_session_ticket unable to create secondary_session_ticket message");
    }
    else
        DB->msg("nbackmain::send_secondary_session_ticket client_ctl_statep is null");
}


















#include "common.h"
#include "debug.h"
#include "backview.h"
#include "exclude.h"
#include "context.h"
#include "backstate.h"
#include "runstage.h"
#include "workelem.h"
#include "backdumpdir.h"
#include "timer.h"
#include "nbackdata.h"
#include "filenames.h"
#include "backviewtop.h"
#include "backdump.h"
#include "ustring.h"

#define backview_msg      ((xflag[2]&4194304)!=0)
#define do_systeminfo     (!flags.makeview_nosubsysteminfos)   

#define TOPINODE          -2                    

backview::backview(const utar_flags_info& flags_,
                   BackCycle* parent_, ustring acntname_, int labelnum_,
                   backviewbase::pathentrylist& namelist_, fileoffset patchoffset_)
  : BackCycle(parent_),
    flags(flags_),
    acntname(acntname_),
    labelnum(labelnum_),
    namelist(namelist_),
    nextinode(100),
    dir_inodes(1024, false),    
    matches_to_find(0),
    matches_found(0)
{
    BackCycle::offset = patchoffset_;
    if(backview_msg) DB->msg("backview::backview constructor (parent:%p) (this:%p)", parent, this);
    DB->msg("backview::backview acnt:%s labelnum:%d", *acntname, labelnum);
    todoEnqueue(TODO_DIR, this);  
}

void backview::init() {
    if(backview_msg)DB->msg("backview::init (parent:%p) (this:%p)", parent, this);
    DB->msg("backview::init acnt:%s labelnum:%d", *acntname, labelnum);

    
    dumpDIRELEM *topelem = new dumpDIRELEM();
    topelem->set_inode_number(TOPINODE); 
    topelem->set_name("TOP");
    inodeinfo.enter(TOPINODE, topelem);

    if (!read_one_snapup()) {
      DB->msg(DBTXT("backview::init() unable to read snapup"));
      if (!has_error())
        BackCycle::set_error(true, ustring::sprintf(DBTXT("Unable to read snapup %s:%d"), *acntname, labelnum));
      notifyparent();
      return;
    }
    Out->msg(INFO, "<6923>Starting backup of directories");
    backup_one_snapup();
}


void backview::response(message& outargs) {
  if(backview_msg)DB->msg("backview::response (parent:%p) (this:%p)", parent, this);
  assert(false);
}

void backview::childdone(cycle *child) {
    if(backview_msg) DB->msg("backview::childdone (parent:%p) (this:%p) (child:%p)", parent, this, child);
    this->size = child->size;
    if(backview_msg) DB->msg("backview::childdone hash:%s size:%s", *hash.partialimage(), *size.image());
    Out->msg(INFO, "<7528>Backed up directories for account '%s' backup#%d", *acntname, labelnum);
    notifyparent();
    
}

void backview::notifyparent() {
    if(backview_msg) DB->msg("backview::notifyparent (parent:%p) (this:%p)", parent, this);

    BackCycle::notifyparent();
    
}

bool backview::read_one_snapup() {
    if (!main) { DB->msg(DBTXT("backview::read_one_snapup no main")); return false; }
    if (!main->state) { DB->msg(DBTXT("backview::read_one_snapup no state")); return false; }

    
    DB->msg(DBTXT("backview::read_one_snapup entering include list (do_systeminfo:%d)"), do_systeminfo);
    main->state->includes.clear_list();  
    assert(main->state->includes.isempty());
    matches_found = 0;
    if (do_systeminfo) {
        main->state->includes.enter_exact(UNDOO_DIRECTORY_NAME, true); 
        if (backview_msg)DB->msg("backview::enter_include '%s'", UNDOO_DIRECTORY_NAME);
    }
    main->state->includes.enter_exact(DIRSEPSTR, false); 
    enter_include_list(namelist);

    Out->msg(INFO, "<7208>Entered %d includes", matches_to_find);

    
    main->state->excludes.enter_single("*", exclude::none);

    DB->msg(DBTXT("Reading client:%s snapup#%d"), *acntname, labelnum);
    if (!main->restore_a_view(this, labelnum, acntname)) {   
        DB->msg(DBTXT("backview::read_one_snapup() unable to restore view %s:%d"), *acntname, labelnum);
        return false;
    }

    if (backview_msg && DB->messages_on) {
        DB->msg(DBTXT("backview::read_one_snapup back from restore, calling print"));
        print_tree();
        DB->msg(DBTXT("backview::read_one_snapup back from restore, calling traverse"));
        traverse(TOPINODE, "", "/");
        DB->msg(DBTXT("backview::read_one_snapup after traverse"));
    }

    
    Out->msg(INFO, "<7036>Found %d out of %d files for account '%s' backup#%d", matches_found, matches_to_find, *acntname, labelnum);
    if (matches_found < matches_to_find) {
      Out->msg(ERR, "<7037>Unable to reference %d out of %d files for account '%s' backup#%d.  View will be incomplete.",
               matches_to_find - matches_found, matches_to_find, *acntname, labelnum);
      main->state->includes.print_members(false);
    }
    if (matches_found == 0) {
      set_error(true, "");  
      return false;  
    }

    return true;
}

void backview::enter_include_list(backviewbase::pathentrylist& names) {

    for (unsigned int j=0; j<names.size(); j++) {
      upath curname(names[j].fullname);
      bool isdir(names[j].isdir);
      if (curname.get(0) == FS_NAME_OF_ROOT) {
          upath fixroot(curname);  
          fixroot = upath(ustring("/") / fixroot.slice(1, fixroot.numelems()).image());  
          
          enter_include(fixroot, isdir);
      } else {
          
          enter_include(curname, isdir);
      }
      if (!isdir) matches_to_find++;
    }
}





void backview::enter_include(upath& path, bool isdir) {
    if (path.numelems() < 1) return;
    int kind=isdir?EXCLUDE_ISDIR:EXCLUDE_ISFILE;
    if (main->state->includes.match(path)>=kind) return; 
    if (backview_msg)DB->msg("backview::enter_include '%s'", *path.image());
    main->state->includes.enter_exact(path.image(), isdir);
    path.pop_back();
    enter_include(path, false);  
}

bool backview::backup_one_snapup() {
    DB->msg("backview::backup_one_snapup TOPINODE:%d", TOPINODE);

   
    main->state->excludes.clear_list();
    main->state->includes.clear_list();
    assert(main->state->includes.isempty());

    dumpDIRELEM * rootdirelemp = inodeinfo.lookup(TOPINODE).getdd();
    if (rootdirelemp == NULL) {
        if(!uapp::staging().canRun()) return false;
        Out->msg(FATAL, "<6924>Unable to find inode %d(root) in dump stream, aborting", TOPINODE);
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "unable to find inode in dump stream");
        return false;
    }
    
    if (rootdirelemp->num_elems() == 1 && (rootdirelemp->defined(DIRSEPSTR))) {
      int slash_inum = rootdirelemp->lookup(DIRSEPSTR);
      rootdirelemp = inodeinfo.lookup(slash_inum).getdd();
      DB->msg(DBTXT("backview::backup_one_snapup skipping slash:%d (name:%s)"), slash_inum, *rootdirelemp->name());
    }
    DB->msg(DBTXT("backview::backup_one_snapup after lookup rootdirelemp:%p parent:%p  name:%s"), rootdirelemp, parent, *rootdirelemp->name());
    if (!uapp::staging().canRun(RSTAGE_WRAPUP)) return false;

    


    workelem *w = new workelem(NULL, upath("TOP"));
    backdumpdir * dumpdir_cycle = new backdumpdir(this, main, w, rootdirelemp, inodeinfo, 0);
    dumpdir_cycle->noop();

    return true;
}




void backview::gen_inode_num(DIRELEM& de) {
  
  
  
  

  
  
  
  
  

  if(de.is_directory()) {
     
     
     
     

     const ustring name(de.fullpath().image());
     const hashcode hash(*name, name.bytelength());
     const int lookupnum = dir_inodes.lookup(hash);
     if(lookupnum != 0) {
        de.set_inode_number(lookupnum);
     } else {
        const int num = nextinode++;
        de.set_inode_number(num);
        dir_inodes.enter(hash, num);
     }
  } else {
     
     de.set_inode_number(nextinode++);
  }
}



bool backview::add_direlem(DIRELEM& parent, DIRELEM& cur, int level, int matchkind) {
    if (backview_msg)DB->msg("backview::add_direlem parent:%d(%s), cur:%d(%s), level:%d",
                             parent.inode_number(), *parent.fullpath().image(), cur.inode_number(), *cur.fullpath().image(), level);
  
    gen_inode_num(parent);

    if (level==0) {   
        parent.set_inode_number(TOPINODE);  
        ustring newname;                        
        if(cur.name().filesystem_encode(newname)) cur.set_name(newname);
    }

    int parent_inode(parent.inode_number());
    dumpDIRELEM *parent_dde = inodeinfo.lookup(parent_inode).getdd();  
    if (parent_dde == NULL) {
        parent_dde = new dumpDIRELEM(parent);  
        inodeinfo.enter(parent_inode, parent_dde);
    }
  
    gen_inode_num(cur);
    int inode(cur.inode_number());
    if(backview_msg)DB->msg("backview::add_direlem adding to parent:%d num:%d name:%s (%s)", parent_inode, inode, *cur.name(), *cur.file_hash().partialimage());
    parent_dde->enter(cur.name(), inode);   
  
    if (!inodeinfo.defined(inode)) {
      dumpDIRELEM *cur_dde = new dumpDIRELEM(cur);  
      
      
      if (cur_dde->is_directory()
          && matchkind == EXCLUDE_ISFILE) 
        cur_dde->set_hash(hashcode::zero);

      inodeinfo.enter(inode,cur_dde);
    }

    ustring cname(cur.fullpath().image());
    if (!cur.is_internal() && (!cur.is_directory() || matchkind == EXCLUDE_ISDIR)) {
       matches_found++;
       
    }






    return true;
}







bool backview::traverse(int inodenum, ustring indent, ustring fulldir) {

    if (!backview_msg) return true;
    if (!inodeinfo.defined(inodenum)) return false;

    dumpDIRELEM *elemp = inodeinfo.lookup(inodenum).getdd();
    if (elemp == NULL) return false;
    DB->msg("%s%c %d: %s", *indent, elemp->is_directory()?'|':'*', inodenum, *fulldir);

    undoo::vector<ustring> names;
    elemp->keys(names);
    for(unsigned int i=0; i<names.size(); i++) {
        ustring name(names[i]);
        int inum(elemp->lookup(name));

        dumpDIRELEM *subelemp = inodeinfo.lookup(inum).getdd();
        if (!inodeinfo.defined(inum) || subelemp == NULL) {
            DB->msg("%s| %13d %s\n", *indent, inum, *name);
            continue;
        }
        if (name.is_dot_or_dot_dot()) { DB->msg("\n"); continue; }


        ustring fullpath(fulldir/name);

        traverse(inum, indent + "  ", fullpath);
    }
    return true;
}

void backview::print_tree()
{
    if (!backview_msg) return;
    DB->msg("backview::print_tree");

    undoo::vector<intobj> inodes(inodeinfo.keys());
    for(unsigned int i=0; i<inodes.size(); i++) {
        dumpDIRELEM *tmp = inodeinfo.lookup(inodes[i]).getdd();
        if (tmp != NULL) {
            DB->msg("%12d  %c %s               %s", +inodes[i], tmp->is_directory()?'D':' ', *tmp->fullpath(), *tmp->file_hash().partialimage());
            undoo::vector<ustring> names;
            tmp->keys(names);
            for(unsigned int i=0; i<names.size(); i++) {
                ustring name(names[i]);
                DB->msg("          | %12d %s", tmp->lookup(name), *name);
            }
        }
    }
}

#if !defined(RESTONEFILE_H_INCLUDED)
#define RESTONEFILE_H_INCLUDED












#include "cycle.h"
#include "queue.h"
#include "context.h"
#include "ustring.h"
#include "ade/ade_multivolume.h"
#include "ucontainer_base.h"


class restonefile : public multivolumeroot, public bicycle {
public:
    restonefile(const hashcode& hash, context& main_, DIRELEM& direlem, ucontainer::basep container,
                fileoffset startoff=fileoffset(0), fileoffset endoff=fileoffset(0));
    virtual void childdone(cycle *child);
    virtual ~restonefile();
    SAFEALLOC(restonefile);
};

#endif







































#include "common.h"
#include "filename_cache.h"
#include "scope.h"
#include "debug.h"
#include "output.h"
#include "timer.h"
#include "utar_flags_info.h"
#include "datetime.h"
#include "file.h"
#include "upath.h"
#include "context.h"
#include "backstate.h"
#include "location_checker.h"

#define cache_msg               ((xflag[11]&512)!=0)    
#define cache_msg2              ((xflag[30]&128)!=0)    
#define show_element_validation ((xflag[30]&512)!=0)    
#define ignore_zero_or_bad0_checksum_entries ((xflag[10]&33554432)!=0) 



const ustring LOG_ID = "filename";


const int FILENAME_CACHE_BUCKETS = 20;




const int RAW_SIZE_BASE_ELEMENT     = 44;
const int RAW_SIZE_ATIME_ELEMENT    = 48;
const int RAW_SIZE_LOCATION_ELEMENT = 64;



const fileoffset MAX_LOCATION_SIZE(0xFFFFFFFF);
















class filename_cache::filename_cache_element : public cache::cache_element_type
{

public:
    explicit filename_cache_element(filename_cache::cache_format_t use_format);
    virtual ~filename_cache_element() {}
    SAFEPOOLALLOC(filename_cache_element);
    NOCOPY(filename_cache_element);


public:
    
    
    

    

    
    
    

    
    
    static int get_raw_size(filename_cache::cache_format_t format) { return (filename_cache::CFT_LOCATION == format) ? sizeof(filename_element_with_location_type) :
                                                                            (filename_cache::CFT_ATIME == format) ?    sizeof(filename_element_with_atime_type) :
                                                                                                             sizeof(filename_element_data_type); }

    
    
    
    
    
    static const unsigned char FMT_PRIMARY     = 0;         
    static const unsigned char FMT_SECONDARY   = 0x01;      

    
    
    
    
    
    
    
    bool use_filehash_field(location::media::type media) const              { return !use_extended_location_fields(media); }
    bool use_atime_field() const                                            { return m_data_size >= sizeof(filename_element_with_atime_type); }
    bool use_location_fields() const                                        { return m_data_size == sizeof(filename_element_with_location_type); }
    bool use_extended_location_fields(location::media::type media) const    { return use_location_fields() && (media != location::media::gsan); }

    
    void set_filehash(const hashcode& hash)                                 { m_filename_data.value = hash; }
    const hashcode& get_filehash() const                                    { return m_filename_data.value; }

    
    void            set_atime(unsigned int val)                             { m_filename_data.atime = val; }
    unsigned int    get_atime() const                                       { return m_filename_data.atime; }

    
    void                    set_loc_format(location::tformat::type val)     { m_filename_data.format = val; }
    location::tformat::type get_loc_format() const                          { return m_filename_data.format; }
    void                    set_loc_checksum(tchecksum::tchecksumval val)   { m_filename_data.checksum = val; }
    tchecksum::tchecksumval get_loc_checksum() const                        { return m_filename_data.checksum; }
    void                    set_loc_container_id(location::tcontainerid val){ m_filename_data.container_id = val; }
    location::tcontainerid  get_loc_container_id() const                    { return m_filename_data.container_id; }
    void                    set_loc_footer_size(const fileoffset& val)      { m_filename_data.footer_size = val.lopart(); }
    fileoffset              get_loc_footer_size() const                     { return fileoffset(+m_filename_data.footer_size); }
    void                    set_loc_media(location::media::type val)        { m_filename_data.media = val; }
    location::media::type   get_loc_media() const                           { return m_filename_data.media; }
    void                    set_loc_kind(location::entry_kind val)          { m_filename_data.ekind = val; }
    location::entry_kind    get_loc_kind() const                            { return m_filename_data.ekind; }
    void                    set_loc_variant(unsigned char variant)          { m_filename_data.format_variant = variant; }
    unsigned char           get_loc_variant() const                         { return m_filename_data.format_variant; }

    
    void                    set_xloc_offset(const fileoffset& val)          { overlay_location_data.offset = val.value(); }
    fileoffset              get_xloc_offset() const                         { return +overlay_location_data.offset; }
    void                    set_xloc_length(const fileoffset& val)          { overlay_location_data.length = val.value(); }
    fileoffset              get_xloc_length() const                         { return +overlay_location_data.length; }
    void                    set_xloc_header_size(const fileoffset& val)     { overlay_location_data.header_size = val.lopart(); }
    fileoffset              get_xloc_header_size() const                    { return fileoffset(+overlay_location_data.header_size); }


private:
    
    
    
    
    
    
    
    
    struct filename_element_data_type : public cache::cache_element_type::cache_element_data_type
    {
        hashcode    value;          
    };
    struct filename_element_with_atime_type : public filename_element_data_type
    {
        univuns     atime;          
    };
    struct filename_element_with_location_type : public filename_element_with_atime_type
    {
        univenum<location::tformat::type>   format;         
        univuns                             checksum;       
        univuns                             container_id;   
        univuns                             footer_size;    
        univenum<location::media::type>     media;          
        univenum<location::entry_kind>      ekind;          
        univenum<unsigned char>             format_variant; 
    };

    
    
    
    filename_element_with_location_type m_filename_data;
    const unsigned int m_data_size;

    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    struct overlay_location_data_type
    {
        univint64   offset;         
        univint64   length;         
        univuns     header_size;    
    };
    overlay_location_data_type& overlay_location_data;
};




filename_cache::filename_cache_element::filename_cache_element(filename_cache::cache_format_t use_format)
  : cache_element_type(&m_filename_data, get_raw_size(use_format)),
    m_data_size(get_raw_size(use_format)),
    overlay_location_data(reinterpret_cast<overlay_location_data_type&>(m_filename_data.value))
{
    assert(sizeof(hashcode) == sizeof(overlay_location_data_type));

    m_filename_data.format = location::tformat::unknown;
    m_filename_data.media = location::media::unknown;
    m_filename_data.ekind = location::entry_unknown;
    m_filename_data.format_variant = FMT_PRIMARY;
}









filename_cache::filename_cache(context* main_, const ustring name, bool is_paging_cache, int autoflushrate_, bool include_atime)
  : main(main_),
    is_valid_cache(false),
    autoflushrate(autoflushrate_),
    working_cache_format(is_paging_cache ? CFT_LOCATION : (include_atime ? CFT_ATIME : CFT_BASE)),
    working_cache(cache::new_cache(is_paging_cache ? cache::CM_PAGING : cache::CM_MONOLITHIC, *main_, LOG_ID, autoflushrate,
                              main_->get_flags().filecachemax, FILENAME_CACHE_BUCKETS, get_element_version(),
                              filename_cache_element::get_raw_size(working_cache_format))),
    repl_use_secondary(false),
    ro_cache(NULL),
    ro_cache_format(CFT_BASE)
{
    
    
    

    DB->msg("filename_cache::filename_cache: element sizes (BASE=%u, ATIME=%u, LOCATION=%u)",
            filename_cache_element::get_raw_size(CFT_BASE), filename_cache_element::get_raw_size(CFT_ATIME),
            filename_cache_element::get_raw_size(CFT_LOCATION));
    assert(filename_cache_element::get_raw_size(CFT_BASE) == RAW_SIZE_BASE_ELEMENT);
    assert(filename_cache_element::get_raw_size(CFT_ATIME) == RAW_SIZE_ATIME_ELEMENT);
    assert(filename_cache_element::get_raw_size(CFT_LOCATION) == RAW_SIZE_LOCATION_ELEMENT);

    DB->msg("filename_cache::filename_cache: %s (elemsize=%u, size=%s)", *name, filename_cache_element::get_raw_size(working_cache_format), *tostr(get_cache_size()));

    

    is_valid_cache = working_cache->load_cache(name);
    if (!is_valid_cache) {
        Out->msg(ERR, "Unable to load filename cache file '%s'", *name);
        return;
    }
    Out->msg(INFO, 2, "<5573>Loaded filename cache file (%s bytes), the value maybe the same as previous backups.", *commas(static_cast<double>(get_cache_size())));

    
    
    
    
    
    
    

    int ro_element_size = -1;
    if (need_to_migrate(name, &ro_element_size)) {
        Out->msg(INFO, "<16531>Enabling migration of file cache");
        ro_cache = new filename_cache(main, name, false, 0, include_atime);
        ro_cache_format = (ro_element_size == filename_cache_element::get_raw_size(CFT_ATIME)) ? CFT_ATIME : CFT_BASE;
        ro_cache->suppress_update();
    }
}



int filename_cache::get_element_version() const
{
    
    
    

    if (working_cache_format == CFT_LOCATION)
        return 4;

#if SYSTEM_WINDOWS
    
    return 12;
#else
    return 11;
#endif
}




void filename_cache::put_file_info( const upath& fullpath,
                               unsigned int mtime,
                               unsigned int size,
                               unsigned char attr,
                               unsigned char kind,               
                               unsigned int extflags,
                               int streamnum,
                               const hashcode& hashed_content,
                               const bool isatom,
                               unsigned int atime )
{
   if (!main->is_update_file_cache())
       return;

   const ustring pathi(fullpath.image());
   

   hashcode hfileinfo( pathi, mtime, size, attr, kind, extflags, main->get_backupconfighash() );

   put_chunk_info(hfileinfo, hashed_content, extflags, streamnum, isatom, atime, location::default_cache_location, fileoffset(size), fullpath );
   
}

void filename_cache::put_file_info( const upath& fullpath,
                                    const unsigned int size,                    
                                    const DIRELEMp de,
                                    const bool isatom,
                                    const unsigned int atime,
                                    const unsigned int extflags_or,
                                    int streamnum )
{
   if (!main->is_update_file_cache())
       return;

   const ustring pathi(fullpath.image());
   const location loc(de->get_location());

   if ((loc.get_header_size() > MAX_LOCATION_SIZE) || (loc.get_footer_size() > MAX_LOCATION_SIZE)) {
       Out->msg(WARN, "<16532>Attempted to put \"%s\" into filename_cache, but location (%s) would overflow 4-byte header or footer field, ignoring.",
                *de->fullpath().image(), *loc.image());
       return;
   }

   hashcode hashed_content = de->file_hash();

   if (cache_msg2) DB->msg("filename_cache::put_file_info name:%s loc:%s, hash:%s)", *pathi, *loc.image(), *hashed_content.partialimage() );

   const unsigned int extflags(de->filecache_extflags() | extflags_or);

   hashcode hfileinfo( pathi, de->mtime(), size, de->attr(), de->get_kind(), extflags, main->get_backupconfighash() );

   put_chunk_info(hfileinfo, hashed_content, extflags, streamnum, isatom, atime, loc, fileoffset(size), fullpath );
   
}

void filename_cache::put_chunk_info( const hashcode &src_hash,
                                     const hashcode &dst_hash,
                                     const unsigned int extflags,
                                     const int streamnum,
                                     const bool isatom,
                                     const unsigned int atime,
                                     location const &loc,
                                     const fileoffset& filesize,
                                     const upath& fullpath 
                                     )
{
   scope s(update_mtex);
   filename_cache_element ep(working_cache_format);
   

   if (loc.get_footer_size() > MAX_LOCATION_SIZE) {
       Out->msg(WARN, "Size of location footer for '%s' would overflow.", *fullpath.image());
       DB->msg("filename_cache put_chunk_info called with location:%s would overflow footer_size cache field for '%s'.", *loc.image(), *fullpath.image());
       return;
   }

   

   ep.set_hash(src_hash);
   ep.set_atomic(isatom);

   if (ep.use_filehash_field(loc.getMedia()))
       ep.set_filehash(dst_hash);

   if (ep.use_atime_field())
       ep.set_atime(atime);

   if (ep.use_location_fields()) {
       ep.set_loc_format(loc.get_format());
       ep.set_loc_kind(location::entry_unknown);

       
       if (extflags & DIRELEM::extflag_begindir) {
           ep.set_loc_checksum(loc.get_checksum().header_value);
           ep.set_loc_kind(location::entry_dir_header);
       } else if (extflags & DIRELEM::extflag_enddir) {
           ep.set_loc_checksum(loc.get_checksum().footer_value);
           ep.set_loc_kind(location::entry_dir_footer);
       } else {
           ep.set_loc_checksum(loc.get_checksum().value);
           if (extflags & DIRELEM::extflag_is_directory) {
               ep.set_loc_kind(location::entry_directory);
           } else {
               ep.set_loc_kind(location::entry_file);
           }
       }

       ep.set_loc_container_id(loc.get_containerid());
       ep.set_loc_footer_size(loc.get_footer_size());
       ep.set_loc_media(loc.getMedia());

       if(ep.get_loc_media() == location::media::ddr) {
           
           
           
           const tchecksum::tchecksumval chksumv(ep.get_loc_checksum());

           if(chksumv == 0 || chksumv == tchecksum::DDRMGR_BADCHECKSUM) {
               if(ignore_zero_or_bad0_checksum_entries) {
                   
                   Out->msg(WARN, "Ignoring filename cache entry creation for '%s' (flags:%#x) because of checksum value %#x", *fullpath.image(), extflags, chksumv);
                   return;
               } else {
                   DB->msg("filename_cache::put_chunk_info(): Entering %#x checksum in paging cache for '%s' %#x", chksumv, *fullpath.image(), extflags);
               }
           }
       }
   }

   if (ep.use_extended_location_fields(loc.getMedia())) {
       ep.set_xloc_offset(loc.get_abs_offset_in_container());
       ep.set_xloc_length(loc.get_coverage_size());
       ep.set_xloc_header_size(loc.get_header_size());
   }

   if (cache_msg2) DB->msg("filename_cache::put_chunk_info: src_hash:%s, dst_hash:%s, loc:%s", *src_hash.partialimage(), *dst_hash.partialimage(), *loc.image());

   filename_element_set(ep, dst_hash, -1, streamnum, filesize);
}

bool filename_cache::get_file_info(const upath& fullpath,
                                   const unsigned int mtime,
                                   const unsigned int size,
                                   const unsigned char attr,
                                   const unsigned char kind,               
                                   const unsigned int extflags,
                                   int streamnum,
                                   hashcode& hashed_content,
                                   int &tagword,
                                   bool& isatom,
                                   unsigned int &atime,
                                   location &loc, const bool update_tag )
{
    const ustring pathi(fullpath.image());

    
    
    
    const hashcode hfileinfo( pathi, mtime, size, attr, kind, extflags, main->get_backupconfighash() );
    cache::lookup_result ret_val = metadata_lookup(hfileinfo, fullpath, streamnum, fileoffset(size), hashed_content,
                                                   tagword, isatom, atime, loc, update_tag );

    if( cache_msg2 ) DB->msg( "filename_cache::get_file_info(%s)=%s loc:%s", *fullpath.image(), *working_cache->lookup_result_image(ret_val), *loc.image()  );
    return ret_val != working_cache->lookup_result_miss();
}




cache::lookup_result filename_cache::metadata_lookup( const hashcode &src_hash,
                                     const upath path,
                                     int streamnum,
                                     const fileoffset& filesize,
                                     hashcode& dst_hash,
                                     int &tagword,
                                     bool& isatom,
                                     unsigned int& atime,
                                     location& loc, const bool update_tag )
{
   scope s(update_mtex);
   filename_cache_element ep(working_cache_format);
   int old_index = -1;
   if (cache_msg2) DB->msg( "filename_cache::metadata_lookup( %s )", *src_hash.partialimage() );

   
   
   

   const bool fail_lookup = main->get_flags().ignore_filecache_lookup.isempty() ? false : ignore_this_file(path);
   if (fail_lookup && !update_tag) {
       if (cache_msg) DB->msg("filename_cache::metadata_lookup: not looking up hash %s (artificially missing), path '%s'", *src_hash.partialimage(), *path.image());
       return working_cache->lookup_result_miss();
   }
   if (cache_msg2)
       DB->msg("filename_cache::metadata_lookup: normal processing on hash %s, path '%s' (fail %d, update %d)",
                *src_hash.partialimage(), *path.image(), fail_lookup, update_tag);

   

   ubigint64 backupid = 0;
   hashcode filehash;
   cache::lookup_result res = filename_element_lookup(src_hash, streamnum, &ep, &filehash, &old_index, &backupid);
   if (res != working_cache->lookup_result_miss()) {
       assert(ep.get_hash() == src_hash);
       location::media::type old_media = ep.use_location_fields() ? ep.get_loc_media() : location::media::gsan;

       isatom = ep.is_atomic();

       if (ep.use_filehash_field(old_media))
           dst_hash = ep.get_filehash();
       else
           dst_hash = filehash;

       if (ep.use_atime_field())
           atime = ep.get_atime();
       else
           atime = 0;

       loc = location::default_cache_location; 
       loc.set_backupid(backupid);

       if (ep.use_location_fields()) {
           loc.set_format                   (ep.get_loc_format());
           loc.set_checksum_value           (ep.get_loc_checksum());
           loc.set_containerid              (ep.get_loc_container_id());
           loc.set_footer_size              (ep.get_loc_footer_size());
           loc.setMedia(ep.get_loc_media());
       }

       if (ep.use_extended_location_fields(old_media)) {
           loc.set_abs_offset_in_container  (ep.get_xloc_offset());
           loc.set_coverage_size            (ep.get_xloc_length());
           loc.set_header_size              (ep.get_xloc_header_size());
       }

       tagword = ep.is_tagged() ? 1 : 0;

       if (cache_msg2) DB->msg("filename_cache::metadata_lookup: returns %d, hash:%s, loc(%s)", res, *dst_hash.partialimage(), *loc.image());

       
       

       if (update_tag && ep.is_tagged() && (loc.get_format() == location::tformat::gsan))
           filename_element_set(ep, dst_hash, old_index, streamnum, filesize);

       

       return fail_lookup ? working_cache->lookup_result_miss() : res;
   }

    
    
    

    if ((ro_cache != NULL) && !fail_lookup) {
        filename_cache_element ro_entry(ro_cache_format);
        int ro_index = -1;
        const cache::lookup_result ro_result = ro_cache->working_cache->lookup_element(src_hash, streamnum, &ro_entry, &ro_index, NULL);
        if ((ro_result != working_cache->lookup_result_miss()) && ro_entry.is_tagged()) {
            if (cache_msg2) DB->msg("filename_cache::metadata_lookup: found entry in RO cache");

            
            
            
            

            isatom = ro_entry.is_atomic();
            dst_hash = ro_entry.get_filehash();
            atime = (ro_entry.use_atime_field()) ? ro_entry.get_atime() : 0;
            tagword = 1;
            loc = location::default_cache_location;

            

            if(update_tag) {
                filename_cache_element element(working_cache_format);
                element.set_hash(src_hash);
                element.set_atomic(isatom);

                if (element.use_filehash_field(loc.getMedia()))
                    element.set_filehash(dst_hash);

                if (element.use_atime_field())
                    element.set_atime(atime);

                if (element.use_location_fields()) {
                    element.set_loc_format(loc.get_format());
                    element.set_loc_checksum(loc.get_checksum().value);
                    element.set_loc_container_id(loc.get_containerid());
                    element.set_loc_footer_size(loc.get_footer_size());
                    element.set_loc_media(loc.getMedia());
                }

                if (element.use_extended_location_fields(loc.getMedia())) {
                    element.set_xloc_offset(loc.get_abs_offset_in_container());
                    element.set_xloc_length(loc.get_coverage_size());
                    element.set_xloc_header_size(loc.get_header_size());
                }

                if (cache_msg2) DB->msg("filename_cache::metadata_lookup: adding element hash %s from RO cache to working cache", *element.get_hash().partialimage());
                filename_element_set(element, dst_hash, -1, streamnum, filesize);
            }

            return ro_result;
        }
    }

   
   return res;
}




bool filename_cache::ignore_this_file(const upath& path) const
{
    
    

    static DEFINE_STL_SET_TYPE(upath) path_set;
    if (path_set.empty()) {
        const int path_count = main->get_flags().ignore_filecache_lookup.size();
        for (int index = 0; index < path_count; index++) {
            
            
            
            

            const ustring& ignore_path_option = main->get_flags().ignore_filecache_lookup[index];
            const upath ignore_path(ignore_path_option);
#if SYSTEM_WINDOWS
            const bool valid_ignore_path = ignore_path.is_absolute() && ignore_path.isWinDrive();
#else
            const bool valid_ignore_path = ignore_path.is_absolute();
#endif
            if (!valid_ignore_path) {
                Out->msg(WARN, "Unusable ignore-filecache-lookup path '%s': not a valid ignore path (%s)", *ignore_path_option, *ignore_path.image());
            } else {
                Out->msg(INFO, "Adding ignore-filecache-lookup path '%s'", *ignore_path.image());
                path_set.insert(ignore_path);
            }
        }
        if (path_set.empty())
            return false;
    }
    return path_set.find(path) != path_set.end();
}

bool filename_cache::tag_file_info( const upath& fullpath,
                                    const unsigned int mtime,
                                    const unsigned int size,
                                    const unsigned char attr,
                                    const unsigned char kind,
                                    const unsigned int extflags,
                                    const int streamnum
) {
   const ustring pathi(fullpath.image());
   const hashcode hfileinfo( pathi, mtime, size, attr, kind, extflags, main->get_backupconfighash() );
   const bool res = tag_chunk_info(hfileinfo, streamnum, fileoffset(size));
 
   return res;
}

bool filename_cache::tag_chunk_info( const hashcode &src_hash, int streamnum, const fileoffset& filesize )
{
   scope s(update_mtex);

   

   filename_cache_element new_element(working_cache_format);
   int old_index = -1;
   hashcode filehash;
   const cache::lookup_result result = filename_element_lookup(src_hash, streamnum, &new_element, &filehash, &old_index, NULL);
   if (result != working_cache->lookup_result_miss()) {
      if (cache_msg2) DB->msg("filename_cache::tag_chunk_info: tagging chunk %s", *new_element.get_hash().image());
      filename_element_set(new_element, filehash, old_index, streamnum, filesize);
      return true;
   }

   
   

   if (ro_cache != NULL) {
       filename_cache_element ro_element(ro_cache_format);
       int ro_index = -1;
       const cache::lookup_result ro_result = ro_cache->working_cache->lookup_element(src_hash, streamnum, &ro_element, &ro_index, NULL);
       if ((ro_result != working_cache->lookup_result_miss()) && ro_element.is_tagged()) {
           if (cache_msg2) DB->msg("filename_cache::tag_chunk_info: found chunk %s in RO cache", *ro_element.get_hash().image());
           assert(ro_element.get_hash() == src_hash);

           
           
           
           

           location loc = location::default_cache_location; 

           new_element.clear_element();

           new_element.set_hash(ro_element.get_hash());
           new_element.set_atomic(ro_element.is_atomic());

           if (new_element.use_filehash_field(loc.getMedia()))
               new_element.set_filehash(ro_element.get_filehash());

           if (new_element.use_atime_field())
               new_element.set_atime(0);

           if (new_element.use_location_fields()) {
               new_element.set_loc_format(loc.get_format());
               new_element.set_loc_checksum(loc.get_checksum().value);
               new_element.set_loc_container_id(loc.get_containerid());
               new_element.set_loc_footer_size(loc.get_footer_size());
               new_element.set_loc_media(loc.getMedia());
           }

           if (new_element.use_extended_location_fields(loc.getMedia())) {
               new_element.set_xloc_offset(loc.get_abs_offset_in_container());
               new_element.set_xloc_length(loc.get_coverage_size());
               new_element.set_xloc_header_size(loc.get_header_size());
           }

           filename_element_set(new_element, ro_element.get_filehash(), -1, streamnum, filesize);

           return true;
       }
   }

   return false;
}




void filename_cache::choose_root_tag(bool checkcache, bool assume_root_hashes_are_valid, bool readheader, dpns dpninx)
{
    
    

    working_cache->choose_root_tag(checkcache, assume_root_hashes_are_valid, readheader, dpninx);
    if (ro_cache != NULL) {
        ro_cache->choose_root_tag(checkcache, assume_root_hashes_are_valid, readheader, dpninx);
    }

    

    if (main->get_flags().replicate)
    {
        repl_use_secondary = (main->get_flags().destination_data == client_config_flags::same_destination);
        DB->msg("filename_cache::filename_cache: repl_use_secondary=%s", repl_use_secondary ? "true" : "false");
    }
}






bool filename_cache::copy_forward(int stream_num, const location& old_location, const location& new_location, const hashcode& base_hash, int* file_count, int* dir_count)
{
    if (working_cache_format != CFT_LOCATION)
        return false;

    if (cache_msg) {
        DB->msg("filename_cache::copy_forward: stream=%d, base_hash=%s", stream_num, *base_hash.partialimage());
        DB->msg("filename_cache::copy_forward: --> old location: %s", *old_location.image());
        DB->msg("filename_cache::copy_forward: --> new location: %s", *new_location.image());
    }
    filename_callback_methods_type callback_methods(working_cache_format);
    callback_methods.set_copy_forward(old_location, new_location, base_hash);

    if (!working_cache->copy_forward_elements(stream_num, &callback_methods))
        return false;
    callback_methods.get_copy_forward_counts(file_count, dir_count);
    return true;
}










bool filename_cache::need_to_migrate(const ustring& old_filename, int* element_size)
{
    
    

    if (main->get_flags().clearcache) {
        DB->msg("filename_cache::need_to_migrate: clearcache specified, no migration");
        return false;
    }

    

    if (working_cache_format != CFT_LOCATION) {
        return false;
    }

    

    file::statbuf file_stats;
    try {
        file::lstat(old_filename, file_stats);
    }
    catch (...) {
        DB->msg("cache::need_to_migrate: No existing monolithic cache file '%s', no migration.", *old_filename);
        return false;
    }
    const time_t file_age = (main->getcurtime() - file_stats.sb_mtime) / SEC_PER_DAY;
    if (file_age > main->get_flags().cache_migration_period) {
        DB->msg("cache::need_to_migrate: Monolithic cache file '%s' is %s days old: beyond migration period, no migration.", *old_filename, *tostr(file_age));
        return false;
    }

    

    cache::cache_model cache_model = cache::CM_UNKNOWN;
    if (!cache::is_supported_cachefile(old_filename, &cache_model, NULL, element_size)) {
        Out->msg(WARN, "<17937>Invalid or in-use old cache file '%s', no migration.", *old_filename);
        return false;
    }
    if (cache_model != cache::CM_MONOLITHIC) {
        Out->msg(WARN, "Old cache file '%s' is not monolithic, no migration.", *old_filename);
        return false;
    }

    

    DB->msg("cache::need_to_migrate: enable migration");
    return true;
}



bool filename_cache::get_secondary_element_hash(const filename_cache_element& primary_element, hashcode* secondary_hash)
{
    
    if (!repl_use_secondary)
        return false;
    if (!primary_element.use_location_fields())
        return false;
    if (primary_element.get_loc_variant() != filename_cache::filename_cache_element::FMT_PRIMARY)
        return false;
    if (primary_element.get_loc_kind() != location::entry_directory)
        return false;

    
    
    
    const char* primary_hash = reinterpret_cast<const char*>(primary_element.get_hash().data);
    *secondary_hash = hashcode(primary_hash, BYTES_IN_HASH);

    return true;
}



cache::lookup_result filename_cache::filename_element_lookup(const hashcode& hash, int streamnum, filename_cache_element* found_element, hashcode* found_filehash, int* found_index, ubigint64* backup_id)
{
    
    

    *found_filehash = hashcode::zero;
    cache::lookup_result result = working_cache->lookup_element(hash, streamnum, found_element, found_index, backup_id);
    if (result == working_cache->lookup_result_miss())
        return false;

    

    hashcode secondary_hash;
    if (!get_secondary_element_hash(*found_element, &secondary_hash))
        return true;

    
    

    filename_cache_element secondary_element(working_cache_format);
    int secondary_index = -1;
    result = working_cache->lookup_element(secondary_hash, streamnum, &secondary_element, &secondary_index, NULL);
    if (result == working_cache->lookup_result_miss()) {
        DB->msg("filename_cache::filename_element_lookup: can't find expected secondary element %s for primary %s, returning MISS",
                *secondary_hash.partialimage(), *hash.partialimage());
        return false;
    }
    if (!secondary_element.use_location_fields() || secondary_element.get_loc_variant() != filename_cache::filename_cache_element::FMT_SECONDARY) {
        DB->msg("filename_cache::filename_element_lookup: secondary %s for primary %s not marked as secondary, returning MISS",
                *secondary_hash.partialimage(), *hash.partialimage());
        return false;
    }
    *found_filehash = secondary_element.get_filehash();
    if (cache_msg) DB->msg("filename_cache::filename_element_lookup: for primary %s and secondary %s, retrieved filehash %s",
                            *found_element->get_hash().partialimage(), *secondary_hash.partialimage(), *found_filehash->partialimage());

    return result;
}



bool filename_cache::filename_element_set(const filename_cache_element& source_element, const hashcode& filehash, int target_index, int streamnum, const fileoffset& file_size)
{
    
    

    if (!working_cache->set_element(source_element, target_index, streamnum, file_size))
        return false;

    hashcode secondary_hash;
    if (!get_secondary_element_hash(source_element, &secondary_hash))
        return true;

    
    

    filename_cache_element secondary_element(working_cache_format);
    secondary_element.set_hash(secondary_hash);
    secondary_element.set_filehash(filehash);
    secondary_element.set_loc_variant(filename_cache_element::FMT_SECONDARY);
    if (cache_msg) DB->msg("filename_cache::filename_element_set: for primary %s, setting secondary %s (filehash %s)",
                            *source_element.get_hash().partialimage(), *secondary_hash.partialimage(), *filehash.partialimage());
    return working_cache->set_element(secondary_element, -1, streamnum, fileoffset(0));
}



filename_cache::~filename_cache() {
  const int items_entered = working_cache->get_elements_entered();
  const int items_booted = working_cache->get_elements_booted();

  Out->msg(STATS, "<6151>File cache: entries added/updated %s, booted %s", *commas(items_entered), *commas(items_booted));
  DB->servlog("FILE_CACHE", "entries added/updated=%d, overflow=%d", items_entered, items_booted);

  delete working_cache;
  if (ro_cache != NULL) {
      DB->msg("filename_cache::~filename_cache: start RO cache DTOR");
      delete ro_cache;
      DB->msg("filename_cache::~filename_cache: RO cache DTOR done");
  }
}











hashcode filename_cache::filename_callback_methods_type::get_server_verify_hash(const cache::cache_element_type& element)
{
    

    filename_cache_element test(m_cache_format);
    if (!test.copy_from(element))
        return hashcode::zero;
    return test.use_filehash_field(test.get_loc_media()) ? test.get_filehash() : hashcode::zero;
}



bool filename_cache::filename_callback_methods_type::validate(const cache::cache_element_type& element)
{
    

    filename_cache_element test(filename_cache::CFT_LOCATION);
    if (!test.copy_from(element))
        return true;

    

    if (test.get_loc_media() == location::media::gsan)
    {
        if (show_element_validation)
            Out->msg(INFO, "Cache GSAN entry [ekind=%d, format=%d, media=%d, container_id=%d]",
                     test.get_loc_kind(), test.get_loc_format(), test.get_loc_media(), test.get_loc_container_id());
        m_checkinfo.found_gsan_entry();
        return false;
    }

    

    ustring precheck_result;
    if (test.get_loc_kind() == location::entry_unknown)
        precheck_result += ustring::sprintf("[ekind is zero (%d)] ", test.get_loc_kind());

    
    

    if (show_element_validation && (test.get_loc_format() == location::tformat::cdsf || test.get_loc_format() == location::tformat::raw))
    {
        Out->msg(INFO, "<18740>Cache raw or CDSF entry [ekind=%d, format=%d, media=%d, container_id=%d, offset=%s, length=%s, header_size=%s]",
                 test.get_loc_kind(), test.get_loc_format(), test.get_loc_media(), test.get_loc_container_id(),
                 *tostr(test.get_xloc_offset().value()), *tostr(test.get_xloc_length().value()), *tostr(test.get_xloc_header_size().value()));
    }

    return m_checkinfo.validate_entry(test.get_loc_kind(), test.get_loc_media(), test.get_loc_format(), location::tbackupid(0),
                                     test.get_loc_container_id(), test.get_xloc_length(), test.get_xloc_header_size(),
                                     test.get_loc_footer_size(), test.get_xloc_offset(), test.get_loc_checksum(),
                                     precheck_result);
}



void filename_cache::filename_callback_methods_type::validate_summary()
{
    m_checkinfo.summary();
}



void filename_cache::filename_callback_methods_type::set_copy_forward(const location& old_location, const location& new_location, const hashcode& base_hash)
{
    m_region_start = old_location.get_abs_offset_in_container();
    m_region_end = m_region_start + old_location.get_coverage_size();
    m_offset_diff = new_location.get_abs_offset_in_container() - m_region_start;

    m_container_id = new_location.get_containerid();
    m_base_hash = base_hash;
    m_cf_dir_count = 0;
    m_cf_file_count = 0;
}






bool filename_cache::filename_callback_methods_type::apply_copy_forward(const cache::cache_element_type& element,
                                                                        cache::cache_element_type* modified_element)
{
    
    
    
    
    
    
    
    
    

    if (element.get_hash() == m_base_hash)
        return false;

    filename_cache_element local_element(filename_cache::CFT_LOCATION);
    if (!local_element.copy_from(element))
        return false;
    if (local_element.get_loc_variant() != filename_cache::filename_cache_element::FMT_PRIMARY)
        return false;
    if (!local_element.use_extended_location_fields(local_element.get_loc_media()))
        return false;

    fileoffset old_offset = local_element.get_xloc_offset();
    if ((old_offset < m_region_start) || (old_offset >= m_region_end))
        return false;

    
    

    const fileoffset new_offset = old_offset + m_offset_diff;
    local_element.set_xloc_offset(new_offset);
    local_element.set_loc_container_id(m_container_id);
    modified_element->copy_from(local_element);

    switch (local_element.get_loc_kind())
    {
    case location::entry_file:      m_cf_file_count++; break;
    case location::entry_directory: m_cf_dir_count++; break;
    default: break;
    }

    if (cache_msg2) {
        DB->msg("filename_cache::filename_callback_methods_type::apply_copy_forward: hash=%s, old offset=%s, new offset=%s",
                    *local_element.get_hash().partialimage(),
                    *old_offset.image(),
                    *new_offset.image());
    }
    return true;
}




void filename_cache::filename_callback_methods_type::get_copy_forward_counts(int* file_count, int* dir_count)
{
    if (file_count != NULL)
        *file_count = m_cf_file_count;
    if (dir_count != NULL)
        *dir_count = m_cf_dir_count;
}

#if !defined(RESTDATAPRODUCER_H_INCLUDED)
#define RESTDATAPRODUCER_H_INCLUDED











#include "cycle.h"
#include "fileref.h"
#include "restelem.h"
#include "ade_restore.h"

class restpipe;


class restdataproducer : public bicycle, nsAdeLib::ADERestore {
public:
    SAFEPOOLALLOC(restdataproducer);

    class consumer {
    public:
        consumer() {}
        virtual ~consumer() {}

        
        
        
        
        
        
        
        
        
        
        
        virtual void rdpconsume(const fileref &buf, const fileoffset &startoff, restdataproducer * const producer) = 0;
    };

    restdataproducer(cycle*            parent,
                     const hashcode&   hash_,
                     const fileoffset& datasize_,
                     consumer * const  callback_,
                     const bool        process_in_order_,
                     const ustring&    msgid_ = "unknown",
                     const dpns        dpninx = dpn0);

    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~restdataproducer();

    
    
    void terminate();

    fileoffset pendingbytes() const;
    fileoffset bufferedbytes() const;
    fileoffset highwaterbytes() const { return highwater; }


private:
    NOCOPY(restdataproducer);

    class elem_t {
    public:
        elem_t(const hashcode& h_, const fileoffset& startbyte_, const fileoffset& endbyte_) 
            : h(h_), startbyte(startbyte_), endbyte(endbyte_), done(false), prev(NULL), next(NULL) 
            { buf.initlist(1024); }

        const hashcode h;
        const fileoffset startbyte, endbyte;        
        fileref buf;
        chunktype ctype;
        bool done;
        elem_t *prev, *next;
        
        ustring image() const { return ustring::sprintf("(%s done:%d buf.size64():%s start:%s end:%s prev:%p next:%p)",
                                                        *h.partialimage(), done, *buf.size64().image(), *startbyte.image(), *endbyte.image(), prev, next); }
    };

    
    
    void spawn_subcycles(elem_t *e);

    
    
    void flush_ready_buffers();

    
    void process_data(elem_t *e);

    
    bool flushable(elem_t *e);

    
    elem_t *remove_elem(elem_t *e);

    
    void check_elemlist() const;

    fileoffset tailoffset;    
    fileoffset logicaloffset; 
    fileoffset buffered;      
    fileoffset highwater;     

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    typedef DEFINE_STL_MAP_TYPE(restpipe*, elem_t *) cycle_to_elem_t;
    cycle_to_elem_t  inflight;
    elem_t          *elemlist;

    hashcode   requested_hash;   
    fileoffset datasize;         
    consumer  *callback;         
    bool       process_in_order; 
    bool       terminated;       
    const ustring    msgid;            
    dpns       dpninx;
};

#endif

#if !defined(BACKHIDDEN_H_INCLUDED)
#define BACKHIDDEN_H_INCLUDED












#include "cycle.h"
#include "interfaceade_export.h"
#include "shared_ptr.h"



class hiddendirfuncs {
public:
    virtual ~hiddendirfuncs() { }

    
    virtual void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false ) = 0;

    
    virtual void do_file_finish() = 0;
};





class hiddendirwriter : public hiddendirfuncs {
    public:

        hiddendirwriter() { }
        virtual ~hiddendirwriter() { }

        
        void add_server(hiddendirfuncs * server);

        
        virtual void do_file( const ustring& name, unsigned char attributes, const fileref& data, const bool use_container_also = false );

        
        virtual void do_file_finish();

        
        
        
        typedef DEFINE_STL_VECTOR_TYPE(hiddendirfuncs *) ServersType;
        ServersType servers;
};

typedef undoo::shared_ptr<hiddendirwriter> hiddendirwriter_sp;

class fileref;
class workelem;
class nbackdir;

class backhidden : public BackCycle {
public:
    
    
    
    backhidden(BackCycle *parent, workelem *info, fileoffset offset, const fileoffset incdumpsize, const bool use_container_also = false, const bool write_ddrfiles_xml_ = false, const DataDomainSysInfo* ddrSysInfoVp = NULL);

    virtual void init();
    virtual void response(message& outargs);
    virtual void childdone(cycle *child);
    virtual void notifyparent();
    virtual ~backhidden();

    
    
    virtual void save_last_sysinfo(DIRELEMp last_sysinfo_de);

    void set_target_path(const ustring& target_path);

    SAFEPOOLALLOC(backhidden);
private:
    hiddendirwriter_sp proxy;
    fileref listing;
    ustring path;

    const fileoffset incdumpsize;
    const bool use_container_also;

    
    const bool write_ddrfiles_xml;

    
    const DataDomainSysInfo* ddrSysInfoVp;

    bool write_target_workresults;

    bool create_archive_info_file(fileref& info_data, const char *xmlname);
    void do_hidden_dir();
    bool do_diskfile(const ustring& name, const ustring& diskname, int waitsecs );
    void do_comment_files(const stringlist& list);

    
    void do_sysinfo_assoc(const tassoc<ustring, fileref>& sysinfo_files_and_data);

    typedef backupboost::target_system_info_data target_sysinfo_data_map;
    typedef target_sysinfo_data_map::sysinfo_data_list system_info_data_list;
    void do_target_sysinfo_assoc(const target_sysinfo_data_map& target_sysinfo_files_and_data);

    bool do_backuptag(hiddendirwriter_sp proxy);
};








class backhiddendir : public BackCycle
{
public:
    
    backhiddendir(BackCycle *parent, DIRELEMp last_sysinfo_de, DIRELEMp new_prev_de, fileoffset offset);

    void init();
    void childdone(cycle *child);

private:
    enum phase {
        phase_get_last_sysinfo,   
        phase_get_last_prev,      
        phase_write_new_sysinfo,  
        phase_write_new_prev,     
        phase_notify_parent       
    };

    phase                   m_phase;
    DIRELEMp                m_last_sysinfo_de;       
    DIRELEMp                m_new_prev_de;           
    fileref                 m_new_sysinfo_fr;        
    fileref                 m_prev_fr;               
    name_to_direlemp_table  m_last_sysinfo_contents; 
};

#endif































#include "common.h"
#include "output.h"
#include "debug.h"
#include "export_netappvol.h"
#include "restdirlist.h"
#include "restdir.h"
#include "restfile.h"
#include "restnofilter.h"
#include "todoelem.h"
#include "context.h"
#include "utar_flags_info.h"
#include "pipe_control.h"
#include "filenames.h"
#include "dumpstreamutils.h" 

#define msg1  ((xflag[2]&8)!=0)




static const char *entry_order[] =
    {
        
        
        
        

        
        

        TS_TAPE_FILENAME,
        TS_CLRI_FILENAME,
        TS_BITS_FILENAME,
        TS_DIR_FILENAME,
        TS_ACL3_FILENAME,
        TS_FILE_FILENAME,
        TS_EOM_FILENAME,
        TS_ACL_FILENAME,

        
        

        
        
        
        
        0
    };

export_netappvol::export_netappvol(bicycle *parent, const location& _theloc,
                                   const restelem& restinfo, cycle *starter,
                                   dumpcontext::dirlistelem *dumpparent_,
                                   bool excluded_, int traverse_depth_,
                                   bool waspreexisting, bool directory_dir_)
  : bicycle(parent),
    ADERestore(parent->main),
    theloc(_theloc),
    directory_dir(directory_dir_),
    phase(phase_construct),
    traverse_depth(traverse_depth_),
    info(restinfo),
    dumpparent(dumpparent_)
{
    assert(theloc.isFromGsan());   
    this->hash = hashcode::zero;
    cyexcluded = excluded_;
    cyisdirectory = true;
    assert(info.direlem.is_directory());

    if ((xflag[21]&32)!=0) {    
        if(starter)
            starter->setnext(TODO_DIR, this, 0);
        else
            todoEnqueue(TODO_DIR, this); 
    } else {
        
        if(starter)
            starter->setnext(TODO_DIR, this, -traverse_depth);
        else
            todoEnqueueInsert(TODO_DIR, this, -traverse_depth);
    }

    phase = phase_init;
}

void export_netappvol::init()
{
    assert(phase == phase_init);

    
    if(pipe_control *ppipe_control = main->getpipe_control(&info)) {
        fileref dummy;
        ppipe_control->addobj(pipe_control::DIRTYPE, info.path.image(), info.direlem, 0, dummy);
    }

    
    cycle *child = new restdirlist(this, theloc, upath(), info.direlem.get_location(), dir_contents);
    child->noop();

    nforked++;

    childdone(0);

    phase = phase_gather;
}


const undoo::vector<DIRELEMp> export_netappvol::detable2delist(name_to_direlemp_table& detable)
{
    undoo::vector<DIRELEMp> ret;

    if(!directory_dir) {
        
        {
            const ustring key(UNDOO_DIRECTORY_NAME);
            const DIRELEMp dep(detable.lookup(key));
            if(!dep.isnull() && dep->is_internal()) {
                ret.push_back(dep);
                assert(detable.remove(key));
            } else {
                Out->msg(WARN, "<14707>'%s' not found in Netapp volume backup", *key);
            }
        }

        
        {
            const undoo::vector<ustring> keys(detable.keys());
            for(size_t i = 0; i < keys.size(); i++) {
                const DIRELEMp dep(detable.lookup(keys[i]));
                if(!dep.isnull() && dep->is_internal()) {
                    ret.push_back(dep);
                    assert(detable.remove(keys[i]));
                }
            }
        }

        
        const char **entry = entry_order;
        while(*entry) {
            const ustring key(*entry);
            const DIRELEMp dep(detable.lookup(key));
            if(!dep.isnull()) {
                ret.push_back(dep);
                assert(detable.remove(key));
            } else {
                Out->msg(INFO, "<12455>Netapp volume backup did not contain an entry of '%s'", *entry);
            }
            entry++;
        }

        
        {
            const undoo::vector<ustring> keys(detable.keys());

            for(size_t i = 0; i < keys.size(); i++) {
                const ustring key(keys[i]);

                if(!key.contains(TS_END_FILENAME) == 0) {
                    const DIRELEMp dep(detable.lookup(key));
                    if(!dep.isnull()) {
                        ret.push_back(dep);
                        assert(detable.remove(key));
                        Out->msg(WARN, "<12456>Netapp volume backup contains entry '%s' which was not in sort list", *key);
                    }
                }
            }
        }

        
        {
            const undoo::vector<ustring> keys(detable.keys());

            for(size_t i = 0; i < keys.size(); i++) {
                const ustring key(keys[i]);

                const DIRELEMp dep(detable.lookup(key));
                if(!dep.isnull()) {
                    ret.push_back(dep);
                    assert(detable.remove(key));
                }
            }
        }
    } else {
        const undoo::vector<ustring> keys(detable.keys());
        for(size_t i = 0; i < keys.size(); i++) {
            const ustring key(keys[i]);
            const DIRELEMp dep(detable.lookup(key));
            if(!dep.isnull()) {
                if(dep->name() == TS_DIR_ROOT_INODE_FILENAME) {
                    
                    ret.insert(ret.begin(), dep);
                } else {
                    ret.push_back(dep);
                }
            }
        }
    }

    return ret;
}


const unsigned export_netappvol::enqueue_cycles(const undoo::vector<DIRELEMp> delist)
{
    unsigned ret(0);

    cycle *prevchild(0), *child(0);
    for(size_t i = 0; i < delist.size(); i++) {
        const DIRELEMp dep(delist[i]);

        if(!dep.isnull()) {
            if(msg1) DB->msg(DBTXT("export_netappvol::enqueue_cycle(): [%s] => %s"), *tostr(i), *dep->name());

            if(dep->is_directory()) {
                const restelem restinfo(dep->fullpath(), *dep, info.fstats, false, info.vinfo);

                const location tmploc(theloc.getMedia(), dep->file_hash());
                if(!directory_dir && dep->name() == TS_DIR_FILENAME) {
                    child = new export_netappvol(this, tmploc, restinfo, prevchild, 0,
                                                 false, traverse_depth+1, false, true );
                } else {
                    child = new restdir(this, tmploc, restinfo, prevchild, dumpparent,
                                        false, traverse_depth+1, false);    
                }
            } else {
                ucontainer::basep container(main->open_container_for_read(dep->get_location()));
                child = (flags.archive_unfiltered_data && flags.streaming_an_archive() && (main->getpipe_control(&info) != 0)) ?
                    new restnofilter(this, dep->file_hash(), *dep, container, prevchild, info.vinfo) :
                    new restfile(this, dep->file_hash(), *dep, container, prevchild, info.vinfo);
            }
            child->noop();
            prevchild = child;
            ret++;
        }
    }

    return ret;
}

void export_netappvol::childdone(cycle *child) {
    if(child) {
        ncollected++;

        if(phase == phase_gather) {
            nforked += enqueue_cycles(detable2delist(dir_contents));

            phase = phase_dirs_and_files;
        } else {
            assert(phase == phase_dirs_and_files);
        }
    }

    if(msg1)DB->msg("export_netappvol::childdone this:%p, nforked:%d ncollected:%d child:%p info.data.size():%d",
                    this, nforked, ncollected, child, info.data.size());

    if (ncollected < nforked)
        return;

    
    if(pipe_control *ppipe_control = main->getpipe_control(&info)) {
        ppipe_control->finobj(pipe_control::DIRTYPE, info.path.image(), info.direlem);
    }

    notifyparent();
}

export_netappvol::~export_netappvol() {}











#include "clientapp.h"




clientapp::clientapp(const char* appname, const int appversion, int argc , char **argv ) :
    uapp()
{
}


clientapp::~clientapp()
{
}
#ifndef BACKUPBOOST_UTILS_H
#define BACKUPBOOST_UTILS_H
















#include "hardlink_path_table.h"
#include "inode_table.h"
#include "utar_flags_info.h"
#include "ndmp_volume_entification.h"
#include "BackupRootInfo.h"

class utar_commands;

namespace backupboost
{


#define BB_DELIMITER ('|')     
#define HL_FLAG      ("HL")    
                               
#define NODE_REG     ("Reg")   
#define NODE_DIR     ("Dir")   
#define NODE_LNK     ("Lnk")   
#define NODE_BDEV    ("Blk")   
#define NODE_CDEV    ("Chr")   
#define NODE_SOC     ("Soc")   
#define NODE_FIFO    ("Fifo")  








class path2event_table {
public:
    path2event_table() { current_table_itr = event_table.begin(); current_list_index = 0; }
    ~path2event_table() {}

    
    
    
    struct event_list_entry {
        event_list_entry() : event_info(), inode(0) {}
        event_list_entry(const bbevent& event_info_, const ubigint64& inode_)
            : event_info(event_info_), inode(inode_) {}

        bbevent event_info;
        ubigint64 inode;

        
        inline const bool is_empty() const { return inode == 0 && event_info.is_empty(); }
        inline const bool is_hardlink() const { return event_info.is_hardlink(); }
        inline const bool is_dir() const { return event_info.is_dir(); }
        inline const bool is_reg() const { return event_info.is_reg(); }
    };

    
    
    
    
    
    const bool add_table_entry(const upath& path, const ubigint64 inode,
                               const bbevent& eventinfo, const bool add_dir_elements = false);

    
    void remove_table_entry(const upath path);

    
    void dump() const;

    
    inline const size_t table_size() const { return event_table.size(); }

    
    
    
    
    inline void init_next_entry() { current_table_itr = event_table.begin(); current_list_index = 0; }

    
    
    
    const bool get_next_entry(event_list_entry &event, upath &path);

    
    inline const bool is_begin() { return ((current_table_itr == event_table.begin()) && (current_list_index == 0)); }

    
    inline const bool is_end() { return (current_table_itr == event_table.end()); }

    
    
    
    
    
    
    inline const bool decrement_itr()
    {
        if ((current_table_itr == event_table.begin()) && (current_list_index == 0)) {
            
            return false;
        } else {
            
            if (current_list_index > 0) {
                current_list_index--;
            } else {
                
                
                current_table_itr--;
                current_list_index = current_table_itr->second.size() - 1;
            }
            return true;
        }
    }

    SAFEALLOC(event_list_entry);

private:
    
    typedef DEFINE_STL_VECTOR_TYPE(event_list_entry) event_entry_list_t;
    typedef event_entry_list_t::iterator event_entry_list_itr;

    
    
    
    #if SYSTEM_WINDOWS
      typedef std::multimap<upath, event_entry_list_t, bb_common::subpath_comp > path2event_table_t;
    #else
      typedef std::multimap<upath, event_entry_list_t, bb_common::subpath_comp, stlsafepoolallocator<std::pair<upath const, event_entry_list_t > > > path2event_table_t;
    #endif
    typedef path2event_table_t::const_iterator const_path2event_table_itr;
    typedef path2event_table_t::iterator path2event_table_itr;

    path2event_table(const path2event_table&);

    path2event_table_t event_table;

    
    
    path2event_table_itr current_table_itr;
    size_t current_list_index;
};





struct hl_event_list_entry {
    hl_event_list_entry() : event_info(), inode(0), path("") {}
    hl_event_list_entry(const bbevent& event_info_, const ubigint64& inode_, const upath& path_ = upath(""))
        : event_info(event_info_), inode(inode_), path(path_) {}

    bbevent event_info;
    ubigint64 inode;
    upath path;
};






class hardlink_event_list {
public:
    hardlink_event_list() { current_list_itr = event_list.end(); }
    ~hardlink_event_list() {}

    
    inline void add_entry(const hl_event_list_entry& entry) { event_list.push_back(entry); }

    
    inline const size_t list_size() const { return event_list.size(); }

    
    void dump(ustring &list_name) const;

    
    
    
    
    inline void init_next_entry() { current_list_itr = event_list.begin(); }

    
    
    
    const bool get_next_entry(bbevent &eventinfo, ubigint64 &inode, upath &path);

    SAFEALLOC(hardlink_event_list);

private:
    typedef DEFINE_STL_VECTOR_TYPE(hl_event_list_entry) hl_event_list_t;
    typedef hl_event_list_t::iterator hl_event_list_itr;

    hl_event_list_t event_list;

    
    hl_event_list_itr current_list_itr;
};





class directory_rename_list {
public:
    directory_rename_list() { current_list_itr = rename_list.end(); }
    ~directory_rename_list() {}

    
    const bool add_list_entry(const upath &key_path, const ubigint64 inode,
                              const bbevent &eventinfo, const upath &new_path);

    
    inline const size_t list_size() const { return rename_list.size(); }

    
    void dump() const;

    
    
    
    
    inline void init_next_entry() { current_list_itr = rename_list.end(); }

    
    
    
    
    const bool get_next_entry(upath &old_path, ubigint64 &inode,
                              bbevent &eventinfo, upath &new_path);

private:
    
    
    
    #if SYSTEM_WINDOWS
      typedef std::map<upath, hl_event_list_entry, bb_common::subpath_comp > dir_rename_list_t;
    #else
      typedef std::map<upath, hl_event_list_entry, bb_common::subpath_comp, stlsafepoolallocator<std::pair<upath const, hl_event_list_entry > > > dir_rename_list_t;
    #endif
    typedef dir_rename_list_t::const_iterator const_dir_rename_list_itr;
    typedef dir_rename_list_t::iterator dir_rename_list_itr;

    directory_rename_list(const directory_rename_list&);

    dir_rename_list_t rename_list;

    
    
    dir_rename_list_itr current_list_itr;
};

struct target_session_result;

class backupboostutils {
public:
    backupboostutils() : base_sequencenum(-1), base_savesetid("") {}
    ~backupboostutils() {}

    
    const bool preprocess(inode_table &inodetab,
                          hardlink_path_table &pathtab,
                          path2event_table &bbeventlist,
                          utar_flags_info *flags = NULL);

    
    
    
    
    const bool prepare_incremental(utar_flags_info &vol_flags,
                                   utar_commands &uc,
                                   const BackupRootInfoList &backup_list,
                                   BackupRootInfo &prev_backup,
                                   target_session_result &prev_result,
                                   inode_table &inodetab,
                                   hardlink_path_table &pathtab);

private:
    
    
    
    const bool select_incremental_base(const utar_flags_info &vol_flags,
                                       const ustring &volume_name,
                                       utar_commands &uc,
                                       const BackupRootInfoList& backup_list,
                                       BackupRootInfo &one_backup,
                                       backupboost::target_session_result &prev_result);

    
    
    
    const bool validate_incremental_base(const utar_flags_info &vol_flags,
                                         const ustring &volume_name,
                                         utar_commands &uc,
                                         const BackupRootInfo &one_backup,
                                         backupboost::target_session_result &prev_result);

    int base_sequencenum;
    ustring base_savesetid;
};






class backupboost_parser {
public:
  SAFEALLOC(backupboost_parser);

  
  
  backupboost_parser(const ustring& streamdesc,
                     const int stream_timeoutsecs,
                     const ustring& input_tee_streamdesc);

  
  virtual ~backupboost_parser();

  
  
  const bool getentry(bbevent& eventinfo, ubigint64& inode, upath& path_1, upath& path_2);

  
  
  
  const bool readdata();

  
  
  
  
  const int myopen_streamdesc(const ustring& streamdesc, const int streamfd, const int stream_timeoutsecs) const;

protected:
  
  const int fd;

  
  const bool fd_is_socket;

  
  const int fd_input_tee;

  
  FILE* fd_stream;

  private:
  NOCOPY(backupboost_parser);

  
  ustring current_line;

  
  ubigint64 line_count;

  
  ubigint64 byte_count;
};
















class target_system_info_data {
public:
    typedef std::pair<ustring, fileref> sysinfo_data;
    typedef std::vector<sysinfo_data> sysinfo_data_list;
    typedef sysinfo_data_list::iterator sysinfo_data_list_iter;
    typedef std::map<ustring, sysinfo_data_list> target_sysinfo_data_map;
    void set(const ustring& target, const ustring& file, const fileref& data) {
        scope s(sysinfo_mut);
        target_sysinfo_data_map::iterator itr = target_sysinfo_data.find(target);
        if (itr != target_sysinfo_data.end()) {
            itr->second.push_back(std::make_pair(file, data));
            return;
        }
        sysinfo_data_list list;
        list.push_back(std::make_pair(file, data));
        target_sysinfo_data.insert(std::make_pair(target, list));
    }
    void get(const ustring& target, sysinfo_data_list& list) const {
        target_sysinfo_data_map::const_iterator itr = target_sysinfo_data.find(target);
        if (itr != target_sysinfo_data.end())
            list = itr->second;
    }
    void remove(const ustring& target) {
        scope s(sysinfo_mut);
        target_sysinfo_data.erase(target);
    }
    bool is_empty() const {
        return target_sysinfo_data.empty();
    }
private:
    target_sysinfo_data_map target_sysinfo_data;
    mtex sysinfo_mut;
};









struct target_session_result
{
    target_session_result() : session_id(0), exit_code(0) {}
    target_session_result(const ustring& target_, const ustring& backup_mode_,
                          int session_id_, ubigint64 backup_time_, int exit_code_)
        : target(target_),
          backup_mode(backup_mode_),
          session_id(session_id_),
          backup_time(backup_time_),
          exit_code(exit_code_) {}

    ustring target;
    ustring backup_mode;
    ubigint64 session_id;
    ubigint64 backup_time;
    int exit_code;
};


class target_work_results
{
public:
    target_work_results();
    ~target_work_results();

    bool parse(const ustring& work_results_string);
    bool parse(const xml_messagep& work_results_xml);

    
    xml_messagep to_xml() const;

    
    ustring image() const;

    bool is_empty() const;

    
    void add_result(const target_session_result& session_result);

    void set_avtar_version(const ustring& version);
    void set_ddr_index(int ddr_index);
    void set_version(int version);
    ustring get_avtar_version() const;
    int get_ddr_index() const;
    int get_version() const;

    
    int get_final_exitcode() const;

    
    bool get_session_result(const ustring& target, target_session_result& session_result) const;

    
    void list_backups(stringlist& backup_list) const;

private:
    typedef DEFINE_STL_VECTOR_TYPE(target_session_result) session_results;
    typedef session_results::const_iterator results_iterator;
    session_results results;
    mtex work_results_mtex;
    ustring avtar_version;
    int ddr_index;
    
    int version;
};


class journal_session_id_time_t
{
public:
    journal_session_id_time_t() {}
    bool parse(const ustring& in_file);
    bool image(const ustring& out_file) const;
    void add_session_entry(const upath& key_path, ubigint64 session_id, ubigint64 session_time);
    bool get_session_entry(const upath& key_path, const ubigint64 search_time, ubigint64& session_id) const;
    bool get_session_time(const upath& key_path, const ubigint64 session_id, ubigint64& session_time) const;
    bool remove_session_entries(const upath& key_path, const ubigint64 search_time);
    void remove_target_entry(const upath& key_path);

private:
    NOCOPY(journal_session_id_time_t);
    typedef std::pair<ubigint64, ubigint64> session_id_time_entry_t;
    typedef DEFINE_STL_VECTOR_TYPE(session_id_time_entry_t) session_id_time_list_t;
    typedef session_id_time_list_t::const_iterator session_id_time_list_citr_t;
    typedef session_id_time_list_t::iterator session_id_time_list_itr_t;
    typedef std::map<upath, session_id_time_list_t> session_id_time_map_t;
    typedef session_id_time_map_t::const_iterator session_id_time_map_citr_t;
    typedef session_id_time_map_t::iterator session_id_time_map_itr_t;
    int get_latest_session_index(const upath& key_path, const ubigint64 search_time) const;
    session_id_time_map_t session_id_time_map;
};

}

#endif 
















#include "common.h"
#include "debug.h"
#include "emctarpipe.h"
#include "output.h"
#include "utar_flags_enums.h"
#include "dirrec_pack.h"
#include "ndmp_volume_entification.h"
#include "restelem.h"
#include "data_regions.h"

using namespace data_regions;

#define BLOCKSIZE 512

#define MAXPREFIX 155
#define MAXNAME 100

#define dowfs    ((xflag[15]&2)==0)

#define msg1 ((xflag[11]&4194304)!=0)

emctarpipe::emctarpipe(fileref& data_,
                       const userid *uidmap_, const groupid *gidmap_,
                       const ustring &pathprefix_, const bool i18n_,
                       const bool rewrite_i18n_,
                       const ustring ndmp_prefix_)
  : pipe_control(data_, BLOCKSIZE, utar_flags_enums::streamformat_emctar),
    uidmap(uidmap_),
    gidmap(gidmap_),
    pathprefix(pathprefix_),
    i18n(i18n_),
    rewrite_i18n(rewrite_i18n_),
    ndmp_prefix(ndmp_prefix_)
{
    if((pathprefix.isempty() || pathprefix.byteindex(0) != '/') && (xflag[15]&4096)==0)
        pathprefix = ustring("/")+pathprefix;                       

    Out->msg(INFO, "<7223>Generating EMC tar stream to path \"%s\"", *pathprefix);

    DB->msg ("emctarpipe::emctarpipe pathprefix:%s", *pathprefix);
}


void emctarpipe::fillmyblock(fileref &fref)
{
    if(blocksize > 0) {
        const int cursize(fref.size());

        
        int extra = blocksize - (cursize % blocksize);
        if(extra == blocksize) {
            extra = 0;
        }
        if(extra > 0) {
            fileref zero = makezeros(extra);
            fref.setslice64(cursize, zero, false);
        }
        DB->msg("emctarpipe::fillmyblock curroffset:%d (extra:%d)", cursize, extra);
    }
}



ustring emctarpipe::convert_path_to_hardlink_path(const ustring& direlemfullpath) const
{
    if (ndmp_prefix.isempty()) {
        return (get_path_prefix() / direlemfullpath);
    } else {
        return ndmp_unentify_volume_plus_path(direlemfullpath);
    }
}

bool emctarpipe::islnk(const DIRELEM &de)
{
#ifdef S_ISLNK
    if (de.is_symlink()) {
        assert(S_ISLNK(de.unix_mode()));
        return true;
    }
    return S_ISLNK(de.unix_mode());
#else
    return de.is_symlink();
#endif
}

bool emctarpipe::isfifo(const DIRELEM &de)
{
#ifdef S_ISFIFO
    if (de.is_fifo()) {
        assert(S_ISFIFO(de.unix_mode()));
        return true;
    }
    return S_ISFIFO(de.unix_mode());
#else
    return de.is_fifo();
#endif
}

bool emctarpipe::ischr(const DIRELEM &de)
{
#ifdef S_ISCHR
    return S_ISCHR(de.unix_mode());
#else
    return false;
#endif
}

bool emctarpipe::isblk(const DIRELEM &de)
{
#ifdef S_ISBLK
    return S_ISBLK(de.unix_mode());
#else
    return false;
#endif
}

void emctarpipe::fillemcheader(struct HD_EMC &head,
                               const DIRELEM &de,
                               const ustring &fullpath,
                               int extattrsize, 
                               bool is_hardlink, 
                               const ustring &linkcontent)
{
    memset(&head, 0, sizeof(head));
    sprintf(head.mode,  "%7lo",(long)de.unix_mode());
    sprintf(head.uid32, "%08lx",(long)de.unix_uid());
    sprintf(head.gid32, "%08lx",(long)de.unix_gid());
    if (de.is_directory()) {
        
        
        
        head.typeflag=PAXNDMP_DIRTYPE;
        sprintf(head.size,"%23"LL"o",(bigint64)0L); 
    } else {
        if (is_hardlink) {
            if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader LNKTYPE for de:'%s' fullpath:'%s'"), *de.fullpath().image(), *fullpath);
            head.typeflag = PAXNDMP_LNKTYPE;
        } else if (islnk(de)) {
            if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader SYMTYPE for '%s'"), *fullpath);
            head.typeflag = PAXNDMP_SYMTYPE;
        } else if (isfifo(de)) {
            if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader found FIFO '%s' and NOT setting typeflag to FIFOTYPE"), *fullpath);
            
            head.typeflag = PAXNDMP_REGTYPE;
        } else if (ischr(de)) {
            if(msg1) DB->msg (DBTXT("emctarpipe::fillemcheader CHRTYPE_OB for '%s'"), *fullpath);
            head.typeflag = PAXNDMP_CHRTYPE_OB;
        } else if (isblk(de)) {
            if(msg1) DB->msg (DBTXT("emctarpipe::fillemcheader BLKTYPE_OB for '%s'"), *fullpath);
            head.typeflag = PAXNDMP_BLKTYPE_OB;
        } else if (!de.is_stream_slice() && de.is_device_file_mknode_only()) {
            DB->error(DBTXT("emctarpipe::fillemcheader direlem for '%s' claims is_device_file_mknode_only(), but has unrecognized mode %u"), 
                      *fullpath, de.unix_mode());
        
        
        
        } else {
            if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader REGTYPE for '%s'"), *fullpath);
            head.typeflag = PAXNDMP_REGTYPE;
        }

        if (is_hardlink) {
            if(msg1) 
                DB->msg (DBTXT("emctarpipe::fillemcheader setting head.size for hardlink to len('%s'):%s"),
                         *linkcontent, *fileoffset(linkcontent.bytelength()).image());
            sprintf(head.size, "%23"LL"o", fileoffset(linkcontent.bytelength()).value());
        } else {
            fileoffset compressedsize;
            if (checkemctardedup(de, compressedsize)) {
                sprintf(head.size, "%23"LL"o", compressedsize.value());
            } else {
                sprintf(head.size,"%23"LL"o", de.file_size().value());
            }
        }
    }

    suppress_next_fillblock = (head.typeflag != PAXNDMP_REGTYPE);
    
    

    if (dowfs && !is_hardlink) {
        dirrec_pack::regions dr(&de);
        data_regions::endoffsets_t eoff;
        fileoffset f1, f2;
        bool has_slice_ads = dr.get(eoff) && data_regions::findrange(eoff, data_regions::ads, true, f1, f2);

        dirrec_pack::emctar_altdata ead(&de);
        ubigint64 altdatasize; 
        unsigned char hashoffset;
        bool has_old_ads = ead.get(altdatasize, hashoffset);

        if(has_old_ads || has_slice_ads) {
            if (msg1)
                DB->msg(DBTXT("emctarpipe::fillemcheader found altdatasize:%"LL"u hashoffset:%d"),
                        altdatasize, hashoffset);
            head.typeflag = de.is_directory() ? PAXNDMP_MFS_DIRTYPE : PAXNDMP_MFS_REGTYPE;
        }
    }

    sprintf(head.mtime,"%011o",de.mtime());
    
    sprintf(head.chksum, "%s", "     00"); 
    sprintf(head.magic,"%s","emc");

    

    if (extattrsize && (de.get_security_size() <= 0)) {
        Out->msg(ERR, "emctarpipe::fillemcheader direlem::security is empty, but extattrsize:%d", extattrsize);
    }

    
    
    
    

    
    
    
    
    
    

    char isi18n = i18n ? '3' : '1';
    char has_security = 0;
    if (de.get_ufs64data().size() > 0) {
        has_security = (extattrsize > 0) ? '7' : '6';
    } else {
        has_security = (extattrsize > 0) ? '5' : '4';
    }
    head.version[0] = has_security;
    head.version[1] = isi18n;

    if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader i18n = %s"),(i18n) ? "true" : "false");
    if(msg1) DB->msg(DBTXT("emctarpipe::fillemcheader fullpath.tohex() = '%s'"),*fullpath.tohex());

    sprintf(head.uname,"%ld",(long)de.unix_uid());
    sprintf(head.gname,"%ld",(long)de.unix_gid());

    
    
    bool is_inode64 = false;
    dirrec_pack::emctar_inode64 eti(&de);
    if (!eti.get(is_inode64)) is_inode64 = false;
    dev_t device = static_cast<dev_t> (is_inode64 ? de.device_number() : de.unix_rdev());
    int majordev, minordev;
#ifdef major
    majordev = major(device);
#else
    majordev = (device & 0xff00) >> 8; 
    DB->warn("emctarpipe::fillemcheader need macro to extract device major number from rdev");
#endif
#ifdef minor
    minordev = minor(device);
#else
    minordev = device & 0xff; 
    DB->warn("emctarpipe::fillemcheader need macro to extract device major number from rdev");
#endif
    
    sprintf(head.devmajor, "%7o", majordev);
    
    sprintf(head.devminor, "%7o", minordev);
    sprintf(head.namesize,"%5lo",(long)fullpath.bytelength()+1);
    sprintf(head.extsize,"%11lo",(long)extattrsize);

    unsigned short chksum = 0;
    const char *p = (const char *) &head;
    for (size_t i=0; i<sizeof(head); i++) {
        chksum += p[i];
    }
    sprintf(head.chksum, "%7o", chksum);
}

bool emctarpipe::checkemctardedup(const DIRELEM& elem, fileoffset& reservesize)
{
    dirrec_pack::emctar_dedup epd(&elem);

    fileoffset streamsize, uncompressedsize, compressordatasize;
    unsigned char compressordepoffset;

    if (epd.get(streamsize, uncompressedsize, compressordatasize, compressordepoffset)) {
        DB->msg("emctarpipe::check_emctardedup %s is an expanded emctardedup compressed file streamsize:%s uncompressedsize:%s direlem.get_file_size():%s",
                *elem.fullpath().image(), *streamsize.image(), *uncompressedsize.image(), *elem.file_size().image());
        reservesize = streamsize; 
        return true;
    }
    return false;
}

bool emctarpipe::check_streamslices(fileoffset &filesize, fileoffset &altdatasize, fileoffset &stubdatasize,
                                    const DIRELEM &elem) const
{
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    dirrec_pack::regions drp(&elem);
    endoffsets_t endoffsets;
    if (!drp.get(endoffsets))
        return false;

    if (endoffsets.size() == 0) {
        Out->msg(ERR, "Found direlem '%s' with KIND_REGIONS dirrec with empty endoffsets vector", 
                 *elem.fullpath().image());
        return false;
    }

    fileoffset stubstart, stubend, adsstart, adsend, primarystart, primaryend;
    bool foundstubsection = offattrsrange(endoffsets, stubstart, stubend);
    bool foundads = findrange(endoffsets, ads, true, adsstart, adsend);
    bool foundprimary = findrange(endoffsets, primarydata, true, primarystart, primaryend);

    if (!enableslicerestore || rewrite_i18n) {
        if (foundstubsection) {
            
            
            stubdatasize = (stubend - stubstart);
        }
        if (foundads) {
            
            altdatasize = adsend - adsstart;
        }
        if (foundprimary) {
            filesize = primaryend - primarystart;
        }
        return false;
    }

    fileoffset lastoffset((endoffsets.back()).second);
    
    
    
    if (elem.is_directory()) {
        dirrec_pack::streamslice ssp(&elem);
        ubigint64 datasize;
        unsigned char dephashoffset;
        if (!ssp.get(datasize, dephashoffset)) {
            Out->msg(ERR, "emctarpipe::check_streamslices found dir '%s' with KIND_REGIONS %s, but no streamslice dirrec",
                     *elem.fullpath().image(), *image_endoffsets(endoffsets));
            return false;
        }

        if (msg1)
            DB->msg("emctarpipe::check_streamslices found dir '%s' with streamslice of %"LL"u bytes in dephash[%d]",
                    *elem.fullpath().image(), datasize, dephashoffset);
        if (lastoffset != datasize) {
            Out->msg(ERR, "Found direlem '%s' with dirrecs dataregions:%s and streamslice datasize:%"LL"u which should match but do not.",
                     *elem.fullpath().image(), *image_endoffsets(endoffsets), datasize);
        }
        altdatasize = 0;
        stubdatasize = datasize;
        return true;
    }

    
    if (msg1)
        DB->msg("emctarpipe::check_streamslices found '%s' direlem.file_size():%s with KIND_REGIONS dirrec %s, so turning fillheader into noop, reserving %s bytes",
                *elem.fullpath().image(), *elem.file_size().image(),
                *image_endoffsets(endoffsets), *lastoffset.image());
    filesize = lastoffset;
    altdatasize = 0;
    stubdatasize = 0;
    return true;
}


bool emctarpipe::fillheader(fileref& header, fileoffset& filesize, fileoffset& altdatasize, fileoffset& stubdatasize,
                         const DIRELEM& elem,
                         const ustring& _path,
                         const filetype ftype,
                         const ustring& linkname,
                         const fileoffset startoff
) {
    if (check_streamslices(filesize, altdatasize, stubdatasize, elem)) 
        return true;
    if (msg1) DB->msg("emctarpipe::fillheader check_streamslices returned false, with filesize:%s altdatasize:%s stubdatasize:%s",
                      *filesize.image(), *altdatasize.image(), *stubdatasize.image());

    ustring path(_path);
    
    
    
    if (!ndmp_prefix.isempty())
    {
        upath slice_path(path);
        
        if (slice_path.get(0) == ndmp_prefix && (slice_path.numelems() > 0))
        {
            path = ustring("/") / slice_path.slice(1, slice_path.numelems() - 1).image();
        }
    }

    ustring realpath(pathprefix/path);  
    if (msg1) DB->msg("emctarpipe::fillheader after processing ndmp_prefix:'%s', pathprefix:'%s' + path:'%s' (orig path:'%s') -> realpath:'%s' isdir:%d",
                      *ndmp_prefix, *pathprefix, *path, *_path, *realpath, elem.is_directory());

    dirrec_pack::emctar_stubdata esd(&elem);
    ubigint64 stubdatasizex;
    unsigned char stubhashoffset;
    if (esd.get(stubdatasizex, stubhashoffset)) {
        hashvect hashes;
        elem.getdephashes(hashes);
        if (hashes.size() > stubhashoffset) {
            if (msg1) {
                DB->msg(DBTXT("emctarpipe::fillheader '%s' found stubhashoffset %d, stubdata hash %s"), 
                        *realpath, stubhashoffset, *(hashes[stubhashoffset+1].image()));
                for (size_t i=0; i<hashes.size(); i++) {
                    DB->msg(DBTXT("emctarpipe::fillheader dephash %"Z"u: %s"), i, *(hashes[i].image()));
                }
            }
            stubdatasize = stubdatasizex;
        } else {
            Out->msg(ERR, "<7407>emctarpipe::fillheader cannot find enough dephashes for the stub file data");
            stubdatasize = 0;
        }
    }

    struct HD_EMC emcheader;
    fileref ea;
    elem.get_security(ea);
    bool is_hardlink = (ftype == pipe_control::LNKTYPE);
    fillemcheader(emcheader, elem, realpath, ea.size(), is_hardlink, linkname); 

    
    
    
    
    if (filesize == 0) {
        if (!checkemctardedup(elem, filesize))
            filesize = elem.file_size();
        
        if(ftype != REGTYPE) { 
            filesize = fileoffset(0);
        }
    }

    

    if (msg1) DB->msg("emctarpipe::fillheader %s ea.size():%d filesize:%s",
                      *realpath, ea.size(), *filesize.image());

    
    
    

    
    
    int totalsize = BLOCKSIZE + realpath.bytelength() + ea.size() + 1 ;
    int ufs64datasize = elem.get_ufs64data().size();
    totalsize += ufs64datasize;
    header.initlist(totalsize);
    header.clrslice(0, totalsize);
    

    header.setslice(0,                             sizeof(emcheader), (const void *) &emcheader);
    header.setslice(BLOCKSIZE,                     realpath.bytelength(), *realpath);
    header.setslice(BLOCKSIZE+realpath.bytelength(),   1,                 "\0");
    header.setslice(BLOCKSIZE+realpath.bytelength()+1, ea.size(),         ea.start());
    if (ufs64datasize > 0) {
        header.setslice(totalsize - ufs64datasize, ufs64datasize, elem.get_ufs64data().start());
    }

    if (is_hardlink) {
        
        
        
        
        altdatasize = 0;
    } else {
        
        dirrec_pack::emctar_altdata ead(&elem);
        unsigned char hashoffset;
        ubigint64 altdatasizex;
        
        if(ead.get(altdatasizex, hashoffset)) {
            if (dowfs) {
                altdatasize=altdatasizex;
            } else {
                
                
            }
        }
    }

    
    

    return true;
}


#if !defined(BACKDUMP_H_INCLUDED)
#define BACKDUMP_H_INCLUDED












#include "dumpdirelem.h"
#include "fileref.h"
#include "scalar.h"
#include "dump_layout.h"
#include "dumpinodemap.h"
#include "cycle.h"
#include "fileoffset.h"
#include "nbackdir.h"

class context;
class cycle;
class workelem;             
class utar_flags_info;
class DIRELEM_netapp;

class backdump : public BackCycle   
{

public:
  SAFEALLOC(backdump);

  backdump(BackCycle* parent, workelem *info, fileoffset offset, fileref f, utar_flags_info& flags);
  virtual ~backdump();

  virtual void init();
  virtual void response(message& outargs);
  virtual void childdone(cycle *child);
  virtual void notifyparent();
  bool getroot(DIRELEM& direlem);

  static bool read_header(dump_header& header);    
  static int  read_stuff(void *buff, int size);    
  static int  count_sparse(dump_header& header);   

  
  
  void add_directory(DIRELEM& owner, fileref& data);

  
  static bool traverse(direlem_assoc_type& inodeinfo, int inodenum, ustring indent, ustring path);

  static int check_for_orphaned_inodes(direlem_assoc_type& inodeinfo);

private:

  fileref f;
  utar_flags_info& flags;

  direlem_assoc_type inodeinfo;  

  
  dumpinodemap clri_map;

  
  dumpinodemap bits_map;

  
  dumpinodemap acl_map;

  
  tassoc<intobj, int> acltab;

  bool restore_prev_dump();

  
  bool parse_inode(const dump_header& header, int read_size,
                   bool continuation, bool &doubleslashmode);

  
  bool parse_direntries(int read_size, int parent_inodenum, dumpDIRELEM *elemp);

  
  bool check_magic(swapint magic);

  bool readstream();  
  bool snapup_directory_tree(); 
  void set_phase(int phasenum);

  backdump();

  int phase;
  s_spcl header;

  
  bool indoubleslash_mode;
  int LARA_count;
  DIRELEM_netapp * de_LARA; 
};


#endif

#if !defined(CLIENTAPP_H_INCLUDED)
#define CLIENTAPP_H_INCLUDED












#include "common.h"
#include "uapp.h"

class clientapp : public uapp {
public:
    SAFEALLOC(clientapp);

    
    clientapp(const char* appname, const int appversion, int argc = 0, char **argv = 0);

    
    ~clientapp();

protected:

private:
    NOCOPY(clientapp);
};

#endif



#if !defined(backzfstardir_H_INCLUDED)
#define backzfstardir_H_INCLUDED












#include "zfstar_history.h"
#include "backndmptardir_base.h"


class backzfstardir : public backndmptardir_base
{
public:
  SAFEALLOC(backzfstardir);

  
  
  
  
  backzfstardir(BackCycle* parent_,
                   workelem* info_,
                   parsestream_base* parser,
                   int traverse_depth,
                   inode_table& inodetab_,
                   int mount_point_numelems = 0,
                   zfstar_history* hist = 0,
                   MetadataIntf_sp parent_metadataIntfp_ = MetadataIntf_sp());

  virtual ~backzfstardir();

  virtual void init();
  virtual void response(message& outargs);  
  virtual void childdone(cycle* child);

  virtual void responseReceived(DataHasher* dataHasher) { childdone(dataHasher); }

private:
  backzfstardir(); 

  
  bool get_next_header(DIRELEMp& obj_direlem, fileref& altdata, fileref& stubdata);
  void process_direlem(DIRELEMp obj_direlem, fileref altdata, fileref stubdata);
  void process_dir_data(DIRELEMp obj_direlem);

  
  
  
  void remember_hardlinked_info(DIRELEMp& de);

  void request_prevlist();     
  void request_history();      
  bool merge_lists();          

  void get_end_offsets(DIRELEMp& de);

  void finish_top_level_directory(cycle *child);
  void commit_directory_metadata();

  histvector_t* histlist;           

  zfstar_history* histsrv;         

  ubigint64 hdroffset;
  ubigint64 dataoffset;
  ubigint64 padoffset;
  ubigint64 extattroffset;
};

#endif
#if !defined(LOCATION_CHECKER_H_INCLUDED)
#define LOCATION_CHECKER_H_INCLUDED












#include "location.h"
class containerinfo;
class offinfo;




class location_checker {
public:
    location_checker() : num_gsan_entries(0) {}

    ~location_checker();

    
    
    
    
    
    
    
    bool validate_entry(const DIRELEM& de, const ustring& precheck = "");

    bool validate_entry(const location::entry_kind    ekind,
                        const location::media::type   media,
                        const location::tformat::type format,
                        const location::tbackupid     backupid,
                        const location::tcontainerid  containerid,
                        const fileoffset    coverage_size,
                        const fileoffset    header_size,
                        const fileoffset    footer_size,
                        const fileoffset    abs_offset,
                        const tchecksum     checksum,
                        const ustring& precheck = "");        

    
    void summary();

    void found_gsan_entry() { num_gsan_entries++; }

private:
    void enter_atom(const int container_id, offinfo *n);
    void enter_dir(const int container_id, offinfo *n);
    bool check_container_exists(const int container_id);

    int num_gsan_entries;
    DEFINE_STL_VECTOR_TYPE(containerinfo*) containers;
};

#endif
#if !defined(LIST_ARCHIVE_H_INCLUDED)
#define LIST_ARCHIVE_H_INCLUDED















#include "common.h"
#include "direlem.h"
#include "upath.h"
#include "ucontainer_base.h"
#include "exitcodes.h"

class MetadataIntf;
class utar_commands;
class dumpformat_directory;
class location;
class BackupRootInfo;
class xml_messagep;
class fileoffset;
class hashcode;
class ddrfiles_xmlp;
namespace dumpstream { class typemap; }
namespace undoo {
    template<typename T>
    class shared_ptr;
}

class list_archive {
public:
    class outputsink;
    class xmloutputsink;
    class stdoutputsink;
    class cacherebuildsink;

    SAFEALLOC(list_archive);

    
    list_archive(utar_commands& uc);
    exitcodes_t do_list_archive();

    
    bool checkBrowseOverrideForPath(const BackupRootInfo& backupInfo, const upath& frompath, ustring& listing) const;

    void init_container(const hashcode tophash, const hashcode volhash, DIRELEM& de);
    bool read_file_from_ucontainer(const DIRELEM &de, fileref &data);

private:

    bool load_ddrfiles_from_ddr(const BackupRootInfo& one_backup, ddrfiles_xmlp& ddrfiles) const;

    
    
    
    template<typename Iter>
    exitcodes_t list_within_backups(Iter cur, Iter end, int nbackups);

    bool list_path_within_backup(const BackupRootInfo& backupInfo, const upath& frompath);

    static bool ls_archive(DIRELEM::iterator iter, const undoo::shared_ptr<outputsink>& outsink);

    void get_ndmp_startpoint_and_path(DIRELEM& startpoint, upath& listpath);

    exitcodes_t do_dpnobj_listing(const BackupRootInfo& backup);

    
    void dpnobj_ls(dpnobj& obj, const ustring& fullpath, bool recurse = false, bool deltastyle = false, int indent = 0);

    
    
    bool get_inode2_de(const DIRELEM& volume_de, DIRELEM& inode2_de);

    
    bool ls_dumpformat(const hashcode& tophash, const hashcode& roothash, DIRELEM& de,
                       const upath& frompath, const upath& origpath);

    
    bool search_for_inode(const hashcode& hash, DIRELEM& de, const ustring& name, int& inode);

    
    bool traverse_chunks(const int dirinode, const hashcode& hash, DIRELEM& de,
                         dumpformat_directory& dir, bool& keepgoing);

    
    
    bool get_type_map(const BackupRootInfo& backupInfo, dumpstream::typemap& tmap);

    utar_commands& uc;
    pidtype pid;        
    int delta_error_count;	

    
    ucontainer::basep m_container;

    
    upath m_vol_path;

    
    DIRELEM m_root_de;

    
    upath directory2inodepath;
};

#endif




















#include "common.h"
#include "debug.h"
#include "backaxionfsdir.h"

#include "fileref.h"
#include "context.h"
#include "workelem.h"
#include "output.h"
#include "nbackdata.h"
#include "connerror.h"  

#include <algorithm>

#define debug_axionfs ((xflag[2]&(1<<22))!=0)
#define backaxionfsdir_dironly_msg ((xflag[2]&4096)!=0)
#define breadth_first ((xflag[10]&2048)!=0)


backaxionfsdir::backaxionfsdir(BackCycle *parent, context *main, workelem *info_, axionfsDIRELEM* direlemp_,
                               
                               fileoffset offset_,
                               int traverse_depth_
                               ) :
    BackCycle(parent, info_),
    direlemp(direlemp_),
    
    traverse_depth(traverse_depth_)
{
    if (debug_axionfs) DB->msg("backaxionfsdir::backaxionfsdir (parent:%p) (this:%p)", parent, this);
    cycle::offset = offset_;
    if (!info)
        DB->bt_error("backaxionfsdir::backaxionfsdir ---------------------> INFO is NULL <------------------------");
    for (int i=0; i<traverse_depth; i++) spaces += "   ";
    assert(direlemp != NULL);
    if (debug_axionfs) DB->msg(DBTXT("%sbackaxionfsdir::backaxionfsdir initializer traverse_depth:%d name:%s"), *spaces, traverse_depth, *direlemp->fullpath());

    listing.initlist(20 * DIRELEM_DOLAYOUT_AVERAGE_SIZE);

    
    
    
    
    if (breadth_first)
        todoEnqueue(TODO_DIR, this);
    else
        todoEnqueueInsert(TODO_DIR, this, -traverse_depth);

    if (debug_axionfs) DB->msg("%sbackaxionfsdir::backaxionfsdir done initializer", *spaces);
}

static bool namecmp(const ustring& lhs, const ustring& rhs) {
    
#if SYSTEM_UNIX
    return strcmp(*lhs, *rhs) < 0;
#else
    return strcasecmp(*lhs, *rhs) < 0;
#endif
}

void backaxionfsdir::init()
{
    if (direlemp == NULL) {
        Out->msg(ERR, "<6630>null direlemp in backaxionfsdir is bad???");
        return;
    }

    int last_listing_size = 0;
    main->set_cur_filename(info->path, true);

    if( debug_axionfs || backaxionfsdir_dironly_msg )
        DB->msg( "%sbackaxionfsdir::init %p info->path:%s name:%s", *spaces, this, *info->path.image(), *direlemp->name() );
    Out->msg(output::SEV_VERBOSE, 4, "%s", *(info->path/ upath(DIRSEPSTR)).image());

    cyisdirectory = true;

    
    undoo::vector<ustring> names;
    direlemp->keys(names);
    std::sort(names.begin(), names.end(), namecmp);
    for (unsigned int i=0; i<names.size(); i++) {
        const ustring elemname(names[i]);
        if (debug_axionfs) DB->msg (DBTXT("backaxionfsdir::init processing name %d of %d '%s'"), i, (int)names.size(), *elemname);
        if (elemname.is_dot_or_dot_dot()) continue;

        axionfsDIRELEM *elemp = direlemp->lookup(elemname);

        if (elemp == NULL) {
            if (debug_axionfs) DB->msg("%sbackaxionfsdir::init NULL   %s", *spaces, *elemname);
            continue;
        }

        
        
        

        const ustring fullname = elemp->fullpath();
        elemp->set_name(elemname);

        if(!uapp::staging().canRun()) throw EXC_CANCEL;

        if( debug_axionfs ) DB->msg("%sfilename = %s\n", *spaces, *fullname);

    

        fileoffset patchoffset(listing.size());

        last_listing_size = listing.size();

        
        
        const int max_dir_size = main->getmaxdirelemsize(dpn0);   
        if(!elemp->dolayout(listing, true, main->isnewdir(), true, max_dir_size )) {  
            DB->msg(DBTXT("WARNING: backaxionfsdir::init() elemp chunk larger than %d, security attributes discarded from %s."),
                          max_dir_size, *fullname);
        }

        if( elemp->is_directory() ) {
            DIRELEMp elempp(new DIRELEM(*elemp));
            workelem *w = new workelem(info, (upath)fullname, elempp);
            cycle *child;

            if (debug_axionfs) DB->msg(DBTXT("%sbackaxionfsdir::init calling backaxionfsdir %s"), *spaces, *elemp->fullpath());
            child = new backaxionfsdir(this, main,                
                                       w,                   
                                       elemp,               
                                       patchoffset,         
                                       traverse_depth + 1); 
            nforked++;
        } else {
            
            sizeofchildren += elemp->file_size();
        }
    }
    if (debug_axionfs) DB->msg("%sbackaxionfsdir::init listing.size():%d", *spaces, listing.size());
    childdone(NULL);  
}

void backaxionfsdir::response(message& outargs ) {
    if (debug_axionfs) DB->msg( "%sbackaxionfsdir::response", *spaces );
    assert(false);
}

void backaxionfsdir::childdone(cycle *child) {
    if( debug_axionfs ) DB->msg( "%sbackaxionfsdir::childdone %s ncollected=%d nforked=%d collectdone=%d", *spaces, *direlemp->fullpath(), ncollected, nforked, collectdone );
    if(! collectdone) {
        if(child == NULL) {  
            if( debug_axionfs ) DB->msg( DBTXT("%sbackaxionfsdir::childdone child NULL"), *spaces);
            forksdone = true;
        } else {
            if( debug_axionfs ) DB->msg( DBTXT("%sbackaxionfsdir::childdone child non-null"), *spaces);
            if( child->hash == hashcode::zero )
                DIRELEM::patch_internal( listing, child->offset );

            if( main->isatombit() && child->cyisatomic )
                DIRELEM::patch_is_atomic( listing, child->offset );

            if( debug_axionfs ) DB->msg("%sbackaxionfsdir::childdone setslice hash:%s offset:%s", *spaces, *child->hash.partialimage(), *child->offset.image());
            listing.setslice64(child->offset, sizeof(hashcode), &child->hash);

            
            fileoffset changesize = DIRELEM::patch_size( child->size, listing, child->offset, main->isnewdir() );
            if (!child->cyisdirectory && changesize > fileoffset(0)) 
                main->addfilebytes(context::backupstats, changesize.dvalue());
            ncollected++;
            sizeofchildren += child->size;  
            
        }

        if(forksdone && nforked == ncollected) {
            collectdone = true;
            if( debug_axionfs ) DB->msg( "%sbackaxionfsdir::childdone %s collectdone:%d size:%d", *spaces, *direlemp->fullpath(), collectdone, listing.size());

            workelem *w = new workelem( NULL, listing );
            datachild   = new nbackdata(this, w, fileoffset(0), true  );
            
        }
    } else {
        if( debug_axionfs ) DB->msg( DBTXT("%sbackaxionfsdir::childdone calling notifyparent this=%p"), *spaces, this );
        size = sizeofchildren;  
        notifyparent();
    }
}

void backaxionfsdir::notifyparent() {
    if( debug_axionfs ) DB->msg("%sbackaxionfsdir::notifyparent %p %s   (parent:%p)",
                                     *spaces, this, *info->path.image(), parent);
    cycle::notifyparent();
}

backaxionfsdir::~backaxionfsdir() {
    if( debug_axionfs ) DB->msg(DBTXT("%sbackaxionfsdir::~backaxionfsdir skip:%d dot:%d name:%s"), *spaces,
                                 info->direlemp->should_skip_this_file(), info->direlemp->is_dot_or_dot_dot(), *info->direlemp->name());
    
    if( debug_axionfs || backaxionfsdir_dironly_msg)
        DB->msg( "%sbackaxionfsdir::~backaxionfsdir (parent:%p) (this:%p) ""%s""",
                 *spaces, parent, this, *info->path.image() );
    
    if(! info->isapi) {
        
        
        
        

        delete info;
    }
    
}





















#include "common.h"
#include "debug.h"
#include "backrand.h"
#include "todoelem.h"
#include "context.h"
#include "utar_flags_info.h"
#include "output.h"
#include "backatom.h"
#include "restdata.h"
#include "runstage.h"

backrand::backrand(BackCycle *parent) 
  : BackCycle(parent, ((workelem*)NULL) )
{
    forksdone = false;
    nforked = 0;
    ncollected = 0;
    todoEnqueue(TODO_FILE, this);
}

void backrand::init() {
    fileref data;
    hashcode hash;
    if(DB->randchunk(data, hash, flags.randchunk, flags.minchunksize, (int)(flags.threshold * 0.9), flags.samechunk) &&
       uapp::staging().canRun()) {
        if(flags.validate) {
            
            
            restelem info;
            bool isatomic = true;  
            cycle *child = new restdata( this, hash, NULL, isatomic, info, fileoffset( 0 ), fileoffset( 0 ), NULL, 0, data );
            child->noop();
        } else {
            cycle *child = new backatom( this, hash, data, !flags.level0 );
            child->noop();
        }
        nforked++;
        todoEnqueue(TODO_FILE, this);
    } else
        childdone(NULL);  
}

void backrand::childdone(cycle *child) {
    if(child == NULL) {  
        forksdone = true;
    } else {
        ncollected++;
    }
    if(forksdone && nforked == ncollected) {
        notifyparent();
    }
}

backrand::~backrand() {
    
}

#if !defined(BACKATOM_H_INCLUDED)
#define BACKATOM_H_INCLUDED











               
#include "cycle.h"
#include "fileref.h"


class backatom : public BackCycle {
public:
    backatom(BackCycle *parent, hashcode hash, const fileref& data, bool dolookup);
    virtual void init();
    virtual void response(message& outargs);
    virtual ~backatom();
    SAFEALLOC(backatom);
private:
    bool dolookup;
    bool inlookup;
    fileref data;
    char kind;
};

#endif











#include "common.h"
#include "debug.h"
#include "filenames.h"
#include "client_commands.h"

#include "acntmngr.h"
#include "assoc.h"
#include "authuser.h"
#include "blkconst.h"
#include "blkname.h"
#include "msgxauth.h"
#include "msgxrange.h"
#include "namelist.h"
#include "roothashlist.h"
#include "output.h"
#include "utar_commands.h"
#include "runstage.h"
#include "context.h"
#include "timer.h"
#include "agenttest.h"
#include "utar_flags_info.h"
#include "synccall.h"
#include "uwrapper.h"
#include "filerefx.h"
#include "ade_mgrx.h"
#include "dataextents.h"
#include "restmain.h"




bool client_commands::getRootHash(synccall &sync, hashcode &rh, const blktraj &traj, const authid &id, bool include_partials)
{
    rh = hashcode::zero;
    roothashlist rhl;
    int maxRec = 1;
    bool rslt = getRootHashList(sync, rhl, traj, id, maxRec, 0, (ubigint64)-1, include_partials);
    if (rslt!=MSG_ERR_NONE)
        return false;
    rhl.sort(LIST_SORT_HIGH_TO_LOW);
    roothashlistrec rec;
    rhl.get(rec, 0);        
    rh = rec.getRoot();
    return true;
}


bool client_commands::getRootHashList(
    synccall &sync,          
    roothashlist &rhl,
    const blktraj &bn,       
    const authid &au,
    int maxRec,              
    ubigint64 startTime,     
    ubigint64 endTime,       
    bool include_partials    
) {
    acntmngr acnt(&sync);
    msgerrors rslt = acnt.getBackups(rhl, bn, au, maxRec, startTime, endTime, include_partials);
    if (rslt!=MSG_ERR_NONE)
    {
        message m;
        m.setresponsecode(rslt);
        DB->msg(DBTXT("<5090>Unable to obtain a list of archives  (errcode: %d  %s)"), rslt, m.found_image().tostr());       
        return false;
    }
    return true;
}

bool client_commands::getnamelist(synccall &sync, namelist &names, const blktraj &bn, const authid &au) {
    acntmngr acnt(&sync);

    
    int  MaxRec = 0;
    MSGX_RANGE_T   range(blkname::undefined, blkname::undefined, MaxRec);

    msgerrors rslt = acnt.getDir(names, bn, au, range);
    if (rslt!=MSG_ERR_NONE)
    {
        message m;
        m.setresponsecode(rslt);
        Out->msg(ERR, "<5090>Unable to obtain a list of archives  (errcode: %d  %s)", rslt, m.found_image().tostr());
        return false;
    }

    Out->msg(INFO, "<5385>got names - trying to print");
    names.print(stdout, LIST_FORM_XML);

    return true;
}




#if RAWCLIENT




exitcodes_t client_commands::do_pipe(hfs_info_struct& hfs_info, utar_flags_info& flags, context* mycontext)
{
    
    const ustring firstarg = (flags.args.size() > 1 ? flags.args[1] : "");

    DB->msg("client_commands::do_pipe arg '%s'", *firstarg);
    DB->msg("client_commands::do_pipe flags.args '%s'", *flags.args.image());

    hashcode hash;

    if (firstarg.bytelength() == 0) {      
        if (!getRootHash( *hfs_info.sync, hash, hfs_info.blk, hfs_info.auth, flags.incpartials )) {
            Out->msg(ERR, "<5290>client pipe Failed to locate backup.");
            return EXIT_NO_ARCHIVES;
        }
        DB->msg("root hash = %s", *hash.partialimage() );

    } else  {
        DB->msg("client::do_pipe %s\n", *firstarg);
        hashcode   arghash(firstarg);
        hash = arghash;
        if (!mycontext->get_hash_ispresent(hash)) {
          Out->msg(ERR, "<5085>Hash not found %s", *hash.image());
          return EXIT_MISC;
        }
    }

    bool    raw      = flags.raw;
    int     sizehint = flags.size;
    fileref res;
    bool success;
    if (raw) {
        chunktype ctype;
        success = mycontext->restore_chunk(res, hash, ctype);
        uwrapper::uprintf("%c", ctype.ckind());
        if (! success)
          DB->error("pipe failed");
        else
          res.print(stdout);

    } else {
        
        filerefx::initpipe(res, stdout);
        success = mycontext->restore_gsanonly_file(res, hash, NULL, fileoffset(sizehint));
    }

    if (!success) return EXIT_RESTORE_FAIL;
    return EXIT_OK;
}




exitcodes_t client_commands::do_user(hfs_info_struct& hfs_info, utar_flags_info& flags)
{
    
    ubigint64 starttime = flags.start;
    ubigint64 endtime   = flags.end;
    roothashlist rhl;
    int maxRec = 0;
    if (!getRootHashList( *hfs_info.sync, rhl, hfs_info.blk, hfs_info.auth, maxRec, starttime, endtime, flags.incpartials )) {
      
      namelist names;
      getnamelist(*hfs_info.sync, names, hfs_info.blk, hfs_info.auth);
      DB->msg(DBTXT("<5072>Client user Failed to locate backup."));  
      return EXIT_NO_ARCHIVES;
    }

    
    FILE   *output = stdout;
    ustring  target = flags.target;
    if (target.bytelength() != 0) {
      output = uwrapper::ufopen( target, "w" );
      if (output == NULL) {
        DB->error(DBTXT("error creating file %s"), *target);
        return EXIT_MISC;
      }
    }


    rhl.print( output, LIST_FORM_XML );

    
    
    return EXIT_OK;
}





#include "cycle_test.h"

exitcodes_t  client_commands::do_cycletest(hfs_info_struct& hfs_info, utar_flags_info& flags, context* mycontext)
{
    timer cycletimes(NULL, true);

    Out->msg(INFO, "Running cycle tests:");
    if (flags.rc_cycle_tests.isempty()) {
        Out->msg(INFO, "No --rc-cycle-tests specified (use comma separated list.) Available tests:");
        Out->msg(INFO, "    0: restdata1             restores data from --rc-hash");
        Out->msg(INFO, "    1: restdataproducer1     restores data from --rc-hash");
        Out->msg(INFO, "    2: restdirlistproducer (in-order)  restores data from --rc-hash(works with dir-atomics and dir-composites) or --rc-metadataid");
        Out->msg(INFO, "    3: restdirlistproducer (not-necessarily in-order)  restores data from --rc-hash (works with dir-atomics and dir-composites)");
        Out->msg(INFO, "    4: restdirlist1          restores data from --rc-hash and arg[0]");
        Out->msg(INFO, "    5: persistentlock1       uses argv[0] and argv[1] as mappath and lockid");
        Out->msg(INFO, "    6: restdirelem           restores the direlem from --rc-hash + argv[1]");
        return EXIT_OK;
    }
    Out->msg(INFO, "    %s", *flags.rc_cycle_tests.image());

    bool had_failures = false;

    cycle_test *test(NULL);

    for (int i=0; i<flags.rc_cycle_tests.size(); i++) {
        int testnum = flags.rc_cycle_tests[i].toint();
        Out->msg(INFO, "TEST %s", *flags.rc_cycle_tests[i]);

        switch (testnum) {
        case 0:
            test = new restdata1(flags, mycontext, &cycletimes);
            break;
        case 1:
            test = new restdataproducer1(flags, mycontext, &cycletimes);
            break;
        case 2:
            test = new restdirlistproducer1(flags, mycontext, &cycletimes);
            break;
        case 3:
            test = new restdirlistproducer2(flags, mycontext, &cycletimes);
            break;
        case 4:
            test = new restdirlist1(flags, mycontext, &cycletimes);
            break;
        case 5:
            test = new persistentlock1(flags, mycontext, &cycletimes);
            break;
        case 6:
            test = new restdirelem1(flags, mycontext, &cycletimes);
            break;
        default:
            Out->msg(ERR, "Invalid cycle test '%s'", *flags.rc_cycle_tests[i]);
            continue;
        }

        if (!test) {
            Out->msg(ERR, "Unable to create test %d", i);
            continue;
        }

        cycle *c = test->spawn();
        if (c) {
            timer::timerscope ts(&cycletimes, NAMEOF(*test));

            const bool ok = !mycontext->loop();
            Out->msg(INFO, "do_cycletest, context::loop returned %d", ok);

            const bool test_ok = test->check_result(c);
            Out->msg(INFO, "do_cycletest,      test check_result %d", test_ok);

            if (!ok || !test_ok) had_failures = true;
        } else {
            Out->msg(ERR, "test spawn() returned NULL cycle pointer");
            had_failures = true;
        }

        delete test;
    }
    Out->msg(INFO, "TIMER REPORT:\n%s", *cycletimes.report("", true));

    return (had_failures ? EXIT_MISC : EXIT_OK);
}
#endif 

static int wastecnt = 1000000;

#define NUMGATEDCOUNTERS 100
typedef int gatedcounter_t[NUMGATEDCOUNTERS];

static bool examcounters(gatedcounter_t &counter) {
    int n=counter[0];
    int min=n;
    int max=n;

    int i;
    for(i=1; i<NUMGATEDCOUNTERS; i++) {
        if(counter[i]<min) min=counter[i];
        if(counter[i]>max) max=counter[i];
    }

    Out->msg(INFO, "<8018>Gatedptr counter values: min=%d, max=%d", min, max);
    return max > 0 && min > 0 && (max-min)<=1;
}

class timetest_worker2 : public threadbase {
public:
    semaphore &own;
    semaphore &next;
    int cnt;
    bool spinloop;

    timetest_worker2(semaphore &own_, semaphore &next_, int cnt_, bool spinloop_) : own(own_), next(next_), cnt(cnt_), spinloop(spinloop_) { }

    void body() {
        sum_timer tm;

        if(!spinloop) {                 
            while(cnt-- > 0) {
               own.wait();
               next.signal();
            }
         } else {                       
            own.wait();
            while(cnt-- > 0) {
               
               for(int i=0; i<wastecnt; i++) ;
            }

        }

        
        tm.request_update();
        tm.check_cputime_update(*getdesc());
        DB->msg("CPU time=%1.5f, total=%1.5f\n", tm.cputime(), tm.total_cputime());
    }
};

class timetest_worker3 : public threadbase {
public:
    semaphore &own;
    gatedcounter_t &counter;
    int cnt;

    timetest_worker3(semaphore &own_, gatedcounter_t &counter_, int cnt_) : own(own_), counter(counter_), cnt(cnt_) { }

    void body() {
        sum_timer tm;

        own.wait();

        static safeint cnti;    
        static char *ptr;       
        char *oldval;

        
        
        
        
        
        
        while(cnt-- > 0) {
            char *newval = (char*)((ptrint)(++cnti));   
            oldval = gatedptr(ptr, newval);             
         
         
            {
                
                
                static mtex mut;
                scope s(mut);
                counter[((int)((ptrint)oldval))%NUMGATEDCOUNTERS]++;
            }
        }

        
        tm.request_update();
        tm.check_cputime_update(*getdesc());
        DB->msg("CPU time=%1.5f, total=%1.5f\n", tm.cputime(), tm.total_cputime());
    }
};

extern "C" {
    ubigint64 checksum64(char *cp, int size);           
}


void client_commands::timetest(utar_flags_info& flags) {
    fileref m;
    int memsize = 12000;        
    int loopcnt = 200000;
    int tests = xflag[12];

    if(tests==0) tests = -1;
    if(flags.size) memsize = flags.size;
    if(flags.count) loopcnt = flags.count;

    
    
    

    m.initmem( memsize );
    for(int j=0; j<memsize; j++) m.start()[j]=j;
    fileref n(m);

    if(tests&1) {
        hashcode hash;
        hashcode hash2;
        m.binhash(hash);
        Out->msg(STD, "1) SHA-1:");
        Out->msg(STD, LOCTXT("   --count=%d, --size=%d (hash=%s)"), loopcnt, memsize, *hash.image());

        double totalsize = 0;
        double oldtime = timer::now();
        if(flags.force_nfs) {
            
            fileref *a = new fileref[loopcnt];
            for( int i=0; i<loopcnt;i++ ) {
                fileref n;
                n.initmem(m);
                n.binhash(hash2);
                a[i] = n;           
                if((i%5000) == 0) Out->msg(STD, LOCTXT("loop %d: %p, %.0f MB"), i, n.start(), totalsize/(1024*1024));
                if(hash2 != hash) { Out->msg(ERR, "<6639>FAIL! loop %d: hash=%s, addr=%p", i, *hash2.image(), n.start()); }
                totalsize += memsize;
            }
            delete [] a;
        } else {
            for( int i=0; i<loopcnt;i++ ) {
                m.binhash(hash2);
                totalsize += memsize;
            }
        }
        double newtime = timer::now();

        double elapsedtime = newtime - oldtime;
        double bytes_per_second = totalsize;
        bytes_per_second = bytes_per_second/elapsedtime;
        Out->msg(STD, LOCTXT("   SHA-1 hash         %20s bytes            %7.3f seconds, %8.2f MB/sec\n"),
                 *commas(totalsize), elapsedtime, bytes_per_second/(1024*1024) );
    }

    if(tests&2) {
        
        
        
        
        

        
        
        unsigned int spoiler = 0;
        for(unsigned int j=0; j<(unsigned int)memsize; j++) {
            m.start()[j]=(j%255)^spoiler;
            if (flags.start && (j%flags.start)==0) {
                spoiler=0x73^spoiler;
                spoiler++;
            }
        }

        if(flags.compress==0) flags.compress=fileref::compmode_lzo;

        Out->msg(STD, LOCTXT("2) Compress:"));
        Out->msg(STD, LOCTXT("   --compress=%d, --count=%d, --size=%d, --start=%d, --cpercent=%d, --clevel=%d"), flags.compress, loopcnt, memsize, flags.start, flags.cpercent, flags.clevel);
        Out->msg(STD, LOCTXT("   Use --start=127 or --start=254 to \"spoil\" compression."));
        Out->msg(STD, LOCTXT("   For LZO --size=3000  --count=70000 --start=254 gets 45.87%% savings and runs pretty slow (66MB/sec)"));
        Out->msg(STD, LOCTXT("   For LZO --size=15000 --count=70000 --start=0   gets 97.73%% savings and runs pretty fast (300MB/sec)"));

        bool met_maxpercent;
        if(n.compress(flags.cpercent, fileref::compressionlevels(flags.clevel), fileref::compmodes(flags.compress), fileref::encmode_none, met_maxpercent))
            Out->msg(STD, LOCTXT("   Compressed to %d bytes, %5.2f%% savings (met threshold=%d)"),
                     n.size(), (1-((double)n.size())/((double)memsize))*100, met_maxpercent);
        else
            Out->msg(STD, LOCTXT("   Compress failed"));

        fileref n2;
        {
            double totalsize = 0;
            double oldtime = timer::now();
            for( int i=0; i<loopcnt; i++ ) {
                n2.initmem(m);
                n2.compress(flags.cpercent, fileref::compressionlevels(flags.clevel), fileref::compmodes(flags.compress), fileref::encmode_none, met_maxpercent);
                if(n2.size() != n.size()) Out->msg(ERR, "<6545>Loop %d: Size mismatch (%d should be %d)", i, n2.size(), n.size());
                totalsize += memsize;
            }
            double newtime = timer::now();

            double elapsedtime = newtime - oldtime;
            double bytes_per_second = totalsize/elapsedtime;
            Out->msg(STD, LOCTXT("   Compress           %20s bytes            %7.3f seconds, %8.2f MB/sec\n"),
                     *commas(totalsize), elapsedtime, bytes_per_second/(1024*1024) );
        }

        {   
            double totalsize = 0;
            double oldtime = timer::now();
            for( int i=0; i<loopcnt; i++ ) {
                fileref n3;
                n3.initmem(n2);
                bool ok = n3.uncompress();
                if(!ok) Out->msg(ERR, "<6545>Loop %d: Uncompress failed", i);
                if(n3.size() != m.size()) Out->msg(ERR, "<6545>Loop %d: Size mismatch (%d should be %d)", i, n3.size(), m.size());
                totalsize += memsize;
            }
            double newtime = timer::now();

            double elapsedtime = newtime - oldtime;
            double bytes_per_second = totalsize/elapsedtime;
            Out->msg(STD, LOCTXT(" Uncompress           %20s bytes            %7.3f seconds, %8.2f MB/sec\n"),
                     *commas(totalsize), elapsedtime, bytes_per_second/(1024*1024) );
        }
    }

    
    

    m.initmem( memsize );
    n.initmem( memsize );
    for(int k=0; k<memsize; k++) { m.start()[k]=k; n.start()[k]=k-1; }

    if(tests&4) {
        Out->msg(STD, LOCTXT("4) Memory XOR:"));
        Out->msg(STD, LOCTXT("   --count=%d, --size=%d"), loopcnt, memsize);
        if(memsize<(1024*1024)) Out->msg(STD, LOCTXT("   WARNING: Size < 1MB: Processor data caching may skew results."));

        double totalsize = 0;
        double oldtime = timer::now();
        for( int i=0; i<loopcnt; i++ ) {
            n ^= m;
            totalsize += memsize;
        }
        double newtime = timer::now();

        double elapsedtime = newtime - oldtime;
        double bytes_per_second = totalsize/elapsedtime;
        Out->msg(STD, LOCTXT("   Memory XOR         %20s bytes            %7.3f seconds, %8.2f MB/sec\n"),
                 *commas(totalsize), elapsedtime, bytes_per_second/(1024*1024) );
    }

    if(tests&8) {
        Out->msg(STD, LOCTXT("8) 64-bit XOR checksum:"));
        Out->msg(STD, LOCTXT("   --count=%d, --size=%d"), loopcnt, memsize);
        if(memsize<(1024*1024)) Out->msg(STD, LOCTXT("   WARNING: Size < 1MB: Processor data caching may skew results."));

        double totalsize = 0;
        double oldtime = timer::now();
        for( int i=0; i<loopcnt; i++ ) {
             checksum64(m.start(), memsize);
            totalsize += memsize;
        }
        double newtime = timer::now();

        double elapsedtime = newtime - oldtime;
        double bytes_per_second = totalsize/elapsedtime;
        Out->msg(STD, LOCTXT("   64-bit checksum    %20s bytes            %7.3f seconds, %8.2f MB/sec\n"),
                 *commas(totalsize), elapsedtime, bytes_per_second/(1024*1024) );
    }

    
    
    
    
    
    
    
    if(tests&16) {
        int count = flags.count;
        int numthreads = flags.numthreads;
        if(count==0) count = 1000000;
        if(numthreads==0) numthreads = 2;

        int i;
        if(xflag[1]!=0) DB->threadprint=false;  
        timetest_worker2 **workers = new timetest_worker2 *[numthreads];
        semaphore *sems = new semaphore[numthreads];

        threadbase::defaultstacksize = 32768;

        Out->msg(STD, LOCTXT("16) Thread context switch time:"));
        Out->msg(STD, LOCTXT("   --count=%d, --numthreads=%d"), count, numthreads);

        for(i = 0; i < numthreads; i++) {
            workers[i] = new timetest_worker2(sems[i], sems[(i+numthreads-1)%numthreads], count, false);
        }

        for(i = numthreads-1; i>=0; i--) {
            workers[i]->start();
        }

        double start=timer::now();

        sems[0].signal();

        for(i = 0; i < numthreads; i++) {
            workers[i]->wait();
            delete workers[i];
        }

        double end=timer::now();
        Out->msg(STD, LOCTXT("   Context switch time      %3d threads, %9d switches %7.3f seconds,  %0.3f us/switch"),
                 numthreads, count*numthreads, end-start, 1000000*(end-start)/double(numthreads*count));

        delete[] workers;
    }

    
    
    
    if(tests&32) {
        int count = flags.count;
        int numthreads = flags.numthreads;
        if(count==0) count = 10000;
        if(numthreads==0) numthreads = 2;

        int i;
        if(xflag[1]!=0) DB->threadprint=false;  
        timetest_worker2 **workers = new timetest_worker2 *[numthreads];
        semaphore *sems = new semaphore[numthreads];

        threadbase::defaultstacksize = 32768;

        Out->msg(STD, LOCTXT("32) Multiple threads spinloop:"));
        Out->msg(STD, LOCTXT("   --count=%d, --numthreads=%d"), count, numthreads);

        for(i = 0; i < numthreads; i++) {
            workers[i] = new timetest_worker2(sems[i], sems[(i+numthreads-1)%numthreads], count, true);
        }

        for(i = numthreads-1; i>=0; i--) {
            workers[i]->start();
        }

        double start=timer::now();

        for(i = 0; i < numthreads; i++) {
            sems[i].signal();
        }

        for(i = 0; i < numthreads; i++) {
            workers[i]->wait();
            delete workers[i];
        }

        double end=timer::now();
        Out->msg(STD, LOCTXT("   CPU wasting loops        %3d threads, spin loop %9d million times each, %7.3f seconds"),
                 numthreads, count, end-start);

        delete[] workers;
    }

    
    
    
    if(tests&64) {
        int count = flags.count;
        int numthreads = flags.numthreads;
        if(count==0) count = 1000000;
        if(numthreads==0) numthreads = 2;

        int i;
        if(xflag[1]!=0) DB->threadprint=false;  
        timetest_worker3 **workers = new timetest_worker3 *[numthreads];
        semaphore *sems = new semaphore[numthreads];

        threadbase::defaultstacksize = 32768;

        Out->msg(STD, LOCTXT("64) Verify operation of gatedptr:"));
        Out->msg(STD, LOCTXT("   --count=%d, --numthreads=%d"), count, numthreads);

        gatedcounter_t gatedptr_counter;
        memset(gatedptr_counter, 0, sizeof(gatedptr_counter));

        for(i = 0; i < numthreads; i++) {
            workers[i] = new timetest_worker3(sems[i], gatedptr_counter, count);
        }

        for(i = numthreads-1; i>=0; i--) {
            workers[i]->start();
        }

        double start=timer::now();

        for(i = 0; i < numthreads; i++) {
            sems[i].signal();
        }

        for(i = 0; i < numthreads; i++) {
            workers[i]->wait();
            delete workers[i];
        }

        double end=timer::now();
        Out->msg(STD, LOCTXT("   Gatedptr test            %3d threads, %9d updates  %7.3f seconds,  %0.3f us/update"),
                 numthreads, count*numthreads, end-start, 1000000*(end-start)/double(numthreads*count));

        if(!examcounters(gatedptr_counter))
            Out->msg(ERR, "<8019>FAILED GATEDPTR TEST: max-min > 1");

        delete[] workers;
    }

    
    if(tests&128) {
        int i;
        hashcode h;
        double d2;
        double d0;

        int count = flags.count;
        if(count==0) count = 1000000;

        
        d2 = hashcode::zero.spread2();
        assert(d2 == 0.0);

        
        const double spread_of_ones = (double(1LL<<52)-1.0)/double(1LL<<52);
        d2 = hashcode::ones.spread2();
        d0 = hashcode::ones.spread();
        Out->msg(INFO, "All 1's: d2=%0.20f against %0.20f", d2, spread_of_ones);
        if(d2 != spread_of_ones) Out->msg(ERR, "Spread2(%0.20f) of all 1's is wrong!", d2);
        if(d0 != spread_of_ones) Out->msg(ERR, "Spread(%0.20f) of all 1's is wrong!", d0);
        assert(d2 == d0);

        
        memset(&h, 1, sizeof(h));
        Out->msg(INFO, "0x01 bytes: Spread=%0.20f  Spread2=%0.20f", h.spread(), h.spread2());

        
        int bits[160];          
        memset(bits, 0, sizeof(bits));
        Out->msg(INFO, "Testing %d random hashes", count);
        for(i=0; i<count; i++) {
             const int signs = rand();          
             h[0] = rand() | (signs&1)<<31;
             h[1] = rand() | (signs&2)<<30;
             h[2] = rand() | (signs&4)<<29;
             h[3] = rand() | (signs&8)<<28;
             h[4] = rand() | (signs&16)<<27;
             for(int j=0; j<160; j++) if(h[j/32]&(1<<(j%32))) bits[j]++;        

             d0 = h.spread();
             d2 = h.spread2();
             if(d2 < 0.0 || d2 >= 1.0) Out->msg(ERR, "Iteration %d: hash=%s: spread2() out of range: %0.20f", i, *h.image(), d2);
             if(d2 != d0) Out->msg(ERR, "Iteration %d: hash=%s: spread2=%0.20f != spread=%0.20f", i, *h.image(), d2, d0);
        }

        if (count < 5000) Out->msg(WARN, "Bit counts may print errors because count (%d) is so low", count);

        
        for(int j=0; j<160; j++) if(double(bits[j]) < double(count)*.45 || double(bits[j]) > double(count)*.55) Out->msg(ERR, "bits[%d]=%d", j, bits[j]);

        
        double start=timer::now();
        for(i = 0; i < count; i++) {
            d2 = 100.0;
        }
        double end=timer::now();
        Out->msg(STD, LOCTXT("   Empty loop               %9d calls  %0.7f seconds, %0.3f us/iter"), count, end-start, 1000000*(end-start)/double(count));

        
        start=timer::now();
        for(i = 0; i < count; i++) {
            d0 = h.spread();
        }
        end=timer::now();
        Out->msg(STD, LOCTXT("   Spread test              %9d calls  %0.7f seconds, %0.3f us/call"), count, end-start, 1000000*(end-start)/double(count));

        
        start=timer::now();
        for(i = 0; i < count; i++) {
            d2 = h.spread2();
        }
        end=timer::now();
        Out->msg(STD, LOCTXT("   Spread2 test             %9d calls  %0.7f seconds, %0.3f us/call"), count, end-start, 1000000*(end-start)/double(count));
    }
}

void client_commands::testagent() {
  DB->msg(DBTXT("testagent: begin"));








  DB->msg(DBTXT("testagent: done"));
}


void client_commands::testagentserver(utar_flags_info& flags) {
    agenttest server(flags.hfsport, flags.encrypt);
    while(true) {
       server.start();
       server.terminate();
    }
}





#define MAXEXTLEN 64

static uint64_t my_rand64() {
    uint64_t x = uint64_t(rand());
    x += uint64_t(rand())<<32;
    return x;
}

static dataextents to_extents(uint64_t num, int scale) {
    dataextents e(MAXEXTLEN*scale);
    int start=-1;
    for(int i=0; i<MAXEXTLEN; i++) {
        if (num & (uint64_t(1)<<i)) {
            if (start < 0) start=i;
        } else {
            if (start >= 0) e.enter(start*scale, (i-start)*scale);
            start = -1;
        }
    }
    if (start >= 0) e.enter(start*scale, (MAXEXTLEN-start)*scale);
    return e;
}

static uint64_t to_uint64(dataextents &e, int scale) {
    uint64_t res = 0;
    for (int i=0; i<MAXEXTLEN; i++) {
        const bool is_in = e.is_in(i*scale);
        if (is_in) res |= (uint64_t(1)<<i);
        for (int j=(i*scale)+1; j<i*scale+std::min(MAXEXTLEN,scale); j++) assert(e.is_in(j) == is_in);
    }

    return res;
}

static void print(const ustring who, dataextents &e) {
    fileref f;
    f.initlist();
    e.image(f);
    dataextents tmp;
    assert(tmp.parse("print", who, f)); 
}

static bool match(dataextents &e, uint64_t num, int scale) {
    if (!e.isinorder()) print("isinorder() failed", e);
    if (e.hasoverlapping()) print("hasoverlapping failed", e);

    for (int i=0; i<MAXEXTLEN; i++) {
        const bool res = (num & (uint64_t(1)<<i)) != 0;
        for (int j=i*scale; j<i*scale+std::min(MAXEXTLEN,scale); j++) if (e.is_in(j) != res) return false;
    }
    return true;
}

void client_commands::testdataextents(int iterations) {
    if (iterations==0) iterations=5000;
    Out->msg(INFO, "<12606>testdataextents: --count=%d", iterations);
    for(int i=1; i<=iterations; i++) {
        if (!uapp::staging().canRun()) break;
        const uint64_t r1 = my_rand64();
        const uint64_t r2 = my_rand64();
        const int scale = 1<<(rand()%20);

        if((i%100)==0) Out->msg(INFO, "<12607>testdataextents(%d) r1=%"LL"x, r2=%"LL"x, scale=%d", i, r1, r2, scale);

        dataextents e1(to_extents(r1, scale));
        dataextents e2(to_extents(r2, scale));


        assert(to_uint64(e1,scale) == r1);
        assert(to_uint64(e2,scale) == r2);

        dataextents e1x(e1);
        dataextents e2x(e2);
        if(!(e1==e1x)) { print("e1==e1x, e1", e1); print("e1==e1x, e1x", e1x); }
        if(!(e2==e2x)) { print("e2==e2x, e2", e2); print("e2==e2x, e2x", e2x); }
        if((e1x != e2x) != (r1 != r2)) { print("e1x!=e2x, e1x", e1x); print("e1x!=e2x, e2x", e2x); }

        uint64_t r3 = r1&r2;
        dataextents e3 = e1&e2;
        if (!match(e3, r3, scale)) {
            DB->error("dataextent::unittest(%d) Fail %"LL"x & %"LL"x = %"LL"x", i, r1, r2, r3);
            print("e1", e1);
            print("e2", e2);
            print("e3", e3);
        }

        uint64_t r4 = r1|r2;
        dataextents e4 = e1|e2;
        if (!match(e4, r4, scale)) {
            DB->error("dataextent::unittest(%d) Fail %"LL"x | %"LL"x = %"LL"x", i, r1, r2, r4);
            print("e1", e1);
            print("e2", e2);
            print("e4", e4);
        }

        uint64_t r5 = r1&r2;
        dataextents e5 = e2&e1;
        if (!match(e5, r5, scale)) {
            DB->error("dataextent::unittest(%d) Fail %"LL"x & %"LL"x = %"LL"x", i, r1, r2, r5);
            print("e1", e1);
            print("e2", e2);
            print("e5", e5);
        }

        uint64_t r6 = r1|r2;
        dataextents e6 = e1|e2;
        if (!match(e6, r6, scale)) {
            DB->error("dataextent::unittest(%d) Fail %"LL"x | %"LL"x = %"LL"x", i, r1, r2, r6);
            print("e1", e1);
            print("e2", e2);
            print("e6", e6);
        }
    }
}





void client_commands::controltest(utar_flags_info& flags) {
    IPADDR sockaddr(flags.hfsaddr, flags.hfsport);
    if (!sockaddr.isResolved()){
        if (Out) Out->msg(ERR, "<5337>Unable to resolve name \"%s\"", *flags.hfsaddr);
        else DB->error (DBTXT("controltest  can't resolve name: %s"), *flags.hfsaddr);
    }
    tsocktype sockty(*flags.encrypt);
    DB->msg(DBTXT("connecting to %s"), *sockaddr.image());
    tcpsock* s = flags.format == "xml" ? tcpsock::createrawclient(sockty, sockaddr) : tcpsock::createclient(sockty, sockaddr);
    if(s == NULL || ! s->open()) {
        DB->error("cannot connect to %s", *sockaddr.image());
        delete s;
        return;
    }
    if(flags.internal) { 
        DB->msg(DBTXT("sending exit"));
        message m(CONTROL_EXIT);
        s->send(m);
        m = s->recv();
    }

    if(flags.statistics) { 
        DB->msg(DBTXT("sending run - super hack to turn on debugging"));
        message m(CONTROL_RUN);
        s->send(m);
        m = s->recv();
    }

    message m(CONTROL_STATUS);
    while(true) {
        if(! s->send(m))
            break;
        m = s->recv();
        if(m.isnull())
            break;
        fileref data = m.data();
        if(data.isnull())
            break;
        data.print(stdout);

        if(flags.format!="xml") {  
            assoc params;
            params.expand(data);
            undoo::vector<ustring> keys(params.keys());

            for(size_t i = 0; i < keys.size(); i++) {
                ustring key = keys[i];
                ustring val = params.lookup(key);
                DB->msg("%s =>%s", *key, *val);
            }
            if(params.ilookup("done") != 0)
                break;
        } else {
            xml_message xparams(data, true);
            if(xparams.defined("done")) break;
        }

        threadbase::threadsleep(5000);
    }
    s->close();
    delete s;
}


int client_commands::pingtest(utar_flags_info& flags) {
    
    if (sock::libinit(flags.encrypt, flags.sysdir, flags.encrypt_strength) != EXIT_OK) return EXIT_SSL_ERROR;
    
    int rsp = 0;
    stringlist hfsnames(flags.hfsaddr.split(','));
    if(hfsnames.size() <= 0) {
        DB->msg(DBTXT("missing value for --hfsaddr flag"));
        rsp = 1;
    }
    else {
        for (int i=0; i<hfsnames.size(); i++) {
            ustring hfsname = hfsnames[i];

            IPADDR sockaddr(hfsname, flags.hfsport);
            if (!sockaddr.isResolved()){
                if (Out) Out->msg(ERR, "<5337>Unable to resolve name \"%s\"", *hfsname);
                else DB->error ("pingtest  can't resolve name: %s", *hfsname);
            }
            tsocktype sockty(*flags.encrypt);
            DB->msg(DBTXT("connecting to %s at %s"), *hfsname, *sockaddr.image());
            tcpsock* s = tcpsock::createclient(sockty, sockaddr);
            int answer=0;
            if(s == NULL || ! s->open()) {
                answer = 1;
                rsp = 1;
            }
            delete s;
            DB->msg(DBTXT("connecting to %s at %s returns %d"), *hfsname, *sockaddr.image(), answer);
        }
    }
    DB->msg(DBTXT("pingtest returns %d"), rsp);
    return rsp;
}


void client_commands::testpipe(utar_flags_info& flags) {
    DB->msg("testpipe: start");
    ustring pipename = flags.args[0];
    int pipefile = uwrapper::uopen(pipename, O_WRONLY);
	if (pipefile == -1)	{
	    DB->error("testpipe: could not open pipe %s", *pipename);
		return;
	}
	else {
	    DB->msg("testpipe: pipe opened %s", *pipename);
	}

    int numfiles = flags.args.size();
    int curfile = 1;
    while (curfile < numfiles) {
        
        int buff_size = flags.blocksize;
        std::vector<char> buf(buff_size);
        char *bufp = &buf[0];
        int size;
        DB->msg("testpipe: opening %s", *flags.args[curfile]);
        int infile = uwrapper::uopen(flags.args[curfile], O_RDONLY);
        if (infile == -1) {
            DB->error("testpipe: could not open file %s", *flags.args[curfile]);
            return;
        }

        while( true ) {
            size = ::read(infile, bufp, buff_size);
            DB->msg("testpipe: writing %d\nbuf:\n%s\n------------------", size, bufp);
            if(size<= 0) break;
            ::write(pipefile, bufp, size);
        }
        DB->msg("testpipe: done with %s", *flags.args[curfile]);
        curfile++;
        ::close(infile);
    }
    DB->msg("testpipe: done with pipe %s", *pipename);
    ::close(pipefile);
}


#if !defined(RESTDUMPFILE_H_INCLUDED)
#define RESTDUMPFILE_H_INCLUDED












#include "cycle.h"
#include "restelem.h"
#include "direlem.h"



class restdumpfile : public cycle {
public:
    restdumpfile(cycle *parent, int inode, DIRELEM de, int priority_id);
    virtual void init();
    virtual void childdone(cycle *child);
    virtual ~restdumpfile();
    SAFEPOOLALLOC(restdumpfile);
private:
    restdumpfile();
    int inode;
    DIRELEM de;
    dumpcontext * dumpctx;
    fileoffset startoff;   
    fileoffset totalsize;  
    upath      path;       

    
    
    
    
    
    
    
    
    int        priority_id;
};

#endif











#include "common.h"
#include "hexhash.h"

static const char *hexdigit = "0123456789abcdef";

hexhash::hexhash() {
}

hexhash::hexhash(const hashcode& hash) {
    set(hash);
}

void hexhash::set(const hashcode& hash) {
    char *res = image;
    for(int i = 0; i < (int)sizeof(hash.data); i++) {
        *res++ = hexdigit[hash.data[i]>>4];
        *res++ = hexdigit[hash.data[i]&15];
    }
    *res = 0;
}

char *hexhash::operator &() {
    return image;
}
#include <algorithm>

#include "common.h"
#include "debug.h"
#include "output.h"
#include "isilontar_history.h"
#include "msgpack_c.h"
#include "timer.h"
#include "context.h"
#include "message.h"
#include "runstage.h"
#include "file.h"
#include "cycle.h"
#include "histmap.h"

















































#define msg1 ((xflag[2] & 2048) != 0)   
#define msg2 ((xflag[2] & 4096) != 0)   

#define dumphist ((xflag[14] & 131072) != 0)  

isilontar_history::isilontar_history(context* main, upath fifopath, upath savehistpath)
  : todoqueue('n'), readhist_thread(NULL), processhist_thread(NULL), flags(main->get_flags())
{
    DB->msg("isilontar_history::isilontar_history starting fifopath:%s", *fifopath.image());

    readhist_thread = new readhist(todoqueue, fifopath, savehistpath, histsem);
    processhist_thread = new processhist(todoqueue, this);
    readhist_thread->start();
    processhist_thread->start();
}

isilontar_history::~isilontar_history()
{
    DB->msg("isilontar_history::~isilontar_history");
    todoqueue.terminate();
    histsem.signal();
    readhist_thread->kick();
    readhist_thread->wait();
    processhist_thread->wait();
    delete readhist_thread;
    delete processhist_thread;
}

void isilontar_history::data_stream_done()
{
    DB->msg("isilontar_history::data_stream_done, signal the history stream reader...");
    histsem.signal();
    readhist_thread->wait();
    if (flags.ndmpmemthrottlethresh <= 0) {
        
        
        DB->msg("isilontar_history::data_stream_done terminating todoqueue");
        todoqueue.terminate();
    }
    DB->msg("isilontar_history::data_stream_done--");
}

void isilontar_history::send(BackCycle* cycle, message& m)
{
    if(msg2) DB->msg("isilontar_history::send enqueuing message '%s'", *m.ximage());
    const bool willPackOK = (sizeof(void*) <= sizeof(time_t)); 
    assert(willPackOK);   
    m.info().sendtime = (time_t)cycle;  
    m.info().connection = -1;       
    todoqueue.enqueue(m);
}


isilontar_history::readhist::readhist(msgqueue& todoqueue_, upath fifopath, upath savehistpath_, semaphore& histsem_)
  : todoqueue(todoqueue_),
    fifo(namedpipe::inbound, fifopath),
    savehistpath(savehistpath_),
    histsem(histsem_),
    is_done(false),
    msg_count(0)
{
    setdesc(ustring::sprintf("rhist"));
}

isilontar_history::readhist::~readhist()
{
    DB->msg("isilontar_history::readhist::~readhist calling wait()...");
    wait();
    DB->msg("isilontar_history::readhist::~readhist done");
}

static char buf[8192];
static int buflen;
static int bufidx;


static ustring readline(int d)
{
    char res[8192];
    int i = 0;
    while (1) {
        while (bufidx < buflen) {
            const char c = buf[bufidx];
            if (c == '\n') {
                res[i] = 0;
                if (i > 0) {
                    bufidx++;
                    return ustring(res);
                }
            } else if (c != '\r') {
                if (i >= (int)sizeof(res)) {
                     res[sizeof(res) - 1] = 0;
                     Out->msg(ERR, "<10762>isilontar_history readline: Line too long, truncating: '%s'", res);
                     return ustring(res);
                }
                res[i++] = c;
            }
            bufidx++;
        }

        bufidx = 0;
        buflen = ::read(d, buf, sizeof(buf));
        if (buflen <= 0) {
            if (buflen < 0)
                Out->msg(ERR, "<10763>isilontar_history readline: I/O error (%d, errno=%d) on fd %d", buflen, errno, d);
            return "";
        }
    }
}

void isilontar_history::readhist::body()
{
    DB->msg("isilontar_history::readhist::body start");

    bool mainloopdone = false;

    
    if (!fifo.connect()) {
        Out->msg(FATAL, "<7235>Cannot open history stream for reading, files will not be deleted");
        DB->msg("isilontar_history::readhist::body exiting body with error");
        todoqueue.terminate();
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "cannot open history stream for read");
        mainloopdone = true;   
    }
    DB->msg("isilontar_history::readhist::body connected to history pipe");

    file savehist;
    if (!savehistpath.isempty()) {
        if (!savehist.open(savehistpath.image(), O_RDWR | O_CREAT | O_TRUNC)) {
            Out->msg(ERR, "<8665>NDMP history reading thread failed to open or create file '%s' for saving history stream",
                     *savehistpath.image());
        } else {
            Out->msg(INFO, "<8666>NDMP history reading thread opened file '%s' to save history stream",
                     *savehistpath.image());
        }
    }

    sum_timer sumt;
    while (!mainloopdone && uapp::staging().canRun()) {
        
        
        
        ustring oneline(readline(fifo.filedescriptor()));
        if (oneline.bytelength() == 0) {
            
            DB->msg("isilontar_history::readhist::body end of file");
            break;
        }
        if (savehist.isopen()) {
            savehist.append(*oneline, oneline.bytelength());
            savehist.append("\n", 1);
        }

        message m;
        msgpack_c::ndmphistlistline nhll(m);
        nhll.arg(PACK, oneline);
        m.setresponsecode(MSG_ERR_NONE);
        m.setflag(MSGFLAG_NOACK);
        msg_count++;
        todoqueue.enqueue(m);

        savehist.close();
        sumt.check_cputime_update("ndmpreadhist");
    }
    is_done = true;

    DB->msg("isilontar_history::readhist::body finished reading fifo, wait for data stream to signal us");
    histsem.wait();
    DB->msg("isilontar_history::readhist::body--");
}



isilontar_history::processhist::processhist(msgqueue& todoqueue_, isilontar_history *parent_)
    : todoqueue(todoqueue_), parent(parent_), mainloopdone(false), todoqueue_terminated(false)
{
    setdesc(ustring::sprintf("phist"));
}

isilontar_history::processhist::~processhist()
{
    DB->msg("isilontar_history::processhist::~processhist");
    terminate();
    wait();
    DB->msg("isilontar_history::processhist::~processhist done");
}

void isilontar_history::processhist::terminate()
{
    DB->msg("isilontar_history::processhist::terminate()");
    todoqueue.terminate();
    kick();
}

void isilontar_history::processhist::body()
{
    if(msg2) DB->msg("isilontar_history::processhist::body");

    bool todoqueue_terminated = false;
    static size_t count_ndmp_histlistline_processed = 0;

    bool some_processed(false);
    while (uapp::staging().canRun() && !todoqueue_terminated) {
        int waittime(10000);       
        message m = todoqueue.dequeue(todoqueue_terminated, waittime);
        if (todoqueue_terminated) {
            DB->msg("isilontar_history::processhist::body todoqueue terminated %d", todoqueue_terminated);
            break;
        }

        if (m.requestcode() == NO_MESSAGE) {
            
            
            
            
            
            
            
            
            

            

            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("isilontar_history::processhist::body handled %"Z"d NDMPHISTLISTLINE "
                        "messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
            }

            continue;
        }

        some_processed = true;

        switch(m.requestcode()) {
        case CLIENTONLY_GETNDMPHISTLIST64:
            handle_getndmpisilonhistlist(m);
            break;
        case CLIENTONLY_NDMPHISTLISTLINE:
            count_ndmp_histlistline_processed++;
            handle_ndmphistlistline(m);
            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("processhist::body handled %"Z"d NDMPHISTLISTLINE messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
            }
            break;
        default:
            DB->msg("isilontar_history::processhist::body strange message %s", *m.image());
            continue;
        }
    }
    if (some_processed && (parent->flags.ndmpmemthrottlethresh <= 0)) {
        
        
        mark_eof_history();
    }

    
    
    inode_obj_t inode;
    message m;
    if (todoassoc.size() > 0)
        Out->msg(ERR, "<8667>NDMP history processing thread has read all file history data and is unable "
                 "to answer remaining %u GETNDMPHISTLIST64 messages from the data processing thread",
                 todoassoc.size());

    while (todoassoc.pop(inode, m))
        postprocess_getndmpisilonhistlist((ndmp_inode64_t)inode, m);
    DB->msg("isilontar_history::processhist::body done");
}

void isilontar_history::processhist::mark_eof_history()
{
    ndmp_inode64_t n = historytree.lastparent_done();
    DB->msg("isilontar_history::processhist::mark_eof_history lastparent_done inode:%"LL"u", n);
    attempt_answer(n);
}




void isilontar_history::processhist::handle_getndmpisilonhistlist(message& m)
{
    msgpack_c::getndmphistlist64 thl(m);
    ndmp_inode64_t queryinode(0);
    thl.arg(UNPACK, queryinode); 

    
    

    message preexistingmsg;
    bool entered = false;
    {
        scope s(todomut);
        entered = todoassoc.enter_if_undef(queryinode, m, preexistingmsg);
    }
    if (!entered)
        Out->msg(WARN, "<10764>NDMP history processing thread received another message requesting history for directory with inode %lu",
                 queryinode);

    
    if (historytree.answer_ready(queryinode))
        attempt_answer(queryinode);
}

bool isilontar_history::processhist::handle_ndmphistlistline(message& m)
{
    msgpack_c::ndmphistlistline nhll(m);
    ustring oneline;
    nhll.arg(UNPACK, oneline);

    xml_messagep mess(new xml_message(oneline, true));

    ustring cmd(mess->valid() ? mess->getcommand() : "invalid");
    if ((cmd != "hist") && (cmd != "node")) {
        Out->msg(ERR, "<7236>unknown history string: '%s'", *oneline);
        return false;
    }

    if (dumphist)
        DB->msg("isilontar_history::processhist::read_and_enter_xml xml: %s", *mess->simage());

    if (cmd == "hist") {
        ndmp_inode64_t num = mess->getrawstring("num").touint64();
        ndmp_inode64_t parent = mess->getrawstring("parent").touint64();

        
        ustring name = xml_message::fromathexat(mess->getstring("name"));

        if (msg2)
            DB->msg("isilontar_history::processhist::read_and_enter_xml read hist num:%lu parent:%lu name:%s",
                    num, parent, *name);

        
        
        
        
        ndmp_inode64_t finished_inode = historytree.enter_hist(this, num, parent, name);

        if (finished_inode > 0)
            attempt_answer(finished_inode);
    }

    
    return true;
}

void isilontar_history::processhist::attempt_answer(ndmp_inode64_t dirinode)
{
    histvector_t* names = NULL;
    message m;

    {
        scope s(todomut);
        m = todoassoc.lookup(dirinode);
        if (m.isnull()) {
            if (msg2)
                DB->msg("isilontar_history::processhist::attempt_answer inode:%lu - no outstanding GETNDMPHISTLIST64 message for this inode",
                              dirinode);
            return; 
        }

        names = historytree.get_names(dirinode);
        if (names == NULL) {
            if (msg2) DB->msg("isilontar_history::processhist::attempt_answer inode:%lu - no answer for GETNDMPHISTLIST64 message for this inode yet",
                              dirinode);
            return; 
        } else {
            if (msg2) {
                DB->msg("isilontar_history::processhist::attempt_answer DEBUG DUMP histlist:%p for inode %lu with %"Z"u entries",
                        names, dirinode, names->size());

                for (histvector_t::const_iterator i=names->begin(); i!=names->end(); i++) {
                    DB->msg("    name:'%s' inode:%lu", *((*i).key_string), (*i).key_number);
                }
            }
        }

        
        todoassoc.remove(dirinode);
    }

    assert(m.info().connection == -1);
    BackCycle* cycle = (BackCycle*)m.info().sendtime;

    msgpack_c::getndmphistlist64 thl(m);
    ndmp_inode64_t queryinode(0);
    thl.arg(UNPACK, queryinode); 
    assert(dirinode == queryinode);

    bool goodresult(true);
    ubigint64 namesptr = (ubigint64)((ptrint)names);
    thl.res(PACK, goodresult, namesptr);
    if (msg2)
        DB->msg("isilontar_history::processhist::attempt_answer inode %lu sending goodresult:%d namesptr:%p",
                      dirinode, goodresult, (void*)namesptr);
    sendResponse(cycle, m);
}

void isilontar_history::processhist::postprocess_getndmpisilonhistlist(ndmp_inode64_t queryinode, message& m)
{
    assert(!m.isnull());
    assert(m.info().connection == -1);   
    BackCycle* cycle = (BackCycle*)m.info().sendtime;
    histvector_t* names = historytree.get_names(queryinode, true);

    msgpack_c::getndmphistlist64 mp(m);
    ndmp_inode64_t dirinode(0);
    mp.arg(UNPACK, dirinode); 
    assert(queryinode == dirinode);

    Out->msg(INFO, "<10765>    DEBUG: answering GETNDMPHISTLIST64 message:%s for dir inode:%lu with done=false and best effort data histlist:%p",
             *m.ximage(), dirinode, names);

    bool done = false;
    ubigint64 namesptr = (ubigint64)((ptrint)names);

    mp.res(PACK, done, namesptr);
    sendResponse(cycle, m);
}




void isilontar_history::processhist::sendResponse(BackCycle* cycle, message& m)
{
    cycle->enqueueResponse(cycle, m, false);
}

isilontar_history::processhist::historytree_class::~historytree_class()
{
}



ndmp_inode64_t isilontar_history::processhist::historytree_class::lastparent_done()
{
    if (lastparentinode != 0) {
        iter old = nodes.find(lastparentinode);

        
        
        
        

        old->second.isdone = true;
        if (msg2)
            DB->msg("isilontar_history::processhist::historytree_class::check_lastparent_done set done=true for inode:%lu", lastparentinode);
        return lastparentinode;
    }

    return 0;
}

ndmp_inode64_t isilontar_history::processhist::historytree_class::enter_hist(processhist* ph,
                                                           ndmp_inode64_t inode,
                                                           ndmp_inode64_t parentinode,
                                                           const ustring& name)
{
    ndmp_inode64_t ret = 0;

    scope s(m);

    if ((parentinode != lastparentinode)) {
        ret = lastparent_done();
        lastparentinode = parentinode;
    }

    dirrecord &dr(nodes[parentinode]); 
    assert(dr.names != NULL);          

    dr.names->push_back(composite_key(inode, name));

    return ret;
}

histvector_t* isilontar_history::processhist::historytree_class::get_names(ndmp_inode64_t inode, bool accept_unready)
{
    scope s(m);

    iter i = nodes.find(inode);
    if (i == nodes.end())
        return NULL;

    if (!i->second.isdone) {
        if (!accept_unready) return NULL;
    }

    histvector_t *result = i->second.names;
    nodes.erase(i);

    return result;
}

bool isilontar_history::processhist::historytree_class::answer_ready(ndmp_inode64_t queryinode) const
{
    scope s(m);
    nodemap::const_iterator i = nodes.find(queryinode);
    if (i == nodes.end())
        return false;

    if (i->second.isdone)
        return true;

    return false;
}
#include <algorithm>

#include "common.h"
#include "debug.h"
#include "output.h"
#include "zfstar_history.h"
#include "msgpack_c.h"
#include "timer.h"
#include "context.h"
#include "message.h"
#include "runstage.h"
#include "file.h"
#include "cycle.h"
#include "histmap.h"

















































#define msg1 ((xflag[2] & 2048) != 0)   
#define msg2 ((xflag[2] & 4096) != 0)   

#define dumphist ((xflag[14] & 131072) != 0)  

zfstar_history::zfstar_history(context* main, upath fifopath, upath savehistpath)
  : todoqueue('n'), readhist_thread(NULL), processhist_thread(NULL), flags(main->get_flags())
{
    DB->msg("zfstar_history::zfstar_history starting fifopath:%s", *fifopath.image());

    readhist_thread = new readhist(todoqueue, fifopath, savehistpath, histsem);
    processhist_thread = new processhist(todoqueue, this);
    readhist_thread->start();
    processhist_thread->start();
}

zfstar_history::~zfstar_history()
{
    DB->msg("zfstar_history::~zfstar_history");
    todoqueue.terminate();
    histsem.signal();
    readhist_thread->kick();
    readhist_thread->wait();
    processhist_thread->wait();
    delete readhist_thread;
    delete processhist_thread;
}

void zfstar_history::data_stream_done()
{
    DB->msg("zfstar_history::data_stream_done, signal the history stream reader...");
    histsem.signal();
    readhist_thread->wait();
    if (flags.ndmpmemthrottlethresh <= 0) {
        
        
        DB->msg("zfstar_history::data_stream_done terminating todoqueue");
        todoqueue.terminate();
    }
    DB->msg("zfstar_history::data_stream_done--");
}

void zfstar_history::send(BackCycle* cycle, message& m)
{
    if(msg2) DB->msg("zfstar_history::send enqueuing message '%s'", *m.ximage());
    const bool willPackOK = (sizeof(void*) <= sizeof(time_t)); 
    assert(willPackOK);   
    m.info().sendtime = (time_t)cycle;  
    m.info().connection = -1;       
    todoqueue.enqueue(m);
}


zfstar_history::readhist::readhist(msgqueue& todoqueue_, upath fifopath, upath savehistpath_, semaphore& histsem_)
  : todoqueue(todoqueue_),
    fifo(namedpipe::inbound, fifopath),
    savehistpath(savehistpath_),
    histsem(histsem_),
    is_done(false),
    msg_count(0)
{
    setdesc(ustring::sprintf("rhist"));
}

zfstar_history::readhist::~readhist()
{
    DB->msg("zfstar_history::readhist::~readhist calling wait()...");
    wait();
    DB->msg("zfstar_history::readhist::~readhist done");
}

static char buf[8192];
static int buflen;
static int bufidx;


static ustring readline(int d)
{
    char res[8192];
    int i = 0;
    while (1) {
        while (bufidx < buflen) {
            const char c = buf[bufidx];
            if (c == '\n') {
                res[i] = 0;
                if (i > 0) {
                    bufidx++;
                    return ustring(res);
                }
            } else if (c != '\r') {
                if (i >= (int)sizeof(res)) {
                     res[sizeof(res) - 1] = 0;
                     Out->msg(ERR, "<10762>zfstar_history readline: Line too long, truncating: '%s'", res);
                     return ustring(res);
                }
                res[i++] = c;
            }
            bufidx++;
        }

        bufidx = 0;
        buflen = ::read(d, buf, sizeof(buf));
        if (buflen <= 0) {
            if (buflen < 0)
                Out->msg(ERR, "<10763>zfstar_history readline: I/O error (%d, errno=%d) on fd %d", buflen, errno, d);
            return "";
        }
    }
}

void zfstar_history::readhist::body()
{
    DB->msg("zfstar_history::readhist::body start");

    bool mainloopdone = false;

    
    if (!fifo.connect()) {
        Out->msg(FATAL, "<7235>Cannot open history stream for reading, files will not be deleted");
        DB->msg("zfstar_history::readhist::body exiting body with error");
        todoqueue.terminate();
        uapp::staging().startTermination(EXIT_DUMPSTREAM, "cannot open history stream for read");
        mainloopdone = true;   
    }
    DB->msg("zfstar_history::readhist::body connected to history pipe");

    file savehist;
    if (!savehistpath.isempty()) {
        if (!savehist.open(savehistpath.image(), O_RDWR | O_CREAT | O_TRUNC)) {
            Out->msg(ERR, "<8665>NDMP history reading thread failed to open or create file '%s' for saving history stream",
                     *savehistpath.image());
        } else {
            Out->msg(INFO, "<8666>NDMP history reading thread opened file '%s' to save history stream",
                     *savehistpath.image());
        }
    }

    sum_timer sumt;
    while (!mainloopdone && uapp::staging().canRun()) {
        
        
        
        ustring oneline(readline(fifo.filedescriptor()));
        if (oneline.bytelength() == 0) {
            
            DB->msg("zfstar_history::readhist::body end of file");
            break;
        }
        if (savehist.isopen()) {
            savehist.append(*oneline, oneline.bytelength());
            savehist.append("\n", 1);
        }

        message m;
        msgpack_c::ndmphistlistline nhll(m);
        nhll.arg(PACK, oneline);
        m.setresponsecode(MSG_ERR_NONE);
        m.setflag(MSGFLAG_NOACK);
        msg_count++;
        todoqueue.enqueue(m);

        savehist.close();
        sumt.check_cputime_update("ndmpreadhist");
    }
    is_done = true;

    DB->msg("zfstar_history::readhist::body finished reading fifo, wait for data stream to signal us");
    histsem.wait();
    DB->msg("zfstar_history::readhist::body--");
}



zfstar_history::processhist::processhist(msgqueue& todoqueue_, zfstar_history *parent_)
    : todoqueue(todoqueue_), parent(parent_), mainloopdone(false), todoqueue_terminated(false)
{
    setdesc(ustring::sprintf("phist"));
}

zfstar_history::processhist::~processhist()
{
    DB->msg("zfstar_history::processhist::~processhist");
    terminate();
    wait();
    DB->msg("zfstar_history::processhist::~processhist done");
}

void zfstar_history::processhist::terminate()
{
    DB->msg("zfstar_history::processhist::terminate()");
    todoqueue.terminate();
    kick();
}

void zfstar_history::processhist::body()
{
    if(msg2) DB->msg("zfstar_history::processhist::body");

    bool todoqueue_terminated = false;
    static size_t count_ndmp_histlistline_processed = 0;

    bool some_processed(false);
    while (uapp::staging().canRun() && !todoqueue_terminated) {
        int waittime(10000);       
        message m = todoqueue.dequeue(todoqueue_terminated, waittime);
        if (todoqueue_terminated) {
            DB->msg("zfstar_history::processhist::body todoqueue terminated %d", todoqueue_terminated);
            break;
        }

        if (m.requestcode() == NO_MESSAGE) {
            
            
            
            
            
            
            
            
            

            

            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("zfstar_history::processhist::body handled %"Z"d NDMPHISTLISTLINE "
                        "messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
            }

            continue;
        }

        some_processed = true;

        switch(m.requestcode()) {
        case CLIENTONLY_GETNDMPHISTLIST64:
            handle_getndmpzfshistlist(m);
            break;
        case CLIENTONLY_NDMPHISTLISTLINE:
            count_ndmp_histlistline_processed++;
            handle_ndmphistlistline(m);
            if (parent->is_rhist_done() && count_ndmp_histlistline_processed == parent->rhist_msg_count()) {
                DB->msg("processhist::body handled %"Z"d NDMPHISTLISTLINE messages, which is all that readhist sent",
                        count_ndmp_histlistline_processed);
                if (parent->flags.ndmpmemthrottlethresh > 0) {
                    
                    
                    
                    
                    
                    
                    mark_eof_history();
                }
            }
            break;
        default:
            DB->msg("zfstar_history::processhist::body strange message %s", *m.image());
            continue;
        }
    }
    if (some_processed && (parent->flags.ndmpmemthrottlethresh <= 0)) {
        
        
        mark_eof_history();
    }

    
    
    inode_obj_t inode;
    message m;
    if (todoassoc.size() > 0)
        Out->msg(ERR, "<8667>NDMP history processing thread has read all file history data and is unable "
                 "to answer remaining %u GETNDMPZFSHISTLIST messages from the data processing thread",
                 todoassoc.size());

    while (todoassoc.pop(inode, m))
        postprocess_getndmpzfshistlist((ndmp_inode64_t)inode, m);
    DB->msg("zfstar_history::processhist::body done");
}

void zfstar_history::processhist::mark_eof_history()
{
    ndmp_inode64_t n = historytree.lastparent_done();
    DB->msg("zfstar_history::processhist::mark_eof_history lastparent_done inode:%"LL"u", n);
    attempt_answer(n);
}




void zfstar_history::processhist::handle_getndmpzfshistlist(message& m)
{
    msgpack_c::getndmphistlist64 thl(m);
    ndmp_inode64_t queryinode(0);
    thl.arg(UNPACK, queryinode); 

    
    

    message preexistingmsg;
    bool entered = false;
    {
        scope s(todomut);
        entered = todoassoc.enter_if_undef(queryinode, m, preexistingmsg);
    }
    if (!entered)
        Out->msg(WARN, "<10764>NDMP history processing thread received another message requesting history for directory with inode %lu",
                 queryinode);

    
    if (historytree.answer_ready(queryinode))
        attempt_answer(queryinode);
}

bool zfstar_history::processhist::handle_ndmphistlistline(message& m)
{
    msgpack_c::ndmphistlistline nhll(m);
    ustring oneline;
    nhll.arg(UNPACK, oneline);

    xml_messagep mess(new xml_message(oneline, true));

    ustring cmd(mess->valid() ? mess->getcommand() : "invalid");
    if ((cmd != "hist") && (cmd != "node")) {
        Out->msg(ERR, "<7236>unknown history string: '%s'", *oneline);
        return false;
    }

    if (dumphist)
        DB->msg("zfstar_history::processhist::read_and_enter_xml xml: %s", *mess->simage());

    if (cmd == "hist") {
        ndmp_inode64_t num = mess->getrawstring("num").touint64();
        ndmp_inode64_t parent = mess->getrawstring("parent").touint64();

        
        ustring name = xml_message::fromathexat(mess->getstring("name"));

        if (msg2)
            DB->msg("zfstar_history::processhist::read_and_enter_xml read hist num:%lu parent:%lu name:%s",
                    num, parent, *name);

        
        
        
        
        ndmp_inode64_t finished_inode = historytree.enter_hist(this, num, parent, name);

        if (finished_inode > 0)
            attempt_answer(finished_inode);
    }

    
    return true;
}

void zfstar_history::processhist::attempt_answer(ndmp_inode64_t dirinode)
{
    histvector_t* names = NULL;
    message m;

    {
        scope s(todomut);
        m = todoassoc.lookup(dirinode);
        if (m.isnull()) {
            if (msg2)
                DB->msg("zfstar_history::processhist::attempt_answer inode:%lu - no outstanding GETNDMPZFSHISTLIST message for this inode",
                              dirinode);
            return; 
        }

        names = historytree.get_names(dirinode);
        if (names == NULL) {
            if (msg2) DB->msg("zfstar_history::processhist::attempt_answer inode:%lu - no answer for GETNDMPZFSHISTLIST message for this inode yet",
                              dirinode);
            return; 
        } else {
            if (msg2) {
                DB->msg("zfstar_history::processhist::attempt_answer DEBUG DUMP histlist:%p for inode %lu with %"Z"u entries",
                        names, dirinode, names->size());

                for (histvector_t::const_iterator i=names->begin(); i!=names->end(); i++) {
                    DB->msg("    name:'%s' inode:%lu", *((*i).key_string), (*i).key_number);
                }
            }
        }

        
        todoassoc.remove(dirinode);
    }

    assert(m.info().connection == -1);
    BackCycle* cycle = (BackCycle*)m.info().sendtime;

    msgpack_c::getndmphistlist64 thl(m);
    ndmp_inode64_t queryinode(0);
    thl.arg(UNPACK, queryinode); 
    assert(dirinode == queryinode);

    bool goodresult(true);
    ubigint64 namesptr = (ubigint64)((ptrint)names);
    thl.res(PACK, goodresult, namesptr);
    if (msg2)
        DB->msg("zfstar_history::processhist::attempt_answer inode %lu sending goodresult:%d namesptr:%p",
                      dirinode, goodresult, (void*)namesptr);
    sendResponse(cycle, m);
}

void zfstar_history::processhist::postprocess_getndmpzfshistlist(ndmp_inode64_t queryinode, message& m)
{
    assert(!m.isnull());
    assert(m.info().connection == -1);   
    BackCycle* cycle = (BackCycle*)m.info().sendtime;
    histvector_t* names = historytree.get_names(queryinode, true);

    msgpack_c::getndmphistlist64 mp(m);
    ndmp_inode64_t dirinode(0);
    mp.arg(UNPACK, dirinode); 
    assert(queryinode == dirinode);

    Out->msg(INFO, "<10765>    DEBUG: answering GETNDMPZFSHISTLIST message:%s for dir inode:%lu with done=false and best effort data histlist:%p",
             *m.ximage(), dirinode, names);

    bool done = false;
    ubigint64 namesptr = (ubigint64)((ptrint)names);

    mp.res(PACK, done, namesptr);
    sendResponse(cycle, m);
}




void zfstar_history::processhist::sendResponse(BackCycle* cycle, message& m)
{
    cycle->enqueueResponse(cycle, m, false);
}

zfstar_history::processhist::historytree_class::~historytree_class()
{
}



ndmp_inode64_t zfstar_history::processhist::historytree_class::lastparent_done()
{
    if (lastparentinode != 0) {
        iter old = nodes.find(lastparentinode);

        
        
        
        

        old->second.isdone = true;
        if (msg2)
            DB->msg("zfstar_history::processhist::historytree_class::check_lastparent_done set done=true for inode:%"LL"u", lastparentinode);
        return lastparentinode;
    }

    return 0;
}

ndmp_inode64_t zfstar_history::processhist::historytree_class::enter_hist(processhist* ph,
                                                           ndmp_inode64_t inode,
                                                           ndmp_inode64_t parentinode,
                                                           const ustring& name)
{
    ndmp_inode64_t ret = 0;

    scope s(m);

    if ((parentinode != lastparentinode)) {
        ret = lastparent_done();
        lastparentinode = parentinode;
    }

    dirrecord &dr(nodes[parentinode]); 
    assert(dr.names != NULL);          

    dr.names->push_back(composite_key(inode, name));

    return ret;
}

histvector_t* zfstar_history::processhist::historytree_class::get_names(ndmp_inode64_t inode, bool accept_unready)
{
    scope s(m);

    iter i = nodes.find(inode);
    if (i == nodes.end())
        return NULL;

    if (!i->second.isdone) {
        if (!accept_unready) return NULL;
    }

    histvector_t *result = i->second.names;
    nodes.erase(i);

    return result;
}

bool zfstar_history::processhist::historytree_class::answer_ready(ndmp_inode64_t queryinode) const
{
    scope s(m);
    nodemap::const_iterator i = nodes.find(queryinode);
    if (i == nodes.end())
        return false;

    if (i->second.isdone)
        return true;

    return false;
}

#if !defined(BACKFILE2RAWCONTAINER_H_INCLUDED)
#define BACKFILE2RAWCONTAINER_H_INCLUDED















#include <memory>
#include "cycle.h"
#include "raw_container.h"

class workelem;
class parsestream_base;

class backfile2rawcontainer : public BackCycle  {
public:
    
    backfile2rawcontainer(BackCycle *parent_,
                          workelem *info_,
                          parsestream_base *parser = 0);

    virtual ~backfile2rawcontainer();

    virtual void init();

    virtual void childdone(cycle *child);

    SAFEPOOLALLOC(backfile2rawcontainer);
private:
    
    location::tcontainerid containerid;

    
    ucontainer::basep containerp;
};

#endif













#include "common.h"
#include "location_checker.h"
#include "location.h"
#include "fileoffset.h"
#include <map>
#include "uapp.h"
#include "debug.h"
#include "direlem.h"



class offinfo {
public:
    offinfo(location::entry_kind _ekind, fileoffset _lo, fileoffset _hi) : ekind(_ekind), lo(_lo), hi(_hi) {}

    enum overlap_results {
        less_than = -3,                 
        less_overlaps = -2,             
        inside = -1,                    
        equal = 0,                      
        outside = 1,                    
        greater_overlaps = 2,           
        greater_than = 3                
    };

    
    overlap_results overlaps(const offinfo &other) const {
        assert(other.lo <= other.hi);
        if (lo == other.lo && hi == other.hi) return equal;             

        if (lo > other.hi) return greater_than;                         
        if (hi < other.lo) return less_than;                            

        if (lo <= other.lo && hi >= other.hi) return outside;           
        if (lo >  other.lo && hi >  other.hi) return greater_overlaps;  
        if (lo <  other.lo && hi <  other.hi) return less_overlaps;     
        return inside;                                                  
    }

    
    ustring image() const {
       return ustring::sprintf("[ekind=%d, %s length %s]", ekind, *lo.image(), *((hi-lo)+1).image());
    }

    const location::entry_kind ekind;      
    const fileoffset lo;         
    const fileoffset hi;         
};




typedef DEFINE_STL_MAP_TYPE(fileoffset, offinfo*) offinfo_map_t;




class containerinfo {
public:
    containerinfo(int _container_id) : container_id(_container_id), lastatomoff(0), lastdiroff(0) { }

    ~containerinfo() {
        offinfo_map_t::iterator it;
        for(it=atoms.begin(); it!=atoms.end(); it++) delete(it->second);
        for(it=dirs.begin(); it!=dirs.end(); it++) delete(it->second);
    }

    
    
    void enter_atom(offinfo *n) {
        if(n->hi > lastatomoff) lastatomoff=n->hi;

        std::pair<offinfo_map_t::iterator,bool> ret;
        ret = atoms.insert(std::pair<fileoffset, offinfo*>(n->lo, n));
        if (!ret.second) Out->msg(ERR, "Container #%d: Atom entry at offset %s already exists %s", container_id, *n->image(), *ret.first->second->image());
    }

    
    
    void enter_dir(offinfo *n) {
        if(n->hi > lastdiroff) lastdiroff=n->hi;

        std::pair<offinfo_map_t::iterator,bool> ret;
        ret = dirs.insert(std::pair<fileoffset, offinfo*>(n->lo, n));
        if (!ret.second) Out->msg(ERR, "Container #%d: Directory entry at offset %s already exists %s", container_id, *n->image(), *ret.first->second->image());
    }

    
    
    
    void scan_atoms() {
        int scanned = 0;
        fileoffset off = 0;
        offinfo_map_t::const_iterator prev;
        offinfo_map_t::const_iterator curr;
        for (curr=atoms.begin(); uapp::staging().canRun() && curr!=atoms.end(); curr++) {
            scanned++;
            if ((scanned%1000000)==0) Out->msg(INFO, 3, "Scanned %d", scanned);
            if (curr != atoms.begin()) {
                const offinfo::overlap_results cmp = prev->second->overlaps(*curr->second);
                if (cmp != offinfo::less_than) {        
                    Out->msg(ERR, "Container #%d: Atom overlap error: cmp=%d, %s and %s", container_id, cmp, *(prev->second->image()), *(curr->second->image()));
                }

                
                
                
                if (curr->second->lo != off)
                    Out->msg(ERR, "Container #%d: Unadjacent offset error: %s != %s, delta=%s", container_id, *curr->second->lo.image(), *off.image(), *(curr->second->lo-off).image());
            }
            off = curr->second->hi+1;
            prev = curr;
        }
        if (dirs.size() > 0 && off > lastdiroff+1) Out->msg(ERR, "Container #%d: Maximum atom offset %s exceeds last directory offset %s", container_id, *off.image(), *lastdiroff.image());
        Out->msg(INFO, 2, "Container #%d: %d atoms checked", container_id, scanned);
    }

    
    offinfo_map_t::const_iterator scan_dirs(const int depth, const offinfo &parent, int &maxdepth) {
        if (depth>maxdepth) maxdepth=depth;

        const offinfo_map_t::iterator start = dirs.upper_bound(parent.lo);      
        if(start == dirs.end()) return start;   

        offinfo_map_t::const_iterator prev = dirs.end();
        offinfo_map_t::const_iterator curr;
        for (curr=start; uapp::staging().canRun() && curr!=dirs.end() && curr->second->hi <= parent.hi; curr++) {
            if (curr != start) {
                const offinfo::overlap_results cmp = prev->second->overlaps(*curr->second);
                switch (cmp) {
                    case offinfo::less_than: break;     

                    case offinfo::outside: {            
                        
                        
                        
                        
                        
                        
                        curr = scan_dirs(depth+1, *prev->second, maxdepth);
                        assert(curr != dirs.end());
                        break;
                    }

                    default:
                        Out->msg(ERR, "Directory overlap error: depth=%d, cmp=%d, %s and %s", depth, cmp, *(prev->second->image()), *(curr->second->image()));
                }
            }
            prev = curr;
        }
        return prev;     
    }

    void scan_directories() {
        if (dirs.size() == 0) return;   

        int maxdepth = 0;
        const offinfo start(location::entry_directory, 0, lastdiroff);
        scan_dirs(0, start, maxdepth);
        Out->msg(INFO, 2, "Container #%d: %d directories checked (maxdepth=%d)", container_id, (int)dirs.size(), maxdepth);
    }

    void summary() {
        Out->msg(INFO, 2, "Container #%d: %d atoms, %d directories (lastatomoff=%s, lastdiroff=%s)",
                 container_id, (int)atoms.size(), (int)dirs.size(), *lastatomoff.image(), *lastdiroff.image());

        if (atoms.size() > 1) {                 
            scan_atoms();
            scan_directories();
        }
    }

private:
    const int container_id;     
    fileoffset lastatomoff;     
    fileoffset lastdiroff;      

    offinfo_map_t atoms;        
    offinfo_map_t dirs;         
};




location_checker::~location_checker() {
    DEFINE_STL_VECTOR_TYPE(containerinfo*)::const_iterator it;
    for (it=containers.begin(); it!=containers.end(); it++) delete(*it);

}




void location_checker::summary() {
    if (num_gsan_entries > 0) Out->msg(INFO, 2, "Checked %d GSAN entries", num_gsan_entries);
    Out->msg(INFO, "Checking location information");
    for (int i=1; i<(int)containers.size(); i++)
        if (containers[i]!=NULL) containers[i]->summary();
}

void location_checker::enter_atom(const int container_id, offinfo *n) {
    if (check_container_exists(container_id)) {
        containers[container_id]->enter_atom(n);
    } else delete n;
}

void location_checker::enter_dir(const int container_id, offinfo *n) {
    if (check_container_exists(container_id)) {
        containers[container_id]->enter_dir(n);
    } else delete n;
}

bool location_checker::check_container_exists(const int container_id) {
    if (container_id <= 0) return false;

    if ((int)containers.size() < container_id+1)
        containers.resize(container_id+1, NULL);

    if (containers[container_id]==NULL) containers[container_id] = new containerinfo(container_id);
    return true;
}

bool location_checker::validate_entry(const DIRELEM& de, const ustring& precheck ) {
    
    
    
    
    
    
    const location loc = de.get_location();
    if (de.is_device_file_mknode_only() ||
        (de.is_reparsePoint() && de.file_hash() == hashcode::zero && !loc.is_stream())
        ) {
        
        
        
        return true;
    }
    const location::entry_kind tmpkind(de.is_directory() ? location::entry_directory : location::entry_file);
    return validate_entry(tmpkind, loc.getMedia(), loc.get_format(), loc.get_backupid(), loc.get_containerid(),
            loc.get_coverage_size(), loc.get_header_size(), loc.get_footer_size(), loc.get_abs_offset_in_container(), loc.get_checksum(), precheck);
}











bool location_checker::validate_entry(
                    const location::entry_kind    ekind,        
                    const location::media::type   media,        
                    const location::tformat::type format,       
                    const location::tbackupid     backupid,     
                    const location::tcontainerid  containerid,  
                    const fileoffset    coverage_size,          
                    const fileoffset    header_size,            
                    const fileoffset    footer_size,            
                    const fileoffset    abs_offset,             
                    const tchecksum     checksum,               
                    const ustring& precheck )           
{
    

    if (media == location::media::gsan) {
        if ((xflag[30]&512)) Out->msg(INFO, "Location GSAN entry [ekind=%d, format=%s, media=%s, containerid=%d]",
                                      +ekind, *location::tformat::image(format), *location::media::image(media), +containerid);
        found_gsan_entry();
        return false;                                                                   
    }

    ustring res = precheck;
    
    if (ekind < 0 || ekind >= location::after_end_of_entry_enum)            res += ustring::sprintf("[invalid ekind=%d] ", +ekind);

    if (media <= location::media::unknown
        || media >= location::media::after_end_of_media_enum)               res += ustring::sprintf("[invalid media=%d] ", +media);
    if (media != location::media::ddr && media != location::media::disk)    res += ustring::sprintf("[unexpected media=%d not ddr(2) or disk(3)] ", +media);

    if (format <= location::tformat::unknown
        || format >=location::tformat::after_end_of_format_enum)            res += ustring::sprintf("[invalid format=%d] ", +format);
    if (format != location::tformat::raw
        && format != location::tformat::cdsf)                               res += ustring::sprintf("[unexpected format=%d not raw(2) or cdsf(3)] ", +media);

    if (containerid > 100000)                                               res += ustring::sprintf("[invalid containerid=%d] ", +containerid);
    if (header_size > 50000)                                                res += ustring::sprintf("[invalid header_size=%s] ", *header_size.image());
    if (footer_size > 50000)                                                res += ustring::sprintf("[invalid footer_size=%s] ", *footer_size.image());

    
    if (format == location::tformat::cdsf || format == location::tformat::raw) {
        
        if (containerid == 0)                                               res += ustring::sprintf("[invalid RAW or CDSF containerid=%d] ", +containerid);
        if (abs_offset.value() < 0
            || abs_offset.value() > 100000000000000LL)                      res += ustring::sprintf("[invalid abs_offset=%s] ", *abs_offset.image());
        if (coverage_size.value() < 0
            || (coverage_size.value() == 0 && ekind != location::entry_dir_header)
            || coverage_size.value() > 100000000000000LL)                   res += ustring::sprintf("[invalid coverage_size=%s] ", *coverage_size.image());
        if (format == location::tformat::raw) {
            if (header_size != 0)                                           res += ustring::sprintf("[raw header_size (%s) not zero] ", *header_size.image());
            if (footer_size != 0)                                           res += ustring::sprintf("[raw footer_size (%s) not zero] ", *header_size.image());
            if (ekind != location::entry_file)                              res += ustring::sprintf("[raw ekind(%u) not file(1)] ", +ekind);
            enter_atom(containerid, new offinfo(ekind, abs_offset, abs_offset+coverage_size-1));
        } else if (containerid > 0) {
            if (footer_size < 0
                || (footer_size == 0 && ekind != location::entry_dir_header))
                                                                            res += ustring::sprintf("[invalid footer_size=%s] ", *footer_size.image());
            if (header_size <= 0)                                           res += ustring::sprintf("[invalid header_size=%s] ", *header_size.image());
            switch (ekind) {
            case location::entry_directory:
            case location::entry_dir_header:
                enter_atom(containerid, new offinfo(location::entry_dir_header, abs_offset, abs_offset+header_size-1));
                if(ekind==location::entry_dir_header) break; 
            case location::entry_dir_footer: {
                enter_dir(containerid, new offinfo(location::entry_directory, abs_offset, abs_offset+coverage_size-1));
                const fileoffset base = abs_offset+coverage_size-fileoffset(footer_size);
                enter_atom(containerid, new offinfo(location::entry_dir_footer, base, base+footer_size-1));
                break;
            }
            case location::entry_file:
                enter_atom(containerid, new offinfo(location::entry_file, abs_offset, abs_offset+coverage_size-1));
                break;
            default:                                                        res += ustring::sprintf("[invalid ekind (%d)] ", ekind);
            }
        }
    } else {
        if ((xflag[30]&512)) Out->msg(INFO, "Location other entry [ekind=%d, format=%d, media=%d, containerid=%d]",
                                      +ekind, +format, +media, +containerid);
    }

    if(!res.isempty()) {
      location loc(media, format, backupid, containerid, coverage_size, header_size, footer_size, abs_offset, checksum);
      Out->msg(ERR, "Checklocation error: %s loc:%s", *res, *loc.image());
    }
    return true;        
}

#if !defined(BACKVIEW_H_INCLUDED)
#define BACKVIEW_H_INCLUDED












#include "common.h"
#include "tassoc.h"
#include "ustring.h"
#include "cycle.h"
#include "dumpdirelem.h"
#include "backviewtop.h"

class context;
class fileoffset;
class utar_flags_info;

class backview : public BackCycle {
public:
  SAFEALLOC(backview);

  backview(const utar_flags_info& flags_,
           BackCycle* parent, ustring acntname, int labelnum,
           backviewbase::pathentrylist& namelist, fileoffset patchoffset);

  
  
  bool add_direlem(DIRELEM& parent, DIRELEM& cur, int level, int matchkind);

  virtual void init();
  virtual void response(message& outargs);
  virtual void childdone(cycle *child);
  virtual void notifyparent();

  
private:

  const utar_flags_info& flags;

  ustring acntname;
  int labelnum;
  backviewbase::pathentrylist& namelist;
  direlem_assoc_type inodeinfo;         

  int nextinode;
  tassoc<hashcode, int> dir_inodes;     

  bool read_one_snapup();
  bool backup_one_snapup();

  void gen_inode_num(DIRELEM& de);
  void enter_include(upath& path, bool isdir);
  void enter_include_list(backviewbase::pathentrylist& names);

  
  bool traverse(int inodenum, ustring indent, ustring path);  
  void  print_tree();

  int matches_to_find;   
  int matches_found;  

};

#endif


#if !defined(RestoreStreamState_H_INCLUDED)
#define RestoreStreamState_H_INCLUDED
#include <set>
#include "fileref.h"
#include "streamtransform.h"

typedef enum {
    rst_none,
    rst_ntfs,
    rst_emctar_dedup
} RestoreStreamType;

class RestoreStreamState

{
public:
    RestoreStreamState(RestoreStreamType type, const fileref compressordata = fileref::empty); 

    
    
    

    ~RestoreStreamState(void);

    
    bool signalEndOfPass(void);

    
    
    bool queueStreamSegment(fileoffset foOffset, fileref& frWriteThis);

    
    
    
    fileref retrieveStreamSegment(bool& bNextSegReady);

    fileoffset getBytesRetrieved(void) { return m_foBytesRetrieved; }

    ustring stImage() const { if (m_pst) { return m_pst->image(); } else { return "null"; } };

private:

    
    
    bool isNextSegmentPresent(void);

    
    Streambuffer        m_sb; 
    Streamtransform    *m_pst; 

    fileoffset          m_foStartOfNextSegment; 
    fileoffset          m_foBytesRetrieved;

    
    class StreamSegment {
    public:
        StreamSegment( fileoffset fo, fileref fr) : offset(fo), data(fr) {} 
        StreamSegment( const StreamSegment& rhs) : offset(rhs.offset), data(rhs.data) {} 
        StreamSegment& operator=(const StreamSegment& rhs) { 
            if( this != &rhs ) {
                offset = rhs.offset;
                data = rhs.data;
            }
            return *this;
        }
        bool operator < ( const StreamSegment& arg ) const { return offset < arg.offset; }
        fileoffset getOffset(void) const { return offset; }
        fileref getSegment(void) const { return data; }
    private: 
        fileoffset      offset;
        fileref         data;
    };

    typedef std::set<StreamSegment> QUEUEDSEGMENTS;
    QUEUEDSEGMENTS      m_sQueuedSegments;

};

#endif

#if !defined(FILESTATS_H_INCLUDED)
#define FILESTATS_H_INCLUDED












#include "safeint.h"
#include "safedouble.h"
#include "ustring.h"
#include "chunktype.h"
#include "stats.h"
#include "refcounter.h"
#include "upath.h"

class utar_flags_info;



class filestats : public stats {
public:
    filestats(const utar_flags_info& flags, const upath& _path, double _size);
    ~filestats();

    void start();

      
    void fupdate(reason why, double size, chunktype kind, bool system_info);

      
    double get_atomcount() { return f_atomcount.value(); }

      
    double get_compcount() { return f_compcount.value(); }

      
      
    double get_percentsent() { if (f_size.value()<=0) return 0.0;
                               if (filebytes[sent].value() > f_size.value()) return 100.0;   
                               return filebytes[sent].value()*100/f_size.value();
                             }

    upath      f_path;             
    safedouble f_size;             

    SAFEPOOLALLOC(filestats);

private:
    const utar_flags_info& flags;

    filestats();

    safedouble f_atomcount;       
    safedouble f_compcount;       
    double stime, etime;
};

class filestatsref : public refcounter<filestats> {
public:
    filestatsref() : refcounter<filestats>() {}
    filestatsref(const filestatsref& f) : refcounter<filestats>(f) {}
    filestatsref(const utar_flags_info& flags, const upath& path, double size)
        : refcounter<filestats>(new filestats(flags, path, size))
    {}  
    void fupdate(stats::reason why, double size, chunktype kind, bool system_info) const {
        if(isdefined())
            getimpl()->fupdate(why, size, kind, system_info);
    }
    ustring fpath() const {
        return isdefined() ? getimpl()->f_path.image() : "";
    }
    double get_percentsent() { if(isdefined()) return getimpl()->get_percentsent(); return 0.0; }
};

#endif

#if !defined(emctar_history_H_INCLUDED)
#define emctar_history_H_INCLUDED












#include "threadbase.h"
#include "vector.h"
#include "msgqueue.h"
#include "assoc.h"
#include "msgvect.h"
#include "namedpipe.h"
#include "usemaphore.h"
#include "histmap.h"
#include "utar_flags_info.h"

#include <map>

class message;
class context;
class BackCycle;

class emctar_history {
public:
    emctar_history(context *main, upath fifopath, upath savehistpath);
    ~emctar_history();

    void data_stream_done();
    void send(BackCycle* cycle, message& m);

    
    
    
    
    

    
    
    

    
    
    
    
    bool is_rhist_done() const { return readhist_thread->is_done; }
    
    
    
    
    size_t rhist_msg_count() const { return readhist_thread->msg_count; }

    SAFEALLOC(emctar_history);


#if SYSTEM_WINDOWS
#else
private:
#endif

    class readhist : public threadbase {
    public:
        
        readhist(msgqueue& todoqueue, upath fifopath, upath savehistpath, semaphore& histsem, emctar_history *parent_);
        ~readhist();

        void body();

        SAFEALLOC(readhist);

#if SYSTEM_WINDOWS
#else
    private:
#endif
        friend class emctar_history;

        msgqueue& todoqueue;
        
        namedpipe fifo;
        upath savehistpath;
        semaphore& histsem;
        emctar_history *parent;
        bool is_done;
        size_t msg_count;
    };

    class processhist;
    class processhist : public threadbase {
    public:
        processhist(msgqueue& todoqueue, emctar_history *parent_);
        ~processhist();

        void terminate();

        void mark_eof_history();

        SAFEALLOC(processhist);


#if SYSTEM_WINDOWS
#else
    private:
#endif

        msgqueue& todoqueue;
        emctar_history *parent;
        mtex todomut;
        typedef scalar<ubigint64> inode_obj_t;
        tassoc<inode_obj_t, message> todoassoc; 

        bool      mainloopdone;
        bool      todoqueue_terminated;

        
        
        
        
        
        
        struct dirrecord {
            dirrecord() : isdone(false), names(NULL) { names = new histvector_t(); }
            ~dirrecord() {  }
            ustring image() const { return ustring::sprintf("FIX: implement dirrecord::image"); }

            bool isdone; 

            
            histvector_t *names;
        };

        class historytree_class {
        public:
            historytree_class() : m(true), lastparentinode(0) {} 
            ~historytree_class();

            ubigint64 lastparent_done(); 

            
            ubigint64 enter_hist(processhist *ph, ubigint64 inode, ubigint64 parentinode, const ustring &name);

            
            
            
            
            
            
            histvector_t *get_names(ubigint64 inode, bool accept_unready = false);

            bool answer_ready(ubigint64 queryinode) const;

        protected:
            mtex m;
            typedef DEFINE_STL_MAP_TYPE(ubigint64, dirrecord) nodemap;
            typedef nodemap::iterator iter;

            nodemap nodes;
            ubigint64 lastparentinode;
        };
        historytree_class historytree;

        
        void body();
        void handle_getndmphistlist(message &m);
        bool handle_ndmphistlistline(message &m);
        void postprocess_getndmphistlist(ubigint64 queryinode, message &m);

        void attempt_answer(ubigint64 inode);

        int  read_and_enter_xml(ustring oneline);

   private:
        void sendResponse(BackCycle* cycle, message &m);
   }; 
private:
    msgqueue     todoqueue;             
    semaphore    histsem;
    readhist*    readhist_thread;
    processhist* processhist_thread;


#if SYSTEM_UNIX_SCO || SYSTEM_UNIX_UNIXWARE
    public:
#else
#endif
    utar_flags_info& flags;

};

#endif
